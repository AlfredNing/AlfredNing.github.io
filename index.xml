<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>AlfredNing</title>
    <link>https://AlfredNing.github.io/</link>
    <description>Recent content on AlfredNing</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Sun, 03 Sep 2023 08:44:09 +0800</lastBuildDate><atom:link href="https://AlfredNing.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Mybatis_generator</title>
      <link>https://AlfredNing.github.io/note/program/mybatis/mybatis_generator/</link>
      <pubDate>Sun, 03 Sep 2023 08:44:09 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/mybatis/mybatis_generator/</guid>
      <description>Mybatis-Generator 生成方式 命令行 maven插件 使用图形化 运行过程 连接数据库 从数据库元数据 生成文件 问题 下划线和驼峰法命名，不加设置下划线自动转驼峰
maven插件生成 pom.xml
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;project xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xsi:schemaLocation=&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;groupId&amp;gt;com.nq&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis_generator&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;maven.compiler.source&amp;gt;8&amp;lt;/maven.compiler.source&amp;gt; &amp;lt;maven.compiler.target&amp;gt;8&amp;lt;/maven.compiler.target&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis.generator&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis-generator-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.4.2&amp;lt;/version&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.1.46&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;!--指定生成文件--&amp;gt; &amp;lt;configurationFile&amp;gt;src/main/resources/generator/generatorConfig.xml&amp;lt;/configurationFile&amp;gt; &amp;lt;!--If true, then MBG will write progress messages to the build log.--&amp;gt; &amp;lt;verbose&amp;gt;true&amp;lt;/verbose&amp;gt; &amp;lt;!-- If true, then existing Java files will be overwritten if an existing Java file if found with the same name as a generated file.</description>
    </item>
    
    <item>
      <title>行为模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 03 Aug 2023 10:19:40 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F/</guid>
      <description>定义 关注点在于“怎样运行对象和类” 用户描述程序在运行时复杂的流程控制 类行为模式：采用继承机制，对象行为模式：采用组合或聚合在对象之间分配行为 模板方法模式 定义算法框架，算法具体涉及的相关步骤延迟到子类中实现。模板方法模式允许在不改变算法结构的情况下，通过子类来重新定义算法的特定步骤。
角色 模板类 具体子类 适用场景 当有一个算法的框架需要稳定不变，但其中的某些步骤需要根据不同情况进行定制时，可以使用模板方法模式。 当希望通过子类来扩展算法的特定步骤，而不是整个算法时，模板方法模式非常有用。 Spring的BeanFactory, Java的Servlet 实现 package design_patterns; /** * 模板方法模式 * * @author Alfred.Ning * @since 2023年08月03日 10:32:00 */ public class TemplateMethodMain { public static void main(String[] args) { Chess chess = new Chess(); chess.play(); new Monopoly().play(); } } // 模板类 abstract class Game { abstract void initialize(); abstract void startGame(); abstract void endGame(); public final void play() { initialize(); startGame(); endGame(); } } // 具体游戏类 - 国际象棋 class Chess extends Game { @Override void initialize() { System.</description>
    </item>
    
    <item>
      <title>结构型模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 30 Jul 2023 11:44:12 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>导论 结构型模式关注点在于 怎样组合对象和类 类结构模式关心类的组合，由多个类组合成一个更大的 对象结构模式关心类与对象的组合，通过关联关系在一个类中定义另一个类的实例对象 根据合成复用原则，在系统中尽量使用关联关系来替代继承关系，因为大部分结构型模式都是对象结构模式
适配器模式: 两个不兼容接口之间适配的桥梁 桥接模式：相同功能抽象化与是实现化解构，抽象和实现独立升级 过滤器模式：使用不同的标准来过滤同一组对象 组合模式：相似对象组合，形成树形结构 装饰器模式：向一个对象中添加新功能，同时不改变其结构 外观模式：向现有系统添加一个接口，客户端访问此接口来隐藏系统的复杂性 享元模式：尝试重用现有的同类对象，如果未找到匹配的对象，则创建新的对象 代理模式：一个类代表另一个类的功能 适配器模式 将一个接口转换为客户希望的另一个接口，适配器使不兼容的类一起工作，适配器模式分为：
类适配器模式： 继承手段 对象适配器模式: 组合手段 类适配器模式耦合度要求较高，应用相对比较少，别名：Wrapper, 包装器
角色 目标接口 适配器 被适配对象 使用场景 当需要使用一个已有的类，但其接口与现有代码不匹配时，可以使用适配器模式将其转换为所需的接口
当希望复用一些现有的类，但其接口与应用代码的接口要求不一致时，可以通过适配器模式将这些类适配为符合要求的接口。
Tomcat Request转标准Request
Spring AOP的Advisor Adapter
Spring MVC的 HandlerAdapter
SpringBoot的 WebMvcConfigurerAdapter
实现 package design_patterns.behavior; /** * @author Alfred.Ning * @since 2023年07月30日 12:12:00 */ public class AdapterMain { public static void main(String[] args) { Adapter adapter = new Adapter(new Adaptee()); adapter.request(); } } // 目标接口 interface Target { void request(); } // 被适配对象 class Adaptee { public void specificRequest() { System.</description>
    </item>
    
    <item>
      <title>创建型模式 建造者模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 29 Jul 2023 19:24:24 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>定义 创建过程细节复杂，暴露给调用者。屏蔽过程而不屏蔽细节
角色 产品角色 抽象建造者 具体建造者 指挥者 实现 package design_patterns; /** * 创建者模式 也可以改为返回相同引用 * * @author Alfred.Ning * @since 2023年07月29日 19:41:00 */ public class Builder { public static void main(String[] args) { Director director = new Director(); AbstractBuilder concreteBuilder1 = new ConcreteBuilder1(); director.setBuilder(concreteBuilder1); System.out.println(director.contruct()); AbstractBuilder concreteBuilder2 = new ConcreteBuilder2(); director.setBuilder(concreteBuilder2); System.out.println(director.contruct()); } } // 指挥者 class Director { private AbstractBuilder builder; public void setBuilder(AbstractBuilder abstractBuilder) { this.builder = abstractBuilder; } public Product contruct() { builder.</description>
    </item>
    
    <item>
      <title>创建型模式 工厂模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 29 Jul 2023 16:21:44 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>定义 不必关心创建对象的细节，根据不同情况获取不同产品
分类 简单工厂模式 角色 产品接口 具体产品接口 简单工厂 特点 针对少量产品
缺陷 违反开闭原则
实现 /** * 产品接口 * * @author Alfred.Ning * @since 2023年07月29日 16:38:00 */ public interface Product { void operation(); } /** * 具体产品A * * @author Alfred.Ning * @since 2023年07月29日 16:39:00 */ class ConcreteProductA implements Product { @Override public void operation() { System.out.println(&amp;#34;ConcreteProductA....operation&amp;#34;); } } /** * 具体产品B * * @author Alfred.Ning * @since 2023年07月29日 16:39:00 */ class ConcreteProductB implements Product { @Override public void operation() { System.</description>
    </item>
    
    <item>
      <title>创建型模式 原型模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 29 Jul 2023 16:03:04 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>定义 用于创建重复对象，同时又能保证性能
本体给外部提供一个克隆体
实现 JDK实现Cloneable接口，重写该方法
使用场景 资源优化 性能和安全要求 一个对象多个修改者 </description>
    </item>
    
    <item>
      <title>创建型模式 单例模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 29 Jul 2023 12:10:08 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>定义 一个单一的类，负责创建自己的对象，同时确保系统中只有单个对象被创建
特点 某个类只能由有一个实例（构造器私有化） 自行创建实例 向外界提供实例方法 实现 /** * 饿汉式 * * @author Alfred.Ning * @since 2023年07月29日 15:50:00 */ public class Singleton { private static volatile Singleton INSTANCE; // private static volatile Singleton INSTANCE = new Singleton(); // 饱汉式 private Singleton() { } public static Singleton getINSTANCE() { if (INSTANCE == null) { synchronized (Singleton.class) { if (INSTANCE == null) { INSTANCE = new Singleton(); } } } return INSTANCE; } // 通过静态内部类单例模式 private static class SingletonHolder { private static Singleton instance = new Singleton(); } public static Singleton getInstanceByInnerClass() { return SingletonHolder.</description>
    </item>
    
    <item>
      <title>创建型模式导论</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%AF%BC%E8%AE%BA/</link>
      <pubDate>Sat, 29 Jul 2023 12:07:13 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%AF%BC%E8%AE%BA/</guid>
      <description>创建型模式关注点 降低系统耦合度 将对象的创建和使用分离 无需关注对象的创建细节 创建由相关工厂完成	各种工厂模式 创建由一个建造者完成 建造者模式 创建由原来对象克隆模式 原型模式 对象始终在系统中只有一个实例 单例模式 ​</description>
    </item>
    
    <item>
      <title>设计模式导论</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AF%BC%E8%AE%BA/</link>
      <pubDate>Sat, 29 Jul 2023 10:59:30 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AF%BC%E8%AE%BA/</guid>
      <description> 设计模式是一种思想，灵活运用远大于死记代码
对接口编程而不是对实现编程
优先使用对象组合而不是继承
面向对象的特性 封装 继承 多态 设计模式分类 创建型模式 结构型模式 行为型模式 也存在多种形式模式组合在不同阶段中使用
设计模式的7大原则 开闭原则 - Open Closed Principle (OCP) 对扩展开放，对修改关闭
扩展新类而不是修改旧类
里氏替换原则- Liskov Substitution Principle (LSP) 继承必须确保超类所拥有的性质在子类中仍然成立
继承父类而不去改变父类
依赖倒置原则- Dependence Inversion Principle (DIP) 高层模块不依赖于底层模块，两者都依赖于抽象，抽象不依赖于细节，细节依赖于抽象
接口隔离原则- Interface Segrgation Principle (ISP) 一个类对另一个类的依赖原则应该建立在最下的接口上
各个类建立自己的专用接口，而不是建立万能接口
单一职责原则- Single Responsibility Principle, SRP 一个类应该有且仅有一个引起它变化的原因，否则应该被拆分
每个类只负责自己的事，而不是变成万能
迪米特法则- Law of Demeter (Lod) 最少知识原则
无需直接交互的类，如果需要交互，使用中间者
过度使用迪米特法则则会使系统产生大量的中介类，从而增加系统的复杂性，使模块直接的通信效率降低
合成复用原则 组合/聚合原则
优先组合，其次继承
总结 </description>
    </item>
    
    <item>
      <title>Spring源码01</title>
      <link>https://AlfredNing.github.io/note/program/spring/%E4%B8%8E%E6%BA%90%E7%A0%81%E5%B9%B2%E6%88%98-spring-01/</link>
      <pubDate>Mon, 24 Jul 2023 14:42:20 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/spring/%E4%B8%8E%E6%BA%90%E7%A0%81%E5%B9%B2%E6%88%98-spring-01/</guid>
      <description>基本注解 @Lookup 从容器中查找不同的实例，
/** * @author Alfred.Ning * @since 2023年08月12日 20:27:00 */ @Component @Data public class Person { private String name; // @Autowired private Cat cat; @Lookup // 去容器里找 public Cat getCat() { return cat; } } /** * @author Alfred.Ning * @since 2023年08月13日 14:42:00 */ @Scope(scopeName = ConfigurableBeanFactory.SCOPE_PROTOTYPE) @Component @Data public class Cat { private String name; } Resource+ResourceLoader Resource:负责资源
ResourceLoader: 对应资源加载 ，策略模式。
BeanFactory 容器的根节点，入口。
HierarchicalBeanFactory： 定义父子容器
AutowireCapableBeanFactory： 处理自动装配功能</description>
    </item>
    
    <item>
      <title>07 AQS</title>
      <link>https://AlfredNing.github.io/note/program/juc/07-aqs/</link>
      <pubDate>Sat, 22 Jul 2023 20:31:52 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/juc/07-aqs/</guid>
      <description>定义 AbstractQueuedSynchronizer: 抽象队列同步器
是用来构建锁或者其它同步器组件的重量级基础框架及整个JUC体系的基石，通过内置的FIFO队列来完成资源获取线程的排队工作，并通过一个int类变量表示持有锁的状态
和AQS相关的
ReentrantLock CountDownLatch ReentrantReadWriteLock Semaphore 锁: 面向锁的使用者,定义了程序员和锁交互的使用层API
同步器: 面向锁的实现者
抢到资源的线程直接使用处理业务，抢不到资源的必然涉及一种排队等候机制。抢占资源失败的线程继续去等待(类似银行业务办理窗口都满了，暂时没有受理窗口的顾客只能去候客区排队等候)，但等候线程仍然保留获取锁的可能且获取锁流程仍在继续(候客区的顾客也在等着叫号，轮到了再去受理窗口办理业务)。
既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？
如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中，这个队列就是AQS的抽象表现。它将请求共享资源的线程封装成队列的结点（Node），通过CAS、自旋以及LockSupport.park()的方式，维护state变量的状态，使并发达到同步的效果。
体系架构 AQS = int变量 + CLH队列
Node内部类 同步队列基本结构 CLH：Craig、Landin and Hagersten 队列，是个单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO）
ReentrantLock 实现 ReentrantLock 底层使用Sync实现，对应有非公平NonfairSync 和公平FairSync 都是继承AbstractQueuedSynchronizer
对比公平锁和非公平锁的 tryAcquire()方法的实现代码，其实差别就在于非公平锁获取锁时比公平锁中少了一个判断 !hasQueuedPredecessors()
hasQueuedPredecessors() 中判断了是否需要排队，导致公平锁和非公平锁的差异如下：
公平锁：公平锁讲究先来先到，线程在获取锁时，如果这个锁的等待队列中已经有线程在等待，那么当前线程就会进入等待队列中；
非公平锁：不管是否有等待队列，如果可以获取锁，则立刻占有锁对象。也就是说队列的第一个排队线程在unpark()，之后还是需要竞争锁（存在线程竞争的情况下）
加锁过程 static final class NonfairSync extends Sync { private static final long serialVersionUID = 7316153563782823691L; /** * Performs lock. Try immediate barge, backing up to normal * acquire on failure.</description>
    </item>
    
    <item>
      <title>06 Synchronized与锁升级</title>
      <link>https://AlfredNing.github.io/note/program/juc/06-synchronized%E4%B8%8E%E9%94%81%E5%8D%87%E7%BA%A7/</link>
      <pubDate>Sat, 22 Jul 2023 10:21:34 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/juc/06-synchronized%E4%B8%8E%E9%94%81%E5%8D%87%E7%BA%A7/</guid>
      <description>Syncronized的性能变化 锁升级
无锁 -&amp;gt; 偏向锁 -&amp;gt; 轻量级锁 -&amp;gt; 重量级锁
java5之前，只有Syncronized，操作系统级别的重量锁，性能低下。内核态与用户态的切换 java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统介入，需要在户态与核心态之间切换，这种切换会消耗大量的系统资源，因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。
Java早期版本，Synchronized依赖于操作系统底层的Mutex Lock来实现，挂起线程和恢复线程都需要转入内核态运行，阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态切换需要耗费处理器时间，如果同步代码块中内容过于简单，这种切换的时间可能比用户代码执行的时间还长”，时间成本相对较高。
Java 6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁
? 为什么为什么每一个对象都可以成为一个锁 Monitor可以理解为一种同步工具，也可理解为一种同步机制，常常被描述为一个Java对象。Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中 ，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁。
Monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的转换，成本非常高。
Mutex Lock
Monitor是在jvm底层实现的，底层代码是c++。本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的转换，状态转换需要耗费很多的处理器时间成本非常高。所以synchronized是Java语言中的一个重量级操作。
Monitor与java对象以及线程是如何关联 ？
1.如果一个java对象被某个线程锁住，则该java对象的Mark Word字段中LockWord指向monitor的起始地址
2.Monitor的Owner字段会存放拥有相关联对象锁的线程id
Mutex Lock 的切换需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间。
java6开始，优化Synchronized Java 6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁, 逐步升级锁的过程
无锁演示 程序不会有锁的竞争
偏向锁 定义 大多数情况下，锁不仅不存在多线程竞争，还存在由同一线程多次获得的情况。
偏向锁就是在这种情况下出现的，它的出现是为了解决只有在一个线程执行同步时提高性能。
偏向锁的持有 锁总是被第一个占用它的线程拥有，该线程就是锁的偏向线程
锁第一次拥有，记录偏向线程ID。这样偏向线程就一直持有着锁(后续这个线程进入和退出这段加了同步锁的代码块时，不需要再次加锁和释放锁。而是直接比较对象头里面是否存储了指向当前线程的偏向锁) 相等时：表示偏向锁偏向于当前线程。就不需要再尝试获得锁了，直到竞争发生才释放锁。以后每次同步，检查锁的偏向线程ID与当前线程ID是否一致，如果一致直接进入同步。无需每次加锁解锁都去CAS更新对象头。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。 不一致：发生竞争。锁已经不是总是偏向于同一个线程了，这时候可能需要升级变为轻量级锁，才能保证线程间公平竞争锁。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。 技术实现
一个synchronized方法被一个线程抢到了锁时，那这个方法所在的对象就会在其所在的Mark Word中将偏向锁修改状态位，同时还会有占用前54位来存储线程指针作为标识。若该线程再次访问同一个synchronized方法时，该线程只需去对象头的Mark Word 中去判断一下是否有偏向锁指向本身的ID，无需再进入 Monitor 去竞争对象了。
演示 import org.openjdk.jol.info.ClassLayout; /** * @author Alfred.Ning * @since 2023年07月22日 18:49:00 */ public class BiasedLockDemo { private static Object objectLock = new Object(); public static void main(String[] args) { /** * -XX:+UseBiasedLocking 开启偏向锁(默认) -XX:-UseBiasedLocking 关闭偏向锁 -XX:BiasedLockingStartupDelay=0 关闭延迟(演示偏向锁时需要开启) 参数说明： 偏向锁在JDK1.</description>
    </item>
    
    <item>
      <title>05 对象内存布局</title>
      <link>https://AlfredNing.github.io/note/program/juc/05-%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%A4%B4/</link>
      <pubDate>Sat, 22 Jul 2023 07:01:53 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/juc/05-%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%A4%B4/</guid>
      <description>对象内存布局 对象内部结构 = 对象头 + 实例数据 + 内存填充（保证8字节的倍数）
对象头 对象头 = 对象标记(Mark Word) + 类元信息(类型指针)
对象标记占8个字节， 类型指针占8个字节，总共16个字节
对象标记 对象的HashCode 分代年龄，锁标志位等信息。
这些信息都是与对象自身定义无关的数据，所以MarkWord被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间MarkWord里存储的数据会随着锁标志位的变化而变化。
对象布局、GC回收和后面的锁升级就是对象标记MarkWord里面标志位的变化
类元信息 对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
实例数据 内存填充 虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐这部分内存按8字节补充对齐。
Object obj = new Object() GC年龄采用4位bit存储，最大为15，
例如MaxTenuringThreshold参数默认值就是15
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.openjdk.jol&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jol-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.15&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; import org.openjdk.jol.info.ClassLayout; /** * @author Alfred.Ning * @since 2023年07月22日 10:06:00 */ public class ObjectDemo { public static void main(String[] args) { // vm的细节详细情况 // System.out.println(VM.current().details()); Object obj = new Object(); System.out.println(ClassLayout.parseInstance(obj).toPrintable()); } } -- 查看启动参数 java -XX:+PrintCommandLineFlags -version 关闭压缩之前</description>
    </item>
    
    <item>
      <title>04 ThreadLocal</title>
      <link>https://AlfredNing.github.io/note/program/juc/04-threadlocal/</link>
      <pubDate>Wed, 19 Jul 2023 16:22:32 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/juc/04-threadlocal/</guid>
      <description>定义 ThreadLocal提供线程局部变量。这些变量与正常的变量不同，因为每一个线程在访问ThreadLocal实例的时候（通过其get或set方法）都有自己的、独立初始化的变量副本。ThreadLocal实例通常是类中的私有静态字段，使用它的目的是希望将状态（例如，用户ID或事务ID）与线程关联起来。
每个ThreadLocl都是自己专属的本地变量副本,不存在多线程间共享的问题 每个线程对该值都是各自线程互相独立访问的 初始化 ThreadLocal&amp;lt;Integer&amp;gt; tl1 = new ThreadLocal&amp;lt;Integer&amp;gt;() { @Override protected Integer initialValue() { return 2; } }; ThreadLocal&amp;lt;Integer&amp;gt; tl2 = ThreadLocal.withInitial(() -&amp;gt; 2); ? 为什么要加remove方法
防止内存泄露
实践 不安全的SimpleDateFormat 问题演示 class SimpleDateFormatDemo { public static final SimpleDateFormat sdf = new SimpleDateFormat(&amp;#34;yyyy-MM-dd HH:mm:ss&amp;#34;); public static Date parseSdf(String dataStr) throws ParseException { return sdf.parse(dataStr); } public static void main(String[] args) throws ParseException { for (int i = 0; i &amp;lt; 5; i++) { new Thread(() -&amp;gt; { try { System.</description>
    </item>
    
    <item>
      <title>03-Cas-原子操作</title>
      <link>https://AlfredNing.github.io/note/program/juc/03-cas-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Wed, 12 Jul 2023 16:20:37 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/juc/03-cas-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</guid>
      <description>CAS定义 Compare And Swap：比较并交换 V: 位置内存值 A: 旧的预期值 B: 要修改更新的值
当且仅当V中的值和A值相等，用B值更新V中的值
硬件级别保证 CAS底层是一条CPU的原子指令 cmpxchg指令，不会造成数据不一致的问题，Java底层提供由Unsafe类提供的CAS方法
执行cmpxchg指令的时候，会判断当前系统是否为多核系统，如果是就给总线加锁，只有一个线程会对总线加锁成功，加锁成功之后会执行cas操作，也就是说CAS的原子性实际上是CPU实现的， 其实在这一点上还是有排他锁的，只是比起用synchronized， 这里的排他时间要短的多， 所以在多线程情况下性能会比较好
Unsafe类 是CAS的核心类，Unsafe位于sun.misc包中，通过CAS类可以直接通过操作特定内存的数据**，所有的方法都是用native修饰， 也就是说Unsafe类底层都直接调用操作系统底层资源执行相应任务**
变量offSet代表变量值在内存的地址
变量value用volatile修饰，保证了多线程之间的内存可见性。
AtomicInteger类 AtomicInteger主要是通过CAS + volatile + native方法类保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。
CAS并发原语体现在JAVA语言中就是sun.misc.Unsafe类中的各个方法。调用UnSafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令。这是一种完全依赖于硬件的功能，通过它实现了原子操作。再次强调，由于CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题。
CAS是靠硬件实现的从而在硬件层面提升效率，最底层还是交给硬件来保证原子性和可见性
实现方式是基于硬件平台的汇编指令，在intel的CPU中(X86机器上)，使用的是汇编指令cmpxchg指令。
核心思想就是：比较要更新变量的值V和预期值E（compare），相等才会将V的值设为新值N（swap）如果不相等自旋再来。
原子引用 AtomicInteger原子整型，可以自定义自己的原理引用类型
自定义原子引用 import java.util.concurrent.atomic.AtomicReference; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; /** * 自定义原子类型引用 * * @author Alfred.Ning * @since 2023年07月18日 11:41:00 */ public class AtomicReferenceDemo { public static void main(String[] args) { User u1 = new User(&amp;#34;u1&amp;#34;, 20); User u2 = new User(&amp;#34;u2&amp;#34;, 30); AtomicReference&amp;lt;User&amp;gt; userAtomicReference = new AtomicReference&amp;lt;&amp;gt;(); userAtomicReference.</description>
    </item>
    
    <item>
      <title>02-Volatile</title>
      <link>https://AlfredNing.github.io/note/program/juc/02-volatile/</link>
      <pubDate>Tue, 11 Jul 2023 08:04:59 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/juc/02-volatile/</guid>
      <description>JMM 现代计算机组成体系之上，CPU与内存之间的运行速度差距较大，为了缓存速度上的差异，引入了多级缓存。
Java Memory Model 本身是一种抽象的概念并不真实存在它仅仅描述的是一组约定或规范，通过这组规范定义了
程序中各个变量的读写访问方式 决定另一个线程对共享变量的写入以及如何变成对另一个线程可见 关键技术点围绕多线程的原子性、可见性、原子性
通过JMM来实现线程和主内存的抽象关系 屏蔽各个硬件平台和操作系统的内存访问差异以实现让Java程序在各种平台下都能达到一致的内存访问效果 特性 可见性 是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道该变更 ，JMM规定了所有的变量都存储在主内存中。
Java中普通的共享变量不保证可见性，因为数据修改被写入内存的时机是不确定的，多线程并发下很可能出现&amp;quot;脏读&amp;quot;，所以每个线程都有自己的工作内存，线程自己的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取，赋值等 ）都必需在线程自己的工作内存中进行，而不能够直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成
原子性 指一个操作是不可中断的，即多线程环境下，操作不能被其他线程干扰
有序性 对于一个线程的执行代码而言，我们总是习惯性认为代码的执行总是从上到下，有序执行。
但为了提供性能，编译器和处理器通常会对指令序列进行重新排序。
**指令重排可以保证串行语义一致，但没有义务保证多线程间的语义也一致，即可能产生&amp;quot;脏读&amp;quot;，**简单说，
两行以上不相干的代码在执行的时候有可能先执行的不是第一条，不见得是从上到下顺序执行，执行顺序会被优化。
单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。处理器在进行重排序时必须要考虑指令之间的数据依赖性，多线程环境中线程交替执行,由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的,结果无法预测
多线程度变量的读写过程 读写过程 JVM运行过程的实体是线程，而每个线程创建JVM时都会为其创建工作内存（栈空间）属于私有数据区，而java内存模型规定的所有变量都在主内存中。主内存是共享内存区域，所有线程都可以访问。
线程对变量的操作必须在工作内存中进行，首先要将变量从主内存中拷贝到自己的工作内存空间，然后对变量进行操作，操作完成之后在写回主内存
不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完
总结 我们定义的所有共享变量都储存在物理主内存中 每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本(主内存中该变量的一份拷贝) 线程对共享变量所有的操作都必须先在线程自己的工作内存中进行后写回主内存，不能直接从主内存中读写(不能越级) 不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行(同级不能相互访问) 多线程先行发生原则之happens-before 定义 在JMM中，如果一个操作执行的结果需要对另一个操作可见性或者 代码重排序，那么这两个操作之间必须存在happens-before关系。包含可见性和有序性的约束
说明 如果Java内存模型中所有的有序性都仅靠volatile和synchronized来完成，那么有很多操作都将会变得非常啰嗦，但是我们在编写Java并发代码的时候并没有察觉到这一点。
我们没有时时、处处、次次，添加volatile和synchronized来完成程序，这是因为Java语言中JMM原则下，有一个“先行发生”(Happens-Before)的原则限制和规矩
原则：
它是判断数据是否存在竞争，线程是否安全的非常有用的手段。依赖这个原则，我们可以通过几条简单规则一揽子解决并发环境下两个操作之间是否可能存在冲突的所有问题，而不需要陷入Java内存模型苦涩难懂的底层编译原理之中
总原则 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。 两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。 8条规则 次序规则 一个线程内，按照代码顺序，写在前面的操作先行发生于写在后面的操作
锁定规则 一个unLock操作先行发生于后面((这里的“后面”是指时间上的先后))对同一个锁的lock操作
volatile变量规则 对一个volatile变量的写操作先行发生于后面对这个变量的读操作，前面的写对后面的读是可见的，这里的“后面”同样是指时间上的先后
传递规则 如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
线程启动规则(Thread Start Rule) Thread对象的start()方法先行发生于此线程的每一个动作
线程中断规则(Thread Interruption Rule) 对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
可以通过Thread.interrupted()检测到是否发生中断
线程终止规则(Thread Termination Rule) 线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。
对象终结规则(Finalizer Rule) 一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始</description>
    </item>
    
    <item>
      <title>数仓理论</title>
      <link>https://AlfredNing.github.io/note/program/dw/%E6%95%B0%E4%BB%93%E7%90%86%E8%AE%BA/</link>
      <pubDate>Thu, 06 Jul 2023 19:41:37 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/dw/%E6%95%B0%E4%BB%93%E7%90%86%E8%AE%BA/</guid>
      <description>数据模型简介 模型的定义 表：负责数据真实存储
模型：在表的基础上多了业务含义，侧重点：使用角度、业务
作用：更好的存储、组织数据、在性能、成本、效率和质量取得最佳平衡
建模方法论 ER建模 对三范式要求更高，基于三范式
缺点：
需要全面了解业务和数据 实施周期比较长 对建模人员要求比较高 优点：
冗余少 维度建模 对数据冗余的宽容度比较高
基于维度和事实构建
Data Valut模型 Anchor模型 数仓体系 主题域划分 面向业务分析，将业务过程或者维度抽象集合。
可以划分多级主题域
指标体系 原子指标 派生指标 衍生指标 派生指标 = 原子指标 + 时间周期修饰词 + 其他修饰词
原子指标： 动作 + 度量，例如：支付金额
修饰词：1d/2h, 只有时间周期有英文名
模型层次 操作数据层：ods 公共维度模型层：cdm 明细层：dwd 汇总数据层：dws 应用数据层：ads ODS层 业务操作数据几乎无处理存放在数据仓库中
CDM层 存放明细事实表，维表数据及公共指标数据
ADS层 存放数据产品个性化的统计指标数据，根据CDM层与ODS层加工生成
模型设计基本原则 高内聚 低耦合： 将业务相同，粒度相同的数据设计为同一个逻辑或模型，将高概率同时访问的数据放在一起，将低概率同时访问的数据分开存储 核心模型与扩展模型分离 公共处理逻辑下沉及单一 成本与性能平衡 数据可回滚 一致性 数仓构建流程 指导方针 业务调研：自下而上
需求分析：自上而下
维度建模 构建总线矩阵 抽象出业务过程和维度 报表需求抽象出指标体系 结合工具，完成指标规范定义和模型设计 代码研发和运维 数仓的规范性特别重要</description>
    </item>
    
    <item>
      <title>01-Thread</title>
      <link>https://AlfredNing.github.io/note/program/juc/01-thread/</link>
      <pubDate>Mon, 19 Jun 2023 19:56:37 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/juc/01-thread/</guid>
      <description>前置知识 1. 为什么多线程如何重要 硬件方面：摩尔定律失效，主频不在提高，核数在不断增加的情况下，让程序运行更快就需要用到并行或者并发编程
软件方面：高并发系统： 异步 + 回调等生产需求
2. 进程 是程序的一次执行，是系统进行资源分配和调度的独立单位，每个进程都有它自己的内存空间和系统资源
3. 线程 在同一进程有1个或多个线程，执行多个任务，每个任务可以看做线程，共享内存空间和资源
操作系统
多进程形式，允许多个任务同时进行 多线程形式，允许单个任务进行拆分不同的部分允许 提供协调机制：一方面进程和线程之间产生冲突，一方面进程和线程之间共享资源 4. 管程 操作系统层面：监视器(Monitor), 同步机制，是保证（同一时间）只有一个线程可以访问被保护的数据和代码。JVM中同步是基于进入和退出监视器对象(Monitor,管程对象)来实现的，每个对象实例都会有一个Monitor对象，底层是由C++实现。
5. 用户线程和守护线程 Java线程分为用户线程和守护线程
线程的daemon属性默认为false:用户线程
守护线程：特殊线程，后台执行任务，比如垃圾回收线程
用户线程：系统的工作线程，完成程序所执行的业务操作
当程序的所有用户线程执行完毕，不管是否守护线程执行完毕，系统自动退出 设置守护线程，需要在start()方法之前 6. 异步编排 Future 与 Callable Future 定义了操作异步执行任务的一些方法，如：获取异步执行的结果，取消任务执行，判断任务是否取消，判断任务执行是否完毕等。子线程去执行任务，比较耗时，主线程继续执行 Callable定义了具有返回值的任务 FutureTask **get阻塞：**一旦调用get方法，无论执行完成都会阻塞，生成禁****用
解决措施：轮询替代阻塞
高并发中，不要阻塞，尽可能少加锁，使用CAS
isDone轮询：
轮询方式也是会耗费cpu资源，不能立即获得计算结果 如果想要异步获取结果,通常都会以轮询的方式去获取结果尽量不要阻塞 import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; import java.util.concurrent.TimeUnit; import java.util.concurrent.TimeoutException; /** * @author Alfred.Ning * @since 2023年06月20日 20:59:00 */ public class FutureTaskDemo { public static void main(String[] args) throws ExecutionException, InterruptedException, TimeoutException { FutureTask&amp;lt;String&amp;gt; futureTask = new FutureTask&amp;lt;&amp;gt;(() -&amp;gt; { System.</description>
    </item>
    
    <item>
      <title>MySql高级 事务</title>
      <link>https://AlfredNing.github.io/note/program/sql/mysql/mysql%E9%AB%98%E7%BA%A7-%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Sun, 11 Jun 2023 13:57:55 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/sql/mysql/mysql%E9%AB%98%E7%BA%A7-%E4%BA%8B%E5%8A%A1/</guid>
      <description>数据库事务概述 引擎支持情况 SHOW ENGINES 命令来查看当前 MySQL 支持的存储引擎都有哪些，以及这些存储引擎是否支持事务
基本概念 事务：一组逻辑单元，是数据从一种合法状态切换到另一种合法状态。
合法状态：符合现实逻辑
**事务处理的原则：**保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(commit)，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务回滚(rollback)到最初状态。
事务的ACID特性 原子性（atomicity）： 原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。
一致性（consistency）： 一致性是指事务执行前后，数据从一个合法性状态变换到另外一个合法性状态。这种状态是语义上的而不是语法上的，跟具体的业务有关。
隔离型（isolation）： 事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。
持久性（durability）： 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。
持久性是通过事务日志来保证的。日志包括了重做日志和回滚日志。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。
事务的状态 活动的（active） 事务对应的数据库操作正在执行过程中时，我们就说该事务处在活动的状态。
部分提交的（partially committed） 当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，我们就说该事务处在部分提交的状态。
失败的（failed） 当事务处在活动的或者部分提交的状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在失败的状态。
中止的（aborted） 如果事务执行了一部分而变为失败的状态，那么就需要把已经修改的事务中的操作还原到事务执行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为回滚。当回滚操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了中止的状态。
提交的（committed） 当一个处在部分提交的状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事务处在了提交的状态。
ACID是事务的四大特性，原子性是基础，隔离性是手段，一致性是约束条件，持久性是目的。
如何使用事务 显式事务 隐式事务 显示事务 -- 显式事务 -- 步骤1：开启事务 -- START TRANSACTION 可以限制事务操作 -- 当前事务是只读事务，不能增删改，只是不允许修改那些其他事务也能访问到的表的数据，对于临时表(CREATE TEMPORARY TABLE)来说，是可以进行增删改的 START TRANSACTION READ ONLY; -- 读写，默认 START TRANSACTION READ WRITE; -- 开启一致性读 START TRANSACTION READ CONSISTENT SNAPSHOT; -- 或者 BEGIN; -- 步骤2：一系列的DML操作 -- 步骤3：提交或者中止状态 -- 提交事务 COMMIT; -- 回滚事务 ROLLBACK; 隐式事务 -- 隐式事务 -- 通过 autocommit 设置 ,默认 on，代表每一条DML都是一个独立的操作，执行之后，默认会自动提交。 SHOW VARIABLES LIKE &amp;#39;%autocommit%&amp;#39;; -- 关闭自动提，只针对DML，对DDL是无效的 SET autocommit=FALSE; -- 执行操作，构成一个独立的事务 -- 提交 COMMIT; -- 当 autocommit 为 true，START TRANSACTION或者BEGIN之后，都不会将DML操作作为单个事务，而是作为整体一个事务。 保存点：</description>
    </item>
    
    <item>
      <title>浪潮之巔所感</title>
      <link>https://AlfredNing.github.io/thinking/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%94%E6%89%80%E6%84%9F/</link>
      <pubDate>Sun, 04 Jun 2023 21:08:54 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/thinking/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%94%E6%89%80%E6%84%9F/</guid>
      <description>2023年上，看了浪潮之巅。
20世纪不联网信息产业密度不断扩大，新型了各大历史上著名的公司，有的至今还在，有的早已灭亡。科学技术的不断发展，有的公司靠自己影响力，有的公司靠自己的垄断，有的公司在技术上的发展却无法商业变现。历史上著名的太阳公司，雅虎公司。好的公司里面必要有优秀的人才。
每一个叫的名字的公司，之前都经历过一段痛苦时间，每一个站在行业顶端的互联网公司，都占据着市场上诸多的利润。不要看到大公司的今天，回头看看，他们的一路。任何事情也都是如此。
下面的记录的一些定律：未来的一天这些定律也可能不复存在
计算机行业的发展规律 摩尔定律 每18个月，计算机等IT产品的性能翻一番；或者是说相同性能的计算机等IT产品，每18个月价钱会降一半。【小范围适用于你买电子产品】
安迪-比尔定律 安迪：英特尔公司传奇CEO
比尔: 微软公司创始人比尔盖茨
软件压榨着硬件的性能
以微软为首的软件开发公司吃掉硬件提升带来的全部好处，迫使用户更新机器，让硬件厂商受益。硬件厂商继而研发，根据摩尔定律，提升硬件性能，为微软下一步更新软件做准备，形成完整生态链。
反摩尔定律 一个IT公司如果今天和18个月前卖掉同样多的、同样的产品，它的营业额就会降一半。
反摩尔定律逼着所有硬件公司都必须追赶上摩尔定律规定的更新速度。
信息产业的规律性 70-20-10 行业老大吃掉市场的70%，老二吃掉20%，剩下的瓜分10%
诺威格定律 一家公司的市场占有率超过50%，就无法在翻一番了。公司进行“横向扩展” 、业务转型
基因决定定律 一家公司的基因决定了这家公司的发展
黑格尔的一句话: 凡是现实的都是合理的，凡是合理的都是现实的。All that is real is rational; and all that is rational is real
意思是说: 现实存在的现象，当初产生它的时候必然有它产生的原因和理由。如果这个理由将来不存在了，终究有一天它也会消亡。
巴菲特：成功的关键不在于做对了多少件事，而在于少犯多少错误
工业革命与颠覆式创新 蒸汽机 电 信息革命-计算机 人工智能 技术革命的共性 时间间隔大约70-90年 拥有核心技术 带来新的财富剧增 信息和能量的造就
对服务的需求 对高端人才的需求 对品质的需求 对新事物的需求 工业革命的范式 现有产业 + 蒸汽机 = 新的产业 现有产业 + 电 = 新的产业 现有产业 + 摩尔定律 = 新的产业 第四次工业革命 - 智能革命， 上世纪70年代就提出来数据驱动的方法 现有产业 + 智能技术 = 新的产业 工业革命的核心资源：</description>
    </item>
    
    <item>
      <title>MySql高级 索引_集群</title>
      <link>https://AlfredNing.github.io/note/program/sql/mysql/mysql%E9%AB%98%E7%BA%A7-%E5%88%86%E6%9E%90_%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Sun, 04 Jun 2023 11:20:59 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/sql/mysql/mysql%E9%AB%98%E7%BA%A7-%E5%88%86%E6%9E%90_%E7%B4%A2%E5%BC%95/</guid>
      <description>索引 索引的分类 从功能逻辑划分 普通索引 唯一索引 主键索引 全文索引 从物理实现方法划分 聚簇索引 非聚簇索引 从作用字段划分 单列索引 联合索引 InnoDB: 支持B-Tree，FullText索引，不支持Hash索引
MyISAM: 支持B-Tree，FullText索引，不支持Hash索引
Memory: 支持B-Tree，Hash索引，不支持FullText索引
NDB: 支持Hash索引，不支持 B-Tree, FullText索引
Archive: 不支持 B-Tree, FullText,Hash索引
创建索引 方式1- 创建表时候指定 普通索引 CREATE TABLE book( book_id INT , book_name VARCHAR(100), authors VARCHAR(100), info VARCHAR(100) , comment VARCHAR(100), year_publication YEAR, INDEX(year_publication) ); 创建唯一索引 CREATE TABLE test1( id INT NOT NULL, name varchar(30) NOT NULL, UNIQUE INDEX uk_idx_id(id) ); 主键索引 CREATE TABLE student ( id INT(10) UNSIGNED AUTO_INCREMENT, student_no VARCHAR(200), student_name VARCHAR(200), PRIMARY KEY(id) ); # 删除主键索引 ALTER TABLE student drop PRIMARY KEY ; 创建单列索引 CREATE TABLE test2( id INT NOT NULL, name CHAR(50) NULL, INDEX single_idx_name(name(20)) ); 创建组合索引 CREATE TABLE test3( id INT(11) NOT NULL, name CHAR(30) NOT NULL, age INT(11) NOT NULL, info VARCHAR(255), INDEX multi_idx(id,name,age) ); 全文索引 CREATE TABLE `papers` ( id` int(10) unsigned NOT NULL AUTO_INCREMENT, `title` varchar(200) DEFAULT NULL, `content` text, PRIMARY KEY (`id`), FULLTEXT KEY `title` (`title`,`content`) ) ENGINE=MyISAM DEFAULT CHARSET=utf8; SELECT * FROM papers WHERE MATCH(title,content) AGAINST (‘查询字符串’); 空间索引 CREATE TABLE test5( geo GEOMETRY NOT NULL, SPATIAL INDEX spa_idx_geo(geo) ) ENGINE=MyISAM; 方式2-已经创建表上的添加 alter 形式 ALTER TABLE table_name ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name[length],.</description>
    </item>
    
    <item>
      <title>Vue</title>
      <link>https://AlfredNing.github.io/note/program/front_end/vue/</link>
      <pubDate>Thu, 01 Jun 2023 00:55:03 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/front_end/vue/</guid>
      <description>前介 构建用户界面的渐进式的框架
渐进式：可以在项目中一点点使用
Vue3初识 命令式编程vs声明式编程 命令式编程：how to do
声明式编程：what to do . 由框架完成how 的部分
MVVM模型 Model - View - ViewMode ： 软件架构模式
Vue Demo &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- 这里的template 是html提供的，也可以换成div等，但是template是不显示 --&amp;gt; &amp;lt;template id=&amp;#34;t1&amp;#34;&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h2&amp;gt;{{counter}}&amp;lt;/h2&amp;gt; &amp;lt;button @click=&amp;#39;increment&amp;#39;&amp;gt;+1&amp;lt;/button&amp;gt; &amp;lt;button @click=&amp;#39;decrement&amp;#39;&amp;gt;-1&amp;lt;/button&amp;gt; &amp;lt;h3&amp;gt;{{message}}&amp;lt;/h3&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script src=&amp;#34;https://unpkg.com/vue@3/dist/vue.global.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; Vue.createApp({ // 这里使用模板字符串 template: &amp;#39;#t1&amp;#39;, // vue3 data 函数 data: function () { return { message: &amp;#34;hello&amp;#34;, counter: 100 } }, methods: { increment() { this.</description>
    </item>
    
    <item>
      <title>DDD</title>
      <link>https://AlfredNing.github.io/note/program/architecture/ddd/</link>
      <pubDate>Sat, 27 May 2023 23:18:05 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/architecture/ddd/</guid>
      <description>DDD是软件核心复杂性的应对之道
调整程序的结构，该解耦的解耦，该拆分的拆分，在实现新的功能，才能保证设计质量
运用DDD，当系统业务变得复杂，将对业务的理解绘制出领域模型正确知道软件开发
微服务： 小而专
软件开发方式 DL驱动开发 数据驱动设计 DDD驱动设计 DL驱动开发 DeadLine驱动开发，给定截至日期。我挂你他喵的写成什么样，完成就好。
数据驱动设计 **良好的设计数据库表，**通过数据流串联对应的业务流程。适合小型系统，基本可以应付大多数的应用场景。
确定对应的数据实体 完成库表设计 DDD领域驱动设计 应对软件架构复杂设计方法论
整洁架构 软件退化 软件的本质是对真实世界的模拟 软件中业务逻辑正确与否的唯一标准就是是否与真实世界一致 软件要做成什么样，不由我们决定，也不用用户决定，而是由真实世界决定 产品为什么提出变更需求，因为他们对真实世界的理解也不是完全正确，跳过需要，建立在对真实世界理解的基础上进行开发。但认识真实世界是一件非常难的事情，最初只能认识真实世界中那些简单、清晰、易于理解的业务逻辑，完成该部分的软件 根源 第一版软件是完美的，但随后随着业务需求变动，软件的业务逻辑越来越接近真实世界，使得我们的软件越来越专业，同时业务逻辑也越来越复杂，软件规模也越来越大。简单软件有简单软件的设计，复杂软件有复杂软件的设计
每次软件变更，逐步调整软件的程序结构，由简单程序转变为复杂程序结构，而不是一味的塞代码，赛代码才是最终根源。
杜绝软件退化的两顶帽子 软件的发展规律是逐步从简单软件转换为复杂软件
发生在每次新需求变更的时候，采用一下设计方法
在不添加新功能的前提下，重构代码，调整原有程序结构，以适应新功能实现新的功能 实现新功能 过渡设计 每一种初始所谓的“灵活设计”只能应对一种需求变更，不能真正解决未来变更的问题，被称为“过度设计”
活在今天的格子里，做今天的事。为当前的需求进行设计，使其刚刚满足当前的需求 解决思路：
每次需求变更额设计，只有保证每次需求变更时候做出正确的设计，才能使得软件以良性循环维护下午
两顶帽子的实现思路 困难的是第一步，如何调整程序设计以适应新功能
多次变更，难以理清思路，设计开始迷失方向
最终解决 领域驱动的思想： 将真实世界与软件世界进行对应。每次需求变更，将变更还原到真实世界，看看真实世界，在根据真实世界进行变更设计，保持领域驱动。
领域驱动核心要求：领域模型 每次变更，先回到领域模型，基于业务进行领域模型的变更，然后在根据领域模型的变更指导程序变更
电商功能演练DDD 首要需求 采用领域分析 先进行需求分析，设计领域模型
领域模型图
1. 需求变更 分析付款与折扣的关系？
单一职责原则：软件系统中的每个元素都只负责自己职责范围内的事情，而将其他的事情交给别人去做，我只是去调用。
职责如何定义？ 错误理解：做某件事，和这件事相关的一切所有的事都是它的职责
正确理解：一个职责就是软件变化的原因
什么是高质量的代码？
用户提出需求变更，为了实现这个变更而修改软件的成本越低，软件的设计质量就越高。
这就要求每次需求变更的时候只修改一个模块的代码来实现新需求。
需要平时不断的整理代码，将因同一个原因而变更的代码放在一起，将因不同原因的代码而放在不同的模块中、不同类中。
单一职责原则要求在维护软件的过程中需要不断的进行整理，将软件变化的同一个原因的代码放在一起，将软件变化的不同原因分开放。
如何分析不同原因？
答案是否定，说明是不同原因。
2. 需求变更 答案是否定的
3. 需求变更 支付方式变更</description>
    </item>
    
    <item>
      <title>MySQL高级-引擎_底层文件</title>
      <link>https://AlfredNing.github.io/note/program/sql/mysql/mysql%E9%AB%98%E7%BA%A7-%E5%BC%95%E6%93%8E_%E5%BA%95%E5%B1%82%E6%96%87%E4%BB%B6/</link>
      <pubDate>Tue, 23 May 2023 19:40:55 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/sql/mysql/mysql%E9%AB%98%E7%BA%A7-%E5%BC%95%E6%93%8E_%E5%BA%95%E5%B1%82%E6%96%87%E4%BB%B6/</guid>
      <description>系统配置 字符集的设置 show variables like &amp;#39;character%&amp;#39;; character_set_server：服务器级别的字符集 character_set_database：当前数据库的字符集 character_set_client：服务器解码请求时使用的字符集 character_set_connection：服务器处理请求时会把请求字符串从character_set_client转为character_set_connection character_set_results：服务器向客户端返回数据时使用的字符集 小结
如果创建或修改列时没有显式的指定字符集和比较规则，则该列默认用表的字符集和比较规则 如果创建表时没有显式的指定字符集和比较规则，则该表默认用数据库的字符集和比较规则 如果创建数据库时没有显式的指定字符集和比较规则，则该数据库默认用服务器的字符集和比较规则 请求到响应过程中字符集的变化 graph TB A(客户端) --&amp;gt; |&amp;#34;使用操作系统的字符集编码请求字符串&amp;#34;| B(从character_set_client转换为character_set_connection) B --&amp;gt; C(从character_set_connection转换为具体的列使用的字符集) C --&amp;gt; D(将查询结果从具体的列上使用的字符集转换为character_set_results) D --&amp;gt; |&amp;#34;使用操作系统的字符集解码响应的字符串&amp;#34;| A SQL大小写的设置 show variables like &amp;#39;%lower_case_table_names%&amp;#39; 该参数只适用于5.7版本 默认为0 大小写敏感 设置为1，大小写不敏感，创建的表都是以小写方式存放在磁盘上，对于sql语句都是转换为小写对表和数据库查找 设置为2，创建的表和数据库依据语句上存放，凡是查找都是转换为小写进行 SQL编写建议 关键字和函数名称全部大写 数据库名、表名、表别名、字段名、字段别名等全部小写 SQL语句必须以分号结尾 SQL_MODE的设置 宽松模式 严格模式 MySQL的sql_mode合理设置
sql_mode是个很容易被忽视的变量,默认值是空值,在这种设置下是可以允许一些非法操作的,比如允许一些非法数据的插入。在生产环境必须将这个值设置为严格模式,所以开发、测试环境的数据库也必须要设置,这样在开发测试阶段就可以发现问题.
sql model 常用来解决下面几类问题
通过设置sql mode, 可以完成不同严格程度的数据校验，有效地保障数据准备性。
通过设置sql model 为宽松模式，来保证大多数sql符合标准的sql语法，这样应用在不同数据库之间进行迁移时，则不需要对业务sql 进行较大的修改。
3. 在不同数据库之间进行数据迁移之前，通过设置SQL Mode 可以使MySQL 上的数据更方便地迁移到目标数据库中。
# 临时设置 set global sql_mode = &amp;#39;&amp;#39;; -- 全局生效 set session sql_mode = &amp;#39;&amp;#39;; -- 会话生效 # my.</description>
    </item>
    
    <item>
      <title>分布式数据库理论</title>
      <link>https://AlfredNing.github.io/note/program/sql/distributed_database/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA/</link>
      <pubDate>Mon, 08 May 2023 22:36:49 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/sql/distributed_database/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA/</guid>
      <description>分布式数据库 分布式数据库的介绍 数据库产品特点
抽象程度高，用户仅从使用层面解除 商业氛围一直很浓厚 基本概念 分布式数据库的核心： 数据分片、数据同步
数据分片 讲数据分散到多个节点，以更高效、更灵活的方式来处理数据 分类：
水平分片：按行进行数据分割，数据被切割成一个个数据组，分散到不同节点 垂直分片：按列进行数据分割，一个数据表的模式（Schema）被切割为多个小的模式 数据同步 数据一致性的保证，分布式数据库的底线
早期的关系型商业数据库的分布式能力可以满足大部分用户的场景，因此产生了如 Oracle 等几种巨无霸数据库产品；
OLAP 领域首先寻求突破，演化出了大数据技术与 MPP 类型数据库，提供功能更强的数据分析能力；
去IOE 引入数据库中间件，并结合应用平台与开源单机数据库形成新一代解决方案，让商业关系型数据库走下神坛，NoSQL 数据库更进一步&amp;gt;打破了关系型数据库唯我独尊的江湖地位；
新一代分布式 OLTP 数据库正式完成了分布式领域对数据库核心特性的完整支持，它代表了分布式数据库从此走向了成熟，也表明了 OLAP 与 OLTP 分布式场景下，分别在各自领域内取得了胜利；
HTAP 和多模式数据处理的引入，再一次将 OLAP 与 OLTP 融合，从而将分布式数据库推向如传统商业关系型数据库数十年前那般的盛况，而其产生的影响要比后者更为深远
SQL的发展史 最初的数据管理“关系模型”是指由 IBM 研究人员 E.F. Codd 在 20 世纪 70 年代初设计的，并在 System R 及后续许多数据库系统中得到了普及。 由于 Schema（模式）的预定义，数据库获得存储相对紧凑，从而导致其性能较为优异；之后就是经典的 ACID 给业务带来了可控性，而基于标准化 SQL 的数据访问模式给企业级应用带来了更多的红利，因为“标准即是生产力”
缺点：
对前期设计要求高，因为后期修改 Schema 往往需要停机，没有考虑分布式场景，在扩展性和可用性层面缺乏支持；而分布式是 21 世纪应用必备的技能。
NoSQL数据库和SQL数据库的区别 NoSQL的缺点 由于缺乏ACID, 应用时需要非常小心处理数据一致性问题；同时其数据模型只针对特定的应用场景，一般不能使用一种 NoSQL 数据库来完成整个应用的构建，导致设计层面的复杂和维护的困难。</description>
    </item>
    
    <item>
      <title>调优案例</title>
      <link>https://AlfredNing.github.io/note/program/jvm/%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B/</link>
      <pubDate>Mon, 08 May 2023 20:30:30 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/jvm/%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B/</guid>
      <description>调优工具 jConsole Visual VM eclipse MAT JProfiler Arthas Java Mission Control Flame Graphs（火焰图） Tprofiler Btrace YourKit JProbe Spring Insight OOM 案例 堆溢出 报错信息 java.lang.OutOfMemoryError: Java heap space
参数配置 -XX:+PrintGCDetails -XX:MetaspaceSize=64m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=heap/heapdump.hprof -XX:+PrintGCDateStamps -Xms200M -Xmx200M -Xloggc:log/gc-oomHeap.log 原因及解决 原因
1、代码中可能存在大对象分配
2、可能存在内存泄漏，导致在多次GC之后，还是无法找到一块足够大的内存容纳当前对象。
解决方法
1、检查是否存在大对象的分配，最有可能的是大数组分配
2、通过jmap命令，把堆内存dump下来，使用MAT等工具分析一下，检查是否存在内存泄漏的问题
3、如果没有找到明显的内存泄漏，使用 -Xmx 加大堆内存
4、还有一点容易被忽略，检查是否有大量的自定义的 Finalizable 对象，也有可能是框架内部提供的，考虑其存在的必要性
分析GC日志
元空间溢出 方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、即时编译器编译后的代码等数据。虽然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。
Java 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。垃圾收集行为在这个区域是比较少出现的，其内存回收目标主要是针对常量池的回收和对类型的卸载。当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。
报错信息 java.lang.OutOfMemoryError: Metaspace
参数配置 -XX:+PrintGCDetails -XX:MetaspaceSize=60m -XX:MaxMetaspaceSize=60m -Xss512K -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=heap/heapdumpMeta.</description>
    </item>
    
    <item>
      <title>GC日志分析</title>
      <link>https://AlfredNing.github.io/note/program/jvm/gc%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/</link>
      <pubDate>Thu, 04 May 2023 22:36:26 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/jvm/gc%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/</guid>
      <description>GC日志参数 -verbose:gc 输出gc日志信息，默认输出到标准输出
-XX:+PrintGC 输出GC日志。类似：-verbose:gc
-XX:+PrintGCDetails 在发生垃圾回收时打印内存回收详细的日志，
并在进程退出时输出当前内存各区域分配情况
-XX:+PrintGCTimeStamps 输出GC发生时的时间戳
-XX:+PrintGCDateStamps 输出GC发生时的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）
-XX:+PrintHeapAtGC 每一次GC前和GC后，都打印堆信息
-Xloggc: 表示把GC日志写入到一个文件中去，而不是打印到标准输出中
测试代码 import java.util.ArrayList; /** * -Xms60m -Xmx60m -XX:SurvivorRatio=8 -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:./logs/gc.log * * @author Alfred.Ning * @since 2023年05月04日 22:54:00 */ public class GLogTest { public static void main(String[] args) { ArrayList&amp;lt;byte[]&amp;gt; bytes = new ArrayList&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; 500; i++) { byte[] arr = new byte[1024 * 1024]; bytes.add(arr); try { Thread.</description>
    </item>
    
    <item>
      <title>垃圾回收</title>
      <link>https://AlfredNing.github.io/note/program/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link>
      <pubDate>Tue, 02 May 2023 12:10:15 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid>
      <description>概述 什么是垃圾 运行程序中没有任何指针指向的对象。如果垃圾对象一直保留在内存空间，严重情况下，导致内存溢出
为什么需要GC 垃圾回收器: garbage collector 垃圾回收行为：gargage collection 如果不进行垃圾回收，内存迟早被消耗完 释放没用的对象，清楚内存的记录碎片。JVM将整理出来的内存分配给新的对象 随着应用程序所交付的业务越来越复杂。没有GC就不能保证应用程序的正常进行。经常造成STW的GC跟不上实际的需求，所以才会尝试不断的对GC进行优化 对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。 此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见OutOfMemoryError时，快速地根据错误异常日志定位问题和解决问题。 当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。 java垃圾回收区域中重点区域是 垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收。其中，Java堆是垃圾收集器的工作重点。 从次数上讲：
频繁收集Young区 较少收集Old区 基本不动Perm区（或元空间） 早期的GC 这种方式可以灵活控制内存释放的时间，但是会给开发人员带来频繁申请和释放内存的管理负担。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生内存泄漏，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。 在有了垃圾回收机制后，上述代码块极有可能变成这样：
现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势。可以说，这种自动化的内存分配和垃圾回收的方式己经成为现代开发语言必备的标准。
垃圾回收算法 垃圾判别阶段算法 JVM中究竟是如何标记一个死亡对象呢
简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。
引用计数算法 引用计数算法(Reference Counting)比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。
原理及其基本思路 对于一个对象A来说，只要有任何一个对象引用了A,则A的应用计数器就加1，当引用失效时，引用计数器就减1。只要对象A的引用计数器值为0，则表示对象A不可能再被使用，可进行回收。
优点 实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。
缺点 需要单独的字段存储计数器，这样的做法增加了存储空间的开销。 每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。 引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java 的垃圾回收器中没有使用这类算法。 如果使用该算法，如何解决循环引用 引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。
具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。
Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。
Python如何解决循环引用？
手动解除：很好理解，就是在合适的时机，解除引用关系。
使用弱引用weakref， weakref是Python提供的标准库，旨在解决循环引用。
可达性分析算法 - [目前常用算法] 原理及其基本思路 原理 将对象和对象的引用关系看做是一个图，选定活动的对象作为GC ROOTS，然后跟踪引用链条，如果一个对象和一个GC ROOTS之间不可达，也就是不存在引用链条，那么认为是可回收的对象。
基本思路 可达性分析算法是以根对象集合(GC Roots)为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链(Reference Chain) 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。 优点 实现简单，执行高效 ，有效的解决循环引用的问题，防止内存泄漏。
GC ROOTS 在Java 语言中， GC Roots 包括以下几类元素：</description>
    </item>
    
    <item>
      <title>执行引擎</title>
      <link>https://AlfredNing.github.io/note/program/jvm/%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</link>
      <pubDate>Mon, 01 May 2023 21:28:28 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/jvm/%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</guid>
      <description>执行引擎的定义 将字节码指令解释/编译为对应平台上的本地机器指令。将高级语言翻译成低级语言
执行引擎的工作流程 从外观上来看，所有的Java虚拟机的执行引擎输入、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果。
执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。 每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。 当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。 代码执行和编译的过程 过程1: javac.exe的执行 Java代码编译是由Java源码编译器来完成，流程图如下所示
java.exe的执行： Java字节码的执行是由JVM执行引擎来完成，流程图如下所示 概念 前端编译器 .java文件转换为.class文件的过程
后端运行期编译器 JIT 编译器，Just In Time Compiler: 把字节码转变成机器码的过程。
静态提前编译器 AOT 编译器，Ahead Of Time Compiler: 直接把.java文件编译成本地机器代码的过程。
HotSpot VM是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器并存的架构。
解释器 当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。
工作机制 解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。从这个角度说，java是解释语言。 当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。 解释器的分类 在Java的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。
字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。 而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。 在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。 Interpreter模块：实现了解释器的核心功能 Code模块：用于管理HotSpot VM在运行时生成的本地机器指令 只用解释器的问题 由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C/C++程序员所调侃。 为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。 不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。 为什么说Java是半解释半编译的语言 JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。 现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。 JIT编译器 JIT（Just In Time Compiler)编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。
为什么还保留解释器的问题 有些开发人员会感觉到诧异，既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。
首先明确：
当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。
编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。
所以：
尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。在此模式下，当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。
同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。
HotSpot执行方式 当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。</description>
    </item>
    
    <item>
      <title>对象内存布局</title>
      <link>https://AlfredNing.github.io/note/program/jvm/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</link>
      <pubDate>Thu, 13 Apr 2023 22:46:33 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/jvm/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</guid>
      <description>对象的实例化 创建对象的方式 new 关键字 Class的newInstance()：反射的方式，只能调用空参的构造器，权限必须是public Constructor的newInstance(X)：反射的方式，可以调用空参、带参的构造器，权限没有要求，实用性更广 使用clone: 不调用任何构造器，当前类只需要实现Clonable接口，默认是浅拷贝 使用反序列化：从文件、数据库当中、网络中获取一个对象的二进制流，反序列化为内存的对象 利用asm字节码技术，动态生成Constructor对象，第三方库Objensis 创建对象的步骤 字节码角度 new 后面来说一般都会跟着dup，因为在需要调用init方法，操作栈上要进行出栈
NEW ：如果找不到Class对象，则进行类加载。加载成功后，则在堆中分配内存，从Object 开始到本类路径上的所有属性值都要分配内存。分配完毕之后，进行零值初始化。在分配过程中，注意引用是占据存储空间的，它是一个变量，占用4个字节。这个指令完毕后，将指向实例对象的引用变量压入虚拟机栈顶。 DUP ：在栈顶复制该引用变量，这时的栈顶有两个指向堆内实例对象的引用变量。如果 方法有参数，还需要把参数压人操作栈中。两个引用变量的目的不同，其中压至底下的引用用于赋值，或者保存到局部变量表，另一个栈顶的引用变量作为句柄调用相关方法。 INVOKESPECIAL ：调用对象实例方法，通过栈顶的引用变量调用＜init&amp;gt; 方法。
执行步骤角度 - 面试回答 判断对象的类是否加载、链接、初始化 虚拟机遇到一条new指令，首选会去检查指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号所代表的类是否被加载、解析和初始化。（判断类元信息是否存在） 如果没有，在双亲委派模型下，使用当前类加载器以ClassLoader+包名+类名为key进行查找对应的.class文件 如果没有找到文件，抛出ClassNotFoundException异常 如果找到，则进行类加载，并生成对应的class类对象 为对象分配内存 首先计算对象占用空间的大小，接着在堆中划分一块内存给对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小 说明：选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。 指针碰撞 如果内存规整，使用指针碰撞 如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Pointer）来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。 如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。 一般使用带有compact（整理）过程的收集器时，使用指针碰撞。 空闲列表 如果内存不规整，虚拟机需要维护一个列表，使用空闲列表分配 如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式称为“空闲列表（Free List）”。 处理并发安全问题 分配内存空间问题，创建对象是很频繁的操作，虚拟机确保new对象的时候的线程安全，需要解决并发问题。虚拟机采用两种方式来解决并发问题 CAS 失败重试、区域加锁：保证指针更新操作的原子性 TLAB 把内存分配的动作按照不同的线程划分在不同的空间之中进行，即保证每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲区。（Thread Local Allocation Buffer)。虚拟机是否使用TLAB, 可以通过-XX:+/-UseTLAB参数决定 初始化分配到的内存空间 内存分配结束，虚拟机将分配到的内存空间都初始化为零值(不包括对象头)。这一步保证了对象的实例字段在Java代码中不用初始化就可以直接使用，程序能访问到这些字段的数据类型所对应的零值 设置对象的对象头 将对象的所属类（即类的元数据信息）、对象的hashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现 执行init方法的初始化 在Java程序的视角来看，初始化在正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量 因此一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。 对象的内存布局 对象头 对象自身运行的运行时元数据 哈希值：对象在堆空间中都有一个首地址值，栈空间的引用根据这个地址指向堆中的对象，这就是哈希值起的作用 GC分代年龄：对象是在Eden区创建，经过多次GC后，如果还没有进行回收，就会在survivor中来回移动，其对应的年龄计数器会发生变化，达到阈值后会进入养老区。 锁状态标志：在同步中判断该对象是否是锁 线程持有的锁 线程偏向ID 偏向时间戳 另一个是类型指针，执行元数据区的类元数据InstancClass,确定该对象所数据的类型 如果对象是数组，对象头中还必须要有一块用于记录数组的长度的数据 因为正常对象元数据就知道对象的确切大小。数组必须得知道长度 实例数据 对象真正存储的有效数据，包括代码中定义的各种类型的字段（包括从父类继承下来【包括父类私有】的和本身拥有的字段）</description>
    </item>
    
    <item>
      <title>并查集</title>
      <link>https://AlfredNing.github.io/note/program/algorithm/%E5%B9%B6%E6%9F%A5%E9%9B%86/</link>
      <pubDate>Sat, 25 Mar 2023 08:37:28 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/algorithm/%E5%B9%B6%E6%9F%A5%E9%9B%86/</guid>
      <description>算法定义 有若干个样本a、c、d、e&amp;hellip; 类型假设是V
在并查集一开始认为每个样本都在单独的集合里
设计两个方法
`isSameSet(V x, V y)： 查询两个样本x和有是否在同一个集合里面 union(V x, V y) : 把x和y各自所有集合的样本合并成一个集合 两个算法的时间复杂度越小越好
算法流程 算法实现 import java.util.HashMap; import java.util.List; import java.util.Stack; /** * 并查集实现 * * @author Alfred.Ning * @since 2023年03月25日 09:23:00 */ public class UnionFindImpl { public static class Node&amp;lt;V&amp;gt; { V value; public Node(V v) { value = v; } } public static class UnionFind&amp;lt;V&amp;gt; { private HashMap&amp;lt;V, Node&amp;lt;V&amp;gt;&amp;gt; nodes; private HashMap&amp;lt;Node&amp;lt;V&amp;gt;, Node&amp;lt;V&amp;gt;&amp;gt; parents; private HashMap&amp;lt;Node&amp;lt;V&amp;gt;, Integer&amp;gt; sizeMap; public UnionFind(List&amp;lt;V&amp;gt; values) { nodes = new HashMap&amp;lt;&amp;gt;(); parents = new HashMap&amp;lt;&amp;gt;(); sizeMap = new HashMap&amp;lt;&amp;gt;(); for (V v : values) { Node&amp;lt;V&amp;gt; node = new Node&amp;lt;&amp;gt;(v); nodes.</description>
    </item>
    
    <item>
      <title>运行时内存</title>
      <link>https://AlfredNing.github.io/note/program/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98/</link>
      <pubDate>Mon, 27 Feb 2023 21:33:26 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98/</guid>
      <description>jvm内存结构图
哪些内存结构与线程意义对应，其实问的是线程共有和私有 共有： 堆和方法区 私有： 本地方法栈、虚拟机栈、程序计数器
程序计数器 保证程序在程序系统中能够执行下去，CPU必须具有某些手段来确定下一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器 一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器。 在程序开始执行前，必须将它的起始地址，即程序的一条指令所在的内存单元地址送入PC，因此程序计数器（PC）的内容即是从内存提取的第一条指令的地址。当执行指令时，CPU将自动修改PC的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数，以便使其保持的总是将要执行的下一条指令的地址 由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单的对PC加1 当程序转移时，转移指令执行的最终结果就是要改变PC的值，此PC值就是转去的地址，以此实现转移。有些机器中也称PC为指令指针IP（Instruction Pointer） 特征 JVM中的程序计数寄存器（Program Counter Register）中， Register 的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。 CPU只有把数据装载到寄存器才能够运行。
JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟
很小的内存结构，忽略不计，也是运行最快的存储区域，不会随着程序的运行需要更大的空间 在JVM规范中，每个线程都有自己的程序计数器，是线程私有的，生命周期与线程生命周期保持一致 它是唯一一个在JVM虚拟机规范中没有规定任何OutOtMemoryError 情况的区域 问题 为什么使用PC寄存器来记录当前线程的执行地址 因为CPU需要不停的切换各个线程，准确知道执行的位置。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令 PC寄存器为什么被设置为线程私有 多线程在一个特定的时间段内之会执行某一个线程的方法，CPU需要不停的做任务切换**。为了准确记录各个线程正在执行的当前字节码指令，最好的办法就是为每一个线程分配PC寄存器**，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况 虚拟机栈 栈管运行，堆管内存
栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿
Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。 是线程私有的 生命周期: 生命周期和线程一致。
特点: 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。
栈是否有GC？ 不存在GC, 但有OOM
抛出的异常：
StackOverFlowError OutOfMemoryError Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个 StackOverflowError 异常 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出—个 OutOfMemoryError 异常 设置栈大小 -Xsssize (即：-XX:ThreadStackSize)
一般为：512k-1M 栈的大小直接决定了函数调用的最大深度 设置的栈空间值过大，会导致系统可以用于创建线程的数量减少 一般一个进程中通常有3000-5000个线程
jdk5.0之前，默认为256k jdk5.0之后，默认为1024k
栈帧 栈的基本单位是栈帧，每个线程都有自己的栈，栈中的数据都是以栈帧存在的。
方法与栈帧的关系 在这个线程执行的方法都有一个栈帧 栈帧是一个内存区块，是一个数据集，维护着方法执行过程中的各种数据信息 栈的内部结构 局部变量表 操作数栈或表达式栈 动态链接或指向运行时常量池的方法引用 方法返回地址（或方法正常退出或者异常退出的定义） 一些附加信息 局部变量表 - Local Varibales 局部变量表被称为局部变量数组或者本地变量表 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，数据类别包括：基本数据类型，对象引用、以returnAddress类型 局部变量表的大小是在编译器确定，保存在方法的code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的 方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减 **局部变量表的变量只在当前方法调用中有效。**在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。 静态变量与局部变量区别 类变量表有两次初始化的机会，第一次准备阶段，执行系统初始化，赋零值，另一次是在初始化阶段，赋予代码中指定的初始值 和类变量初始化不同，局部变量表不存在系统初始化的过程，一旦定义了局部变量则必须人为的初始化，否则无法使用 与GC ROOTS的关系 局部变量表的变量也是重要的垃圾回收节点，只要被局部变量中直接或者间接引用的对象都不会被回收</description>
    </item>
    
    <item>
      <title>类的加载</title>
      <link>https://AlfredNing.github.io/note/program/jvm/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/</link>
      <pubDate>Thu, 23 Feb 2023 20:16:54 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/jvm/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/</guid>
      <description>类的加载过程 Java数据类型分为数据基本数据类型和引用数据类型
基本类型由虚拟机预先定义，引用类型需要进行类的加载
类的加载大过程分为三步, 总过程七步
装载 将java的class文件加载到机器内存，并在内存中构建出Java类的原型-类模板对象
查找类的二进制文件，生成class实例
加载类，需要完成以下三件事情：
通过类的全名，获取类的二进制数据流 解析类的二进制数据流转换为方法区的数据结构(Java类模型) 创建java.lang.class类的实例，表示该类型 类模板对象 Java类在内存中的一个快照，JVM从字节码文件解析出来的常量池、类字段、类方法等类信息存储到类模板中。在运行期通过类模板获取Java类的任意信息，能够对Java类的成员变量进行遍历，进行方法调用。反射机制也是基于此，如果没有存储Java类的声明信息，JVM在运行期也无法进行反射
获取二进制数据流 class字节码文件符号JVM规范
通过读取class后缀的文件 读入jar、zip等归档数据包，提取类文件(热部署jar包原理基础) 事先存放在数据库的二进制数据 使用类型Http之类的协议通过网络进行加载 在运行时生成一段class的二进制信息等 class实例位置 类将.class文件加载至元空间后，会在堆中创建一个Java.lang.Class对象，用来封装类位于方法区内的数据结构，该Class对象是在加载类的过程中创建的，每个类都对应有一个Class类型的对象 数组类的加载 数组类本身不是由类加载器负责创建，而是由JVM在运行时根据需要去创建。加载器只负责加载数据元素的数据类型(基本数据类型和引用数据类型)，申请内存分配长度
链接 验证阶段 保证加载的字节码是合法、合理并符合jvm规范
格式验证回合装载阶段一起执行。验证通过之后，类加载器才会把验证成功的二级制数据信息加载到方法区中 格式验证之外的验证操作都在方法区中进行 准备阶段 为类的静态变量分配内存，并将其初始化为默认值。
Java并不支持boolean类型，对于boolean类型，内部实现是int,由于int的默认值是0,故对应的，boolean的默认值就是false
解析阶段 将类、接口、自动和方法的符号引用转换为直接引用
符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。比较容易理解的就是在Class类文件中，通过常量池进行了大量的符号引用。通过解析操作，符号引用就可以转化为目标方法在类中方法表的位置，从而使得方法被成功调用。
解析就是将符号引用转换为直接引用。换言之，直接引用存在，一定存在符号引用，反之不然
Java虚拟机规范并没有要求解析操作一定要按照顺序执行
在HotSpot VM中，加载、验证、准备和初始化会按照顺序有条不紊地执行，但链接阶段中的解析操作往往会伴随着JVM在执行完初始化之后再执行
初始化 为静态变量赋予正确的初始值
开始执行java字节码，执行类的初始化方法
clinit方法：该方法只能由JVM编译器生成，程序开发者无法自定义一个同名的方法，无法在java程序中调用该方法，该方法由java字节码组成 init方法：由类的静态成员变量赋值及其static语句块产生 clinit方法的生成 以下几种情况，不会生产clinit方法
一个类中没有声明任何类变量，也没静态代码块 一个类中声明类变量，但没有明确使用类的初始化语句以及静态代码块进行初始化操作 一个类中包含static final 修饰的基本类型字段，这些类字段使用编译时常量表达式 clinit是由虚拟机保证在多线程环境下正确的加锁同步，是线程安全的。如果有很长的耗时操作，是会造成死锁的。
类的加载 加载 = 装载 + 链接 + 初始化
Java程序的主动使用
主动使用的说明 Class只有在必须要首次使用的时候才会被装载，Java虚拟机不会无条件地装载Class类型。Java虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用。
主动使用只有下列几种情况：（即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成。）
当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化。
当调用类的静态方法时，即当使用了字节码invokestatic指令。
当使用类、接口的静态字段时(final修饰特殊考虑)，比如，使用getstatic或者putstatic指令。
当使用java.lang.reflect包中的方法反射类的方法时。比如：Class.forName(&amp;ldquo;com.atguigu.java.Test&amp;rdquo;)
当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</description>
    </item>
    
    <item>
      <title>Java8</title>
      <link>https://AlfredNing.github.io/note/program/java8/java8/</link>
      <pubDate>Sat, 18 Feb 2023 12:47:59 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/java8/java8/</guid>
      <description>新特性 lambda表达式 方法引用 函数接口 流式处理 新日期时间API Optional类 新工具、JavaScript执行引擎 javaFx 函数编程 lambda表达式 想要在代码块以后某个时间点执行 可以转换为函数式接口 闭包作用域中有效访问final变量 任何一个lambda表达式都可以转换为所使用API中对应的函数式接口，注意：lambda表达式转换为函数式接口时候，注意检查期异常 不允许声明一个与局部变量同名的参数或者局部变量 lambda使用this,创建该lambda表达式方法的参数 组成 可选的类型声明 可选的参数小括号 可选的大括号 可选的返回值【只有一句表达式可以省略】 功能 内联功能的实现
注意 变量引用不可变，实际内容可变
函数接口 只包含一个抽象方法的接口，可以通过lambda表达式创建该接口的对象
方法引用 方法引用用其名称指向方法
引用符号:: 指向方法
对象::实例方法 类:: 静态方法 类::实例方法（第一个参数会成为执行方法的对象) 构造器引用 类::new
java中无法构造一个泛型类型T的数组，但可以通过数组引用解决。
例如：stream.toArray(Class::new)
默认方法 类优先原则
接口中有一个默认方法，一个类也有同名的方法。另一个类继承了父类，实现了该接口。这种情况下，只有父类的方法会起作用。 出于兼容性，这样在接口中添加方法，不会对以前的编写的代码产生影响。不能对Object的方法定义默认方法
静态方法 为接口添加静态方法
Stream API 原则：做什么，而不是怎么做
Stream不会自己存储元素。元素可能被存储在底层的集合当中，或者根据需要产生出来 Stream操作符不会改变源对象的。相反，他们会返回一个持有结果的新Stream Stream操作符可能是延迟执行的。意味着他们等到需要结果的时候才执行 Stream使用三阶段 创建Stream 中间操作 终止操作产生结果 创建Stream Stream.of() Arrays.Stream 可选长度参数
空Stream: Stream.Empty()
Stream.generate(Supplier func);
Stream.iterate(seed, operator)
Pattern类的splitAsStream
Files.lines(path) : 记得使用try-with-resources语句</description>
    </item>
    
    <item>
      <title>字节码文件</title>
      <link>https://AlfredNing.github.io/note/program/jvm/%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6/</link>
      <pubDate>Fri, 17 Feb 2023 08:01:55 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/jvm/%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6/</guid>
      <description>字节码文件 字节码文件 字节码文件跨平台 JVM实现遵守JVM虚拟机规范，所有JVM的环境都是一样的，所以字节码文件可以在各种虚拟机上执行
通过Class文件，更多的计算机语言支持Java虚拟机平台。Class文件不仅仅是Java虚拟机的执行入口，更是Java生态圈的核心
字节码文件内容 源代码经过编译器生成一个字节码文件，字节码文件是一种二进制的文件，内容是JVM的指令，而C/C++由编译器直接生成机器码。随着Java平台的不断发展，在将来，Class文件的内容也一定会做进一步的扩充，但是其基本的格式和结构不会做重大调整
字节码文件编译器 作用范围 编译器种类 前端编译器
javac (全量编译器)/Eclipse中的ECJ	Eclipse Compiler for Java （增量编译器） 主要任务：将java源代码转化为符合jvm规范的字节码文件 劣势：前端编译器并不会直接涉及编译优化等方面的技术，而是将这些具体优化细节移交给HotSpot的JIT编译器负责 后端编译器
AOT(静态提前编译器，Ahead Of Time Compiler)
jdk9引入了AOT编译器(静态提前编译器，Ahead Of Time Compiler)
Java 9 引入了实验性 AOT 编译工具jaotc。它借助了 Graal 编译器，将所输入的 Java 类文件转换为机器码，并存放至生成的动态共享库之中。
所谓 AOT 编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而 AOT 编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。
.java -&amp;gt; .class -&amp;gt; .so
最大好处：Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢”的不良体验。
缺点：
破坏了java“一次编译，到处运行”，必须为每个不同硬件、OS编译对应的发行包。 降低了Java链接过程的动态性，加载的代码在编译期就必须全部已知。 还需要继续优化中，最初只支持Linux x64 java base
类的class对象 外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类 接口 数组 枚举 注解 基本数据类型 void 字节码指令 Java虚拟机的指令是由一个字节长度、代表着某种特定操作含义的操作码[opcode]以及跟随其后的零至多个代表此操作所需操作数的操作数[operand]组成。虚拟机中许多指令并不包含操作数，只有一个操作码
字节码相关面试
idea插件：jclasslib
import org.testng.annotations.Test; /** * @author Alfred.</description>
    </item>
    
    <item>
      <title>Jvm初识</title>
      <link>https://AlfredNing.github.io/note/program/jvm/jvm%E5%88%9D%E8%AF%86/</link>
      <pubDate>Tue, 14 Feb 2023 07:58:50 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/jvm/jvm%E5%88%9D%E8%AF%86/</guid>
      <description>JDK关系 Oracle JDK 与 Open JDK 关系
Oracle JDK是由oracle 公司开发的，Open JDK 是由IBM，Apple，SAP AG，Redhat等顶级公司合作开发 Oracle JDK大多数的功能是开源的，一些功能是开源。Open JDK完全开源 Oracle JDK以前的1.0版以前的版本是由Sun开发的，后来被Oracle收购并为其他版本维护，而OpenJDK最初只基于Java SDK或JDK版本7 Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本 Oracle JDK将从其10.0.X版本将收费，用户必须付费或必须依赖OpenJDK才能使用其免费版本 Oracle JDK在运行JDK时不会产生任何问题，而OpenJDK在为某些用户运行JDK时会产生一些问题 在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能 Oracle JDK具有良好的GC选项和更好的渲染器，而OpenJDK具有更少的GC选项，并且由于其包含自己的渲染器的分布，因此具有较慢的图形渲染器选项 Oracle JDK的构建过程基于OpenJDK，因此OpenJDK与Oracle JDK之间没有技术差异 Oracle JDK将更多地关注稳定性，它重视更多的企业级用户，而OpenJDK经常发布以支持其他性能，这可能会导致不稳定 JDK与JVM的关系 JDK: Java Development ToolKit(java开发工具包)。JDK是整个java的核心，包括了运行环境，java工具和java的基础类库。
jvm:Java Virtual Machine(java虚拟机)。通过在实际的计算机上模拟仿真各种计算机功能来实现。
使用JDK（调用JAVA API）开发JAVA程序后，通过JDK中的编译程序（javac）将Java程序编译为Java字节码，在JRE上运行这些字节码，JVM会解析并映射到真实操作系统的CPU指令集和OS的系统调用
如何理解java是跨平台的语言 当java的源代码经过编译程序编译成字节码，需要运行在不同的平台上面时，无需编译。
如何理解JVM是跨语言的平台 jvm面对的是字节码文件，只关心字节码文件，不关心何种编程语言，只要实现jvm规范即可。Java不是最强大的语言，但是JVM是最强大的虚拟机。
JVM的类型 Sun Classic VM &amp;ndash;&amp;gt;解释型
Exact VM &amp;ndash;&amp;gt; Solaris
SUN公司的 HotSpot VM
BEA 的 JRockit &amp;ndash;&amp;gt; 不包含解释器，服务器端，JMC
IBM 的 J9
KVM和CDC/CLDC Hotspot</description>
    </item>
    
    <item>
      <title>Kmp</title>
      <link>https://AlfredNing.github.io/note/program/algorithm/kmp/</link>
      <pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/algorithm/kmp/</guid>
      <description>使用场景 多用于子串匹配问题
流程 在暴力解的过程当中有加速
定义： 在该位置之前的前缀与后缀的长度，但不能取到字符串的整体长度，定义为指标信息
解释：
对匹配串建立上述指标信息 匹配过程 求解证明 x-r 与 y-r&amp;rsquo;是相同，从i位置匹配match串等同于从match的q位置进行匹配
i位置到r位置一定不能匹配match
验证：假设i位置到r位置，有个k位置能够匹配match串，那就说明从k位置到x位置是相同的，也就是match串y位置之前字符串的一个后缀，此时，与next的数组定义违反，出现了一个更长的。假设不成立。
next数组生成 match长度为M,时间复杂度为O(M)
next[0] = -1;
next[1] = 0;
next[2] = 0位置和1位置决定;
求i位置的next[i]时候，前面所有位置都已经准备好
next证明 来到i位置next[i]最大为next[i+1]+1
假设next[i]&amp;gt;next[i-1] + 1,
那么说明next[i-1]求解错误，矛盾，不成立
代码实现 public class Kmp { public static int getIndexOf(String s, String match) { if (s == null || match == null || match.length() &amp;lt; 1 || s.length() &amp;lt; match.length()) { return -1; } char[] strs = s.toCharArray(); char[] matchs = match.</description>
    </item>
    
    
    
  </channel>
</rss>
