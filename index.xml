<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>AlfredNing</title>
    <link>https://AlfredNing.github.io/</link>
    <description>Recent content on AlfredNing</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Thu, 01 Jun 2023 00:55:03 +0800</lastBuildDate><atom:link href="https://AlfredNing.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Vue</title>
      <link>https://AlfredNing.github.io/note/program/front_end/vue/</link>
      <pubDate>Thu, 01 Jun 2023 00:55:03 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/front_end/vue/</guid>
      <description>前介 构建用户界面的渐进式的框架
渐进式：可以在项目中一点点使用</description>
    </item>
    
    <item>
      <title>DDD</title>
      <link>https://AlfredNing.github.io/note/program/architecture/ddd/</link>
      <pubDate>Sat, 27 May 2023 23:18:05 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/architecture/ddd/</guid>
      <description>DDD是软件核心复杂性的应对之道
调整程序的结构，该解耦的解耦，该拆分的拆分，在实现新的功能，才能保证设计质量
运用DDD，当系统业务变得复杂，将对业务的理解绘制出领域模型正确知道软件开发
微服务： 小而专
整洁架构 软件退化 软件的本质是对真实世界的模拟 软件中业务逻辑正确与否的唯一标准就是是否与真实世界一致 软件要做成什么样，不由我们决定，也不用用户决定，而是由真实世界决定 产品为什么提出变更需求，因为他们对真实世界的理解也不是完全正确，跳过需要，建立在对真实世界理解的基础上进行开发。但认识真实世界是一件非常难的事情，最初只能认识真实世界中那些简单、清晰、易于理解的业务逻辑，完成该部分的软件 根源 第一版软件是完美的，但随后随着业务需求变动，软件的业务逻辑越来越接近真实世界，使得我们的软件越来越专业，同时业务逻辑也越来越复杂，软件规模也越来越大。简单软件有简单软件的设计，复杂软件有复杂软件的设计
每次软件变更，逐步调整软件的程序结构，由简单程序转变为复杂程序结构，而不是一味的塞代码，赛代码才是最终根源。
杜绝软件退化的两顶帽子 软件的发展规律是逐步从简单软件转换为复杂软件
发生在每次新需求变更的时候，采用一下设计方法
在不添加新功能的前提下，重构代码，调整原有程序结构，以适应新功能实现新的功能 实现新功能 过渡设计 每一种初始所谓的“灵活设计”只能应对一种需求变更，不能真正解决未来变更的问题，被称为“过度设计”
活在今天的格子里，做今天的事。为当前的需求进行设计，使其刚刚满足当前的需求 解决思路：
每次需求变更额设计，只有保证每次需求变更时候做出正确的设计，才能使得软件以良性循环维护下午
两顶帽子的实现思路 困难的是第一步，如何调整程序设计以适应新功能
多次变更，难以理清思路，设计开始迷失方向
最终解决 领域驱动的思想： 将真实世界与软件世界进行对应。每次需求变更，将变更还原到真实世界，看看真实世界，在根据真实世界进行变更设计，保持领域驱动。
领域驱动核心要求：领域模型 每次变更，先回到领域模型，基于业务进行领域模型的变更，然后在根据领域模型的变更指导程序变更
电商功能演练DDD 首要需求 采用领域分析 先进行需求分析，设计领域模型
领域模型图
1. 需求变更 分析付款与折扣的关系？
单一职责原则：软件系统中的每个元素都只负责自己职责范围内的事情，而将其他的事情交给别人去做，我只是去调用。
职责如何定义？ 错误理解：做某件事，和这件事相关的一切所有的事都是它的职责
正确理解：一个职责就是软件变化的原因
什么是高质量的代码？
用户提出需求变更，为了实现这个变更而修改软件的成本越低，软件的设计质量就越高。
这就要求每次需求变更的时候只修改一个模块的代码来实现新需求。
需要平时不断的整理代码，将因同一个原因而变更的代码放在一起，将因不同原因的代码而放在不同的模块中、不同类中。
单一职责原则要求在维护软件的过程中需要不断的进行整理，将软件变化的同一个原因的代码放在一起，将软件变化的不同原因分开放。
如何分析不同原因？
答案是否定，说明是不同原因。
2. 需求变更 答案是否定的
3. 需求变更 支付方式变更
DDD落地到数据库设计 早期系统设计 缺陷：
先进行数据库设计，但数据库设计只能描述数据结构，而不能描述系统对这些数据结构的处理
面向对象的软件设计系统设计 领域模型对象持久化 插入记录就是新增一个领域对象 修改就是根据key值去修改对应的领域对象 删除就是催毁这个领域对象 领域模型对象持久化存储的思想：将暂时不用的领域对象持久化存储到磁盘，再次使用这个领域对象，从数据库恢复成领域对象。
数据库设计发生剧烈的变化，但唯一不变的是领域对象。数据操作底层发生变更，上层业务代码不修改
DDD数据库设计的核心 以领域模型为核心，如何将领域模型转换成数据库的设计的过程。将类转换为表的过程</description>
    </item>
    
    <item>
      <title>MySql高级</title>
      <link>https://AlfredNing.github.io/note/program/sql/mysql/mysql%E9%AB%98%E7%BA%A7/</link>
      <pubDate>Tue, 23 May 2023 19:40:55 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/sql/mysql/mysql%E9%AB%98%E7%BA%A7/</guid>
      <description>系统配置 字符集的设置 show variables like &amp;#39;character%&amp;#39;; character_set_server：服务器级别的字符集 character_set_database：当前数据库的字符集 character_set_client：服务器解码请求时使用的字符集 character_set_connection：服务器处理请求时会把请求字符串从character_set_client转为character_set_connection character_set_results：服务器向客户端返回数据时使用的字符集 小结
如果创建或修改列时没有显式的指定字符集和比较规则，则该列默认用表的字符集和比较规则 如果创建表时没有显式的指定字符集和比较规则，则该表默认用数据库的字符集和比较规则 如果创建数据库时没有显式的指定字符集和比较规则，则该数据库默认用服务器的字符集和比较规则 请求到响应过程中字符集的变化 graph TB A(客户端) --&amp;gt; |&amp;#34;使用操作系统的字符集编码请求字符串&amp;#34;| B(从character_set_client转换为character_set_connection) B --&amp;gt; C(从character_set_connection转换为具体的列使用的字符集) C --&amp;gt; D(将查询结果从具体的列上使用的字符集转换为character_set_results) D --&amp;gt; |&amp;#34;使用操作系统的字符集解码响应的字符串&amp;#34;| A SQL大小写的设置 show variables like &amp;#39;%lower_case_table_names%&amp;#39; 该参数只适用于5.7版本 默认为0 大小写敏感 设置为1，大小写不敏感，创建的表都是以小写方式存放在磁盘上，对于sql语句都是转换为小写对表和数据库查找 设置为2，创建的表和数据库依据语句上存放，凡是查找都是转换为小写进行 SQL编写建议 关键字和函数名称全部大写 数据库名、表名、表别名、字段名、字段别名等全部小写 SQL语句必须以分号结尾 SQL_MODE的设置 宽松模式 严格模式 MySQL的sql_mode合理设置
sql_mode是个很容易被忽视的变量,默认值是空值,在这种设置下是可以允许一些非法操作的,比如允许一些非法数据的插入。在生产环境必须将这个值设置为严格模式,所以开发、测试环境的数据库也必须要设置,这样在开发测试阶段就可以发现问题.
sql model 常用来解决下面几类问题
通过设置sql mode, 可以完成不同严格程度的数据校验，有效地保障数据准备性。
通过设置sql model 为宽松模式，来保证大多数sql符合标准的sql语法，这样应用在不同数据库之间进行迁移时，则不需要对业务sql 进行较大的修改。
3. 在不同数据库之间进行数据迁移之前，通过设置SQL Mode 可以使MySQL 上的数据更方便地迁移到目标数据库中。
# 临时设置 set global sql_mode = &amp;#39;&amp;#39;; -- 全局生效 set session sql_mode = &amp;#39;&amp;#39;; -- 会话生效 # my.</description>
    </item>
    
    <item>
      <title>分布式数据库理论</title>
      <link>https://AlfredNing.github.io/note/program/sql/distributed_database/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA/</link>
      <pubDate>Mon, 08 May 2023 22:36:49 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/sql/distributed_database/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA/</guid>
      <description>分布式数据库 分布式数据库的介绍 数据库产品特点
抽象程度高，用户仅从使用层面解除 商业氛围一直很浓厚 基本概念 分布式数据库的核心： 数据分片、数据同步
数据分片 讲数据分散到多个节点，以更高效、更灵活的方式来处理数据 分类：
水平分片：按行进行数据分割，数据被切割成一个个数据组，分散到不同节点 垂直分片：按列进行数据分割，一个数据表的模式（Schema）被切割为多个小的模式 数据同步 数据一致性的保证，分布式数据库的底线
早期的关系型商业数据库的分布式能力可以满足大部分用户的场景，因此产生了如 Oracle 等几种巨无霸数据库产品；
OLAP 领域首先寻求突破，演化出了大数据技术与 MPP 类型数据库，提供功能更强的数据分析能力；
去IOE 引入数据库中间件，并结合应用平台与开源单机数据库形成新一代解决方案，让商业关系型数据库走下神坛，NoSQL 数据库更进一步&amp;gt;打破了关系型数据库唯我独尊的江湖地位；
新一代分布式 OLTP 数据库正式完成了分布式领域对数据库核心特性的完整支持，它代表了分布式数据库从此走向了成熟，也表明了 OLAP 与 OLTP 分布式场景下，分别在各自领域内取得了胜利；
HTAP 和多模式数据处理的引入，再一次将 OLAP 与 OLTP 融合，从而将分布式数据库推向如传统商业关系型数据库数十年前那般的盛况，而其产生的影响要比后者更为深远
SQL的发展史 最初的数据管理“关系模型”是指由 IBM 研究人员 E.F. Codd 在 20 世纪 70 年代初设计的，并在 System R 及后续许多数据库系统中得到了普及。 由于 Schema（模式）的预定义，数据库获得存储相对紧凑，从而导致其性能较为优异；之后就是经典的 ACID 给业务带来了可控性，而基于标准化 SQL 的数据访问模式给企业级应用带来了更多的红利，因为“标准即是生产力”
缺点：
对前期设计要求高，因为后期修改 Schema 往往需要停机，没有考虑分布式场景，在扩展性和可用性层面缺乏支持；而分布式是 21 世纪应用必备的技能。
NoSQL数据库和SQL数据库的区别 NoSQL的缺点 由于缺乏ACID, 应用时需要非常小心处理数据一致性问题；同时其数据模型只针对特定的应用场景，一般不能使用一种 NoSQL 数据库来完成整个应用的构建，导致设计层面的复杂和维护的困难。</description>
    </item>
    
    <item>
      <title>调优案例</title>
      <link>https://AlfredNing.github.io/note/program/jvm/%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B/</link>
      <pubDate>Mon, 08 May 2023 20:30:30 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/jvm/%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B/</guid>
      <description>调优工具 jConsole Visual VM eclipse MAT JProfiler Arthas Java Mission Control Flame Graphs（火焰图） Tprofiler Btrace YourKit JProbe Spring Insight OOM 案例 堆溢出 报错信息 java.lang.OutOfMemoryError: Java heap space
参数配置 -XX:+PrintGCDetails -XX:MetaspaceSize=64m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=heap/heapdump.hprof -XX:+PrintGCDateStamps -Xms200M -Xmx200M -Xloggc:log/gc-oomHeap.log 原因及解决 原因
1、代码中可能存在大对象分配
2、可能存在内存泄漏，导致在多次GC之后，还是无法找到一块足够大的内存容纳当前对象。
解决方法
1、检查是否存在大对象的分配，最有可能的是大数组分配
2、通过jmap命令，把堆内存dump下来，使用MAT等工具分析一下，检查是否存在内存泄漏的问题
3、如果没有找到明显的内存泄漏，使用 -Xmx 加大堆内存
4、还有一点容易被忽略，检查是否有大量的自定义的 Finalizable 对象，也有可能是框架内部提供的，考虑其存在的必要性
分析GC日志
元空间溢出 方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、即时编译器编译后的代码等数据。虽然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。
Java 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。垃圾收集行为在这个区域是比较少出现的，其内存回收目标主要是针对常量池的回收和对类型的卸载。当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。
报错信息 java.lang.OutOfMemoryError: Metaspace
参数配置 -XX:+PrintGCDetails -XX:MetaspaceSize=60m -XX:MaxMetaspaceSize=60m -Xss512K -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=heap/heapdumpMeta.</description>
    </item>
    
    <item>
      <title>GC日志分析</title>
      <link>https://AlfredNing.github.io/note/program/jvm/gc%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/</link>
      <pubDate>Thu, 04 May 2023 22:36:26 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/jvm/gc%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/</guid>
      <description>GC日志参数 -verbose:gc 输出gc日志信息，默认输出到标准输出
-XX:+PrintGC 输出GC日志。类似：-verbose:gc
-XX:+PrintGCDetails 在发生垃圾回收时打印内存回收详细的日志，
并在进程退出时输出当前内存各区域分配情况
-XX:+PrintGCTimeStamps 输出GC发生时的时间戳
-XX:+PrintGCDateStamps 输出GC发生时的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）
-XX:+PrintHeapAtGC 每一次GC前和GC后，都打印堆信息
-Xloggc: 表示把GC日志写入到一个文件中去，而不是打印到标准输出中
测试代码 import java.util.ArrayList; /** * -Xms60m -Xmx60m -XX:SurvivorRatio=8 -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:./logs/gc.log * * @author Alfred.Ning * @since 2023年05月04日 22:54:00 */ public class GLogTest { public static void main(String[] args) { ArrayList&amp;lt;byte[]&amp;gt; bytes = new ArrayList&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; 500; i++) { byte[] arr = new byte[1024 * 1024]; bytes.add(arr); try { Thread.</description>
    </item>
    
    <item>
      <title>垃圾回收</title>
      <link>https://AlfredNing.github.io/note/program/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link>
      <pubDate>Tue, 02 May 2023 12:10:15 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid>
      <description>概述 什么是垃圾 运行程序中没有任何指针指向的对象。如果垃圾对象一直保留在内存空间，严重情况下，导致内存溢出
为什么需要GC 垃圾回收器: garbage collector 垃圾回收行为：gargage collection 如果不进行垃圾回收，内存迟早被消耗完 释放没用的对象，清楚内存的记录碎片。JVM将整理出来的内存分配给新的对象 随着应用程序所交付的业务越来越复杂。没有GC就不能保证应用程序的正常进行。经常造成STW的GC跟不上实际的需求，所以才会尝试不断的对GC进行优化 对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。 此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见OutOfMemoryError时，快速地根据错误异常日志定位问题和解决问题。 当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。 java垃圾回收区域中重点区域是 垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收。其中，Java堆是垃圾收集器的工作重点。 从次数上讲：
频繁收集Young区 较少收集Old区 基本不动Perm区（或元空间） 早期的GC 这种方式可以灵活控制内存释放的时间，但是会给开发人员带来频繁申请和释放内存的管理负担。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生内存泄漏，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。 在有了垃圾回收机制后，上述代码块极有可能变成这样：
现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势。可以说，这种自动化的内存分配和垃圾回收的方式己经成为现代开发语言必备的标准。
垃圾回收算法 垃圾判别阶段算法 JVM中究竟是如何标记一个死亡对象呢
简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。
引用计数算法 引用计数算法(Reference Counting)比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。
原理及其基本思路 对于一个对象A来说，只要有任何一个对象引用了A,则A的应用计数器就加1，当引用失效时，引用计数器就减1。只要对象A的引用计数器值为0，则表示对象A不可能再被使用，可进行回收。
优点 实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。
缺点 需要单独的字段存储计数器，这样的做法增加了存储空间的开销。 每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。 引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java 的垃圾回收器中没有使用这类算法。 如果使用该算法，如何解决循环引用 引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。
具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。
Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。
Python如何解决循环引用？
手动解除：很好理解，就是在合适的时机，解除引用关系。
使用弱引用weakref， weakref是Python提供的标准库，旨在解决循环引用。
可达性分析算法 - [目前常用算法] 原理及其基本思路 原理 将对象和对象的引用关系看做是一个图，选定活动的对象作为GC ROOTS，然后跟踪引用链条，如果一个对象和一个GC ROOTS之间不可达，也就是不存在引用链条，那么认为是可回收的对象。
基本思路 可达性分析算法是以根对象集合(GC Roots)为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链(Reference Chain) 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。 优点 实现简单，执行高效 ，有效的解决循环引用的问题，防止内存泄漏。
GC ROOTS 在Java 语言中， GC Roots 包括以下几类元素：</description>
    </item>
    
    <item>
      <title>执行引擎</title>
      <link>https://AlfredNing.github.io/note/program/jvm/%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</link>
      <pubDate>Mon, 01 May 2023 21:28:28 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/jvm/%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</guid>
      <description>执行引擎的定义 将字节码指令解释/编译为对应平台上的本地机器指令。将高级语言翻译成低级语言
执行引擎的工作流程 从外观上来看，所有的Java虚拟机的执行引擎输入、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果。
执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。 每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。 当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。 代码执行和编译的过程 过程1: javac.exe的执行 Java代码编译是由Java源码编译器来完成，流程图如下所示
java.exe的执行： Java字节码的执行是由JVM执行引擎来完成，流程图如下所示 概念 前端编译器 .java文件转换为.class文件的过程
后端运行期编译器 JIT 编译器，Just In Time Compiler: 把字节码转变成机器码的过程。
静态提前编译器 AOT 编译器，Ahead Of Time Compiler: 直接把.java文件编译成本地机器代码的过程。
HotSpot VM是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器并存的架构。
解释器 当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。
工作机制 解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。从这个角度说，java是解释语言。 当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。 解释器的分类 在Java的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。
字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。 而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。 在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。 Interpreter模块：实现了解释器的核心功能 Code模块：用于管理HotSpot VM在运行时生成的本地机器指令 只用解释器的问题 由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C/C++程序员所调侃。 为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。 不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。 为什么说Java是半解释半编译的语言 JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。 现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。 JIT编译器 JIT（Just In Time Compiler)编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。
为什么还保留解释器的问题 有些开发人员会感觉到诧异，既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。
首先明确：
当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。
编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。
所以：
尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。在此模式下，当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。
同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。
HotSpot执行方式 当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。</description>
    </item>
    
    <item>
      <title>对象内存布局</title>
      <link>https://AlfredNing.github.io/note/program/jvm/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</link>
      <pubDate>Thu, 13 Apr 2023 22:46:33 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/jvm/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</guid>
      <description>对象的实例化 创建对象的方式 new 关键字 Class的newInstance()：反射的方式，只能调用空参的构造器，权限必须是public Constructor的newInstance(X)：反射的方式，可以调用空参、带参的构造器，权限没有要求，实用性更广 使用clone: 不调用任何构造器，当前类只需要实现Clonable接口，默认是浅拷贝 使用反序列化：从文件、数据库当中、网络中获取一个对象的二进制流，反序列化为内存的对象 利用asm字节码技术，动态生成Constructor对象，第三方库Objensis 创建对象的步骤 字节码角度 new 后面来说一般都会跟着dup，因为在需要调用init方法，操作栈上要进行出栈
NEW ：如果找不到Class对象，则进行类加载。加载成功后，则在堆中分配内存，从Object 开始到本类路径上的所有属性值都要分配内存。分配完毕之后，进行零值初始化。在分配过程中，注意引用是占据存储空间的，它是一个变量，占用4个字节。这个指令完毕后，将指向实例对象的引用变量压入虚拟机栈顶。 DUP ：在栈顶复制该引用变量，这时的栈顶有两个指向堆内实例对象的引用变量。如果 方法有参数，还需要把参数压人操作栈中。两个引用变量的目的不同，其中压至底下的引用用于赋值，或者保存到局部变量表，另一个栈顶的引用变量作为句柄调用相关方法。 INVOKESPECIAL ：调用对象实例方法，通过栈顶的引用变量调用＜init&amp;gt; 方法。
执行步骤角度 - 面试回答 判断对象的类是否加载、链接、初始化 虚拟机遇到一条new指令，首选会去检查指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号所代表的类是否被加载、解析和初始化。（判断类元信息是否存在） 如果没有，在双亲委派模型下，使用当前类加载器以ClassLoader+包名+类名为key进行查找对应的.class文件 如果没有找到文件，抛出ClassNotFoundException异常 如果找到，则进行类加载，并生成对应的class类对象 为对象分配内存 首先计算对象占用空间的大小，接着在堆中划分一块内存给对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小 说明：选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。 指针碰撞 如果内存规整，使用指针碰撞 如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Pointer）来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。 如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。 一般使用带有compact（整理）过程的收集器时，使用指针碰撞。 空闲列表 如果内存不规整，虚拟机需要维护一个列表，使用空闲列表分配 如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式称为“空闲列表（Free List）”。 处理并发安全问题 分配内存空间问题，创建对象是很频繁的操作，虚拟机确保new对象的时候的线程安全，需要解决并发问题。虚拟机采用两种方式来解决并发问题 CAS 失败重试、区域加锁：保证指针更新操作的原子性 TLAB 把内存分配的动作按照不同的线程划分在不同的空间之中进行，即保证每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲区。（Thread Local Allocation Buffer)。虚拟机是否使用TLAB, 可以通过-XX:+/-UseTLAB参数决定 初始化分配到的内存空间 内存分配结束，虚拟机将分配到的内存空间都初始化为零值(不包括对象头)。这一步保证了对象的实例字段在Java代码中不用初始化就可以直接使用，程序能访问到这些字段的数据类型所对应的零值 设置对象的对象头 将对象的所属类（即类的元数据信息）、对象的hashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现 执行init方法的初始化 在Java程序的视角来看，初始化在正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量 因此一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。 对象的内存布局 对象头 对象自身运行的运行时元数据 哈希值：对象在堆空间中都有一个首地址值，栈空间的引用根据这个地址指向堆中的对象，这就是哈希值起的作用 GC分代年龄：对象是在Eden区创建，经过多次GC后，如果还没有进行回收，就会在survivor中来回移动，其对应的年龄计数器会发生变化，达到阈值后会进入养老区。 锁状态标志：在同步中判断该对象是否是锁 线程持有的锁 线程偏向ID 偏向时间戳 另一个是类型指针，执行元数据区的类元数据InstancClass,确定该对象所数据的类型 如果对象是数组，对象头中还必须要有一块用于记录数组的长度的数据 因为正常对象元数据就知道对象的确切大小。数组必须得知道长度 实例数据 对象真正存储的有效数据，包括代码中定义的各种类型的字段（包括从父类继承下来【包括父类私有】的和本身拥有的字段）</description>
    </item>
    
    <item>
      <title>随想1</title>
      <link>https://AlfredNing.github.io/thinking/%E9%9A%8F%E8%AE%B0/</link>
      <pubDate>Tue, 11 Apr 2023 08:06:02 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/thinking/%E9%9A%8F%E8%AE%B0/</guid>
      <description>黑格尔的一句话: 凡是现实的都是合理的，凡是合理的都是现实的。All that is real is rational; and all that is rational is real
意思是说: 现实存在的现象，当初产生它的时候必然有它产生的原因和理由。如果这个理由将来不存在了，终究有一天它也会消亡。
巴菲特：成功的关键不在于做对了多少件事，而在于少犯多少错误</description>
    </item>
    
    <item>
      <title>C&#43;&#43;基础5</title>
      <link>https://AlfredNing.github.io/note/program/game/c&#43;&#43;/c&#43;&#43;%E5%9F%BA%E7%A1%805/</link>
      <pubDate>Tue, 28 Mar 2023 22:10:36 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/game/c&#43;&#43;/c&#43;&#43;%E5%9F%BA%E7%A1%805/</guid>
      <description>信号处理 号是由操作系统传给进程的中断，会提早终止一个程序。在 UNIX、LINUX、Mac OS X 或 Windows 系统上，可以通过按 Ctrl+C 产生中断
可以在程序捕获的信号
信号 描述 SIGABRT 程序的异常终止，如调用 abort。 SIGFPE 错误的算术运算，比如除以零或导致溢出的操作。 SIGILL 检测非法指令。 SIGINT 接收到交互注意信号。 SIGSEGV 非法访问内存。 SIGTERM 发送到程序的终止请求。 signal函数： 捕获突发事件 raise函数：生成信号 c++多线程 基于进程 ： 程序的并发执行
基于线程：同一程序的片段并发执行
多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径
使用 POSIX 编写多线程 C++ 程序。POSIX Threads 或 Pthreads 提供的 API 可在多种类 Unix POSIX 系统上可用，比如 FreeBSD、NetBSD、GNU/Linux、Mac OS X 和 Solaris
创建线程 #include &amp;lt;pthread.h&amp;gt;pthread_create (thread, attr, start_routine, arg) 在这里，pthread_create 创建一个新的线程，并让它可执行。下面是关于参数的说明：
参数 描述 thread 指向线程标识符指针。 attr 一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。 start_routine 线程运行函数起始地址，一旦线程被创建就会执行。 arg 运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。 创建线程成功时，函数返回 0，若返回值不为 0 则说明创建线程失败</description>
    </item>
    
    <item>
      <title>C&#43;&#43;基础4</title>
      <link>https://AlfredNing.github.io/note/program/game/c&#43;&#43;/c&#43;&#43;%E5%9F%BA%E7%A1%804/</link>
      <pubDate>Mon, 27 Mar 2023 20:10:47 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/game/c&#43;&#43;/c&#43;&#43;%E5%9F%BA%E7%A1%804/</guid>
      <description>数据封装 面向对象编程中把数据和操作数据的函数绑定在一起的一个概念。同等概念既数据隐藏
默认情况下，在类中定义的所有项目都是私有的。
把一个类定义为另一个类的友元类，会暴露实现细节，从而降低了封装性。理想的做法是尽可能地对外隐藏每个类的实现细节
设计策略 通常情况下，我们都会设置类成员状态为私有（private），除非我们真的需要将其暴露，这样才能保证良好的封装性。
这通常应用于数据成员，但它同样适用于所有成员，包括虚函数
接口（抽象类） 接口描述类的行为和功能，而不需要完成特定类的实现。
c++中的接口是用抽象类来实现，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与数据分离开的概念
抽象类: 类中至少有一个函数被声明为纯虚函数，纯虚函数是通过在声明中使用 &amp;ldquo;= 0&amp;rdquo; 来指定的
设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。
因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重载纯虚函数，就尝试实例化该类的对象，会导致编译错误。
可用于实例化对象的类被称为具体类。
#include &amp;lt;iostream&amp;gt; using namespace std; // 基类 class Shape {public: // 提供接口框架的纯虚函数 virtual int getArea() = 0; void setWidth(int w) { width = w; } void setHeight(int h) { height = h; }protected: int width; int height;}; // 派生类 class Rectangle: public Shape{public: int getArea() { return (width * height); }}; class Triangle : public Shape { public: int getArea() { return (width * height) / 2; } }; int main(void) { Rectangle Rect; Triangle Tri; Rect.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;基础3</title>
      <link>https://AlfredNing.github.io/note/program/game/c&#43;&#43;/c&#43;&#43;%E5%9F%BA%E7%A1%803/</link>
      <pubDate>Sun, 26 Mar 2023 19:04:24 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/game/c&#43;&#43;/c&#43;&#43;%E5%9F%BA%E7%A1%803/</guid>
      <description>指针 表示内存的地址。指针是一个变量，值为另一个变量的内存地址。内存位置的直接地址
必须先声明，后使用 所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表存地址的长的十六进制数 不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同 概念 描述 C++ Null 指针 C++ 支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。 C++ 指针的算术运算 可以对指针进行四种算术运算：++、&amp;ndash;、+、- C++ 指针 vs 数组 指针和数组之间有着密切的关系。 C++ 指针数组 可以定义用来存储指针的数组。 C++ 指向指针的指针 C++ 允许指向指针的指针。 C++ 传递指针给函数 通过引用或地址传递参数，使传递的参数在调用函数中被改变。 C++ 从函数返回指针 C++ 允许函数返回指针到局部变量、静态变量和动态内存分配。 #include &amp;lt;iostream&amp;gt; using namespace std; int main() { int var = 20; // 指针变量声明 int* ip; double* dp; ip = &amp;amp;var; // 使用: 变量存储的地址 cout &amp;lt;&amp;lt; &amp;#34;ip: &amp;#34; &amp;lt;&amp;lt; ip &amp;lt;&amp;lt; endl; // 访问地址 cout &amp;lt;&amp;lt; *ip &amp;lt;&amp;lt; endl; return 0; } 引用 引用变量是一个别名，他是一件存在的变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</description>
    </item>
    
    <item>
      <title>并查集</title>
      <link>https://AlfredNing.github.io/note/program/algorithm/%E5%B9%B6%E6%9F%A5%E9%9B%86/</link>
      <pubDate>Sat, 25 Mar 2023 08:37:28 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/algorithm/%E5%B9%B6%E6%9F%A5%E9%9B%86/</guid>
      <description>算法定义 有若干个样本a、c、d、e&amp;hellip; 类型假设是V
在并查集一开始认为每个样本都在单独的集合里
设计两个方法
`isSameSet(V x, V y)： 查询两个样本x和有是否在同一个集合里面 union(V x, V y) : 把x和y各自所有集合的样本合并成一个集合 两个算法的时间复杂度越小越好
算法流程 算法实现 import java.util.HashMap; import java.util.List; import java.util.Stack; /** * 并查集实现 * * @author Alfred.Ning * @since 2023年03月25日 09:23:00 */ public class UnionFindImpl { public static class Node&amp;lt;V&amp;gt; { V value; public Node(V v) { value = v; } } public static class UnionFind&amp;lt;V&amp;gt; { private HashMap&amp;lt;V, Node&amp;lt;V&amp;gt;&amp;gt; nodes; private HashMap&amp;lt;Node&amp;lt;V&amp;gt;, Node&amp;lt;V&amp;gt;&amp;gt; parents; private HashMap&amp;lt;Node&amp;lt;V&amp;gt;, Integer&amp;gt; sizeMap; public UnionFind(List&amp;lt;V&amp;gt; values) { nodes = new HashMap&amp;lt;&amp;gt;(); parents = new HashMap&amp;lt;&amp;gt;(); sizeMap = new HashMap&amp;lt;&amp;gt;(); for (V v : values) { Node&amp;lt;V&amp;gt; node = new Node&amp;lt;&amp;gt;(v); nodes.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;基础2</title>
      <link>https://AlfredNing.github.io/note/program/game/c&#43;&#43;/c&#43;&#43;%E5%9F%BA%E7%A1%802/</link>
      <pubDate>Wed, 22 Mar 2023 22:40:59 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/game/c&#43;&#43;/c&#43;&#43;%E5%9F%BA%E7%A1%802/</guid>
      <description>c++运算符 算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 杂项运算符 算术运算符 假设变量 A 的值为 10，变量 B 的值为 20，则：
运算符 描述 实例 + 把两个操作数相加 A + B 将得到 30 - 从第一个操作数中减去第二个操作数 A - B 将得到 -10 * 把两个操作数相乘 A * B 将得到 200 / 分子除以分母 B / A 将得到 2 % 取模运算符，整除后的余数 B % A 将得到 0 ++ 自增运算符，整数值增加 1 A++ 将得到 11 &amp;ndash; 自减运算符，整数值减少 1 A&amp;ndash; 将得到 9 关系运算符 假设变量 A 的值为 10，变量 B 的值为 20，则：</description>
    </item>
    
    <item>
      <title>C&#43;&#43;初始</title>
      <link>https://AlfredNing.github.io/note/program/game/c&#43;&#43;/c&#43;&#43;%E5%9F%BA%E7%A1%801/</link>
      <pubDate>Wed, 22 Mar 2023 07:31:48 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/game/c&#43;&#43;/c&#43;&#43;%E5%9F%BA%E7%A1%801/</guid>
      <description>简介 C++一种静态类型、编译式、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。
c++是一门中级语言，综合高级语言和低级语言的特点。
C++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。
静态类型的编程语言都是在编译时候执行类型检查，而不是在运行时候执行类型检查
面向对象四大特点 封装 继承 抽象 多态 开发工具，window使用Visual Studio
对象 - 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。 类 - 类可以定义为描述对象行为/状态的模板/蓝图。 方法 - 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。 即时变量 - 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。 程序结构 #include &amp;lt;iostream&amp;gt; using namespace std; int main() { cout &amp;lt;&amp;lt; &amp;#34;Hello, world!&amp;#34; &amp;lt;&amp;lt; endl; return 0; } g++ hello.cpp$ ./a.outHello Wo 头文件：包含程序必须的或有用的信息 命名空间 main 函数程序开始 分号是语句结束符，每个语句必须以分号结束。c++不以行末作为结束符，一行可以放置多个语句 块是一组使用大括号括起来的按逻辑连接的语句 标识符 以字母A-Z或a-z或下划线_开始，后跟多个字母数字下划线
关键字 asm else new this auto enum operator throw bool explicit private true break export protected try case extern public typedef catch false register typeid char float reinterpret_cast typename class for return union const friend short unsigned const_cast goto signed using continue if sizeof virtual default inline static void delete int static_cast volatile do long struct wchar_t double mutable switch while dynamic_cast namespace template 三字符组 用于表示另一个字符的三个字符系列，又称为三字符系列</description>
    </item>
    
    <item>
      <title>运行时内存</title>
      <link>https://AlfredNing.github.io/note/program/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98/</link>
      <pubDate>Mon, 27 Feb 2023 21:33:26 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98/</guid>
      <description>jvm内存结构图
哪些内存结构与线程意义对应，其实问的是线程共有和私有 共有： 堆和方法区 私有： 本地方法栈、虚拟机栈、程序计数器
程序计数器 保证程序在程序系统中能够执行下去，CPU必须具有某些手段来确定下一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器 一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器。 在程序开始执行前，必须将它的起始地址，即程序的一条指令所在的内存单元地址送入PC，因此程序计数器（PC）的内容即是从内存提取的第一条指令的地址。当执行指令时，CPU将自动修改PC的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数，以便使其保持的总是将要执行的下一条指令的地址 由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单的对PC加1 当程序转移时，转移指令执行的最终结果就是要改变PC的值，此PC值就是转去的地址，以此实现转移。有些机器中也称PC为指令指针IP（Instruction Pointer） 特征 JVM中的程序计数寄存器（Program Counter Register）中， Register 的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。 CPU只有把数据装载到寄存器才能够运行。
JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟
很小的内存结构，忽略不计，也是运行最快的存储区域，不会随着程序的运行需要更大的空间 在JVM规范中，每个线程都有自己的程序计数器，是线程私有的，生命周期与线程生命周期保持一致 它是唯一一个在JVM虚拟机规范中没有规定任何OutOtMemoryError 情况的区域 问题 为什么使用PC寄存器来记录当前线程的执行地址 因为CPU需要不停的切换各个线程，准确知道执行的位置。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令 PC寄存器为什么被设置为线程私有 多线程在一个特定的时间段内之会执行某一个线程的方法，CPU需要不停的做任务切换**。为了准确记录各个线程正在执行的当前字节码指令，最好的办法就是为每一个线程分配PC寄存器**，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况 虚拟机栈 栈管运行，堆管内存
栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿
Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。 是线程私有的 生命周期: 生命周期和线程一致。
特点: 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。
栈是否有GC？ 不存在GC, 但有OOM
抛出的异常：
StackOverFlowError OutOfMemoryError Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个 StackOverflowError 异常 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出—个 OutOfMemoryError 异常 设置栈大小 -Xsssize (即：-XX:ThreadStackSize)
一般为：512k-1M 栈的大小直接决定了函数调用的最大深度 设置的栈空间值过大，会导致系统可以用于创建线程的数量减少 一般一个进程中通常有3000-5000个线程
jdk5.0之前，默认为256k jdk5.0之后，默认为1024k
栈帧 栈的基本单位是栈帧，每个线程都有自己的栈，栈中的数据都是以栈帧存在的。
方法与栈帧的关系 在这个线程执行的方法都有一个栈帧 栈帧是一个内存区块，是一个数据集，维护着方法执行过程中的各种数据信息 栈的内部结构 局部变量表 操作数栈或表达式栈 动态链接或指向运行时常量池的方法引用 方法返回地址（或方法正常退出或者异常退出的定义） 一些附加信息 局部变量表 - Local Varibales 局部变量表被称为局部变量数组或者本地变量表 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，数据类别包括：基本数据类型，对象引用、以returnAddress类型 局部变量表的大小是在编译器确定，保存在方法的code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的 方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减 **局部变量表的变量只在当前方法调用中有效。**在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。 静态变量与局部变量区别 类变量表有两次初始化的机会，第一次准备阶段，执行系统初始化，赋零值，另一次是在初始化阶段，赋予代码中指定的初始值 和类变量初始化不同，局部变量表不存在系统初始化的过程，一旦定义了局部变量则必须人为的初始化，否则无法使用 与GC ROOTS的关系 局部变量表的变量也是重要的垃圾回收节点，只要被局部变量中直接或者间接引用的对象都不会被回收</description>
    </item>
    
    <item>
      <title>类的加载</title>
      <link>https://AlfredNing.github.io/note/program/jvm/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/</link>
      <pubDate>Thu, 23 Feb 2023 20:16:54 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/jvm/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/</guid>
      <description>类的加载过程 Java数据类型分为数据基本数据类型和引用数据类型
基本类型由虚拟机预先定义，引用类型需要进行类的加载
类的加载大过程分为三步, 总过程七步
装载 将java的class文件加载到机器内存，并在内存中构建出Java类的原型-类模板对象
查找类的二进制文件，生成class实例
加载类，需要完成以下三件事情：
通过类的全名，获取类的二进制数据流 解析类的二进制数据流转换为方法区的数据结构(Java类模型) 创建java.lang.class类的实例，表示该类型 类模板对象 Java类在内存中的一个快照，JVM从字节码文件解析出来的常量池、类字段、类方法等类信息存储到类模板中。在运行期通过类模板获取Java类的任意信息，能够对Java类的成员变量进行遍历，进行方法调用。反射机制也是基于此，如果没有存储Java类的声明信息，JVM在运行期也无法进行反射
获取二进制数据流 class字节码文件符号JVM规范
通过读取class后缀的文件 读入jar、zip等归档数据包，提取类文件(热部署jar包原理基础) 事先存放在数据库的二进制数据 使用类型Http之类的协议通过网络进行加载 在运行时生成一段class的二进制信息等 class实例位置 类将.class文件加载至元空间后，会在堆中创建一个Java.lang.Class对象，用来封装类位于方法区内的数据结构，该Class对象是在加载类的过程中创建的，每个类都对应有一个Class类型的对象 数组类的加载 数组类本身不是由类加载器负责创建，而是由JVM在运行时根据需要去创建。加载器只负责加载数据元素的数据类型(基本数据类型和引用数据类型)，申请内存分配长度
链接 验证阶段 保证加载的字节码是合法、合理并符合jvm规范
格式验证回合装载阶段一起执行。验证通过之后，类加载器才会把验证成功的二级制数据信息加载到方法区中 格式验证之外的验证操作都在方法区中进行 准备阶段 为类的静态变量分配内存，并将其初始化为默认值。
Java并不支持boolean类型，对于boolean类型，内部实现是int,由于int的默认值是0,故对应的，boolean的默认值就是false
解析阶段 将类、接口、自动和方法的符号引用转换为直接引用
符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。比较容易理解的就是在Class类文件中，通过常量池进行了大量的符号引用。通过解析操作，符号引用就可以转化为目标方法在类中方法表的位置，从而使得方法被成功调用。
解析就是将符号引用转换为直接引用。换言之，直接引用存在，一定存在符号引用，反之不然
Java虚拟机规范并没有要求解析操作一定要按照顺序执行
在HotSpot VM中，加载、验证、准备和初始化会按照顺序有条不紊地执行，但链接阶段中的解析操作往往会伴随着JVM在执行完初始化之后再执行
初始化 为静态变量赋予正确的初始值
开始执行java字节码，执行类的初始化方法
clinit方法：该方法只能由JVM编译器生成，程序开发者无法自定义一个同名的方法，无法在java程序中调用该方法，该方法由java字节码组成 init方法：由类的静态成员变量赋值及其static语句块产生 clinit方法的生成 以下几种情况，不会生产clinit方法
一个类中没有声明任何类变量，也没静态代码块 一个类中声明类变量，但没有明确使用类的初始化语句以及静态代码块进行初始化操作 一个类中包含static final 修饰的基本类型字段，这些类字段使用编译时常量表达式 clinit是由虚拟机保证在多线程环境下正确的加锁同步，是线程安全的。如果有很长的耗时操作，是会造成死锁的。
类的加载 加载 = 装载 + 链接 + 初始化
Java程序的主动使用
主动使用的说明 Class只有在必须要首次使用的时候才会被装载，Java虚拟机不会无条件地装载Class类型。Java虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用。
主动使用只有下列几种情况：（即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成。）
当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化。
当调用类的静态方法时，即当使用了字节码invokestatic指令。
当使用类、接口的静态字段时(final修饰特殊考虑)，比如，使用getstatic或者putstatic指令。
当使用java.lang.reflect包中的方法反射类的方法时。比如：Class.forName(&amp;ldquo;com.atguigu.java.Test&amp;rdquo;)
当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</description>
    </item>
    
    <item>
      <title>Java8</title>
      <link>https://AlfredNing.github.io/note/program/java8/java8/</link>
      <pubDate>Sat, 18 Feb 2023 12:47:59 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/java8/java8/</guid>
      <description>新特性 lambda表达式 方法引用 函数接口 流式处理 新日期时间API Optional类 新工具、JavaScript执行引擎 javaFx 函数编程 lambda表达式 想要在代码块以后某个时间点执行 可以转换为函数式接口 闭包作用域中有效访问final变量 任何一个lambda表达式都可以转换为所使用API中对应的函数式接口，注意：lambda表达式转换为函数式接口时候，注意检查期异常 不允许声明一个与局部变量同名的参数或者局部变量 lambda使用this,创建该lambda表达式方法的参数 组成 可选的类型声明 可选的参数小括号 可选的大括号 可选的返回值【只有一句表达式可以省略】 功能 内联功能的实现
注意 变量引用不可变，实际内容可变
函数接口 只包含一个抽象方法的接口，可以通过lambda表达式创建该接口的对象
方法引用 方法引用用其名称指向方法
引用符号:: 指向方法
对象::实例方法 类:: 静态方法 类::实例方法（第一个参数会成为执行方法的对象) 构造器引用 类::new
java中无法构造一个泛型类型T的数组，但可以通过数组引用解决。
例如：stream.toArray(Class::new)
默认方法 类优先原则
接口中有一个默认方法，一个类也有同名的方法。另一个类继承了父类，实现了该接口。这种情况下，只有父类的方法会起作用。 出于兼容性，这样在接口中添加方法，不会对以前的编写的代码产生影响。不能对Object的方法定义默认方法
静态方法 为接口添加静态方法
Stream API 原则：做什么，而不是怎么做
Stream不会自己存储元素。元素可能被存储在底层的集合当中，或者根据需要产生出来 Stream操作符不会改变源对象的。相反，他们会返回一个持有结果的新Stream Stream操作符可能是延迟执行的。意味着他们等到需要结果的时候才执行 Stream使用三阶段 创建Stream 中间操作 终止操作产生结果 创建Stream Stream.of() Arrays.Stream 可选长度参数
空Stream: Stream.Empty()
Stream.generate(Supplier func);
Stream.iterate(seed, operator)
Pattern类的splitAsStream
Files.lines(path) : 记得使用try-with-resources语句</description>
    </item>
    
    <item>
      <title>字节码文件</title>
      <link>https://AlfredNing.github.io/note/program/jvm/%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6/</link>
      <pubDate>Fri, 17 Feb 2023 08:01:55 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/jvm/%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6/</guid>
      <description>字节码文件 字节码文件 字节码文件跨平台 JVM实现遵守JVM虚拟机规范，所有JVM的环境都是一样的，所以字节码文件可以在各种虚拟机上执行
通过Class文件，更多的计算机语言支持Java虚拟机平台。Class文件不仅仅是Java虚拟机的执行入口，更是Java生态圈的核心
字节码文件内容 源代码经过编译器生成一个字节码文件，字节码文件是一种二进制的文件，内容是JVM的指令，而C/C++由编译器直接生成机器码。随着Java平台的不断发展，在将来，Class文件的内容也一定会做进一步的扩充，但是其基本的格式和结构不会做重大调整
字节码文件编译器 作用范围 编译器种类 前端编译器
javac (全量编译器)/Eclipse中的ECJ	Eclipse Compiler for Java （增量编译器） 主要任务：将java源代码转化为符合jvm规范的字节码文件 劣势：前端编译器并不会直接涉及编译优化等方面的技术，而是将这些具体优化细节移交给HotSpot的JIT编译器负责 后端编译器
AOT(静态提前编译器，Ahead Of Time Compiler)
jdk9引入了AOT编译器(静态提前编译器，Ahead Of Time Compiler)
Java 9 引入了实验性 AOT 编译工具jaotc。它借助了 Graal 编译器，将所输入的 Java 类文件转换为机器码，并存放至生成的动态共享库之中。
所谓 AOT 编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而 AOT 编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。
.java -&amp;gt; .class -&amp;gt; .so
最大好处：Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢”的不良体验。
缺点：
破坏了java“一次编译，到处运行”，必须为每个不同硬件、OS编译对应的发行包。 降低了Java链接过程的动态性，加载的代码在编译期就必须全部已知。 还需要继续优化中，最初只支持Linux x64 java base
类的class对象 外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类 接口 数组 枚举 注解 基本数据类型 void 字节码指令 Java虚拟机的指令是由一个字节长度、代表着某种特定操作含义的操作码[opcode]以及跟随其后的零至多个代表此操作所需操作数的操作数[operand]组成。虚拟机中许多指令并不包含操作数，只有一个操作码
字节码相关面试
idea插件：jclasslib
import org.testng.annotations.Test; /** * @author Alfred.</description>
    </item>
    
    <item>
      <title>Jvm初识</title>
      <link>https://AlfredNing.github.io/note/program/jvm/jvm%E5%88%9D%E8%AF%86/</link>
      <pubDate>Tue, 14 Feb 2023 07:58:50 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/jvm/jvm%E5%88%9D%E8%AF%86/</guid>
      <description>JDK关系 Oracle JDK 与 Open JDK 关系
Oracle JDK是由oracle 公司开发的，Open JDK 是由IBM，Apple，SAP AG，Redhat等顶级公司合作开发 Oracle JDK大多数的功能是开源的，一些功能是开源。Open JDK完全开源 Oracle JDK以前的1.0版以前的版本是由Sun开发的，后来被Oracle收购并为其他版本维护，而OpenJDK最初只基于Java SDK或JDK版本7 Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本 Oracle JDK将从其10.0.X版本将收费，用户必须付费或必须依赖OpenJDK才能使用其免费版本 Oracle JDK在运行JDK时不会产生任何问题，而OpenJDK在为某些用户运行JDK时会产生一些问题 在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能 Oracle JDK具有良好的GC选项和更好的渲染器，而OpenJDK具有更少的GC选项，并且由于其包含自己的渲染器的分布，因此具有较慢的图形渲染器选项 Oracle JDK的构建过程基于OpenJDK，因此OpenJDK与Oracle JDK之间没有技术差异 Oracle JDK将更多地关注稳定性，它重视更多的企业级用户，而OpenJDK经常发布以支持其他性能，这可能会导致不稳定 JDK与JVM的关系 JDK: Java Development ToolKit(java开发工具包)。JDK是整个java的核心，包括了运行环境，java工具和java的基础类库。
jvm:Java Virtual Machine(java虚拟机)。通过在实际的计算机上模拟仿真各种计算机功能来实现。
使用JDK（调用JAVA API）开发JAVA程序后，通过JDK中的编译程序（javac）将Java程序编译为Java字节码，在JRE上运行这些字节码，JVM会解析并映射到真实操作系统的CPU指令集和OS的系统调用
如何理解java是跨平台的语言 当java的源代码经过编译程序编译成字节码，需要运行在不同的平台上面时，无需编译。
如何理解JVM是跨语言的平台 jvm面对的是字节码文件，只关心字节码文件，不关心何种编程语言，只要实现jvm规范即可。Java不是最强大的语言，但是JVM是最强大的虚拟机。
JVM的类型 Sun Classic VM &amp;ndash;&amp;gt;解释型
Exact VM &amp;ndash;&amp;gt; Solaris
SUN公司的 HotSpot VM
BEA 的 JRockit &amp;ndash;&amp;gt; 不包含解释器，服务器端，JMC
IBM 的 J9
KVM和CDC/CLDC Hotspot</description>
    </item>
    
    <item>
      <title>设计原则</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</link>
      <pubDate>Thu, 09 Feb 2023 23:36:46 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</guid>
      <description>指导思想 可维护性：修改功能少，需要改动的地方越少，可维护性越好 可复用性：代码被以后重复使用，写出自己总结的类库 可扩展性：添加功能无需修改原来的代码 灵活性：代码接口可以灵活调用 原则 单一职责原则 SRP 一个类别太大，别太累。负责单一的职责 高内聚，低耦合 开闭原则 OCP 对扩展开放，对修改关闭：尽量不修改原来的代码进行扩展 抽象化，多态是开闭原则的关键 里氏替换原则 LSP 所有使用父类的方法，必须能够透明的使用子类对象 依赖倒置原则 DIP 依赖抽象，而不是依赖具体 面向抽象/接口编程 接口隔离原则 ISP 每一个接口应该承担独立的角色，不干自己不该干的事情 避免子类不需要实现的方法 需要对客户提供接口的时候，只需要暴露最小的接口 迪米特法则 LOD 尽量不要和陌生人说话 在迪米特法则中，对于一个对象，非陌生人包含以下几类 当前对象本身this 以参数形式传入到当前对象方法中的对象 当前对象的成员对象 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友 当前对象所创建的对象 和其它类的耦合度变低 工具类例外 </description>
    </item>
    
    <item>
      <title>解释器模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 09 Feb 2023 23:18:43 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>解释器模式是类的行为模式。给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子
角色 抽象表达式(Expression)角色：声明一个所有的具体表达式角色都需要实现的抽象接口。这个接口主要是一个interpret()方法，称做解释操作 终结符表达式(Terminal Expression)角色：实现了抽象表达式角色所要求的接口 非终结符表达式(Nonterminal Expression)角色：文法中的每一条规则都需要一个具体的非终结符表达式 环境(Context)角色：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值 示例代码</description>
    </item>
    
    <item>
      <title>状态模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 09 Feb 2023 22:12:21 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</guid>
      <description>状态模式，状态对象行为模式。允许对一个对象在其内部状态改变的时候改变其行为。这个对象看上去就像是改变了它的类一样
状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变
角色 环境角色:定义客户端所感兴趣的接口，并且保留一个具体状态类的实例。这个具体状态类的实例给出此环境对象的现有状态 抽象状态(State)角色：定义一个接口，用以封装环境（Context）对象的一个特定的状态所对应的行为 具体状态(ConcreteState)角色：每一个具体状态类都实现了环境（Context）的一个状态所对应的行为 认识状态模式 状态和行为
所谓对象的状态，通常指的就是对象实例的属性的值；而行为指的就是对象的功能，再具体点说，行为大多可以对应到方法上。
状态模式的功能就是分离状态的行为，通过维护状态的变化，来调用不同状态对应的不同功能。也就是说，状态和行为是相关联的，它们的关系可以描述为：状态决定行为。
由于状态是在运行期被改变的，因此行为也会在运行期根据状态的改变而改变。
行为的平行性
注意平行线而不是平等性。所谓平行性指的是各个状态的行为所处的层次是一样的，相互独立的、没有关联的，是根据不同的状态来决定到底走平行线的哪一条。行为是不同的，当然对应的实现也是不同的，相互之间是不可替换的。
策略模式的比较
状态模式的结构和策略模式的结构完全一样，但是，它们的目的、实现、本质却是完全不一样的。还有行为之间的特性也是状态模式和策略模式一个很重要的区别，状态模式的行为是平行性的，不可相互替换的；而策略模式的行为是平等性的，是可以相互替换的。
环境和状态处理对象
在状态模式中，环境(Context)是持有状态的对象，但是环境(Context)自身并不处理跟状态相关的行为，而是把处理状态的功能委托给了状态对应的状态处理类来处理。
在具体的状态处理类中经常需要获取环境(Context)自身的数据，甚至在必要的时候会回调环境(Context)的方法，因此，通常将环境(Context)自身当作一个参数传递给具体的状态处理类。
客户端一般只和环境(Context)交互。客户端可以用状态对象来配置一个环境(Context)，一旦配置完毕，就不再需要和状态对象打交道了。客户端通常不负责运行期间状态的维护，也不负责决定后续到底使用哪一个具体的状态处理对象
示例代码</description>
    </item>
    
    <item>
      <title>模板方法模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 09 Feb 2023 21:50:27 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</guid>
      <description>类的行为模式。使用示例：Servlet的应用
抽象类：将部分逻辑以具体的方法以及具体的构造函数的形式实现。然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的实现方式实现这些抽象方法，从而对剩余逻辑有不同的实现。
模板方法所代表的行为称为顶级行为，其逻辑称为顶级逻辑
角色 抽象模板：顶层逻辑骨架 具体模板：具体实现顶层逻辑 子类可以置换掉父类的可变部分，但是子类却不可以改变模板方法所代表的顶级逻辑
方法 模板方法：一个抽象类可以有任意多个模板方法，而不限于一个。每一个模板方法都可以调用任意多个具体方法 基本方法： 抽象方法：一个抽象方法由抽象类声明，由具体子类实现 具体方法：一个具体方法由抽象类声明并实现，而子类并不实现或置换 钩子方法：一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个空实现，作为方法的默认实现 示例代码</description>
    </item>
    
    <item>
      <title>备忘录模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 09 Feb 2023 21:37:39 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</guid>
      <description>对象的行为模式。又称为快照模式，对象的行为模式。一个用来存储另外一个对象内部状态的快照对象。
指在不破坏封装的条件下，将一个对象的状态捕捉住，并且外部化，进行存储，从而可以在将来合适的时候把这个对象还原存储起来的状态。备忘录模式常常与命令模式和迭代子模式一同使用
角色 备忘录角色 备忘录角色又如下责任：
（1）将发起人（Originator）对象的内战状态存储起来。备忘录可以根据发起人对象的判断来决定存储多少发起人（Originator）对象的内部状态。
（2）备忘录可以保护其内容不被发起人（Originator）对象之外的任何对象所读取。
备忘录有两个等效的接口：
●　**窄接口：**负责人（Caretaker）对象（和其他除发起人对象之外的任何对象）看到的是备忘录的窄接口(narrow interface)，这个窄接口只允许它把备忘录对象传给其他的对象。
●　**宽接口：**与负责人对象看到的窄接口相反的是，发起人对象可以看到一个宽接口(wide interface)，这个宽接口允许它读取所有的数据，以便根据这些数据恢复这个发起人对象的内部状态。
发起人角色 发起人角色有如下责任：
（1）创建一个含有当前的内部状态的备忘录对象。
（2）使用备忘录对象存储其内部状态。
负责人角色 负责人角色有如下责任：
（1）负责保存备忘录对象。
（2）不检查备忘录对象的内容。
示例代码</description>
    </item>
    
    <item>
      <title>原型模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 09 Feb 2023 08:54:46 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>对象的创建模式。通过一个原型对象来指明所有创建的对象的类型，然后复用这个原型对象的方法来创建出更多同类型的对象。
实现一个自身可以克隆的接口
分类 简单形式 角色：
客户角色 抽象原型角色 具体原型角色 登记形式 角色：
客户角色 抽象原型角色 具体原型角色 原型管理角色 两种形式的比较 简单形式和登记形式的原型模式各有其长处和短处。
如果需要创建的原型对象数目较少而且比较固定的话，可以采取第一种形式。在这种情况下，原型对象的引用可以由客户端自己保存。
如果要创建的原型对象数目不固定的话，可以采取第二种形式。在这种情况下，客户端不保存对原型对象的引用，这个任务被交给管理员对象。在复制一个原型对象之前，客户端可以查看管理员对象是否已经有一个满足要求的原型对象。如果有，可以直接从管理员类取得这个对象引用；如果没有，客户端就需要自行复制此原型对象。
Java中的克隆方法 Java的所有类都是从java.lang.Object类继承而来的，而Object类提供protected Object clone()方法对对象进行复制，子类当然也可以把这个方法置换掉，提供满足自己需要的复制方法。对象的复制有一个基本问题，就是对象通常都有对其他的对象的引用。当使用Object类的clone()方法来复制一个对象时，此对象对其他对象的引用也同时会被复制一份
Java语言提供的Cloneable接口只起一个作用，就是在运行时期通知Java虚拟机可以安全地在这个类上使用clone()方法。通过调用这个clone()方法可以得到一个对象的复制。由于Object类本身并不实现Cloneable接口，因此如果所考虑的类没有实现Cloneable接口时，调用clone()方法会抛出CloneNotSupportedException异常。
原型模式的优点 原型模式允许在运行时动态改变具体的实现类型。原型模式可以在运行期间，由客户来注册符合原型接口的实现类型，也可以动态地改变具体的实现类型，看起来接口没有任何变化，但其实运行的已经是另外一个类实例了。因为克隆一个原型就类似于实例化一个类。
原型模式的缺点 原型模式最主要的缺点是每一个类都必须配备一个克隆方法。配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类来说不是很难，而对于已经有的类不一定很容易，特别是当一个类引用不支持序列化的间接对象，或者引用含有循环结构的时候。
示例代码</description>
    </item>
    
    <item>
      <title>命令模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 09 Feb 2023 08:23:19 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</guid>
      <description>命令模式属于对象的行为模式，又成交易模式或行动模式。　命令模式把一个请求或者操作封装到一个对象中。命令模式允许系统使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能
角色 命令角色 具体命令角色 请求者角色 接收者角色 客户端角色 优点 更松散的耦合 更动态的控制 很自然的复合命令 更好的扩展性 代码示例</description>
    </item>
    
    <item>
      <title>桥接模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 08 Feb 2023 22:36:18 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>将抽象部分与实现部分相分离，使他们都可以独立的变化。结构式模式
角色 实现接口 抽象接口 具体实现 具体抽象实现 应用 具体到实际应用上，需要将抽象与实现分离开来，对客户端无感知的一种行为。
示例代码</description>
    </item>
    
    <item>
      <title>适配器模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 08 Feb 2023 08:11:47 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>把一个类的接口变成客户端所期待的另一种接口，从而使原本因接口不匹配而无法完成一起工作的两个类可以一起工作
结构 类的适配器模式 对象的适配器模式 类的适配器模式 把适配类的API转换成目标API
角色：
●　目标(Target)角色：这就是所期待得到的接口。注意：由于这里讨论的是类适配器模式，因此目标不可以是类。
●　源(Adapee)角色：现在需要适配的接口。
●　适配器(Adaper)角色：适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。
对象的适配器模式 类的适配器模式一样，对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类
类适配器和对象适配器的权衡 ●　类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。
●　对于类适配器，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静态的关系，当适配器继承了Adaptee后，就不可能再去处理 Adaptee的子类了。
对于对象适配器，一个适配器可以把多种不同的源适配到同一个目标。换言之，同一个适配器可以把源类和它的子类都适配到目标接口。因为对象适配器采用的是对象组合的关系，只要对象类型正确，是不是子类都无所谓。
●　对于类适配器，适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。
对于对象适配器，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。
●　对于类适配器，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。
对于对象适配器，需要额外的引用来间接得到Adaptee。
建议尽量使用对象适配器的实现方式，多用合成/聚合、少用继承。当然，具体问题具体分析，根据需要来选用实现方式，最适合的才是最好的
优点 复用性 扩展性 缺点 过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构
代码示例
缺省适配器模式 抽象类中实现顶层接口的默认实现</description>
    </item>
    
    <item>
      <title>构建者模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E6%9E%84%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 07 Feb 2023 22:47:44 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E6%9E%84%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>分离对象的的属性与创建过程，用户创建重的对象。
写法分类：
在Builder里面直接new对象的方式，MyBatis的SqlSessionFactoryBuilder就是这种写法，适用于属性之间关联不多且大量属性都有默认值的场景。 间接new的方式：例如Guava的Cache都是这种写法，适用于属性之间有一定关联性的场景。 建造者模式的优点及适用场景
建造者模式这种设计模式，优缺点比较明显。从优点来说：
客户端不比知道产品内部细节，将产品本身与产品创建过程解耦，使得相同的创建过程可以创建不同的产品对象 可以更加精细地控制产品的创建过程，将复杂对象分门别类抽出不同的类别来，使得开发者可以更加方便地得到想要的产品 想了想，说缺点，建造者模式说不上缺点，只能说这种设计模式的使用比较受限：
产品属性之间差异很大且属性没有默认值可以指定，这种情况是没法使用建造者模式的，我们可以试想，一个对象20个属性，彼此之间毫无关联且每个都需要手动指定，那么很显然，即使使用了建造者模式也是毫无作用 代码示例</description>
    </item>
    
    <item>
      <title>访问者模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 07 Feb 2023 21:17:34 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>对象的行为模式。在不修改已有程序的前提下，通过添加额外的访问者来完成对已有代码功能的提升。
将数据结构与操作分离
角色：
抽象访问者: 声明了一个或者多个方法操作，形成所有的具体访问者角色必须实现的接口 具体访问者: 实现抽象访问者所声明的接口，也就是抽象访问者所声明的各个访问操作 抽象节点: 声明一个接受操作，接受一个访问者对象作为一个参数 具体节点: 实现了抽象节点所规定的接受操作 结构对象: 遍历结构的元素 访问者模式优点：
扩展性好，可以在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能； 符合单一职责原则，通过访问者将无关的行为分离，使职责单一；
访问者模式缺点：
违反了迪米特原则，因为具体元素对访问者公布细节； 违反了依赖倒置原则，依赖了具体类，没有依赖抽象； 对象结构变化困难，若对象结构发生了改变，访问者的接口和访问者的实现也都要发生相应的改变；
使用场景：
对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作； 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作&amp;quot;污染&amp;quot;这些对象的类，也不希望在增加新操作时修改这些类。
访问者模式示例</description>
    </item>
    
    <item>
      <title>迭代器模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 07 Feb 2023 20:57:19 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description> 迭代器模式又叫做游标模式，作用：提供一种方法访问一个容器元素中的各个对象，而又不暴露该对象的内部细节
角色：
迭代器角色 具体迭代器角色 容器角色 具体容器角色 </description>
    </item>
    
    <item>
      <title>代理模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 07 Feb 2023 20:48:23 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid>
      <description>代理模式是一种使用代理对象来执行目标对象的方法并在代理对象中增强目标对象方法的一种设计模式
静态代理 动态代理 静态代理的特点如下：
使用静态代理时，通常客户类不需要感知RealSubject。 静态代理的缺点：代理对象需要与目标对象实现一样的接口，因此接口较多时需要定义和维护大量的代理类代码。 与适配器的差异：适配器通常考虑改变接口形态，而代理则不会也不能改变接口形态。 与装饰器的差异：被代理对象由代理对象创建，客户端甚至不需要知道被代理类的存在；被装饰对象则由客户端创建并传给装饰对象，可以层层嵌套，层层装饰。代理模式常用于控制被代理对象的访问，而装饰模式是增加被装饰者的功能。
JDK动态代理的特点如下：
通过实现InvocationHandler接口完成代理逻辑。 通过反射代理方法，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。 代理类必须实现接口。 代理模式</description>
    </item>
    
    <item>
      <title>享元模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 07 Feb 2023 20:29:05 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</guid>
      <description> 对象的结构模式，以共享的方式高效的支持大量的细粒度对象
java中String类型就是享元模式 享元模式采用一个共享来避免大量拥有相同内容对象的开销
分类 单纯享元模式 所有的享元对象都是可以共享的
角色：
抽象享元(Flyweight)角色：抽象接口 具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口 享元工厂(FlyweightFactory)角色：本角色负责创建和管理享元角色 复合享元模式 抽象享元(Flyweight)角色：抽象接口 具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口 复合享元角色：复合享元角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解成为多个本身是单纯享元对象的组合。复合享元角色又称作不可共享的享元对象 享元工厂(FlyweightFactory)角色：本角色负责创建和管理享元角色 </description>
    </item>
    
    <item>
      <title>组合模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 07 Feb 2023 20:13:12 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</guid>
      <description>描述部分与整体的关系，组装树形结构
角色 抽象构件角色 树叶构件角色 树枝构件角色 分类 透明式：在该方式中，由于抽象构件声明了所有子类中的全部方法，所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的 安全式：在该方式中，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题，但由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性 组合模式代码</description>
    </item>
    
    <item>
      <title>观察者模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 07 Feb 2023 19:50:02 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>观察者模式-对象行为模式。发布/订阅模式，模型-视图模式、源-监听器模式，从属者模式。
定义一对多的依赖关系，让多个观察者同时监听某一个主题对象。这个对象在状态上发生变化时，会通知所有观察者对象，是它们能够主动更新自己的状态。
角色：
抽象主题角色：提供一个接口，可以增加和减少观察者对象，抽象主题角色又叫做抽象被观察者角色。 具体主题角色：将有关状态存入具体观察者对象 抽象观察者角色：为所有的观察者提供一个接口，在得到主题的通知时更新自己。 具体观察者角色：存储与主题状态自恰的状态。 模式分类：
推模式
主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。
拉模式 主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。
java对观察者模式的支持
Observer接口： 观察者 Observable类： 被观察者 示例代码</description>
    </item>
    
    <item>
      <title>责任链模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 06 Feb 2023 08:09:32 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</guid>
      <description>对象的行为模式，允许你将请求沿着处理链进行发送。收到请求后，每个处理者可对请求进行处理，或将其传递给链上的下个处理者
角色：
抽象处理者：定义处理请求的接口。 具体处理者：具体处理者接到请求，可以将请求处理，或者将请求传给下家。 示例代码</description>
    </item>
    
    <item>
      <title>装饰者模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 05 Feb 2023 23:28:12 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>动态的将责任添加到对象上，动态添加功能。
分类：
父组件，供子组件使用 装饰者：组合其他组件，一部分功能是自己的，调用被装饰者，等同于保留被装饰者的功能 具体组件：实现具体方法 饮料添加各种配料，返回最终的价格。
代码示例</description>
    </item>
    
    <item>
      <title>调停者模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E8%B0%83%E5%81%9C%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 05 Feb 2023 16:05:46 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E8%B0%83%E5%81%9C%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>门面模式对外，调停者模式对内
对象的行为模式，调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显引用。从而使它们可以较松散地耦合。当这些对象中的某些对象之间的相互作用发生改变时，不会立即影响到其他的一些对象之间的相互作用。从而保证这些相互作用可以彼此独立地变化
角色：
抽象调停者角色 具体调停者角色 抽象同事类角色 具体公式类角色 示例代码</description>
    </item>
    
    <item>
      <title>门面模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 05 Feb 2023 15:50:55 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/</guid>
      <description>提供高层次的接口，统一门面对象进行，使得子系统易于使用。
选择性的暴露方法
角色分类：
门面角色: 客户端可以调用这个角色的方法 子系统角色：可以同时有一个或者多个子系统 门面模式示例代码</description>
    </item>
    
    <item>
      <title>工厂模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 04 Feb 2023 10:18:28 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>任何可以产生对象的方法和类，都可以被称为工厂。
创建型设计模式，父类提供创建对象的方法，允许子类决定实例化对象的类型
分类 根据产品是具体产品还是具体工厂：
简单工厂模式 工厂方法模式 根据工厂的抽象程度
工厂方法模式 抽象工厂模式 简单工厂模式 只对不同类对象的创建进行了一层薄薄的封装，通过向工厂传递类型来指定要创建的对象。
工厂方法模式 工厂方法模式将生产具体产品的任务分发给具体的产品工厂
抽象工厂模式 针对不同产品的创建。在工厂方法模式下，在抽象工厂里面增加创建产品的接口，并在具体子工厂中实现产品的创建
工厂模式代码示例合</description>
    </item>
    
    <item>
      <title>策略模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 03 Feb 2023 07:38:26 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>对于做同一件事有多种方法，Comparator接口。
Context：环境类 Strategy: 抽象策略类 ConcreteStrategy: 具体策略类 使用场景 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。
策略模式示例代码</description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 16 Jan 2023 08:36:37 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>保持内存中只有一个对象
分类：
是否加载实例
饿汉式 饱汉式 是否线程安全
安全 不安全 特殊实现方式：
静态内部类 枚举 单例模式代码</description>
    </item>
    
    <item>
      <title>Kmp</title>
      <link>https://AlfredNing.github.io/note/program/algorithm/kmp/</link>
      <pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/algorithm/kmp/</guid>
      <description>使用场景 多用于子串匹配问题
流程 在暴力解的过程当中有加速
定义： 在该位置之前的前缀与后缀的长度，但不能取到字符串的整体长度，定义为指标信息
解释：
对匹配串建立上述指标信息 匹配过程 求解证明 x-r 与 y-r&amp;rsquo;是相同，从i位置匹配match串等同于从match的q位置进行匹配
i位置到r位置一定不能匹配match
验证：假设i位置到r位置，有个k位置能够匹配match串，那就说明从k位置到x位置是相同的，也就是match串y位置之前字符串的一个后缀，此时，与next的数组定义违反，出现了一个更长的。假设不成立。
next数组生成 match长度为M,时间复杂度为O(M)
next[0] = -1;
next[1] = 0;
next[2] = 0位置和1位置决定;
求i位置的next[i]时候，前面所有位置都已经准备好
next证明 来到i位置next[i]最大为next[i+1]+1
假设next[i]&amp;gt;next[i-1] + 1,
那么说明next[i-1]求解错误，矛盾，不成立
代码实现 public class Kmp { public static int getIndexOf(String s, String match) { if (s == null || match == null || match.length() &amp;lt; 1 || s.length() &amp;lt; match.length()) { return -1; } char[] strs = s.toCharArray(); char[] matchs = match.</description>
    </item>
    
    
    
  </channel>
</rss>
