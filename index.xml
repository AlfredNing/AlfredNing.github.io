<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>AlfredNing</title>
    <link>https://AlfredNing.github.io/</link>
    <description>Recent content on AlfredNing</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 05 Feb 2023 16:05:46 +0800</lastBuildDate><atom:link href="https://AlfredNing.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>调停者模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E8%B0%83%E5%81%9C%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 05 Feb 2023 16:05:46 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E8%B0%83%E5%81%9C%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>门面模式对外，调停者模式对内
对象的行为模式，调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显引用。从而使它们可以较松散地耦合。当这些对象中的某些对象之间的相互作用发生改变时，不会立即影响到其他的一些对象之间的相互作用。从而保证这些相互作用可以彼此独立地变化
角色：
抽象调停者角色 具体调停者角色 抽象同事类角色 具体公式类角色 示例代码</description>
    </item>
    
    <item>
      <title>门面模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 05 Feb 2023 15:50:55 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/</guid>
      <description>提供高层次的接口，统一门面对象进行，使得子系统易于使用。
选择性的暴露方法
角色分类：
门面角色: 客户端可以调用这个角色的方法 子系统角色：可以同时有一个或者多个子系统 门面模式示例代码</description>
    </item>
    
    <item>
      <title>工厂模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 04 Feb 2023 10:18:28 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>任何可以产生对象的方法和类，都可以被称为工厂。
创建型设计模式，父类提供创建对象的方法，允许子类决定实例化对象的类型
分类 根据产品是具体产品还是具体工厂：
简单工厂模式 工厂方法模式 根据工厂的抽象程度
工厂方法模式 抽象工厂模式 简单工厂模式 只对不同类对象的创建进行了一层薄薄的封装，通过向工厂传递类型来指定要创建的对象。
工厂方法模式 工厂方法模式将生产具体产品的任务分发给具体的产品工厂
抽象工厂模式 针对不同产品的创建。在工厂方法模式下，在抽象工厂里面增加创建产品的接口，并在具体子工厂中实现产品的创建
工厂模式代码示例合</description>
    </item>
    
    <item>
      <title>策略模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 03 Feb 2023 07:38:26 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>对于做同一件事有多种方法，Comparator接口。
Context：环境类 Strategy: 抽象策略类 ConcreteStrategy: 具体策略类 使用场景 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。
策略模式示例代码</description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 16 Jan 2023 08:36:37 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>保持内存中只有一个对象
分类：
是否加载实例
饿汉式 饱汉式 是否线程安全
安全 不安全 特殊实现方式：
静态内部类 枚举 单例模式代码</description>
    </item>
    
    <item>
      <title>Kmp</title>
      <link>https://AlfredNing.github.io/note/program/algorithm/kmp/</link>
      <pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/algorithm/kmp/</guid>
      <description>使用场景 多用于子串匹配问题
流程 在暴力解的过程当中有加速
定义： 在该位置之前的前缀与后缀的长度，但不能取到字符串的整体长度，定义为指标信息
解释：
对匹配串建立上述指标信息 匹配过程 求解证明 x-r 与 y-r&amp;rsquo;是相同，从i位置匹配match串等同于从match的q位置进行匹配
i位置到r位置一定不能匹配match
验证：假设i位置到r位置，有个k位置能够匹配match串，那就说明从k位置到x位置是相同的，也就是match串y位置之前字符串的一个后缀，此时，与next的数组定义违反，出现了一个更长的。假设不成立。
next数组生成 match长度为M,时间复杂度为O(M)
next[0] = -1;
next[1] = 0;
next[2] = 0位置和1位置决定;
求i位置的next[i]时候，前面所有位置都已经准备好
next证明 来到i位置next[i]最大为next[i+1]+1
假设next[i]&amp;gt;next[i-1] + 1,
那么说明next[i-1]求解错误，矛盾，不成立
代码实现 public class Kmp { public static int getIndexOf(String s, String match) { if (s == null || match == null || match.length() &amp;lt; 1 || s.length() &amp;lt; match.length()) { return -1; } char[] strs = s.toCharArray(); char[] matchs = match.</description>
    </item>
    
    
    
  </channel>
</rss>
