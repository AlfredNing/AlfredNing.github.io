[{"content":" 对于做同一件事有多种方法，Comparator接口。\nContext：环境类 Strategy: 抽象策略类 ConcreteStrategy: 具体策略类 使用场景 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。\n策略模式示例代码\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","summary":"对于做同一件事有多种方法，Comparator接口。\nContext：环境类 Strategy: 抽象策略类 ConcreteStrategy: 具体策略类 使用场景 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。\n策略模式示例代码","title":"策略模式"},{"content":" 保持内存中只有一个对象\n分类：\n是否加载实例\n饿汉式 饱汉式 是否线程安全\n安全 不安全 特殊实现方式：\n静态内部类 枚举 单例模式代码\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","summary":"保持内存中只有一个对象\n分类：\n是否加载实例\n饿汉式 饱汉式 是否线程安全\n安全 不安全 特殊实现方式：\n静态内部类 枚举 单例模式代码","title":"单例模式"},{"content":"使用场景 多用于子串匹配问题\n流程 在暴力解的过程当中有加速\n定义： 在该位置之前的前缀与后缀的长度，但不能取到字符串的整体长度，定义为指标信息\n解释：\n对匹配串建立上述指标信息 匹配过程 求解证明 x-r 与 y-r\u0026rsquo;是相同，从i位置匹配match串等同于从match的q位置进行匹配\ni位置到r位置一定不能匹配match\n验证：假设i位置到r位置，有个k位置能够匹配match串，那就说明从k位置到x位置是相同的，也就是match串y位置之前字符串的一个后缀，此时，与next的数组定义违反，出现了一个更长的。假设不成立。\nnext数组生成 match长度为M,时间复杂度为O(M)\nnext[0] = -1;\nnext[1] = 0;\nnext[2] = 0位置和1位置决定;\n求i位置的next[i]时候，前面所有位置都已经准备好\nnext证明 来到i位置next[i]最大为next[i+1]+1\n假设next[i]\u0026gt;next[i-1] + 1,\n那么说明next[i-1]求解错误，矛盾，不成立\n代码实现 public class Kmp { public static int getIndexOf(String s, String match) { if (s == null || match == null || match.length() \u0026lt; 1 || s.length() \u0026lt; match.length()) { return -1; } char[] strs = s.toCharArray(); char[] matchs = match.toCharArray(); int x = 0;// strs中当前匹配位置 int y = 0; // match中当前匹配位置、 int[] next = getNextArray(matchs); while (x \u0026lt; strs.length \u0026amp;\u0026amp; y \u0026lt; matchs.length) { if (strs[x] == matchs[y]) { x++; y++; } else if (next[y] == -1) { // y已经来到开头 或者写成y==0 x++; } else { y = next[y]; } } return y == matchs.length ? x - y : -1; } public static int[] getNextArray(char[] matchs) { if (matchs.length == 1) { return new int[]{-1}; } int[] next = new int[matchs.length]; next[0] = -1; // 人为规定 next[1] = 0; // 人为规定 int i = 2; // 从2开始 int cn = 0; // 和i-1位置比较的字符 while (i \u0026lt; matchs.length) { if (matchs[i - 1] == matchs[cn]) { next[i++] = ++cn; } else if (cn \u0026gt; 0) { // 往前跳 cn = next[cn]; } else { // 匹配不到 next[i++] = 0; } } return next; } } 时间复杂度-O(N) 对于上述代码的while循环处理\nx[最大到N] x-y[最大到N] 第一个分支 变大 不变 第二个分支 变大 变大 第三个分支 不变 变大 最大为2N,复杂度为O(N)\n","permalink":"https://AlfredNing.github.io/note/program/algorithm/kmp/","summary":"使用场景 多用于子串匹配问题\n流程 在暴力解的过程当中有加速\n定义： 在该位置之前的前缀与后缀的长度，但不能取到字符串的整体长度，定义为指标信息\n解释：\n对匹配串建立上述指标信息 匹配过程 求解证明 x-r 与 y-r\u0026rsquo;是相同，从i位置匹配match串等同于从match的q位置进行匹配\ni位置到r位置一定不能匹配match\n验证：假设i位置到r位置，有个k位置能够匹配match串，那就说明从k位置到x位置是相同的，也就是match串y位置之前字符串的一个后缀，此时，与next的数组定义违反，出现了一个更长的。假设不成立。\nnext数组生成 match长度为M,时间复杂度为O(M)\nnext[0] = -1;\nnext[1] = 0;\nnext[2] = 0位置和1位置决定;\n求i位置的next[i]时候，前面所有位置都已经准备好\nnext证明 来到i位置next[i]最大为next[i+1]+1\n假设next[i]\u0026gt;next[i-1] + 1,\n那么说明next[i-1]求解错误，矛盾，不成立\n代码实现 public class Kmp { public static int getIndexOf(String s, String match) { if (s == null || match == null || match.length() \u0026lt; 1 || s.length() \u0026lt; match.length()) { return -1; } char[] strs = s.toCharArray(); char[] matchs = match.","title":"Kmp"}]