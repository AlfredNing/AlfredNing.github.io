[{"content":"指针 表示内存的地址。指针是一个变量，值为另一个变量的内存地址。内存位置的直接地址\n必须先声明，后使用 所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表存地址的长的十六进制数 不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同 概念 描述 C++ Null 指针 C++ 支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。 C++ 指针的算术运算 可以对指针进行四种算术运算：++、\u0026ndash;、+、- C++ 指针 vs 数组 指针和数组之间有着密切的关系。 C++ 指针数组 可以定义用来存储指针的数组。 C++ 指向指针的指针 C++ 允许指向指针的指针。 C++ 传递指针给函数 通过引用或地址传递参数，使传递的参数在调用函数中被改变。 C++ 从函数返回指针 C++ 允许函数返回指针到局部变量、静态变量和动态内存分配。 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int var = 20; // 指针变量声明 int* ip; double* dp; ip = \u0026amp;var; // 使用: 变量存储的地址 cout \u0026lt;\u0026lt; \u0026#34;ip: \u0026#34; \u0026lt;\u0026lt; ip \u0026lt;\u0026lt; endl; // 访问地址 cout \u0026lt;\u0026lt; *ip \u0026lt;\u0026lt; endl; return 0; } 引用 引用变量是一个别名，他是一件存在的变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。\n与指针比较 不存在空引用。引用必须连接到一块合法的内存。 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。 引用必须在创建时被初始化。指针可以在任何时间被初始化。 概念 描述 把引用作为参数 C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。 把引用作为返回值 可以从 C++ 函数中返回引用，就像返回其他数据类型一样。 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { // 简单变量 int i; double d; // 引用 int\u0026amp; r = i; double \u0026amp; s = d; i = 5; cout \u0026lt;\u0026lt; \u0026#34;Value of i: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Value of i reference: \u0026#34; \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; d = 11.8; cout \u0026lt;\u0026lt; \u0026#34;Value of d: \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Value of d reference: \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; } 时期和时间 c++标准库没有提供，继承c语言用于日期和时间操作结构和函数。使用时需要引入头部文件\n相关类型\nclock_t time_t size_t tm 类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数\n结构类型 tm 把日期和时间以 C 结构的形式保存\n序号 函数 \u0026amp; 描述 1 time_t time(time_t *time); 该函数返回系统的当前日历时间，自 1970 年 1 月 1 日以来经过的秒数。如果系统没有时间，则返回 .1。 2 char *ctime(const time_t *time); 该返回一个表示当地时间的字符串指针，字符串形式 day month year hours:minutes:seconds year\\n\\0。 3 struct tm *localtime(const time_t *time); 该函数返回一个指向表示本地时间的 tm 结构的指针。 4 clock_t clock(void); 该函数返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。如果时间不可用，则返回 .1。 5 char * asctime ( const struct tm * time ); 该函数返回一个指向字符串的指针，字符串包含了 time 所指向结构中存储的信息，返回形式为：day month date hours:minutes:seconds year\\n\\0。 6 struct tm *gmtime(const time_t *time); 该函数返回一个指向 time 的指针，time 为 tm 结构，用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。 7 time_t mktime(struct tm *time); 该函数返回日历时间，相当于 time 所指向结构中存储的时间。 8 double difftime ( time_t time2, time_t time1 ); 该函数返回 time1 和 time2 之间相差的秒数。 9 size_t strftime(); 该函数可用于格式化日期和时间为指定的格式。 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;iostream\u0026gt; #include \u0026lt;ctime\u0026gt; using namespace std; int main() { // 基于当前系统的当前日期/时间 time_t now = time(0); // 把 now 转换为字符串形式 char* dt = ctime(\u0026amp;now); cout \u0026lt;\u0026lt; \u0026#34;本地日期和时间：\u0026#34; \u0026lt;\u0026lt; dt \u0026lt;\u0026lt; endl; // 把 now 转换为 tm 结构 tm* gmtm = gmtime(\u0026amp;now); dt = asctime(gmtm); cout \u0026lt;\u0026lt; \u0026#34;UTC 日期和时间：\u0026#34; \u0026lt;\u0026lt; dt \u0026lt;\u0026lt; endl; tm* ltm = localtime(\u0026amp;now); cout \u0026lt;\u0026lt; \u0026#34;Year: \u0026#34; \u0026lt;\u0026lt; 1900 + ltm-\u0026gt;tm_year \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Month: \u0026#34; \u0026lt;\u0026lt; 1 + ltm-\u0026gt;tm_mon \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Day: \u0026#34; \u0026lt;\u0026lt; ltm-\u0026gt;tm_mday \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Time: \u0026#34; \u0026lt;\u0026lt; 1 + ltm-\u0026gt;tm_hour \u0026lt;\u0026lt; \u0026#34;:\u0026#34;; cout \u0026lt;\u0026lt; 1 + ltm-\u0026gt;tm_min \u0026lt;\u0026lt; \u0026#34;:\u0026#34;; cout \u0026lt;\u0026lt; 1 + ltm-\u0026gt;tm_sec \u0026lt;\u0026lt; endl; return 0; } 输入和输出 输入操作：外围设备流向内存\n输出操作：内存流向外围设备\nIO 库头文件 头文件 函数和描述 该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。 该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。 该文件为用户控制的文件处理声明服务 标准输出流 - cout 预定义的对象 cout 是 ostream 类的一个实例。cout 对象\u0026quot;连接\u0026quot;到标准输出设备，通常是显示屏。cout 是与流插入运算符 \u0026laquo; 结合使用的,endl 用于在行末添加一个换行符\n标准输入流 -cin 预定义的对象 cin 是 istream 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。cin 是与流提取运算符 \u0026raquo; 结合使用的。\nC++ 编译器根据要输入值的数据类型，选择合适的流提取运算符来提取值，并把它存储在给定的变量中。\n流提取运算符 \u0026raquo; 在一个语句中可以多次使用\n标准错误流 - cerr 预定义的对象 cerr 是 ostream 类的一个实例。cerr 对象附属到标准错误设备，通常也是显示屏，但是 cerr 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。cerr 也是与流插入运算符 \u0026laquo; 结合使用的\n标准日志流 - clog 预定义的对象 clog 是 ostream 类的一个实例。clog 对象附属到标准错误设备，通常也是显示屏，但是 clog 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲在，直到缓冲填满或者缓冲区刷新时才会输出。\nclog 也是与流插入运算符 \u0026laquo; 结合使用的\n#define _CRT_SECURE_NO_WARNINGS #include \u0026lt;iostream\u0026gt; using namespace std; int main() { char name[50]; cout \u0026lt;\u0026lt; \u0026#34;请输入名称：\u0026#34;; cin \u0026gt;\u0026gt; name; cout \u0026lt;\u0026lt; \u0026#34;name: \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl; char str[] = \u0026#34;unable to read\u0026#34;; clog \u0026lt;\u0026lt; \u0026#34;message info: \u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; cerr \u0026lt;\u0026lt; \u0026#34;mesage error: \u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; return 0; } 结构体 用户自定义可用的数据类型，表示存储不同类型的数据项。\n定义结构 访问成员运算符.: 成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;iostream\u0026gt; using namespace std; // 定义一个结构体 struct Books { char title[50]; char author[50]; char subject[100]; int book_id; }; int main() { // 定义结构体类型 Books Book1; Books Book2; strcpy(Book1.title, \u0026#34;浪潮之巅\u0026#34;); strcpy(Book1.author, \u0026#34;吴军\u0026#34;); strcpy(Book1.subject, \u0026#34;科技产业\u0026#34;); Book1.book_id, 1001; cout \u0026lt;\u0026lt; \u0026#34;book1.title: \u0026#34; \u0026lt;\u0026lt; Book1.title; cout \u0026lt;\u0026lt; \u0026#34;book1.author: \u0026#34; \u0026lt;\u0026lt; Book1.author; cout \u0026lt;\u0026lt; \u0026#34;book1.subject: \u0026#34; \u0026lt;\u0026lt; Book1.subject; cout \u0026lt;\u0026lt; \u0026#34;book1.book_id: \u0026#34; \u0026lt;\u0026lt; Book1.book_id; return 0; } 结构作为函数参数 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;iostream\u0026gt; using namespace std; void printBook(struct Books book); // 定义一个结构体 struct Books { char title[50]; char author[50]; char subject[100]; int book_id; }; int main() { // 定义结构体类型 Books Book1; Books Book2; strcpy(Book1.title, \u0026#34;浪潮之巅\u0026#34;); strcpy(Book1.author, \u0026#34;吴军\u0026#34;); strcpy(Book1.subject, \u0026#34;科技产业\u0026#34;); Book1.book_id = 1001; printBook(Book1); return 0; } void printBook(struct Books book) { cout \u0026lt;\u0026lt; \u0026#34;Book.title: \u0026#34; \u0026lt;\u0026lt; book.title; cout \u0026lt;\u0026lt; \u0026#34;Book.author: \u0026#34; \u0026lt;\u0026lt; book.author; cout \u0026lt;\u0026lt; \u0026#34;Book.subject: \u0026#34; \u0026lt;\u0026lt; book.subject; cout \u0026lt;\u0026lt; \u0026#34;Book.book_id: \u0026#34; \u0026lt;\u0026lt; book.book_id; } 指向结构的指针 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;iostream\u0026gt; using namespace std; void printBook(struct Books* book); /* 结构体指针定义：struct Books *struct_pointer; 为了查找结构变量的地址\u0026amp; 运算符放在结构名称的前面 使用指向该结构的指针访问结构的成员： 必须使用-\u0026gt; 运算符 */ // 定义一个结构体 struct Books { char title[50]; char author[50]; char subject[100]; int book_id; }; int main() { // 定义结构体类型 Books Book1; Books Book2; strcpy(Book1.title, \u0026#34;浪潮之巅\u0026#34;); strcpy(Book1.author, \u0026#34;吴军\u0026#34;); strcpy(Book1.subject, \u0026#34;科技产业\u0026#34;); Book1.book_id = 1001; printBook(\u0026amp;Book1); return 0; } void printBook(struct Books* book) { cout \u0026lt;\u0026lt; \u0026#34;Book.title: \u0026#34; \u0026lt;\u0026lt; book-\u0026gt;title; cout \u0026lt;\u0026lt; \u0026#34;Book.author: \u0026#34; \u0026lt;\u0026lt; book-\u0026gt;author; cout \u0026lt;\u0026lt; \u0026#34;Book.subject: \u0026#34; \u0026lt;\u0026lt; book-\u0026gt;subject; cout \u0026lt;\u0026lt; \u0026#34;Book.book_id: \u0026#34; \u0026lt;\u0026lt; book-\u0026gt;book_id; } typedof 更加简单的定义结构体方式\n#define _CRT_SECURE_NO_WARNINGS #include \u0026lt;iostream\u0026gt; using namespace std; // 定义一个结构体 typedef struct { char title[50]; char author[50]; char subject[100]; int book_id; } Books; void printBook(Books* book); /* 结构体指针定义：struct Books *struct_pointer; 为了查找结构变量的地址\u0026amp; 运算符放在结构名称的前面 使用指向该结构的指针访问结构的成员： 必须使用-\u0026gt; 运算符 */ int main() { // 定义结构体类型 Books Book1; Books Book2; strcpy(Book1.title, \u0026#34;浪潮之巅\u0026#34;); strcpy(Book1.author, \u0026#34;吴军\u0026#34;); strcpy(Book1.subject, \u0026#34;科技产业\u0026#34;); Book1.book_id = 1001; printBook(\u0026amp;Book1); // typedef 关键字来定义非结构类型 typedef long int* pint32; pint32 x, y, z; // x, y 和 z 都是指向长整型 long int 的指针。 return 0; } // 直接使用 Books 来定义 Books 类型的变量，而不需要使用 struct 关键字 void printBook(Books* book) { cout \u0026lt;\u0026lt; \u0026#34;Book.title: \u0026#34; \u0026lt;\u0026lt; book-\u0026gt;title; cout \u0026lt;\u0026lt; \u0026#34;Book.author: \u0026#34; \u0026lt;\u0026lt; book-\u0026gt;author; cout \u0026lt;\u0026lt; \u0026#34;Book.subject: \u0026#34; \u0026lt;\u0026lt; book-\u0026gt;subject; cout \u0026lt;\u0026lt; \u0026#34;Book.book_id: \u0026#34; \u0026lt;\u0026lt; book-\u0026gt;book_id; } 类和对象 用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类被称为类的成员。\n类 定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作\n类定义是以关键字 class 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表\n对象 类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样\n#include \u0026lt;iostream\u0026gt; using namespace std; class Box { public: double length; double width; double height; double breadth; }; int main() { // 对象声明 Box Box1; double volume = 0.0; Box1.height = 5.0; Box1.width = 5.0; Box1.length = 5.0; volume = Box1.height * Box1.length * Box1.width; cout \u0026lt;\u0026lt; \u0026#34;Box1 的体积：\u0026#34; \u0026lt;\u0026lt; volume \u0026lt;\u0026lt; endl; return 0; } 概念 描述 类成员函数 类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。 类访问修饰符 类成员可以被定义为 public、private 或 protected。默认情况下是定义为 private。 构造函数 \u0026amp; 析构函数 类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。 C++ 拷贝构造函数 拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。 C++ 友元函数 友元函数可以访问类的 private 和 protected 成员。 C++ 内联函数 通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。 C++ 中的 this 指针 每个对象都有一个特殊的指针 this，它指向对象本身。 C++ 中指向类的指针 指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。 C++ 类的静态成员 类的数据成员和函数成员都可以被声明为静态的 继承 继承代表了 is a 关系\n基类 \u0026amp; 派生类 一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名。\nclass derived-class: access-specifier base-class 其中，访问修饰符 access-specifier 是 public、protected 或 private 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private\n#include \u0026lt;iostream\u0026gt; using namespace std; class Shape { public: void setWidth(int w) { width = w; } void setHeight(int h) { height = h; } protected: int width; int height; }; // 派生类 class Rectangle : public Shape { public: int getArea() { return width * height; } }; int main() { Rectangle Rect; Rect.setWidth(4); Rect.setHeight(5); cout \u0026lt;\u0026lt; \u0026#34;Area is: \u0026#34; \u0026lt;\u0026lt; Rect.getArea() \u0026lt;\u0026lt; endl; return 0; } 访问控制 派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private\n访问 public protected private 同一个类 yes yes yes 派生类 yes yes no 外部的类 yes no no 一个派生类继承了所有的基类方法，但下列情况除外：\n基类的构造函数、析构函数和拷贝构造函数。 基类的重载运算符。 基类的友元函数。 继承类型 当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种类型。\n几乎不使用 protected 或 private 继承，通常使用 public 继承\n公有继承（public）：**当一个类派生自**公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。 保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。 私有继承（private）：**当一个类派生自**私有基类时，基类的公有和保护成员将成为派生类的私有成员。 多继承 多继承即一个子类可以有多个父类，它继承了多个父类的特性\n访问修饰符继承方式是 public、protected 或 private 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔\n#include \u0026lt;iostream\u0026gt; using namespace std; class Shape { public: void setWidth(int w) { width = w; } void setHeight(int h) { height = h; } protected: int width; int height; }; class PointCost { public: int getCost(int area) { return area * 70; } }; // 派生类 class Rectangle : public Shape, public PointCost{ public: int getArea() { return width * height; } }; int main() { int area; Rectangle Rect; Rect.setWidth(4); Rect.setHeight(5); area = Rect.getArea(); cout \u0026lt;\u0026lt; \u0026#34;Area is: \u0026#34; \u0026lt;\u0026lt; area \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Cost is: \u0026#34; \u0026lt;\u0026lt; Rect.getCost(area) \u0026lt;\u0026lt; endl; return 0; } 重载运算符和重载函数 同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载\n同一个作用域 函数名或具有相同名称的声明 形参列表和定义不同 编译器根据传入参数选择合适的重载函数或者重载运算符，该过程称为重载决策。\n函数重载 #include \u0026lt;iostream\u0026gt; using namespace std; class printData { public: void print(int t) { cout \u0026lt;\u0026lt; \u0026#34;int: \u0026#34; \u0026lt;\u0026lt; t \u0026lt;\u0026lt; endl; } void print(char* c) { cout \u0026lt;\u0026lt; \u0026#34;char: \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; } void print(double f) { cout \u0026lt;\u0026lt; \u0026#34;double: \u0026#34; \u0026lt;\u0026lt; f \u0026lt;\u0026lt; endl; } }; int main() { printData pd; // Call print to print integer pd.print(5); // Call print to print float pd.print(500.263); // Call print to print character char s[] = \u0026#34;hello\u0026#34;; pd.print(s); return 0; } 运算符重载 重定义或重载大部分 C++ 内置的运算符，自定义运算符\n重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。\n#include \u0026lt;iostream\u0026gt; using namespace std; class Box { public: double getVolume(void) { return length * breadth * height; } void setLength(double len) { length = len; } void setBreadth(double bre) { breadth = bre; } void setHeight(double hei) { height = hei; } Box operator+(const Box\u0026amp; b) { Box box; box.length = this-\u0026gt;length + b.length; box.breadth = this-\u0026gt;breadth + b.breadth; box.height = this-\u0026gt;height + b.height; return box; } private: double length; double breadth; double height; }; int main() { Box Box1; // 声明 Box1，类型为 Box Box Box2; // 声明 Box2，类型为 Box Box Box3; // 声明 Box3，类型为 Box double volume = 0.0; // 把体积存储在该变量中 // Box1 详述 Box1.setLength(6.0); Box1.setBreadth(7.0); Box1.setHeight(5.0); // Box2 详述 Box2.setLength(12.0); Box2.setBreadth(13.0); Box2.setHeight(10.0); // Box1 的体积 volume = Box1.getVolume(); cout \u0026lt;\u0026lt; \u0026#34;Volume of Box1 : \u0026#34; \u0026lt;\u0026lt; volume \u0026lt;\u0026lt; endl; // Box2 的体积 volume = Box2.getVolume(); cout \u0026lt;\u0026lt; \u0026#34;Volume of Box2 : \u0026#34; \u0026lt;\u0026lt; volume \u0026lt;\u0026lt; endl; // 把两个对象相加，得到 Box3 Box3 = Box1 + Box2; // Box3 的体积 volume = Box3.getVolume(); cout \u0026lt;\u0026lt; \u0026#34;Volume of Box3 : \u0026#34; \u0026lt;\u0026lt; volume \u0026lt;\u0026lt; endl; return 0; } 可重载运算符 + - * / % ^ \u0026amp; | ~ ! , = \u0026lt; \u0026gt; \u0026lt;= \u0026gt;= ++ \u0026ndash; \u0026laquo; \u0026raquo; == != \u0026amp;\u0026amp; || += -= /= %= ^= \u0026amp;= |= *= \u0026laquo;= \u0026raquo;= [] () -\u0026gt; -\u0026gt;* new new [] delete delete [] 不可重载运算符 :: .* . ?: 多态 调用成员函数，会根据调用函数的对象的类型执行不同的函数\n#include \u0026lt;iostream\u0026gt; using namespace std; class Shape { protected: int width, height; public: Shape(int a = 0, int b = 0) { width = a; height = b; } virtual int area() { cout \u0026lt;\u0026lt; \u0026#34;Parent class area :\u0026#34; \u0026lt;\u0026lt; endl; return 0; } };class Rectangle : public Shape { public: Rectangle(int a = 0, int b = 0) :Shape(a, b) { } int area() { cout \u0026lt;\u0026lt; \u0026#34;Rectangle class area :\u0026#34; \u0026lt;\u0026lt; (width * height) \u0026lt;\u0026lt; endl; return (width * height); } };class Triangle : public Shape { public: Triangle(int a = 0, int b = 0) :Shape(a, b) { } int area() { cout \u0026lt;\u0026lt; \u0026#34;Triangle class area :\u0026#34; \u0026lt;\u0026lt; (width * height / 2) \u0026lt;\u0026lt; endl; return (width * height / 2); } };// 程序的主函数 int main() { Shape* shape; Rectangle rec(10, 7); Triangle tri(10, 5); // 存储矩形的地址 shape = \u0026amp;rec; // 调用矩形的求面积函数 area shape-\u0026gt;area(); // 存储三角形的地址 shape = \u0026amp;tri; // 调用三角形的求面积函数 area shape-\u0026gt;area(); // 输出错误： Parent class area Parent class area /* 原因：调用函数 area() 被编译器设置为基类中的版本，这就是所谓的静态多态，或静态链接 - 函数调用在程序执行前就准备好了。有时候这也被称为早绑定，因为 area() 函数在程序编译期间就已经设置好了 添加关键字virtual */ return 0; } 虚函数 在基类中用关键字virtual声明的函数，在派生类中重新定义基类中定义的虚函数，会告诉编译器不要静态链接到该函数\n在程序中任意根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或者后期绑定\n纯虚函数 在基类中不给出默认的实现\nclass Shape { protected: int width, height; public: Shape( int a=0, int b=0) { width = a; height = b; } // pure virtual function virtual int area() = 0; // = 0 告诉编译器，函数没有主体，上面的虚函数是纯虚函数。 }; 数据抽象 定义：只向外界提供信息，并隐藏后台实现细节，既只表现必要的信息而不呈现细节\n数据抽象是一种依赖于接口和实现分离的编程技术。\n访问标签强制抽象 在 C++ 中，我们使用访问标签来定义类的抽象接口。一个类可以包含零个或多个访问标签：\n使用公共标签定义的成员都可以访问该程序的所有部分。一个类型的数据抽象视图是由它的公共成员来定义的。 使用私有标签定义的成员无法访问到使用类的代码。私有部分对使用类型的代码隐藏了实现细节。 访问标签出现的频率没有限制。每个访问标签指定了紧随其后的成员定义的访问级别。指定的访问级别会一直有效，直到遇到下一个访问标签或者遇到类主体的关闭右括号为止。\n好处 类的内部收到保护，不会因为用户的低级错误导致对象状态受损 类实现可能随着时间推移发生变化，以便应对不断变化的需求，或者应对那些要求不改变用户级代码的错误报告 如果只在类的私有部分定义数据成员，编写该类的作者就可以随意更改数据。如果实现发生改变，则只需要检查类的代码，看看这个改变会导致哪些影响。如果数据是公有的，则任何直接访问旧表示形式的数据成员的函数都可能受到影响\n#include \u0026lt;iostream\u0026gt; using namespace std; class Adder { public: Adder(int i = 0) { total = i; } // 对外接口 void addNum(int number) { total += number; } int getTotal() { return total; } private: // 对外界隐藏 int total; }; int main() { Adder a; a.addNum(10); a.addNum(20); cout \u0026lt;\u0026lt; \u0026#34;total: \u0026#34; \u0026lt;\u0026lt; a.getTotal() \u0026lt;\u0026lt; endl; return 0; } 设计策略 接口独立于实现，具体实现依赖于抽象。\n如果改变底层实现，接口也将保持不变\n在这种情况下，不管任何程序使用接口，接口都不会受到影响，只需要将最新的实现重新编译即可\n","permalink":"https://AlfredNing.github.io/note/program/game/c++/c++%E5%9F%BA%E7%A1%803/","summary":"指针 表示内存的地址。指针是一个变量，值为另一个变量的内存地址。内存位置的直接地址\n必须先声明，后使用 所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表存地址的长的十六进制数 不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同 概念 描述 C++ Null 指针 C++ 支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。 C++ 指针的算术运算 可以对指针进行四种算术运算：++、\u0026ndash;、+、- C++ 指针 vs 数组 指针和数组之间有着密切的关系。 C++ 指针数组 可以定义用来存储指针的数组。 C++ 指向指针的指针 C++ 允许指向指针的指针。 C++ 传递指针给函数 通过引用或地址传递参数，使传递的参数在调用函数中被改变。 C++ 从函数返回指针 C++ 允许函数返回指针到局部变量、静态变量和动态内存分配。 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int var = 20; // 指针变量声明 int* ip; double* dp; ip = \u0026amp;var; // 使用: 变量存储的地址 cout \u0026lt;\u0026lt; \u0026#34;ip: \u0026#34; \u0026lt;\u0026lt; ip \u0026lt;\u0026lt; endl; // 访问地址 cout \u0026lt;\u0026lt; *ip \u0026lt;\u0026lt; endl; return 0; } 引用 引用变量是一个别名，他是一件存在的变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。","title":"C++基础3"},{"content":"算法定义 有若干个样本a、c、d、e\u0026hellip; 类型假设是V\n在并查集一开始认为每个样本都在单独的集合里\n设计两个方法\n`isSameSet(V x, V y)： 查询两个样本x和有是否在同一个集合里面 union(V x, V y) : 把x和y各自所有集合的样本合并成一个集合 两个算法的时间复杂度越小越好\n算法流程 算法实现 import java.util.HashMap; import java.util.List; import java.util.Stack; /** * 并查集实现 * * @author Alfred.Ning * @since 2023年03月25日 09:23:00 */ public class UnionFindImpl { public static class Node\u0026lt;V\u0026gt; { V value; public Node(V v) { value = v; } } public static class UnionFind\u0026lt;V\u0026gt; { private HashMap\u0026lt;V, Node\u0026lt;V\u0026gt;\u0026gt; nodes; private HashMap\u0026lt;Node\u0026lt;V\u0026gt;, Node\u0026lt;V\u0026gt;\u0026gt; parents; private HashMap\u0026lt;Node\u0026lt;V\u0026gt;, Integer\u0026gt; sizeMap; public UnionFind(List\u0026lt;V\u0026gt; values) { nodes = new HashMap\u0026lt;\u0026gt;(); parents = new HashMap\u0026lt;\u0026gt;(); sizeMap = new HashMap\u0026lt;\u0026gt;(); for (V v : values) { Node\u0026lt;V\u0026gt; node = new Node\u0026lt;\u0026gt;(v); nodes.put(v, node); // 初始化各自集合 parents.put(node, node); // 初始化各自为代表点 sizeMap.put(node, 1); } } public boolean isSameSet(V a, V b) { if (!nodes.containsKey(a) || !nodes.containsKey(b)) { return false; } return findFather(nodes.get(a)) == findFather(nodes.get(b)); } public void union(V a, V b) { if (!nodes.containsKey(a) || !nodes.containsKey(b)) { return; } Node\u0026lt;V\u0026gt; aHead = findFather(nodes.get(a)); Node\u0026lt;V\u0026gt; bHead = findFather(nodes.get(b)); if (aHead != bHead) { int aSize = sizeMap.get(aHead); int bSize = sizeMap.get(bHead); Node\u0026lt;V\u0026gt; big = aSize \u0026gt;= bSize ? aHead : bHead; Node\u0026lt;V\u0026gt; small = big == aHead ? bHead : aHead; // 小挂大 parents.put(small, big); sizeMap.put(big, aSize + bSize); parents.remove(small); } } public int sets() { return sizeMap.size(); } public Node\u0026lt;V\u0026gt; findFather(Node\u0026lt;V\u0026gt; cur) { Stack\u0026lt;Node\u0026lt;V\u0026gt;\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); while (cur != parents.get(cur)) { stack.push(cur); cur = parents.get(cur); } // 扁平化 while (!stack.isEmpty()) { parents.put(stack.pop(), cur); } return cur; } } } findFather 解释 ","permalink":"https://AlfredNing.github.io/note/program/algorithm/%E5%B9%B6%E6%9F%A5%E9%9B%86/","summary":"算法定义 有若干个样本a、c、d、e\u0026hellip; 类型假设是V\n在并查集一开始认为每个样本都在单独的集合里\n设计两个方法\n`isSameSet(V x, V y)： 查询两个样本x和有是否在同一个集合里面 union(V x, V y) : 把x和y各自所有集合的样本合并成一个集合 两个算法的时间复杂度越小越好\n算法流程 算法实现 import java.util.HashMap; import java.util.List; import java.util.Stack; /** * 并查集实现 * * @author Alfred.Ning * @since 2023年03月25日 09:23:00 */ public class UnionFindImpl { public static class Node\u0026lt;V\u0026gt; { V value; public Node(V v) { value = v; } } public static class UnionFind\u0026lt;V\u0026gt; { private HashMap\u0026lt;V, Node\u0026lt;V\u0026gt;\u0026gt; nodes; private HashMap\u0026lt;Node\u0026lt;V\u0026gt;, Node\u0026lt;V\u0026gt;\u0026gt; parents; private HashMap\u0026lt;Node\u0026lt;V\u0026gt;, Integer\u0026gt; sizeMap; public UnionFind(List\u0026lt;V\u0026gt; values) { nodes = new HashMap\u0026lt;\u0026gt;(); parents = new HashMap\u0026lt;\u0026gt;(); sizeMap = new HashMap\u0026lt;\u0026gt;(); for (V v : values) { Node\u0026lt;V\u0026gt; node = new Node\u0026lt;\u0026gt;(v); nodes.","title":"并查集"},{"content":"c++运算符 算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 杂项运算符 算术运算符 假设变量 A 的值为 10，变量 B 的值为 20，则：\n运算符 描述 实例 + 把两个操作数相加 A + B 将得到 30 - 从第一个操作数中减去第二个操作数 A - B 将得到 -10 * 把两个操作数相乘 A * B 将得到 200 / 分子除以分母 B / A 将得到 2 % 取模运算符，整除后的余数 B % A 将得到 0 ++ 自增运算符，整数值增加 1 A++ 将得到 11 \u0026ndash; 自减运算符，整数值减少 1 A\u0026ndash; 将得到 9 关系运算符 假设变量 A 的值为 10，变量 B 的值为 20，则：\n运算符 描述 实例 == 检查两个操作数的值是否相等，如果相等则条件为真。 (A == B) 不为真。 != 检查两个操作数的值是否相等，如果不相等则条件为真。 (A != B) 为真。 \u0026gt; 检查左操作数的值是否大于右操作数的值，如果是则条件为真。 (A \u0026gt; B) 不为真。 \u0026lt; 检查左操作数的值是否小于右操作数的值，如果是则条件为真。 (A \u0026lt; B) 为真。 \u0026gt;= 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 (A \u0026gt;= B) 不为真。 \u0026lt;= 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 (A \u0026lt;= B) 为真 逻辑运算符 假设变量 A 的值为 1，变量 B 的值为 0，则：\n运算符 描述 实例 \u0026amp;\u0026amp; 称为逻辑与运算符。如果两个操作数都非零，则条件为真。 (A \u0026amp;\u0026amp; B) 为假。 || 称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。 (A || B) 为真。 ! 称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。 !(A \u0026amp;\u0026amp; B) 为真。 位运算符 位运算符作用于位，并逐位执行操作。\u0026amp;、 | 和 ^ 的真值表如下所示：\np q p \u0026amp; q p | q p ^ q 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 作用于数据\n下表显示了 C++ 支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则：\n运算符 描述 实例 \u0026amp; 如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。 (A \u0026amp; B) 将得到 12，即为 0000 1100 | 如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。 (A | B) 将得到 61，即为 0011 1101 ^ 如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。 (A ^ B) 将得到 49，即为 0011 0001 ~ 二进制补码运算符是一元运算符，具有\u0026quot;翻转\u0026quot;位效果，即0变成1，1变成0。 (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 \u0026laquo; 二进制左移运算符。左操作数的值向左移动右操作数指定的位数。 A \u0026laquo; 2 将得到 240，即为 1111 0000 \u0026raquo; 二进制右移运算符。左操作数的值向右移动右操作数指定的位数。 A \u0026raquo; 2 将得到 15，即为 0000 1111 赋值运算符 运算符 描述 实例 = 简单的赋值运算符，把右边操作数的值赋给左边操作数 C = A + B 将把 A + B 的值赋给 C += 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 C += A 相当于 C = C + A -= 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 C -= A 相当于 C = C - A *= 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 C *= A 相当于 C = C * A /= 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 C /= A 相当于 C = C / A %= 求模且赋值运算符，求两个操作数的模赋值给左边操作数 C %= A 相当于 C = C % A \u0026laquo;= 左移且赋值运算符 C \u0026laquo;= 2 等同于 C = C \u0026laquo; 2 \u0026raquo;= 右移且赋值运算符 C \u0026raquo;= 2 等同于 C = C \u0026raquo; 2 \u0026amp;= 按位与且赋值运算符 C \u0026amp;= 2 等同于 C = C \u0026amp; 2 ^= 按位异或且赋值运算符 C ^= 2 等同于 C = C ^ 2 |= 按位或且赋值运算符 C |= 2 等同于 C = C | 2 杂项运算符 下表列出了 C++ 支持的其他一些重要的运算符。\n运算符 描述 sizeof sizeof 运算符返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。 Condition ? X : Y 条件运算符。如果 Condition 为真 ? 则值为 X : 否则值为 Y。 , 逗号运算符会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。 .（点）和 -\u0026gt;（箭头） 成员运算符用于引用类、结构和共用体的成员。 Cast 强制转换运算符把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。 \u0026amp; 指针运算符 \u0026amp; 返回变量的地址。例如 \u0026amp;a; 将给出变量的实际地址。 * 指针运算符 * 指向一个变量。例如，*var; 将指向变量 var。 运算优先级 下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。\n类别 运算符 结合性 后缀 () [] -\u0026gt; . ++ - - 从左到右 一元 + - ! ~ ++ - - (type)* \u0026amp; sizeof 从右到左 乘除 * / % 从左到右 加减 + - 从左到右 移位 \u0026laquo; \u0026raquo; 从左到右 关系 \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= 从左到右 相等 == != 从左到右 位与 AND \u0026amp; 从左到右 位异或 XOR ^ 从左到右 位或 OR | 从左到右 逻辑与 AND \u0026amp;\u0026amp; 从左到右 逻辑或 OR || 从左到右 条件 ?: 从右到左 赋值 = += -= *= /= %=\u0026raquo;= \u0026laquo;= \u0026amp;= ^= |= 从右到左 逗号 , 从左到右 基本结构 循环 循环类型 C++ 编程语言提供了以下几种循环类型。点击链接查看每个类型的细节。\n循环类型 描述 while 循环 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。 for 循环 多次执行一个语句序列，简化管理循环变量的代码。 do\u0026hellip;while 循环 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。 嵌套循环 您可以在 while、for 或 do..while 循环内使用一个或多个循环。 循环控制语句 循环控制语句更改执行的正常序列。当执行离开一个范围时，所有在该范围中创建的自动对象都会被销毁。\nC++ 提供了下列的控制语句。点击链接查看每个语句的细节。\n控制语句 描述 break 语句 终止 loop 或 switch 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。 continue 语句 引起循环跳过主体的剩余部分，立即重新开始测试条件。 goto 语句 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。 无限循环 #include \u0026lt;iostream\u0026gt;using namespace std; int main (){ for( ; ; ) { printf(\u0026#34;This loop will run forever.\\n\u0026#34;); } return 0;} 判断 判断语句 语句 描述 if 语句 一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。 if\u0026hellip;else 语句 一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。 嵌套 if 语句 您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。 switch 语句 一个 switch 语句允许测试一个变量等于多个值时的情况。 嵌套 switch 语句 您可以在一个 switch 语句内使用另一个 switch 语句。 运算符: ?: Exp1 ? Exp2 : Exp3;\n函数 #include \u0026lt;iostream\u0026gt; int count; // 函数声明 在函数声明中，参数的名称并不重要，只有参数的类型是必需的 int funcDefine(int num1, int num2); // 也可以声明为： int funcDefine(int, int); // 一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，在调用函数的文件顶部声明函数 int main() { count = 5; // 调用函数 funcDefine(3, 4); return 0; } // 定义函数 int funcDefine(int num1, int num2) { /** * 函数组成 * 1. 返回类型 * 2. 函数名称 * 3. 参数 * 4. 函数主体 */ } 函数参数 必须声明接受参数值的变量。这些变量称为函数的形式参数\n形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁\n传递参数的方式 调用类型 描述 传值调用 该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。 指针调用 该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 引用调用 该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 lambda函数与表达式 C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)\nLambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。\nLambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:\n[capture](parameters)-\u0026gt;return-type{body} [](int x, int y){ return x \u0026lt; y ; } 没有参数可以表示为： []{++global_x;} [](int x, int y) -\u0026gt; int { int z = x + y; return z + x; } 在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定： [] // 沒有定义任何变量。使用未定义变量会引发错误。 [x, \u0026amp;y] // x以传值方式传入（默认），y以引用方式传入。 [\u0026amp;] // 任何被使用到的外部变量都隐式地以引用方式加以引用。 [=] // 任何被使用到的外部变量都隐式地以传值方式加以引用。 [=, x] // x显式地以传值方式加以引用。其余变量以引用方式加以引用。 [\u0026amp;, \u0026amp;z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。 对于[=]或[\u0026amp;]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入 [this]() { this-\u0026gt;someFunc(); }(); 数字操作 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { // 数字定义 short s; int i; long l; float f; double d; // 数字赋值 s = 10; i = 1000; l = 1000000; f = 230.447; d = 20334.242; // 数字输出 cout \u0026lt;\u0026lt; \u0026#34;short s :\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;int i :\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;long l :\u0026#34; \u0026lt;\u0026lt; l \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;float f :\u0026#34; \u0026lt;\u0026lt; f \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;double d :\u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; // 数学运算 cout \u0026lt;\u0026lt; \u0026#34;sin(d) :\u0026#34; \u0026lt;\u0026lt; sin(d) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;abs(i) :\u0026#34; \u0026lt;\u0026lt; abs(i) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;floor(d) :\u0026#34; \u0026lt;\u0026lt; floor(d) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;sqrt(f) :\u0026#34; \u0026lt;\u0026lt; sqrt(f) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;pow( d, 2) :\u0026#34; \u0026lt;\u0026lt; pow(d, 2) \u0026lt;\u0026lt; endl; // 随机数 int ii, j; // 设置种子 srand((unsigned)time( NULL)); for (ii = 0; ii \u0026lt; 10; ii++) { j = rand(); cout \u0026lt;\u0026lt; \u0026#34;随机数：\u0026#34; \u0026lt;\u0026lt; j \u0026lt;\u0026lt; endl; } return 0; } 数组 固定大小相同类型的元素集合。存储一系列数据。所有数组都是由连续的内存位置组成。最低的位置对应第一个元素，最高的位置对应最后一个元素\n#include \u0026lt;iostream\u0026gt; using namespace std; #include \u0026lt;iomanip\u0026gt; using std::setw; int main() { // 声明数组 type arrayName [arraySize] double balance[10]; // 初始化数组 double balance2[3] = { 10, 20, 30 }; // 大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目 // 如果省略掉了数组的大小，数组的大小则为初始化时元素的个数 double balance1[] = { 1000.0, 2.0, 3.4, 17.0, 50.0 }; // 访问数组元素 double salary = balance[9]; int n[10]; for (int i = 0; i \u0026lt; 10; i++) { n[i] = i + 100; } // setw: 格式化输出 cout \u0026lt;\u0026lt; \u0026#34;Element\u0026#34; \u0026lt;\u0026lt; setw(13) \u0026lt;\u0026lt; \u0026#34;Value\u0026#34; \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; 10; i++) { cout \u0026lt;\u0026lt; setw(7) \u0026lt;\u0026lt; i \u0026lt;\u0026lt; setw(13) \u0026lt;\u0026lt; n[i] \u0026lt;\u0026lt; endl; } return 0; } 概念 概念 描述 多维数组 C++ 支持多维数组。多维数组最简单的形式是二维数组。 指向数组的指针 您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。 传递数组给函数 您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。 从函数返回数组 C++ 允许从函数返回数组。 字符串 C 风格字符串 C++ 引入的 string 类类型 字符串的内存表示| C++ 编译器会在初始化数组时，自动把 \u0026lsquo;\\0\u0026rsquo; 放在字符串的末尾。\n字符串函数 序号 函数 \u0026amp; 目的 1 strcpy(s1, s2); 复制字符串 s2 到字符串 s1。 2 strcat(s1, s2); 连接字符串 s2 到字符串 s1 的末尾。 3 strlen(s1); 返回字符串 s1 的长度。 4 strcmp(s1, s2); 如果 s1 和 s2 是相同的，则返回 0；如果 s1\u0026lt;s2 则返回小于 0；如果 s1\u0026gt;s2 则返回大于 0。 5 strchr(s1, ch); 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 6 strstr(s1, s2); 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 #include \u0026lt;iostream\u0026gt; using namespace std; #include \u0026lt;iomanip\u0026gt; using std::setw; int main() { // c风格字符串 字符串实际上是使用 null 字符 \u0026#39;\\0\u0026#39; 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符 char greeting[6] = { \u0026#39;h\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;,\u0026#39;l\u0026#39;, \u0026#39;0\u0026#39; }; char greeting1[] = \u0026#34;hello\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Greeting message: \u0026#34;; cout \u0026lt;\u0026lt; greeting \u0026lt;\u0026lt; endl; return 0; } String类 c++标准库的类\n#include \u0026lt;iostream\u0026gt; using namespace std; #include \u0026lt;iomanip\u0026gt; using std::setw; #include \u0026lt;string\u0026gt; int main() { string str1 = \u0026#34;hello\u0026#34;; string str2 = \u0026#34;world\u0026#34;; string str3; int len; // 复制 str3 = str1; cout \u0026lt;\u0026lt; \u0026#34;str3: \u0026#34; \u0026lt;\u0026lt; str3 \u0026lt;\u0026lt; endl; // 连接 str3 = str1 + str2; cout \u0026lt;\u0026lt; \u0026#34;str3: \u0026#34; \u0026lt;\u0026lt; str3 \u0026lt;\u0026lt; endl; // 长度 len = str3.size(); cout \u0026lt;\u0026lt; \u0026#34;str3 size(): \u0026#34; \u0026lt;\u0026lt; len \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://AlfredNing.github.io/note/program/game/c++/c++%E5%9F%BA%E7%A1%802/","summary":"c++运算符 算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 杂项运算符 算术运算符 假设变量 A 的值为 10，变量 B 的值为 20，则：\n运算符 描述 实例 + 把两个操作数相加 A + B 将得到 30 - 从第一个操作数中减去第二个操作数 A - B 将得到 -10 * 把两个操作数相乘 A * B 将得到 200 / 分子除以分母 B / A 将得到 2 % 取模运算符，整除后的余数 B % A 将得到 0 ++ 自增运算符，整数值增加 1 A++ 将得到 11 \u0026ndash; 自减运算符，整数值减少 1 A\u0026ndash; 将得到 9 关系运算符 假设变量 A 的值为 10，变量 B 的值为 20，则：","title":"C++基础2"},{"content":"简介 C++一种静态类型、编译式、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。\nc++是一门中级语言，综合高级语言和低级语言的特点。\nC++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。\n静态类型的编程语言都是在编译时候执行类型检查，而不是在运行时候执行类型检查\n面向对象四大特点 封装 继承 抽象 多态 开发工具，window使用Visual Studio\n对象 - 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。 类 - 类可以定义为描述对象行为/状态的模板/蓝图。 方法 - 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。 即时变量 - 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。 程序结构 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello, world!\u0026#34; \u0026lt;\u0026lt; endl; return 0; } g++ hello.cpp$ ./a.outHello Wo 头文件：包含程序必须的或有用的信息 命名空间 main 函数程序开始 分号是语句结束符，每个语句必须以分号结束。c++不以行末作为结束符，一行可以放置多个语句 块是一组使用大括号括起来的按逻辑连接的语句 标识符 以字母A-Z或a-z或下划线_开始，后跟多个字母数字下划线\n关键字 asm else new this auto enum operator throw bool explicit private true break export protected try case extern public typedef catch false register typeid char float reinterpret_cast typename class for return union const friend short unsigned const_cast goto signed using continue if sizeof virtual default inline static void delete int static_cast volatile do long struct wchar_t double mutable switch while dynamic_cast namespace template 三字符组 用于表示另一个字符的三个字符系列，又称为三字符系列\n以两个问号开头 三字符序列不太常见，但 C++ 标准允许把某些字符指定为三字符序列。以前为了表示键盘上没有的字符，这是必不可少的一种方法。 三字符序列可以出现在任何地方，包括字符串、字符序列、注释和预处理指令 三字符组 替换 ??= # ??/ \\ ??' ^ ??( [ ??) ] ??! | ??\u0026lt; { ??\u0026gt; } ??- ~ 如果希望在源程序中有两个连续的问号，且不希望被预处理器替换，这种情况出现在字符常量、字符串字面值或者是程序注释中，可选办法是用字符串的自动连接：\u0026quot;\u0026hellip;?\u0026quot;\u0026quot;?\u0026hellip;\u0026ldquo;或者转义序列：\u0026rdquo;\u0026hellip;??\u0026hellip;\u0026quot;。 从Microsoft Visual C++ 2010版开始，该编译器默认不再自动替换三字符组。如果需要使用三字符组替换（如为了兼容古老的软件代码），需要设置编译器命令行选项/Zc:trigraphs、 g++仍默认支持三字符组，但会给出编译警告 空格 只包含空格的行，被称为空白行，可能带有注释，C++ 编译器会完全忽略它\n注释 单行注释：// 或者 /**/ 多行注释: /**/ 在 /* 和 / 注释内部，// 字符没有特殊的含义 数据类型 变量保留是所存储的值的内存地址，当创建一个变量，就会在内存中保留一些空间。\n七种基本的 C++ 基本内置数据类型 类型 关键字 类型 关键字 布尔型 bool 字符型 char 整型 int 浮点型 float 双浮点型 double 无类型 void 宽字符型 wchar_t 类型修饰符\nsigned unsigned short long 类型 位 范围 char 1 个字节 -128 到 127 或者 0 到 255 unsigned char 1 个字节 0 到 255 signed char 1 个字节 -128 到 127 int 4 个字节 -2147483648 到 2147483647 unsigned int 4 个字节 0 到 4294967295 signed int 4 个字节 -2147483648 到 2147483647 short int 2 个字节 -32768 到 32767 unsigned short int 2 个字节 0 到 65,535 signed short int 2 个字节 -32768 到 32767 long int 8 个字节 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 signed long int 8 个字节 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 unsigned long int 8 个字节 0 to 18,446,744,073,709,551,615 float 4 个字节 +/- 3.4e +/- 38 (~7 个数字) double 8 个字节 +/- 1.7e +/- 308 (~15 个数字) long double 8 个字节 +/- 1.7e +/- 308 (~15 个数字) wchar_t 2 或 4 个字节 1 个宽字符 #include \u0026lt;iostream\u0026gt; using namespace std; int main(){ cout \u0026lt;\u0026lt; \u0026#34;Size of char : \u0026#34; \u0026lt;\u0026lt; sizeof(char) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Size of int : \u0026#34; \u0026lt;\u0026lt; sizeof(int) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Size of short int : \u0026#34; \u0026lt;\u0026lt; sizeof(short int) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Size of long int : \u0026#34; \u0026lt;\u0026lt; sizeof(long int) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Size of float : \u0026#34; \u0026lt;\u0026lt; sizeof(float) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Size of double : \u0026#34; \u0026lt;\u0026lt; sizeof(double) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Size of wchar_t : \u0026#34; \u0026lt;\u0026lt; sizeof(wchar_t) \u0026lt;\u0026lt; endl; return 0; } // 结果会根据所使用的计算机而有所不同 typedef of 声明 为已有的类型取一个新名字\n#include \u0026lt;iostream\u0026gt; using namespace std; typedef int a; int main(){ a b = 10; cout \u0026lt;\u0026lt; b; return 0; } 枚举类型 派生数据类型，由用户定义的若干枚举常量的集合\nenum enum-name { list of names } var-list;\n#include \u0026lt;iostream\u0026gt; using namespace std; typedef int a; int main(){ // 默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推 enum color { red, blue, green } c ; c = blue; cout \u0026lt;\u0026lt; c; // 以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，green 的值为 5。 enum color { red, green = 5, blue }; return 0; } 变量类型 变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C++ 是大小写敏感的。\n前面的基本数据类型\n类型 描述 bool 存储值 true 或 false。 char 通常是一个八位字节（一个字节）。这是一个整数类型。 int 对机器而言，整数的最自然的大小。 float 单精度浮点值。 double 双精度浮点值。 void 表示类型的缺失。 wchar_t 宽字符类型。 c++ 也允许定义各种其他类型的变量，比如枚举、指针、数组、引用、数据结构、类等等\n变声类型 变量名\n声明的时候被初始化。\n不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。\n变量声明 变量声明保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。\n使用多个文件只在其中一个文件定义变量\nextern 关键字在任何地方声明一个变量。可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次\n#include \u0026lt;iostream\u0026gt; using namespace std; extern int a, b;extern int c; extern float f; int func(); // 函数声明 int main(){ // 变量定义 int a, b; int c; float f; // 实际初始化 a = 10; b = 20; c = a + b; cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; f = 70.0 / 3.0; cout \u0026lt;\u0026lt; f \u0026lt;\u0026lt; endl; return 0; } 左值和右值 左值：指向内存位置的表达式被称为左值(lvalue)表达式。左值可以出现在赋值号的左边或右边。\n右值：指存储在内存某些地址的数值。右值是不能对其进行赋值的表达式。右值只能出现在赋值号的右边\n变量作用域 一般有三个地方可以声明变量\n函数或一个代码块中，称为局部变量 在函数参数的定义中声明的变量，称为形式参数 在所有函数外部声明的变量，成为全局变量 #include \u0026lt;iostream\u0026gt; using namespace std; // 全局变量声明 int g; int gg = 100; int main(){ // 局部变量声明 int a, b; int c; // 实际初始化 a = 10; b = 20; c = a + b; cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; // 全局变量初始 g = 100; cout \u0026lt;\u0026lt; g \u0026lt;\u0026lt; endl; // 同名变量，局部覆盖全局变量 int gg = 300; cout \u0026lt;\u0026lt; gg \u0026lt;\u0026lt; endl; return 0; } 当局部变量被定义时，系统不会对其初始化，必须自行对其初始化。定义全局变量时，系统会自动初始化为下列值\n数据类型 初始化默认值 int 0 char \u0026lsquo;\\0\u0026rsquo; float 0 double 0 pointer NULL 正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果\n常量 常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量\n常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值\n常量的值在定义后不能更改\n整数常量 整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。\n整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意\n浮点常量 浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。\n当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的\n.14159 // 合法的 314159E-5L // 合法的 510E // 非法的：不完整的指数210f 布尔常量 true false 不要把 true 的值看成 1，把 false 的值看成 0\n字符常量 字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L\u0026rsquo;x\u0026rsquo;），此时它必须存储在 wchar_t 类型的变量中。否则，它就是一个窄字符常量（例如 \u0026lsquo;x\u0026rsquo;），此时它可以存储在 char 类型的简单变量中。\n字符常量可以是一个普通的字符（例如 \u0026lsquo;x\u0026rsquo;）、一个转义序列（例如 \u0026lsquo;\\t\u0026rsquo;），或一个通用的字符（例如 \u0026lsquo;\\u02C0\u0026rsquo;）\n有反斜杠时，它们就具有特殊的含义\n转义序列码\n转义序列 含义 \\ \\ 字符 ' \u0026rsquo; 字符 \u0026quot; \u0026quot; 字符 ? ? 字符 \\a 警报铃声 \\b 退格键 \\f 换页符 \\n 换行符 \\r 回车 \\t 水平制表符 \\v 垂直制表符 \\ooo 一到三位的八进制数 \\xhh . . . 一个或多个数字的十六进制数 字符串常量 符串字面值或常量是括在双引号 \u0026quot;\u0026quot; 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。\n定义常量 #define 预处理器 #include \u0026lt;iostream\u0026gt; using namespace std; #define WIDTH 5 #define LENGTH 10 #define NEWLINE \u0026#39;\\n\u0026#39; int main(){ cout \u0026lt;\u0026lt; WIDTH \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; LENGTH \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; NEWLINE \u0026lt;\u0026lt; endl; return 0; } const 关键字 #include \u0026lt;iostream\u0026gt; using namespace std; int main(){ const int WIDTH = 5; const int LENGTH = 10; const char NEWLINE = \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; WIDTH \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; LENGTH \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; NEWLINE \u0026lt;\u0026lt; endl; return 0; } 修饰符类型 C++ 允许在 char、int 和 double 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。\n下面列出了数据类型修饰符：\nsigned unsigned long short 修饰符 signed、unsigned、long 和 short 可应用于整型，signed 和 unsigned 可应用于字符型，long 可应用于双精度型。\n修饰符 signed 和 unsigned 也可以作为 long 或 short 修饰符的前缀。例如：unsigned long int。\nC++ 允许使用速记符号来声明无符号短整数或无符号长整数。您可以不写 int，只写单词 unsigned、short 或 unsigned、long，int 是隐含的。例如，下面的两个语句都声明了无符号整型变量。\nunsigned x; unsigned int y;\t类型限定符 给变量设置额外信息\n限定符 含义 const const 类型的对象在程序执行期间不能被修改改变。 volatile 修饰符 volatile 告诉编译器，变量的值可能以程序未明确指定的方式被改变。 restrict 由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。 存储类 作用：定义c++程序中变量/函数的范围（可见性）和声明周期。放置在修饰的类型之前\nauto register static extern mutable thread_local (C++11) 从 C++ 11 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用\nauto存储类 自 C++ 11 以来，auto 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。\nC++98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在C++11中已删除这一用法\nregister 存储类 用于定义存储在寄存器而不是RAM中的局部变量\n最大尺寸等于寄存器的大小，且不能应用一元运算符\u0026amp;， 因为它没有内存位置 寄存器只用于需要快速访问的变量，比如计数器。 不是一味的意味着变量存储到寄存器中，可能意味着存储到寄存器当中，取决于硬件和实现的限制 static存储类 作用：指示编译器在程序的声明周期内保持局部变量的存在，而不需要每次进入和离开作用域时候进行创建和销毁\n利用static变量修饰局部变量可以在函数调用中保持局部变量的值 修饰全局变量，使变量的作用域限定在声明的文件内 作用在类数据成员上，会导致仅有一个该成员的副本被类的所有对象共享 #include \u0026lt;iostream\u0026gt; // 函数声明 void func(void); // 全局静态变量 static int count = 10; int main(){ while (count--) { func(); } return 0; } void func(void) { // 局部静态变量 static int i = 5; i++; std::cout \u0026lt;\u0026lt; \u0026#34;变量i为 \u0026#34; \u0026lt;\u0026lt; i; std::cout \u0026lt;\u0026lt; \u0026#34;变量count为 \u0026#34; \u0026lt;\u0026lt; count \u0026lt;\u0026lt; std::endl; } extern存储类 提供一个全局变量的引用，全局变量对所有程序的文件都是可见的。当使用 \u0026rsquo;extern\u0026rsquo; 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。\n用来在另一个文件中声明一个全局变量或函数\nextern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候\n// t1.cpp #include \u0026lt;iostream\u0026gt; extern int count; void write_externx(void) { // Count is 5 std::cout \u0026lt;\u0026lt; \u0026#34;Count is \u0026#34; \u0026lt;\u0026lt; count \u0026lt;\u0026lt; std::endl; } // main.cpp #include \u0026lt;iostream\u0026gt; int count; extern void write_externx(); int main() { count = 5; write_externx(); return 0; } mutable存储类 只适用于类的对象，允许对象的成员替代常量。mutable 成员可以通过 const 成员函数修改\nthread_local 存储类 声明的变量仅可在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。\nthread_local 说明符可以与 static 或 extern 合并。\n可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。\nthread_local int x; // 命名空间下的全局变量 class X{ static thread_local std::string s; // 类的static成员变量 }; static thread_local std::string X::s; // X::s 是需要定义的 void foo(){ thread_local std::vector\u0026lt;int\u0026gt; v; // 本地变量 } ","permalink":"https://AlfredNing.github.io/note/program/game/c++/c++%E5%9F%BA%E7%A1%801/","summary":"简介 C++一种静态类型、编译式、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。\nc++是一门中级语言，综合高级语言和低级语言的特点。\nC++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。\n静态类型的编程语言都是在编译时候执行类型检查，而不是在运行时候执行类型检查\n面向对象四大特点 封装 继承 抽象 多态 开发工具，window使用Visual Studio\n对象 - 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。 类 - 类可以定义为描述对象行为/状态的模板/蓝图。 方法 - 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。 即时变量 - 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。 程序结构 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello, world!\u0026#34; \u0026lt;\u0026lt; endl; return 0; } g++ hello.cpp$ ./a.outHello Wo 头文件：包含程序必须的或有用的信息 命名空间 main 函数程序开始 分号是语句结束符，每个语句必须以分号结束。c++不以行末作为结束符，一行可以放置多个语句 块是一组使用大括号括起来的按逻辑连接的语句 标识符 以字母A-Z或a-z或下划线_开始，后跟多个字母数字下划线\n关键字 asm else new this auto enum operator throw bool explicit private true break export protected try case extern public typedef catch false register typeid char float reinterpret_cast typename class for return union const friend short unsigned const_cast goto signed using continue if sizeof virtual default inline static void delete int static_cast volatile do long struct wchar_t double mutable switch while dynamic_cast namespace template 三字符组 用于表示另一个字符的三个字符系列，又称为三字符系列","title":"C++初始"},{"content":"jvm内存结构图\n哪些内存结构与线程意义对应，其实问的是线程共有和私有 共有： 堆和方法区 私有： 本地方法栈、虚拟机栈、程序计数器\n程序计数器 保证程序在程序系统中能够执行下去，CPU必须具有某些手段来确定下一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器 一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器。 在程序开始执行前，必须将它的起始地址，即程序的一条指令所在的内存单元地址送入PC，因此程序计数器（PC）的内容即是从内存提取的第一条指令的地址。当执行指令时，CPU将自动修改PC的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数，以便使其保持的总是将要执行的下一条指令的地址 由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单的对PC加1 当程序转移时，转移指令执行的最终结果就是要改变PC的值，此PC值就是转去的地址，以此实现转移。有些机器中也称PC为指令指针IP（Instruction Pointer） 特征 JVM中的程序计数寄存器（Program Counter Register）中， Register 的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。 CPU只有把数据装载到寄存器才能够运行。\nJVM中的PC寄存器是对物理PC寄存器的一种抽象模拟\n很小的内存结构，忽略不计，也是运行最快的存储区域，不会随着程序的运行需要更大的空间 在JVM规范中，每个线程都有自己的程序计数器，是线程私有的，生命周期与线程生命周期保持一致 它是唯一一个在JVM虚拟机规范中没有规定任何OutOtMemoryError 情况的区域 问题 为什么使用PC寄存器来记录当前线程的执行地址 因为CPU需要不停的切换各个线程，准确知道执行的位置。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令 PC寄存器为什么被设置为线程私有 多线程在一个特定的时间段内之会执行某一个线程的方法，CPU需要不停的做任务切换**。为了准确记录各个线程正在执行的当前字节码指令，最好的办法就是为每一个线程分配PC寄存器**，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况 虚拟机栈 栈管运行，堆管内存\n栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿\nJava虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。 是线程私有的 生命周期: 生命周期和线程一致。\n特点: 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。\n栈是否有GC？ 不存在GC, 但有OOM\n抛出的异常：\nStackOverFlowError OutOfMemoryError Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个 StackOverflowError 异常 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出—个 OutOfMemoryError 异常 设置栈大小 -Xsssize (即：-XX:ThreadStackSize)\n一般为：512k-1M 栈的大小直接决定了函数调用的最大深度 设置的栈空间值过大，会导致系统可以用于创建线程的数量减少 一般一个进程中通常有3000-5000个线程\njdk5.0之前，默认为256k jdk5.0之后，默认为1024k\n栈帧 栈的基本单位是栈帧，每个线程都有自己的栈，栈中的数据都是以栈帧存在的。\n方法与栈帧的关系 在这个线程执行的方法都有一个栈帧 栈帧是一个内存区块，是一个数据集，维护着方法执行过程中的各种数据信息 栈的内部结构 局部变量表 操作数栈或表达式栈 动态链接或指向运行时常量池的方法引用 方法返回地址（或方法正常退出或者异常退出的定义） 一些附加信息 局部变量表 - Local Varibales 局部变量表被称为局部变量数组或者本地变量表 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，数据类别包括：基本数据类型，对象引用、以returnAddress类型 局部变量表的大小是在编译器确定，保存在方法的code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的 方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减 **局部变量表的变量只在当前方法调用中有效。**在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。 静态变量与局部变量区别 类变量表有两次初始化的机会，第一次准备阶段，执行系统初始化，赋零值，另一次是在初始化阶段，赋予代码中指定的初始值 和类变量初始化不同，局部变量表不存在系统初始化的过程，一旦定义了局部变量则必须人为的初始化，否则无法使用 与GC ROOTS的关系 局部变量表的变量也是重要的垃圾回收节点，只要被局部变量中直接或者间接引用的对象都不会被回收\n操作数栈 Operand Stack ","permalink":"https://AlfredNing.github.io/note/program/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98/","summary":"jvm内存结构图\n哪些内存结构与线程意义对应，其实问的是线程共有和私有 共有： 堆和方法区 私有： 本地方法栈、虚拟机栈、程序计数器\n程序计数器 保证程序在程序系统中能够执行下去，CPU必须具有某些手段来确定下一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器 一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器。 在程序开始执行前，必须将它的起始地址，即程序的一条指令所在的内存单元地址送入PC，因此程序计数器（PC）的内容即是从内存提取的第一条指令的地址。当执行指令时，CPU将自动修改PC的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数，以便使其保持的总是将要执行的下一条指令的地址 由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单的对PC加1 当程序转移时，转移指令执行的最终结果就是要改变PC的值，此PC值就是转去的地址，以此实现转移。有些机器中也称PC为指令指针IP（Instruction Pointer） 特征 JVM中的程序计数寄存器（Program Counter Register）中， Register 的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。 CPU只有把数据装载到寄存器才能够运行。\nJVM中的PC寄存器是对物理PC寄存器的一种抽象模拟\n很小的内存结构，忽略不计，也是运行最快的存储区域，不会随着程序的运行需要更大的空间 在JVM规范中，每个线程都有自己的程序计数器，是线程私有的，生命周期与线程生命周期保持一致 它是唯一一个在JVM虚拟机规范中没有规定任何OutOtMemoryError 情况的区域 问题 为什么使用PC寄存器来记录当前线程的执行地址 因为CPU需要不停的切换各个线程，准确知道执行的位置。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令 PC寄存器为什么被设置为线程私有 多线程在一个特定的时间段内之会执行某一个线程的方法，CPU需要不停的做任务切换**。为了准确记录各个线程正在执行的当前字节码指令，最好的办法就是为每一个线程分配PC寄存器**，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况 虚拟机栈 栈管运行，堆管内存\n栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿\nJava虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。 是线程私有的 生命周期: 生命周期和线程一致。\n特点: 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。\n栈是否有GC？ 不存在GC, 但有OOM\n抛出的异常：\nStackOverFlowError OutOfMemoryError Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个 StackOverflowError 异常 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出—个 OutOfMemoryError 异常 设置栈大小 -Xsssize (即：-XX:ThreadStackSize)\n一般为：512k-1M 栈的大小直接决定了函数调用的最大深度 设置的栈空间值过大，会导致系统可以用于创建线程的数量减少 一般一个进程中通常有3000-5000个线程\njdk5.0之前，默认为256k jdk5.0之后，默认为1024k\n栈帧 栈的基本单位是栈帧，每个线程都有自己的栈，栈中的数据都是以栈帧存在的。\n方法与栈帧的关系 在这个线程执行的方法都有一个栈帧 栈帧是一个内存区块，是一个数据集，维护着方法执行过程中的各种数据信息 栈的内部结构 局部变量表 操作数栈或表达式栈 动态链接或指向运行时常量池的方法引用 方法返回地址（或方法正常退出或者异常退出的定义） 一些附加信息 局部变量表 - Local Varibales 局部变量表被称为局部变量数组或者本地变量表 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，数据类别包括：基本数据类型，对象引用、以returnAddress类型 局部变量表的大小是在编译器确定，保存在方法的code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的 方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减 **局部变量表的变量只在当前方法调用中有效。**在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。 静态变量与局部变量区别 类变量表有两次初始化的机会，第一次准备阶段，执行系统初始化，赋零值，另一次是在初始化阶段，赋予代码中指定的初始值 和类变量初始化不同，局部变量表不存在系统初始化的过程，一旦定义了局部变量则必须人为的初始化，否则无法使用 与GC ROOTS的关系 局部变量表的变量也是重要的垃圾回收节点，只要被局部变量中直接或者间接引用的对象都不会被回收","title":"运行时内存"},{"content":"类的加载过程 Java数据类型分为数据基本数据类型和引用数据类型\n基本类型由虚拟机预先定义，引用类型需要进行类的加载\n类的加载大过程分为三步, 总过程七步\n装载 将java的class文件加载到机器内存，并在内存中构建出Java类的原型-类模板对象\n查找类的二进制文件，生成class实例\n加载类，需要完成以下三件事情：\n通过类的全名，获取类的二进制数据流 解析类的二进制数据流转换为方法区的数据结构(Java类模型) 创建java.lang.class类的实例，表示该类型 类模板对象 Java类在内存中的一个快照，JVM从字节码文件解析出来的常量池、类字段、类方法等类信息存储到类模板中。在运行期通过类模板获取Java类的任意信息，能够对Java类的成员变量进行遍历，进行方法调用。反射机制也是基于此，如果没有存储Java类的声明信息，JVM在运行期也无法进行反射\n获取二进制数据流 class字节码文件符号JVM规范\n通过读取class后缀的文件 读入jar、zip等归档数据包，提取类文件(热部署jar包原理基础) 事先存放在数据库的二进制数据 使用类型Http之类的协议通过网络进行加载 在运行时生成一段class的二进制信息等 class实例位置 类将.class文件加载至元空间后，会在堆中创建一个Java.lang.Class对象，用来封装类位于方法区内的数据结构，该Class对象是在加载类的过程中创建的，每个类都对应有一个Class类型的对象 数组类的加载 数组类本身不是由类加载器负责创建，而是由JVM在运行时根据需要去创建。加载器只负责加载数据元素的数据类型(基本数据类型和引用数据类型)，申请内存分配长度\n链接 验证阶段 保证加载的字节码是合法、合理并符合jvm规范\n格式验证回合装载阶段一起执行。验证通过之后，类加载器才会把验证成功的二级制数据信息加载到方法区中 格式验证之外的验证操作都在方法区中进行 准备阶段 为类的静态变量分配内存，并将其初始化为默认值。\nJava并不支持boolean类型，对于boolean类型，内部实现是int,由于int的默认值是0,故对应的，boolean的默认值就是false\n解析阶段 将类、接口、自动和方法的符号引用转换为直接应用\n符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。比较容易理解的就是在Class类文件中，通过常量池进行了大量的符号引用。通过解析操作，符号引用就可以转化为目标方法在类中方法表的位置，从而使得方法被成功调用。\n解析就是将符号引用转换为直接引用。换言之，直接引用存在，一定存在符号引用，反之不然\nJava虚拟机规范并没有要求解析操作一定要按照顺序执行\n在HotSpot VM中，加载、验证、准备和初始化会按照顺序有条不紊地执行，但链接阶段中的解析操作往往会伴随着JVM在执行完初始化之后再执行\n初始化 为静态变量赋予正确的初始值\n开始执行java字节码，执行类的初始化方法\nclinit方法：该方法只能由JVM编译器生成，程序开发者无法自定义一个同名的方法，无法在java程序中调用该方法，该方法由java字节码组成 init方法：由类的静态成员变量赋值及其static语句块产生 clinit方法的生成 以下几种情况，不会生产clinit方法\n一个类中没有声明任何类变量，也没静态代码块 一个类中声明类变量，但没有明确使用类的初始化语句以及静态代码块进行初始化操作 一个类中包含static final 修饰的基本类型字段，这些类字段使用编译时常量表达式 clinit是由虚拟机保证在多线程环境下正确的加锁同步，是线程安全的。如果有很长的耗时操作，是会造成死锁的。\n类的加载 加载 = 装载 + 链接 + 初始化\nJava程序的主动使用\n主动使用的说明 Class只有在必须要首次使用的时候才会被装载，Java虚拟机不会无条件地装载Class类型。Java虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用。\n主动使用只有下列几种情况：（即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成。）\n当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化。\n当调用类的静态方法时，即当使用了字节码invokestatic指令。\n当使用类、接口的静态字段时(final修饰特殊考虑)，比如，使用getstatic或者putstatic指令。\n当使用java.lang.reflect包中的方法反射类的方法时。比如：Class.forName(\u0026ldquo;com.atguigu.java.Test\u0026rdquo;)\n当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。\n如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。\n当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。\n当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。（涉及解析REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄对应的类）\n被动使用的情况 除了以上的情况属于主动使用，其他的情况均属于被动使用。被动使用不会引起类的初始化。\n也就是说：并不是在代码中出现的类，就一定会被加载或者初始化。如果不符合主动使用的条件，类就不会初始化。\n当访问一个静态字段时，只有真正声明这个字段的类才会被初始化。 当通过子类引用父类的静态变量，不会导致子类初始化 通过数组定义类引用，不会触发此类的初始化\n引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了。\n调用ClassLoader类的loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化。\n被动的使用，意味着不需要执行初始化环节，意味着没有clinit方法的调用\n如果针对代码，设置参数-XX:+TraceClassLoading，可以追踪类的加载信息并打印出来\nClass.forName 与loadClass Clas.forName加载后执行到初始化阶段\nClass.getClassLoader#loadClass只会执行到装载阶段\n使用 在程序中访问和调用它的静态类成员信息\n卸载 类、类加载器和类的实例之间的引用关系 在类的加载器内部实现中，用一个集合来存放所加载类的引用。另一方面，一个class对象总是会引用它的类加载器，调用class对象的getClassLoader方法，就能够获取它的类加载器。由此可见，代表某个类的Class实例与其类的加载器之间为双向关联关系。 一个类的实例总是引用代表这个类的Class对象。在Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有的Java类都有一个静态属性class，它引用代表这个类的Class对象\n类卸载的时机 一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期\n当Sample类被加载、链接和初始化后，它的生命周期就开始了。当代表Sample类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，Sample类在方法区内的数据也会被卸载，从而结束Sample类的生命周期。\n例如：\nloader1变量和obj变量间接引用代表Sample类的Class对象，而objClass变量则直接引用它。\n如果程序运行过程中，将上图左侧三个引用变量都置为null，此时Sample对象结束生命周期，MyClassLoader对象结束生命周期，代表Sample类的Class对象也结束生命周期，Sample类在方法区内的二进制数据被卸载。\n当再次有需要时，会检查Sample类的Class对象是否存在，如果存在会直接使用，不再重新加载；如果不存在Sample类会被重新加载，在Java虚拟机的堆区会生成一个新的代表Sample类的Class实例(可以通过哈希码查看是否是同一个实例)\n类卸载在实际生产的情况 启动类加载器加载的类型在整个运行期间是不可能被卸载的(jvm和jls规范)\n被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到unreachable的可能性极小。\n被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景中(比如：很多时候用户在开发自定义类加载器实例的时候采用缓存的策略以提高系统性能)，被加载的类型在运行期间也是几乎不太可能被卸载的(至少卸载的时间是不确定的)。\n综合以上三点，一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的。同时我们可以看的出来，开发者在开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下，来实现系统中的特定功能。\n方法区的垃圾回收 回收内容：常量池中废弃常量和不在使用的类\nHotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收\n确定不在使用的类必须同时满足下面三个条件\n该类所有的实例都已经被回收。也就是Java堆中不存在该类及其任何派生子类的实例 加载该类的类加载器已经被回收。这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法 Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收\n类的加载器 作用 类加载器是JVM执行类加载机制的前提。\nClassLoader是Java的核心组件，所有的类都是通过ClassLoader来进行加载的，通过各种方式将class二进制信息数据流读入JVM内部，转换为一个与目标类对应的java.lang.class对象实例，然后交给Java虚拟机进行链接、初始化操作。 ClassLoader在整个装载阶段，只能影响到类的加载，而无法通过其改变类的链接、初始化过程。是否可以加载是由Execution Engine决定的\n显式加载与隐式加载 显式加载 指的是在代码中通过ClassLoader加载class\nClass.forName(name) this.getClass().getClassLoader().loadClass() 隐式加载 通过虚拟机自动加载到内存中，例如：加载一个class文件的时候，class文件中引用到了另一个class，则会进行隐式加载\n类加载机制的必要性 一般情况下，Java开发人员并不需要在程序中显式地使用类加载器，但是了解类加载器的加载机制却显得至关重要。从以下几个方面说：\n避免在开发中遇到 java.lang.ClassNotFoundException异常或java.lang.NoClassDefFoundError异常时，手足无措。只有了解类加载器的加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解决问题\n需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作时，就需要与类加载器打交道了。\n开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑。\n加载的类是否唯一 类的唯一性 对于任意一个类，都是由其类加载器和这个类本身一同确认是否在Java虚拟机的唯一性。每一个加载器都有独立类名称空间，比较两个类是否相等，只有在两个类是由同一个类加载器加载的前提下才有意义，否则，类加载器不相同的时候，这个两个类必不相等\n命名空间 每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成 在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类 在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类 在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本\n类加载机制的基本特征 双亲委派模型：不是所有的类都遵守这个模型，有的时候，引导类加载器需要去加载用户代码，比如JDK内部的ServiceProvider/ServiceLoader机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。例如，Java 中JNDI、JDBC、文件系统、Cipher等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器 可见性： 子类加载器可以访问父加载器加载的类型。但是，反过来不允许，如果允许的话，不能通过利用类的加载器机制实现容器的逻辑 唯一性：由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见。 类加载器的分类 其实分为两类：\n引导类加载器（Bootstrap ClassLoader): c/c++编写\n自定义类加载器（Use-Defined ClassLoader) ： java编写\n自定义类加载器的定义：从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。\n子父类加载器的关系 除了顶层的启动类加载器，其余的类加载器都有其自己的父类加载器 不同类加载器看似是继承关系，实际是包含关系，每个子类加载器包含父类加载器的引用 引导类加载器 - Bootstrap ClassLoader 这个类加载使用C/C++语言实现的，嵌套在JVM内部。 它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar或sun.boot.class.path路径下的内容）。用于提供JVM自身需要类。 并不继承自java.lang.ClassLoader，没有父加载器。 出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类 加载扩展类和应用程序类加载器，并指定为他们的父类加载器。 扩展类加载器-Extension ClassLoader Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。 继承于ClassLoader类 父类加载器为启动类加载器 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。 使用-XX:+TraceClassLoading参数得到\n应用程序类加载器【系统类加载器】-AppClassLoader java语言编写，由sun.misc.Launcher$AppClassLoader实现 继承于ClassLoader类 父类加载器为扩展类加载器 它负责加载环境变量classpath或系统属性 java.class.path 指定路径下的类库 应用程序中的类加载器默认是系统类加载器。 它是用户自定义类加载器的默认父加载器 通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器 用户自定义类加载器 在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式。 体现Java语言强大生命力和巨大魅力的关键因素之一便是,Java开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的JAR包，也可以是网络上的远程资源。 通过类加载器可以实现非常绝妙的插件机制，这方面的实际应用案例举不胜举。例如，著名的OSGI组件框架，再如Eclipse的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。 同时，自定义加载器能够实现应用隔离，例如 Tomcat，Spring等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C/C++程序要好太多，想不修改C/C++程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。 所有用户自定义类加载器通常需要继承于抽象类java.lang.ClassLoader。 说明：\n站在程序的角度看，引导类加载器与另外两种类加载器（系统类加载器和扩展类加载器）并不是同一个层次意义上的加载器，引导类加载器是使用C++语言编写而成的，而另外两种类加载器则是使用Java语言编写而成的。由于引导类加载器压根儿就不是一个Java类，因此在Java程序中只能打印出空值\n获取类加载器的方式 /** * @author Alfred.Ning * @since 2023年02月27日 16:55:00 */ public class Test01 { public static void main(String[] args) { // 获取系统类加载器 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); System.out.println(systemClassLoader); // 获取扩展类加载器 ClassLoader extClassLoader = systemClassLoader.getParent(); System.out.println(extClassLoader); // 试图获取类的引导器加载器 失败 ClassLoader bootStrapClassLoader = extClassLoader.getParent(); System.out.println(bootStrapClassLoader); try { ClassLoader classLoader = Class.forName(\u0026#34;java.lang.String\u0026#34;).getClassLoader(); System.out.println(classLoader); ClassLoader classLoader1 = Class.forName(\u0026#34;Test01\u0026#34;).getClassLoader(); System.out.println(classLoader1); // 关于数组的类型加载器与数组元素的类加载相同 String[] arrStr = new String[10]; System.out.println(arrStr.getClass().getClassLoader()); // null: 引导类加载器 Test01[] arrUserDefined = new Test01[10]; System.out.println(arrUserDefined.getClass().getClassLoader());// 系统加载器 int[] arrInt = new int[10]; System.out.println(arrInt.getClass().getClassLoader());// 引导类加载器 // 获取上下文类的加载器 System.out.println(Thread.currentThread().getContextClassLoader()); } catch (ClassNotFoundException e) { e.printStackTrace(); } } } 自定义类加载器 应用场景 常见的应用场景\n实现类似进程内隔离，类加载器实际上用作不同的命名空间，以提供类似容器、模块化的效果。例如，两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰。这个方面的集大成者是Java EE和OSGI、JPMS等框架。\n应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统。或者是需要自己操纵字节码，动态修改或者生成类型。\n注意： 在一般情况下，使用不同的类加载器去加载不同的功能模块，会提高应用程序的安全性。但是，如果涉及Java类型转换，则加载器反而容易产生不美好的事情。在做Java类型转换时，只有两个类型都是由同一个加载器所加载，才能进行类型转换，否则转换时会发生异常。\n代码实现 覆写findClass方式 import java.io.BufferedInputStream; import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.IOException; /** * @author Alfred.Ning * @since 2023年02月27日 17:39:00 */ public class MyClassLoader extends ClassLoader { private String rootPath; public MyClassLoader(String rootPath) { this.rootPath = rootPath; } @Override protected Class\u0026lt;?\u0026gt; findClass(String name) throws ClassNotFoundException { String filePath = classToFilePath(name); byte[] data = getBytesFromPath(filePath); // 自定义classLoader 内部调用defineClass return defineClass(name, data, 0, data.length); } private byte[] getBytesFromPath(String filePath) { try (FileInputStream fis = new FileInputStream(filePath); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ) { byte[] buffer = new byte[1024]; int len; while ((len = fis.read(buffer)) != -1) { baos.write(buffer, 0, len); } return baos.toByteArray(); } catch (IOException e) { e.printStackTrace(); } return null; } private String classToFilePath(String name) { return rootPath + \u0026#34;\\\\\u0026#34; + name.replace(\u0026#34;.\u0026#34;, \u0026#34;\\\\\u0026#34;) + \u0026#34;.class\u0026#34;; } public static void main(String[] args) throws ClassNotFoundException { MyClassLoader myClassLoader = new MyClassLoader( \u0026#34;D:\\\\java_arch\\\\java_project\\\\test\\\\target\\\\classes\u0026#34;); Class\u0026lt;?\u0026gt; aClass = myClassLoader.findClass(\u0026#34;Test01\u0026#34;); System.out.println(aClass); MyClassLoader myClassLoader2 = new MyClassLoader( \u0026#34;D:\\\\java_arch\\\\java_project\\\\test\\\\target\\\\classes\u0026#34;); Class\u0026lt;?\u0026gt; bClass = myClassLoader2.findClass(\u0026#34;Test01\u0026#34;); System.out.println(bClass); System.out.println(aClass == bClass); //实现类隔离 System.out.println(aClass.getClassLoader()); System.out.println(aClass.getClassLoader().getParent()); } } 覆写loadClass方法 loadClass()也会调用findClass()，但是从逻辑上讲我们最好不要直接修改loadClass()的内部逻辑。建议的做法是只在findClass()里重写自定义类的加载方法，根据参数指定类的名字，返回对应的Class对象的引用\n双亲委派机制 定义 如果一个类加载器在收到加载类的请求时候，首先不会尝试自己去加载这个类，而是将这个请求任务委托给自己的父类加载器去完成，依次递归。如果父类加载器完成不了，才自己去加载\n本质 规定了类的加载顺序：引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会有系统类加载器或自定义的类加载器进行加载\n证明 源码分析 双亲委派机制在java.lang.ClassLoader.loadClass(String,boolean)接口中体现。该接口的逻辑如下： 先在当前加载器的缓存中查找有无目标类，如果有，直接返回 判断当前加载器的父加载器是否为空，如果不为空，则调用parent.loadClass(name, false)接口进行加载。 反之，如果当前加载器的父类加载器为空，则调用findBootstrapClassOrNull(name)接口，让引导类加载器进行加载。 如果通过以上3条路径都没能成功加载，则调用findClass(name)接口进行加载。该接口最终会调用java.lang.ClassLoader接口的defineClass系列的native接口加载目标Java类。 双亲委派的模型就隐藏在这第2和第3步中。\n2.举例\n假设当前加载的是java.lang.Object这个类，很显然，该类属于JDK中核心得不能再核心的一个类，因此一定只能由引导类加载器进行加载。当JVM准备加载javaJang.Object时，JVM默认会使用系统类加载器去加载，按照上面4步加载的逻辑，在第1步从系统类的缓存中肯定查找不到该类，于是进入第2步。由于从系统类加载器的父加载器是扩展类加载器，于是扩展类加载器继续从第1步开始重复。由于扩展类加载器的缓存中也一定査找不到该类，因此进入第2步。扩展类的父加载器是null,因此系统调用findClass(String), 最终通过引导类加载器进行加载。\n打破双亲委派机制 双亲委派机制坏坏1 双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。\n在Java的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况。\n第一次破坏双亲委派机制：\n双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK 1.2面世以前的“远古”时代。\n由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对已经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协，为了兼容这些已有代码，无法再以技术手段避免loadClass()被子类覆盖的可能性，只能在JDK1.2之后的java.lang.ClassLoader中添加一个新的protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码。上节我们已经分析过loadClass()方法，双亲委派的具体逻辑就实现在这里面，按照loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。\n双亲委派机制坏坏2: 线程上下文类加载器 双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（越基础的类由越上层的加载器进行加载），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，如果有基础类型又要调用回用户的代码，那该怎么办呢？\n这并非是不可能出现的事情，一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar的），肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码，现在问题来了，启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？（SPI:在Java平台中，通常把核心类rt.jar中提供外部服务、可由应用层自行实现的接口称为SPI）\n为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。\n有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，但也是无可奈何的事情。Java中涉及SPI的加载基本上都采用这种方式来完成，例如JNDI、JDBC、JCE、JAXB和JBI等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK 6时，JDK提供了java.util.ServiceLoader类，以META-INF/services中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案。\n默认上下文加载器就是应用类加载器，这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类。\n双亲委派机制坏坏3 第三次破坏双亲委派机制：\n双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。如：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等\nIBM公司主导的JSR-291（即OSGi R4.2）实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。\n当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：\n*1）将以java.开头的类，委派给父类加载器加载。\n2）否则，将委派列表名单内的类，委派给父类加载器加载。\n3）否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。\n4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。\n5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。\n6）否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。\n7）否则，类查找失败。\n说明：只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的\n热替换的实现 热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为**。热替换的关键需求在于服务不能中断，修改必须立即表现正在运行的系统之中**。基本上大部分脚本语言都是天生支持热替换的，比如：PHP，只要替换了PHP源文件，这种改动就会立即生效，而无需重启Web服务器。\n但对Java来说，热替换并非天生就支持，如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加载并重定义这个类。因此，在Java中实现这一功能的一个可行的方法就是灵活运用ClassLoader。\n注意：由不同ClassLoader加载的同名类属于不同的类型，不能相互转换和兼容。即两个不同的ClassLoader加载同一个类，在虚拟机内部，会认为这2个类是完全不同的 TOMCAT类加载机制 Tomcat8 和 Tomcat6比较大的区别是 ：Tomcat8可以通过配置 表示遵循双亲委派机制。\n当应用需要某个类时候，会按照下面的顺序进行加载\n使用bootstrap引导类加载器加载 使用system类加载器加载 使用应用类加载器在WEB-INF/classes中加载 使用应用类加载器在WEB-INF/lib中加载 使用common类加载器CATALINA_HOME/lib中加载 五个问题 1、既然 Tomcat 不遵循双亲委派机制，那么如果我自己定义一个恶意的HashMap，会不会有风险呢？(阿里面试问题)\n答： 显然不会有风险，如果有，Tomcat都运行这么多年了，那能不改进吗？\ntomcat不遵循双亲委派机制，只是自定义的classLoader顺序不同，但顶层还是相同的，还是要去顶层请求classloader。\n2、我们思考一下：Tomcat是个web容器， 那么它要解决什么问题？\n一个web容器可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。\n部署在同一个web容器中相同的类库相同的版本可以共享。否则，如果服务器有10个应用程序，那么要有10份相同的类库加载进虚拟机，这是扯淡的。\nweb容器也有自己依赖的类库，不能于应用程序的类库混淆。基于安全考虑，应该让容器的类库和程序的类库隔离开来。\n4、web容器要支持jsp的修改，我们知道，jsp 文件最终也是要编译成class文件才能在虚拟机中运行，但程序运行后修改jsp已经是司空见惯的事情，否则要你何用？ 所以，web容器需要支持 jsp 修改后不用重启。\n3、Tomcat 如果使用默认的类加载机制行不行？\n答案是不行的。为什么？我们看:\n第一个问题，如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的累加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。\n第二个问题，默认的类加载器是能够实现的，因为他的职责就是保证唯一性。\n第三个问题和第一个问题一样。\n我们再看第四个问题，我们想我们要怎么实现jsp文件的热替换，jsp 文件其实也就是class文件，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的，修改后的jsp是不会重新加载的。那么怎么办呢？我们可以直接卸载掉这jsp文件的类加载器，所以你应该想到了，每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载器。重新创建类加载器，重新加载jsp文件。\n4、如果tomcat 的 Common ClassLoader 想加载 WebApp ClassLoader 中的类，该怎么办？\n看了前面的关于破坏双亲委派模型的内容，我们心里有数了，我们可以使用线程上下文类加载器实现，使用线程上下文加载器，可以让父类加载器请求子类加载器去完成类加载的动作。\n5、为什么java文件放在Eclipse/IDEA中的src文件夹下会优先jar包中的class?\ntomcat类加载机制的理解，就不难明白。因为Eclipse/IDEA中的src文件夹中的文件java以及webContent中的JSP都会在tomcat启动时，被编译成class文件放在 WEB-INF/class 中。\n而Eclipse/IDEA外部引用的jar包，则相当于放在 WEB-INF/lib 中。\n因此肯定是 java文件或者JSP文件编译出的class优先加载。\n沙箱安全机制 保护程序安全 保护原生的JDK代码 Java安全模型的核心就是Java沙箱（sandbox）。什么是沙箱？沙箱是一个限制程序运行的环境。\n沙箱机制就是将Java代码限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源访问。通过这样的措施来保证对代码的有限隔离，防止对本地系统造成破坏。\n沙箱主要限制系统资源访问，例如：CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。\n所有的Java程序运行都可以指定沙箱，可以定制安全策略。\njdk9中类加载结构的新变化 为了保证兼容性，JDK 9没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。\n扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器（platform class loader）。可以通过ClassLoader的新方法getPlatformClassLoader()来获取。 JDK 9 时基于模块化进行构建（原来的 rt.jar 和 tools.jar 被拆分成数十个 JMOD 文件），其中的 Java 类库就已天然地满足了可扩展的需求，那自然无须再保留 \\lib\\ext 目录，此前使用这个目录或者 java.ext.dirs 系统变量来扩展 JDK 功能的机制已经没有继续存在的价值了。\n平台类加载器和应用程序类加载器都不再继承自 java.net.URLClassLoader。 现在启动类加载器、平台类加载器、应用程序类加载器全都继承于 jdk.internal.loader.BuiltinClassLoader。\n如果有程序直接依赖了这种继承关系，或者依赖了 URLClassLoader 类的特定方法，那代码很可能会在 JDK 9 及更高版本的 JDK 中崩溃。\n在Java 9中，类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器的名称在调试与类加载器相关的问题时会非常有用。\n启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器（以前是 C++实现），但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例。\n类加载的委派关系也发生了变动。\n当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。\n","permalink":"https://AlfredNing.github.io/note/program/jvm/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/","summary":"类的加载过程 Java数据类型分为数据基本数据类型和引用数据类型\n基本类型由虚拟机预先定义，引用类型需要进行类的加载\n类的加载大过程分为三步, 总过程七步\n装载 将java的class文件加载到机器内存，并在内存中构建出Java类的原型-类模板对象\n查找类的二进制文件，生成class实例\n加载类，需要完成以下三件事情：\n通过类的全名，获取类的二进制数据流 解析类的二进制数据流转换为方法区的数据结构(Java类模型) 创建java.lang.class类的实例，表示该类型 类模板对象 Java类在内存中的一个快照，JVM从字节码文件解析出来的常量池、类字段、类方法等类信息存储到类模板中。在运行期通过类模板获取Java类的任意信息，能够对Java类的成员变量进行遍历，进行方法调用。反射机制也是基于此，如果没有存储Java类的声明信息，JVM在运行期也无法进行反射\n获取二进制数据流 class字节码文件符号JVM规范\n通过读取class后缀的文件 读入jar、zip等归档数据包，提取类文件(热部署jar包原理基础) 事先存放在数据库的二进制数据 使用类型Http之类的协议通过网络进行加载 在运行时生成一段class的二进制信息等 class实例位置 类将.class文件加载至元空间后，会在堆中创建一个Java.lang.Class对象，用来封装类位于方法区内的数据结构，该Class对象是在加载类的过程中创建的，每个类都对应有一个Class类型的对象 数组类的加载 数组类本身不是由类加载器负责创建，而是由JVM在运行时根据需要去创建。加载器只负责加载数据元素的数据类型(基本数据类型和引用数据类型)，申请内存分配长度\n链接 验证阶段 保证加载的字节码是合法、合理并符合jvm规范\n格式验证回合装载阶段一起执行。验证通过之后，类加载器才会把验证成功的二级制数据信息加载到方法区中 格式验证之外的验证操作都在方法区中进行 准备阶段 为类的静态变量分配内存，并将其初始化为默认值。\nJava并不支持boolean类型，对于boolean类型，内部实现是int,由于int的默认值是0,故对应的，boolean的默认值就是false\n解析阶段 将类、接口、自动和方法的符号引用转换为直接应用\n符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。比较容易理解的就是在Class类文件中，通过常量池进行了大量的符号引用。通过解析操作，符号引用就可以转化为目标方法在类中方法表的位置，从而使得方法被成功调用。\n解析就是将符号引用转换为直接引用。换言之，直接引用存在，一定存在符号引用，反之不然\nJava虚拟机规范并没有要求解析操作一定要按照顺序执行\n在HotSpot VM中，加载、验证、准备和初始化会按照顺序有条不紊地执行，但链接阶段中的解析操作往往会伴随着JVM在执行完初始化之后再执行\n初始化 为静态变量赋予正确的初始值\n开始执行java字节码，执行类的初始化方法\nclinit方法：该方法只能由JVM编译器生成，程序开发者无法自定义一个同名的方法，无法在java程序中调用该方法，该方法由java字节码组成 init方法：由类的静态成员变量赋值及其static语句块产生 clinit方法的生成 以下几种情况，不会生产clinit方法\n一个类中没有声明任何类变量，也没静态代码块 一个类中声明类变量，但没有明确使用类的初始化语句以及静态代码块进行初始化操作 一个类中包含static final 修饰的基本类型字段，这些类字段使用编译时常量表达式 clinit是由虚拟机保证在多线程环境下正确的加锁同步，是线程安全的。如果有很长的耗时操作，是会造成死锁的。\n类的加载 加载 = 装载 + 链接 + 初始化\nJava程序的主动使用\n主动使用的说明 Class只有在必须要首次使用的时候才会被装载，Java虚拟机不会无条件地装载Class类型。Java虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用。\n主动使用只有下列几种情况：（即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成。）\n当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化。\n当调用类的静态方法时，即当使用了字节码invokestatic指令。\n当使用类、接口的静态字段时(final修饰特殊考虑)，比如，使用getstatic或者putstatic指令。\n当使用java.lang.reflect包中的方法反射类的方法时。比如：Class.forName(\u0026ldquo;com.atguigu.java.Test\u0026rdquo;)\n当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。","title":"类的加载"},{"content":"新特性 lambda表达式 方法引用 函数接口 流式处理 新日期时间API Optional类 新工具、JavaScript执行引擎 javaFx 函数编程 lambda表达式 想要在代码块以后某个时间点执行 可以转换为函数式接口 闭包作用域中有效访问final变量 任何一个lambda表达式都可以转换为所使用API中对应的函数式接口，注意：lambda表达式转换为函数式接口时候，注意检查期异常 不允许声明一个与局部变量同名的参数或者局部变量 lambda使用this,创建该lambda表达式方法的参数 组成 可选的类型声明 可选的参数小括号 可选的大括号 可选的返回值【只有一句表达式可以省略】 功能 内联功能的实现\n注意 变量引用不可变，实际内容可变\n函数接口 只包含一个抽象方法的接口，可以通过lambda表达式创建该接口的对象\n方法引用 方法引用用其名称指向方法\n引用符号:: 指向方法\n对象::实例方法 类:: 静态方法 类::实例方法（第一个参数会成为执行方法的对象) 构造器引用 类::new\njava中无法构造一个泛型类型T的数组，但可以通过数组引用解决。\n例如：stream.toArray(Class::new)\n默认方法 类优先原则\n接口中有一个默认方法，一个类也有同名的方法。另一个类继承了父类，实现了该接口。这种情况下，只有父类的方法会起作用。 出于兼容性，这样在接口中添加方法，不会对以前的编写的代码产生影响。不能对Object的方法定义默认方法\n静态方法 为接口添加静态方法\nStream API 原则：做什么，而不是怎么做\nStream不会自己存储元素。元素可能被存储在底层的集合当中，或者根据需要产生出来 Stream操作符不会改变源对象的。相反，他们会返回一个持有结果的新Stream Stream操作符可能是延迟执行的。意味着他们等到需要结果的时候才执行 Stream使用三阶段 创建Stream 中间操作 终止操作产生结果 创建Stream Stream.of() Arrays.Stream 可选长度参数\n空Stream: Stream.Empty()\nStream.generate(Supplier func);\nStream.iterate(seed, operator)\nPattern类的splitAsStream\nFiles.lines(path) : 记得使用try-with-resources语句\n中间操作 注意null对象\nfilter map flatMap filter 过滤操作，满足true的保留\n参数：Predicate对象\nT =\u0026gt; Boolean函数\nmap 对流中的每一个元素进行应用一个函数，将返回的值收集到一个新流当中\nflatMap 多流展开流\nflatMap属于计算机科学中的一个基本概念。假设有一个G(例如Stream)和两个函数，从T到G(U)的f函数和从U到G(U)的g方法。通过flatMap,先应用f函数，再应用g函数。\n提取子流和组合流 limit 裁剪指定长度的流\nskip 丢弃前面的n个元素\nStream.concat 将两个流连接起来\npeek 产生与另一个原始具有相同元素的流，每次提取元素的时候，都会调用一个函数\n有状态的转换 distinct 必须记住之前已经读取的元素\nsorted 遍历整个流，进行排序\nCollection.sort方法对原有的集合进行排序，而Stream.sorted方法会返回一个新的已排序的流\n终止操作 聚合方法 count max min findFirst findAny:找到第一个出现的元素就结束 anyMatch:是否有匹配的元素 allMatch: 所有元素匹配，并行执行提高速度 noneMatch: 所有元素不进行匹配，并行执行提高速度 reduce forEach: 保证传入函数并发执行\nforEachOrdered： 按照流的顺序执行访问\n注意返回值Optional\nOptional类型 使用一个或者接受正确值，或者返回另一个替代值的方法\nifPresent 接受一个函数，存在可选值，将值传递给函数。不会返回任何值，如果希望操作，调用map方法\norElse 不存在值产生一个替代值\norElseGet 计算默认值\norElseThrow 没有值的时候抛出异常\n创建可选值 Optional.of\nOptional.empty\nOptiona.ofNullable 对象不为空，返回Optional.of,否则返回Optional.empty()\n使用flatmap组合可选值函数 一个方法f返回Optional， 目标类型有一个返回Optional的方法g, 调用s.f().g()不能操作，如果s.f()存在执行g()。多次调用flatMap实现\n收集结果 收集到集合 iterator\ntoArray\ncollect 使用Collectiors类\n一个能创建目标类型的实例方法 一个元素添加到目标中的方法 一个将两个对象整合到一起的方法 public static void main(String[] args) { Stream\u0026lt;Integer\u0026gt; stream = Stream.iterate(10, v -\u0026gt; v + 1).limit(20); stream.forEach(System.out::println); // toList List\u0026lt;Integer\u0026gt; list = stream.collect(Collectors.toList()); Set\u0026lt;Integer\u0026gt; set1 = stream.collect(Collectors.toSet()); // 排序的set TreeSet\u0026lt;Integer\u0026gt; treeSet = stream.collect(Collectors.toCollection(TreeSet::new)); // 字符串拼接 String str = stream.map(Object::toString).collect(Collectors.joining(\u0026#34;; \u0026#34;)); // 总和 平均值 最大值 最小值summarizing类型 DoubleSummaryStatistics summaryStatistics = stream.collect( Collectors.summarizingDouble(Integer::intValue)); summaryStatistics.getAverage(); summaryStatistics.getCount(); summaryStatistics.getSum(); // ....... } 收集到map Collectors.toMap(键函数，值函数，键冲突函数)\nFunction.identity(). 实际的元素\n如果多个元素拥有相同的键，抛出IllegalStateException异常。传入键冲突函数。返回已有值，新值、两者都返回\n如果希望返回TreeMap，传入第四个函数。\n对于toMap的方法都有对应toConcurentMap方法\n分组和切片 groupingBy partitioningBy partitioningBy 效率大于groupingBy\n传入第二个参数设置downStream\ncounting summingXXX maxBy minBy 原始类型流 IntStream =\u0026gt; short char byte boolean int\nDoubleStream =\u0026gt; float double\n并行流 默认情况下，流操作是创建一个串行流。Collection.parallelStream()方法除外。\nparallel方法可以将任意的串行流转换为一个并行流\n确保传递给并行流的函数都是线程安全的\n日期时间 瞬时时间-Instant 时间间隔-Duration toNacos toMillis toSeconds toMinuters toHours toDays 本地日期 本地日期/时间\nLocalDate 年月日日期\n时段：Period\n日期矫正器：TemporalAdjusters\n本地时间：LocalTime\n本地日期和时间：LocalDateTime\n带时区的时间\n获取所有时区：ZoneId.getAvailableZoneIds() 返回时区：Zone.id(id) 日期转带有时区的：local.atZone(); 带有偏移量的时间：OffsetDateTime 格式化和解析 预定义的标准格式 String format = DateTimeFormatter.ISO_DATE.format(LocalDateTime.now()); System.out.println(format); 语言相关的格式化风格 String format1 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG) .format(ZonedDateTime.now()); System.out.println(format1); // 更改语言环境使用withLocale方法 自定义格式 DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\u0026#34;yyy-MM-dd HH:mm:ss\u0026#34;); System.out.println(formatter.format(LocalDateTime.now())); 与之前日期时间的交互 Instant类似java.util.Date类\njava.util.Date增加了两个方法：toInstant 和format方法\n其他增强内容 字符串 多个字符串组合起来，String.join\n数字类 Short/Integer/Long/Float/Double提供了静态方法sum/max/min,用来流操作中作为聚合函数使用\nBoolean提供logicalAnd / logicalAndor / logicalXor\nInterger支持无符号运算\nByte Short新增toUnsignedInt方法\nByte Short Integer 新增了toUnsignedLong 方法\nFloat Double 新增isFinite\nBigInteger新增实例方法（long|int|short|byte)ValueExtract，返回基本类型，不在目标范围时返回ArithmeticException\n新的数学函数 算术计算：(add | subtract | multiply | increment | decrement | negate)Extract\n将long值转换为等价的Int值： toIntExtract\n整数余数问题：floorMod floorDiv\n集合 Collection接口加入removeIf\nList接口 加入replaceAll ， sort方法\nIterator接口forEachRemaining：将剩余元素传递给一个函数\n比较器\ncomparing/thenComparing\n键函数返回null, 使用nullFirst或者nullLast\nCollections\ncheckQueue emptySorted() 文件 读取文件行的流\nFiles.lines : 默认UTF-8 , 配合使用try-with-resources\n遍历目录项 Files.list : 不会进入子目录\nFiles.walk: 会进入子目录，可以限制深度\nBase64编码 null检查 Objects.isNull 和nonNull 配合流使用\n正则表达式 引用命名捕获组\n语言环境 Locale.getAvailableLocales()\njdbc java.sql包下的Date/Time/TimeStamp提供方法和本地日期时间进行转化\nStatement类新增executeLargeUpdate方法\njava7的一些特性 try-with-resources： 前提实现AutoCloseable接口 忽略异常：ex.addSuppressed(exception) 捕获多个异常 反射异常：ReflectiveOperationException 使用文件 使用Path类 使用Files类 使用Objects equals方法 hash方法 URLClassLoader BitSet构造增强、java8可以通过BitSet返回IntStream 未补充\nJavaFX java8的并发增强 ","permalink":"https://AlfredNing.github.io/note/program/java8/java8/","summary":"新特性 lambda表达式 方法引用 函数接口 流式处理 新日期时间API Optional类 新工具、JavaScript执行引擎 javaFx 函数编程 lambda表达式 想要在代码块以后某个时间点执行 可以转换为函数式接口 闭包作用域中有效访问final变量 任何一个lambda表达式都可以转换为所使用API中对应的函数式接口，注意：lambda表达式转换为函数式接口时候，注意检查期异常 不允许声明一个与局部变量同名的参数或者局部变量 lambda使用this,创建该lambda表达式方法的参数 组成 可选的类型声明 可选的参数小括号 可选的大括号 可选的返回值【只有一句表达式可以省略】 功能 内联功能的实现\n注意 变量引用不可变，实际内容可变\n函数接口 只包含一个抽象方法的接口，可以通过lambda表达式创建该接口的对象\n方法引用 方法引用用其名称指向方法\n引用符号:: 指向方法\n对象::实例方法 类:: 静态方法 类::实例方法（第一个参数会成为执行方法的对象) 构造器引用 类::new\njava中无法构造一个泛型类型T的数组，但可以通过数组引用解决。\n例如：stream.toArray(Class::new)\n默认方法 类优先原则\n接口中有一个默认方法，一个类也有同名的方法。另一个类继承了父类，实现了该接口。这种情况下，只有父类的方法会起作用。 出于兼容性，这样在接口中添加方法，不会对以前的编写的代码产生影响。不能对Object的方法定义默认方法\n静态方法 为接口添加静态方法\nStream API 原则：做什么，而不是怎么做\nStream不会自己存储元素。元素可能被存储在底层的集合当中，或者根据需要产生出来 Stream操作符不会改变源对象的。相反，他们会返回一个持有结果的新Stream Stream操作符可能是延迟执行的。意味着他们等到需要结果的时候才执行 Stream使用三阶段 创建Stream 中间操作 终止操作产生结果 创建Stream Stream.of() Arrays.Stream 可选长度参数\n空Stream: Stream.Empty()\nStream.generate(Supplier func);\nStream.iterate(seed, operator)\nPattern类的splitAsStream\nFiles.lines(path) : 记得使用try-with-resources语句","title":"Java8"},{"content":"字节码文件 字节码文件 字节码文件跨平台 JVM实现遵守JVM虚拟机规范，所有JVM的环境都是一样的，所以字节码文件可以在各种虚拟机上执行\n通过Class文件，更多的计算机语言支持Java虚拟机平台。Class文件不仅仅是Java虚拟机的执行入口，更是Java生态圈的核心\n字节码文件内容 源代码经过编译器生成一个字节码文件，字节码文件是一种二进制的文件，内容是JVM的指令，而C/C++由编译器直接生成机器码。随着Java平台的不断发展，在将来，Class文件的内容也一定会做进一步的扩充，但是其基本的格式和结构不会做重大调整\n字节码文件编译器 作用范围 编译器种类 前端编译器\njavac (全量编译器)/Eclipse中的ECJ\tEclipse Compiler for Java （增量编译器） 主要任务：将java源代码转化为符合jvm规范的字节码文件 劣势：前端编译器并不会直接涉及编译优化等方面的技术，而是将这些具体优化细节移交给HotSpot的JIT编译器负责 后端编译器\nAOT(静态提前编译器，Ahead Of Time Compiler)\njdk9引入了AOT编译器(静态提前编译器，Ahead Of Time Compiler)\nJava 9 引入了实验性 AOT 编译工具jaotc。它借助了 Graal 编译器，将所输入的 Java 类文件转换为机器码，并存放至生成的动态共享库之中。\n所谓 AOT 编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而 AOT 编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。\n.java -\u0026gt; .class -\u0026gt; .so\n最大好处：Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢”的不良体验。\n缺点：\n破坏了java“一次编译，到处运行”，必须为每个不同硬件、OS编译对应的发行包。 降低了Java链接过程的动态性，加载的代码在编译期就必须全部已知。 还需要继续优化中，最初只支持Linux x64 java base\n类的class对象 外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类 接口 数组 枚举 注解 基本数据类型 void 字节码指令 Java虚拟机的指令是由一个字节长度、代表着某种特定操作含义的操作码[opcode]以及跟随其后的零至多个代表此操作所需操作数的操作数[operand]组成。虚拟机中许多指令并不包含操作数，只有一个操作码\n字节码相关面试\nidea插件：jclasslib\nimport org.testng.annotations.Test; /** * @author Alfred.Ning * @since 2023年02月20日 20:10:00 */ public class ByteCodeTest { @Test public void test1() { int i = 10; i++; ++i; System.out.println(i); // 10 } @Test public void test2() { int i = 10; i = i++; System.out.println(i); // 10 这里实际10 -\u0026gt; 11 -\u0026gt; 操作数栈覆盖局部变量表 } @Test public void test3() { int i = 10; i = i + (i++) + (++i); // 10 + 10( i =\u0026gt; 11) + 12 System.out.println(i); // 32 } // 包装类对象的缓存 @Test public void test4() { Integer i1 = 10; Integer i2 = 10; System.out.println(i1 == i2); //true 常量池存在 IntegerCache Integer i3 = 128; Integer i4 = 128; System.out.println(i3 == i4); // false Boolean b1 = true; Boolean b2 = true; System.out.println(b1 == b2); // true } /** * String声明的字面量数据都在字符串常量池 jdk 6中字符串常量池在方法区 jdk7之后常量池存放在堆空间 */ @Test public void test5() { String str = new String(\u0026#34;hello\u0026#34;) + new String(\u0026#34;world\u0026#34;); // str.intern(); //结果为true 如果是jdk1.6这里不生效 如果堆空间有的话，常量池直接引用堆空间的 String str1 = \u0026#34;helloworld\u0026#34;; // str.intern(); //改在这里 也是为false intern在常量池的引用改为堆空间的引用 System.out.println(str == str1); // false 堆空间和常量池 } @Test public void test06() { Father father = new Son(); /** * Son.x = 0 * Son.x = 30 * 20 * * * * 初始化父类构造器 指的是Son对象 print被重写 * son构造还没有被调用 所以为0 * son.print 被赋值是30 * x被赋值40 * 打印自己为20 */ System.out.println(father.x); } class Father { int x = 10; public Father() { this.print(); x = 20; } public void print() { System.out.println(\u0026#34;Father.x = \u0026#34; + x); } } class Son extends Father { int x = 30; public Son() { this.print(); x = 40; } public void print() { System.out.println(\u0026#34;Son.x = \u0026#34; + x); } } } class文件解读 解读工具 文本工具，转换成16进制 javap，java自带工具 IDEA插件，jclasslib ByteCode viewer class文件结构 魔数 Class文件版本 常量池 访问标识 类索引、父类索引、接口索引集合 字段表集合 方法表集合 属性表集合 魔数 class文件的标志\n每个 Class 文件开头的4个字节的无符号整数称为魔数（Magic Number） 它的唯一作用是确定这个文件是否为一个能被虚拟机接受的有效合法的Class文件。即：魔数是Class文件的标识符, 魔数值固定为0xCAFEBABE。不会改变。 如果一个Class文件不以0xCAFEBABE开头，虚拟机在进行文件校验的时候就会直接抛出以下错误： Error: A JNI error has occurred, please check your installation and try again Exception in thread \u0026ldquo;main\u0026rdquo; java.lang.ClassFormatError: Incompatible magic value 1885430635 in class file StringTest 使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。 jvm版本向下兼容 不同版本的Java编译器编译的Class文件对应的版本是不一样的。目前，高版本的Java虚拟机可以执行由低版本编译器生成的Class文件,但是低版本的Java虚拟机不能执行由高版本编译器生成的Class文件。否则JVM会抛出java.lang.UnsupportedClassVersionError异常 在实际应用中，由于开发环境和生产环境的不同，可能会导致该问题的发生。因此，需要我们在开发时，特别注意开发编译的JDK版本和生产环境中的JDK版本是否一致 文件版本号 紧接着魔数的 4 个字节存储的是 Class 文件的版本号。同样也是4个字节。第5个和第6个字节所代表的含义就是编译的副版本号minor_version，而第7个和第8个字节就是编译的主版本号major_version。 它们共同构成了class文件的格式版本号。譬如某个 Class 文件的主版本号为 M，副版本号为 m，那么这个Class 文件的格式版本号就确定为 M.m。 Java 的版本号是从45开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1。 虚拟机JDK版本为1.k （k \u0026gt;= 2）时，对应的class文件格式版本号的范围为45.0 - 44+k.0 （含两端）。 常量池 存放所有常量\nClass文件的资源仓库，它是clas文件结构中与其他项目关联最多的数据类型，也是占用class文件空间最大的数据项之一 常量池表项中，用于存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池存放 在版本号之后，紧跟着的是常量池的数量，以及若干个常量池表项。 常量池计数器 由于常量池的数量不固定，时长时短，所以需要放置两个字节来表示常量池容量计数值。 常量池容量计数值（u2类型）：从1开始，表示常量池中有多少项常量。即constant_pool_count=1表示常量池中有0个常量项。 下面demo的值： 其值为0x0016,掐指一算，也就是22。 需要注意的是，这实际上只有21项常量。索引为范围是1-21。为什么呢？ 通常我们写代码时都是从0开始的，但是这里的常量池却是从1开始，因为它把第0项常量空出来了。这是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况可用索引值0来表示。 int[] arr = new int[10]; arr[0]; arr[1]; ar[10 - 1]; 常量池表 constant_pool是一种表结构，以 1 ~ constant_pool_count - 1为索引。表明了后面有多少个常量项。 常量池主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References） 它包含了class文件结构及其子结构中引用的所有字符串常量、类或接口名、字段名和其他常量。常量池中的每一项都具备相同的特征。第1个字节作为类型标记，用于确定该项的格式，这个字节称为tag byte （标记字节、标签字节） 字面量和符号引用 全限定名：类的全限定，包的.替换成/\n简单名称:没有类型和参数修饰的方法或者字段名称\n描述符: 用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示。用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如：\n方法java.lang.String toString()的描述符为() Ljava/lang/String;，\n方法int abc(int[] x, int y)的描述符为([II) I。\n符号引用是用一组符号来描述引用的目标地址，可以是任意形式的字面量。符号引用和虚拟机实现的内存布局无关，引用的目标不一定加载到了内存中。 直接引用：可以是直接执行目标的指针，相对偏移量或者一个能间接定位到目标的句柄。直接引用与虚拟机实现的内存布局相关。 同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了 常量类型和结构 常量池中每一项常量都是一个表，JDK1.7之后共有14种不同的表结构数据。如下表格所示：\n==================================\n总结：\n这14种表（或者常量项结构）的共同点是：表开始的第一位是一个u1类型的标志位（tag），代表当前这个常量项使用的是哪种表结构，即哪种常量类型。\n在常量池列表中，CONSTANT_Utf8_info常量项是一种使用改进过的UTF-8编码格式来存储诸如文字字符串、类或者接口的全限定名、字段或者方法的简单名称以及描述符等常量字符串信息。\n这14种常量项结构还有一个特点是，其中13个常量项占用的字节固定，只有CONSTANT_Utf8_info占用字节不固定，其大小由length决定。为什么呢？因为从常量池存放的内容可知，其存放的是字面量和符号引用，最终这些内容都会是一个字符串，这些字符串的大小是在编写程序时才确定，比如你定义一个类，类名可以取长取短，所以在没编译前，大小不固定，编译后，通过utf-8编码，就可以知道其长度。\n访问标识(access_flag、访问标志、访问标记) 在常量池后，紧跟着访问标记。该标记使用两个字节表示，用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口；是否定义为 public 类型；是否定义为 abstract 类型；如果是类的话，是否被声明为 final 等。各种访问标记如下所示： 类的访问权限通常为 ACC_ 开头的常量。 每一种类型的表示都是通过设置访问标记的32位中的特定位来实现的。比如，若是public final的类，则该标记为ACC_PUBLIC | ACC_FINAL。 使用ACC_SUPER可以让类更准确地定位到父类的方法super.method(),现代编译器都会设置并且使用这个标记。 类索引、父类索引、接口索引 在访问标记后，会指定该类的类别、父类类别以及实现的接口，格式如下： 这三项数据来确定这个类的继承关系。\n类索引用于确定这个类的全限定名\n父类索引用于确定这个类的父类的全限定名。由于 Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object 之外，所有的Java类都有父类，因此除了java.lang.Object 外，所有Java类的父类索引都不为 0。\n接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按 implements 语句（如果这个类本身是一个接口，则应当是 extends 语句）后的接口顺序从左到右排列在接口索引集合中。\n1.this_class（类索引）\n2字节无符号整数，指向常量池的索引。它提供了类的全限定名。this_class的值必须是对常量池表中某项的一个有效索引值。常量池在这个索引处的成员必须为CONSTANT_Class_info类型结构体，该结构体表示这个class文件所定义的类或接口。\n2.super_class （父类索引）\n2字节无符号整数，指向常量池的索引。它提供了当前类的父类的全限定名。如果我们没有继承任何类，其默认继承的是java/lang/Object类。同时，由于Java不支持多继承，所以其父类只有一个。\nsuperclass指向的父类不能是final。\ninterfaces 指向常量池索引集合，它提供了一个符号引用到所有已实现的接口\n由于一个类可以实现多个接口，因此需要以数组形式保存多个接口的索引，表示接口的每个索引也是一个指向常量池的CONSTANT_Class (当然这里就必须是接口，而不是类)。\n3.1 interfaces_count (接口计数器)\ninterfaces_count项的值表示当前类或接口的直接超接口数量。\n3.2 interfaces [] (接口索引集合)\ninterfaces []中每个成员的值必须是对常量池表中某项的有效索引值，它的长度为 interfaces_count。 每个成员 interfaces[i]必须为 CONSTANT_Class_info结构，其中 0 interfaces[0]对应的是源代码中最左边的接口。\n字段表集合 字段计数器 fields_count （字段计数器）\nfields_count的值表示当前class文件fields表的成员个数。使用两个字节来表示。\nfields表中每个成员都是一个field_info结构，用于表示该类或接口所声明的所有类字段或者实例字段，不包括方法内部声明的变量，也不包括从父类或父接口继承的那些字段。\n字段表 fields []（字段表） fields表中的每个成员都必须是一个fields_info结构的数据项，用于表示当前类或接口中某个字段的完整描述。\n一个字段的信息包括如下这些信息。这些信息中，各个修饰符都是布尔值，要么有，要么没有。\n\u0026gt;作用域（public、private、protected修饰符）\n\u0026gt;是实例变量还是类变量（static修饰符）\n\u0026gt;可变性（final）\n\u0026gt;并发可见性（volatile修饰符，是否强制从主内存读写）\n\u0026gt;可否序列化（transient修饰符）\n\u0026gt;字段数据类型（基本数据类型、对象、数组）\n\u0026gt;字段名称\n字段表结构 字段表作为一个表，同样有他自己的结构：\n方法表集合 methods：指向常量池索引集合，它完整描述了每个方法的签名。\n在字节码文件中，每一个method_info项都对应着一个类或者接口中的方法信息。比如方法的访问修饰符(public、private或protected),方法的返回值类型以及方法的参数信息等。\n如果这个方法不是抽象的或者不是native的，那么字节码中会体现出来。\n一方面，methods表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法。另一方面，methods表有可能会出现由编译器自动添加的方法，最典型的便是编译器产生的方法信息(比如：类(接口)初始化方法()和实例初始化方法())。\n使用注意事项：\n在Java语言中，要重载(Overload)一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名之中，因此Java语言里无法仅仅依靠返回值的不同来对一个已有方法进行重载。但在Class文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个class文件中。\n也就是说，尽管Java语法规范并不允许在一个类或者接口中声明多个方法签名相同的方法，但是和Java语法规范相反，字节码文件中却恰恰允许存放多个方法签名相同的方法，唯一的条件就是这些方法之间的返回值不能相同。\n方法计数器 methods_count methods_count的值表示当前class文件methods表的成员个数。使用两个字节来表示。\nmethods 表中每个成员都是一个method_info结构。\n方法表 methods []（方法表） methods表中的每个成员都必须是一个method_info结构，用于表示当前类或接口中某个方法的完整描述。如果某个method_info结构的access_flags项既没有设置 ACC_NATIVE 标志也没有设置ACC_ABSTRACT标志，那么该结构中也应包含实现这个方法所用的Java虚拟机指令。\nmethod_info结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法和类或接口初始化方法\n方法表的结构实际跟字段表是一样的，方法表结构如下：\n属性表集合 方法表集合之后的属性表集合，指的是class文件所携带的辅助信息，比如该 class 文件的源文件的名称。以及任何带有RetentionPolicy.CLASS 或者RetentionPolicy.RUNTIME的注解。这类信息通常被用于Java虚拟机的验证和运行，以及Java程序的调试，一般无须深入了解。\n此外，字段表、方法表都可以有自己的属性表。用于描述某些场景专有的信息。\n属性表集合的限制没有那么严格，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，但Java虚拟机运行时会忽略掉它不认识的属性。\n属性计数器 attributes_count attributes_count的值表示当前class文件属性表的成员个数。属性表中每一项都是一个attribute_info结构。\n属性表 ConstantValue 属性 ConstantValue 属性表示一个常量字段的值。位于 field_info结构的属性表中。 ConstantValue_attribute { u2 attribute_name_index; u4 attribute_length; u2 constantvalue_index;//字段值在常量池中的索引，常量池在该索引处的项给出该属性表示的常量值。（例如，值是long型的，在常量池中便是CONSTANT_Long） } Deprecated 属性 Deprecated 属性是在 JDK 1.1 为了支持注释中的关键词@deprecated 而引入的。 Deprecated_attribute { u2 attribute_name_index; u4 attribute_length; } Code属性 Code属性就是存放方法体里面的代码。但是，并非所有方法表都有Code属性。像接口或者抽象方法，他们没有具体的方法体，因此也就不会有Code属性了。\nInnerClasses 属性 为了方便说明特别定义一个表示类或接口的 Class 格式为 C。如果 C 的常量池中包含某个CONSTANT_Class_info 成员，且这个成员所表示的类或接口不属于任何一个包，那么 C 的ClassFile 结构的属性表中就必须含有对应的 InnerClasses 属性。InnerClasses 属性是在 JDK 1.1 中为了支持内部类和内部接口而引入的,位于 ClassFile结构的属性表。\nLineNumberTable 属性 LineNumberTable 属性是可选变长属性，位于 Code结构的属性表。\nLineNumberTable属性是用来描述Java源码行号与字节码行号之间的对应关系。这个属性可以用来在调试的时候定位代码执行的行数。\nstart_pc,即字节码行号;line_number，即Java源代码行号。 在 Code 属性的属性表中,LineNumberTable 属性可以按照任意顺序出现，此外，多个 LineNumberTable属性可以共同表示一个行号在源文件中表示的内容，即 LineNumberTable 属性不需要与源文件的行一一对应。\nLocalVariableTable 属性 LocalVariableTable 是可选变长属性，位于 Code属性的属性表中。它被调试器用于确定方法在执行过程中局部变量的信息。在 Code 属性的属性表中，LocalVariableTable 属性可以按照任意顺序出现。 Code 属性中的每个局部变量最多只能有一个 LocalVariableTable 属性。\nstart pc + length表示这个变量在字节码中的生命周期起始和结束的偏移位置（this生命周期从头0到结尾）\nindex就是这个变量在局部变量表中的槽位（槽位可复用）\nname就是变量名称\nDescriptor表示局部变量类型描述\nSignature 属性 Signature 属性是可选的定长属性，位于 ClassFile， field_info或 method_info结构的属性表中。在 Java 语言中，任何类、 接口、 初始化方法或成员的泛型签名如果包含了类型变量（ Type Variables） 或参数化类型（ Parameterized Types），则 Signature 属性会为它记录泛型签名信息。\nSourceFile属性 其他属性 Java虚拟机中预定义的属性有20多个\n字节码指令集 操作码 操作数\n在Java虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。例如，iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。\n对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：\ni代表对int类型的数据操作\nl代表long类型的数据操作\ns代表short类型的数据操作\nb代表byte类型的数据操作\nc代表char类型的数据操作\nf代表float类型的数据操作\nd代表double类型的数据操作\n也有一些指令的助记符中没有明确地指明操作类型的字母，如arraylength指令，它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象。\n还有另外一些指令，如无条件跳转指令goto则是与数据类型无关的。\n大部分的指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。编译器会在编译期或运行期将byte和short类型的数据带符号扩展（Sign-Extend）为相应的int类型数据，将boolean和char类型数据零位扩展（Zero-Extend）为相应的int类型数据。与之类似，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。因此，大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的int类型作为运算类型。\nbyte b1 = 12;\nshort s1 = 10;\nint i = b1 + s1;\n指令分类 加载与存储指令 算术指令 类型转换指令 对象的创建与访问指令 方法调用与返回指令 方法嗲用指令 invokevirtual指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），支持多态。这也是Java语言中最常见的方法分派方式。 invokeinterface指令用于调用接口方法，它会在运行时搜索由特定对象所实现的这个接口方法，并找出适合的方法进行调用。 invokespecial指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法（构造器）、私有方法和父类方法。这些方法都是静态类型绑定的，不会在调用时进行动态派发。 invokestatic指令用于调用命名类中的类方法（static方法）。这是静态绑定的。 invokedynamic：调用动态绑定的方法，这个是JDK 1.7后新加入的指令。用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。前面4条调用指令的分派逻辑都固化在 java 虚拟机内部，而 invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。 操作数栈管理指令 控制转移指令 异常处理指令 同步控制指令 一个指令，可以从局部变量表、常量池、堆中对象、方法调用、系统调用中等取得数据，这些数据（可能是值，可能是对象的引用）被压入操作数栈 一个指令，也可以从操作数栈中取出一到多个值（pop多次），完成赋值、加减乘除、方法传参、系统调用等等操作 Java虚拟机中，数据类型可以分为哪几类 基本类型 数值类型 浮点数类型 float double 整数类型 byte short int long float double boolean returnAddress 引用类型 类类型 接口类型 数组类型 java所有基本类型与Java虚拟机基本类型保持一致，但是boolean有区别，java虚拟机认为boolean是基本类型，当编译成为字节码，用int或者byte表示boolean。java虚拟机中，false是由整数0来表示，所有非0整数表示true, boolean使用int替代操作，boolean数组使用byte数组进行访问\nJava虚拟机还有一个只在内部使用的基本类型：returnAddress，Java程序员不能使用这个类型，这个基本类型被用来实现Java程序中的finally子句。该类型是jsr, ret以及jsr_w指令需要使用到的，它的值是JVM指令的操作码的指针。returnAddress类型不是简单意义上的数值，不属于任何一种基本类型，并且它的值是不能被运行中的程序所修改的\n引用类型的值都是对动态创建对象的引用。 类类型值是引用类实例的引用 接口类型对实现了某个接口的实例的引用 数组类型的值是对数组对象的引用 特殊的引用值是null,表示该引用对象没有引用任何值\n基本类型为什么不放在堆中 首先堆、栈特点不一样。堆比栈要大，但是栈比堆得运行速度要快 复杂数据类型放在堆中，是为了不影响栈的效率。而是通过引用的方式去查找。（八大基本类似大小，创建的时候已经确立大小了。三大引用类型无法确定大小） ","permalink":"https://AlfredNing.github.io/note/program/jvm/%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6/","summary":"字节码文件 字节码文件 字节码文件跨平台 JVM实现遵守JVM虚拟机规范，所有JVM的环境都是一样的，所以字节码文件可以在各种虚拟机上执行\n通过Class文件，更多的计算机语言支持Java虚拟机平台。Class文件不仅仅是Java虚拟机的执行入口，更是Java生态圈的核心\n字节码文件内容 源代码经过编译器生成一个字节码文件，字节码文件是一种二进制的文件，内容是JVM的指令，而C/C++由编译器直接生成机器码。随着Java平台的不断发展，在将来，Class文件的内容也一定会做进一步的扩充，但是其基本的格式和结构不会做重大调整\n字节码文件编译器 作用范围 编译器种类 前端编译器\njavac (全量编译器)/Eclipse中的ECJ\tEclipse Compiler for Java （增量编译器） 主要任务：将java源代码转化为符合jvm规范的字节码文件 劣势：前端编译器并不会直接涉及编译优化等方面的技术，而是将这些具体优化细节移交给HotSpot的JIT编译器负责 后端编译器\nAOT(静态提前编译器，Ahead Of Time Compiler)\njdk9引入了AOT编译器(静态提前编译器，Ahead Of Time Compiler)\nJava 9 引入了实验性 AOT 编译工具jaotc。它借助了 Graal 编译器，将所输入的 Java 类文件转换为机器码，并存放至生成的动态共享库之中。\n所谓 AOT 编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而 AOT 编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。\n.java -\u0026gt; .class -\u0026gt; .so\n最大好处：Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢”的不良体验。\n缺点：\n破坏了java“一次编译，到处运行”，必须为每个不同硬件、OS编译对应的发行包。 降低了Java链接过程的动态性，加载的代码在编译期就必须全部已知。 还需要继续优化中，最初只支持Linux x64 java base\n类的class对象 外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类 接口 数组 枚举 注解 基本数据类型 void 字节码指令 Java虚拟机的指令是由一个字节长度、代表着某种特定操作含义的操作码[opcode]以及跟随其后的零至多个代表此操作所需操作数的操作数[operand]组成。虚拟机中许多指令并不包含操作数，只有一个操作码\n字节码相关面试\nidea插件：jclasslib\nimport org.testng.annotations.Test; /** * @author Alfred.","title":"字节码文件"},{"content":"Web的基础 HTTP概述 http使用的是可靠的数据传输协议 组成 web客户端 类似浏览器\nweb服务器： 通常web服务器使用http协议，通常成为http服务器\n资源 Web服务器是Web资源（Web resource）的宿主。Web资源是Web内容的源头。资源并不一定非的是静态文件，根据需要生成的软件程序\nhtml文件 word文件 其它任何格式 媒体类型 MIME类型(MIME TYPE) ： 数据格式标签，最初是用于解决在不同的电子邮件系统中之间搬移报文时候存在的问题，http借鉴了。weu服务器会为所有的http对象数据附近一个MIME类型（Content-Type,Content-Length)\nURI 每一个web服务服务器资源名都有一个名字，被称为统一资源标识符(Uniform Resouce Identifier)，具有两种形式URL、URN\nURL: 统一资源定位符 HTTP 协议 + 地址 + 某个资源\nURN： 统一资源名 URN是作为特定内容的唯一名称使用的，与目前的资源所在地无关\n事务 ","permalink":"https://AlfredNing.github.io/note/book/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/","summary":"Web的基础 HTTP概述 http使用的是可靠的数据传输协议 组成 web客户端 类似浏览器\nweb服务器： 通常web服务器使用http协议，通常成为http服务器\n资源 Web服务器是Web资源（Web resource）的宿主。Web资源是Web内容的源头。资源并不一定非的是静态文件，根据需要生成的软件程序\nhtml文件 word文件 其它任何格式 媒体类型 MIME类型(MIME TYPE) ： 数据格式标签，最初是用于解决在不同的电子邮件系统中之间搬移报文时候存在的问题，http借鉴了。weu服务器会为所有的http对象数据附近一个MIME类型（Content-Type,Content-Length)\nURI 每一个web服务服务器资源名都有一个名字，被称为统一资源标识符(Uniform Resouce Identifier)，具有两种形式URL、URN\nURL: 统一资源定位符 HTTP 协议 + 地址 + 某个资源\nURN： 统一资源名 URN是作为特定内容的唯一名称使用的，与目前的资源所在地无关\n事务 ","title":"HTTP权威指南"},{"content":"JDK关系 Oracle JDK 与 Open JDK 关系\nOracle JDK是由oracle 公司开发的，Open JDK 是由IBM，Apple，SAP AG，Redhat等顶级公司合作开发 Oracle JDK大多数的功能是开源的，一些功能是开源。Open JDK完全开源 Oracle JDK以前的1.0版以前的版本是由Sun开发的，后来被Oracle收购并为其他版本维护，而OpenJDK最初只基于Java SDK或JDK版本7 Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本 Oracle JDK将从其10.0.X版本将收费，用户必须付费或必须依赖OpenJDK才能使用其免费版本 Oracle JDK在运行JDK时不会产生任何问题，而OpenJDK在为某些用户运行JDK时会产生一些问题 在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能 Oracle JDK具有良好的GC选项和更好的渲染器，而OpenJDK具有更少的GC选项，并且由于其包含自己的渲染器的分布，因此具有较慢的图形渲染器选项 Oracle JDK的构建过程基于OpenJDK，因此OpenJDK与Oracle JDK之间没有技术差异 Oracle JDK将更多地关注稳定性，它重视更多的企业级用户，而OpenJDK经常发布以支持其他性能，这可能会导致不稳定 JDK与JVM的关系 JDK: Java Development ToolKit(java开发工具包)。JDK是整个java的核心，包括了运行环境，java工具和java的基础类库。\njvm:Java Virtual Machine(java虚拟机)。通过在实际的计算机上模拟仿真各种计算机功能来实现。\n使用JDK（调用JAVA API）开发JAVA程序后，通过JDK中的编译程序（javac）将Java程序编译为Java字节码，在JRE上运行这些字节码，JVM会解析并映射到真实操作系统的CPU指令集和OS的系统调用\n如何理解java是跨平台的语言 当java的源代码经过编译程序编译成字节码，需要运行在不同的平台上面时，无需编译。\n如何理解JVM是跨语言的平台 jvm面对的是字节码文件，只关心字节码文件，不关心何种编程语言，只要实现jvm规范即可。Java不是最强大的语言，但是JVM是最强大的虚拟机。\nJVM的类型 Sun Classic VM \u0026ndash;\u0026gt;解释型\nExact VM \u0026ndash;\u0026gt; Solaris\nSUN公司的 HotSpot VM\nBEA 的 JRockit \u0026ndash;\u0026gt; 不包含解释器，服务器端，JMC\nIBM 的 J9\nKVM和CDC/CLDC Hotspot\nAzul VM\nLiquid VM\nApache Harmony\nMicrosoft JVM\nTaobaoJVM\nGraal VM \u0026ndash;\u0026gt; 2018年,“Run Programs Faster Anywhere”\nDalvik VM : 安卓系统底层\n其他JVM：\nJava Card VM、Squawk VM、JavaInJava、Maxine VM、Jikes RVM、IKVM.NET、Jam VM、Cacao VM、Sable VM、Kaffe、Jelatine JVM、Nano VM、MRP、Moxie JVM\nJVM的生命周期 启动 java虚拟机的启动是由引导类加载器(bootstrap class loader)创建一个初始类(initial class)来完成的，这个类是由虚拟机指定\n退出 某线程调用Runtime类或System类的exit方法， 或Runtime类的halt方法【仅仅是拥有退出的机会】，并且在JAVA安全管理器允许这次exit或者halt方法操作会进行退出 程序正常执行结束 程序在执行过程中遇到了异常或错误进而终止 由于操作系统错误而导致java虚拟机进程终止 关于HotSpot 目前是java主流的虚拟机。\nsun的JDK版本从1.3.1开始运用HotSpot虚拟机，2006年底开源，主要实现是c++, JNI接口部分用C实现 HotSpot是比较新的虚拟机，使用JIT(Just In Time)编译器，可以大大提高java运行性能 Java原先是把源代码编译成字节码虚拟机执行，速度较慢。HosSpot将常用的部分编译分为本地（原生，native)代码，显著提高性能 HotSpot JVM参数分为规则参数和非规则参数。 规则参数相对稳定，在JDK未来的版本不太会有太大的改动 非规则参数则有升级JDK而改动的可能 JVM的架构（组成） 详细\n最上层：javac编译器将编译好的字节码class文件，通过java类装载器执行机制，把对象的class文件存放在jvm划分区域 中间层：称为Runtime Data Area 主要是Java代码运行时用于存放数据 最下层：解释器，JIT(just in time)编译器和GC(Garbage Collection 垃圾回收器) ","permalink":"https://AlfredNing.github.io/note/program/jvm/jvm%E5%88%9D%E8%AF%86/","summary":"JDK关系 Oracle JDK 与 Open JDK 关系\nOracle JDK是由oracle 公司开发的，Open JDK 是由IBM，Apple，SAP AG，Redhat等顶级公司合作开发 Oracle JDK大多数的功能是开源的，一些功能是开源。Open JDK完全开源 Oracle JDK以前的1.0版以前的版本是由Sun开发的，后来被Oracle收购并为其他版本维护，而OpenJDK最初只基于Java SDK或JDK版本7 Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本 Oracle JDK将从其10.0.X版本将收费，用户必须付费或必须依赖OpenJDK才能使用其免费版本 Oracle JDK在运行JDK时不会产生任何问题，而OpenJDK在为某些用户运行JDK时会产生一些问题 在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能 Oracle JDK具有良好的GC选项和更好的渲染器，而OpenJDK具有更少的GC选项，并且由于其包含自己的渲染器的分布，因此具有较慢的图形渲染器选项 Oracle JDK的构建过程基于OpenJDK，因此OpenJDK与Oracle JDK之间没有技术差异 Oracle JDK将更多地关注稳定性，它重视更多的企业级用户，而OpenJDK经常发布以支持其他性能，这可能会导致不稳定 JDK与JVM的关系 JDK: Java Development ToolKit(java开发工具包)。JDK是整个java的核心，包括了运行环境，java工具和java的基础类库。\njvm:Java Virtual Machine(java虚拟机)。通过在实际的计算机上模拟仿真各种计算机功能来实现。\n使用JDK（调用JAVA API）开发JAVA程序后，通过JDK中的编译程序（javac）将Java程序编译为Java字节码，在JRE上运行这些字节码，JVM会解析并映射到真实操作系统的CPU指令集和OS的系统调用\n如何理解java是跨平台的语言 当java的源代码经过编译程序编译成字节码，需要运行在不同的平台上面时，无需编译。\n如何理解JVM是跨语言的平台 jvm面对的是字节码文件，只关心字节码文件，不关心何种编程语言，只要实现jvm规范即可。Java不是最强大的语言，但是JVM是最强大的虚拟机。\nJVM的类型 Sun Classic VM \u0026ndash;\u0026gt;解释型\nExact VM \u0026ndash;\u0026gt; Solaris\nSUN公司的 HotSpot VM\nBEA 的 JRockit \u0026ndash;\u0026gt; 不包含解释器，服务器端，JMC\nIBM 的 J9\nKVM和CDC/CLDC Hotspot","title":"Jvm初识"},{"content":"指导思想 可维护性：修改功能少，需要改动的地方越少，可维护性越好 可复用性：代码被以后重复使用，写出自己总结的类库 可扩展性：添加功能无需修改原来的代码 灵活性：代码接口可以灵活调用 原则 单一职责原则 SRP 一个类别太大，别太累。负责单一的职责 高内聚，低耦合 开闭原则 OCP 对扩展开放，对修改关闭：尽量不修改原来的代码进行扩展 抽象化，多态是开闭原则的关键 里氏替换原则 LSP 所有使用父类的方法，必须能够透明的使用子类对象 依赖倒置原则 DIP 依赖抽象，而不是依赖具体 面向抽象/接口编程 接口隔离原则 ISP 每一个接口应该承担独立的角色，不干自己不该干的事情 避免子类不需要实现的方法 需要对客户提供接口的时候，只需要暴露最小的接口 迪米特法则 LOD 尽量不要和陌生人说话 在迪米特法则中，对于一个对象，非陌生人包含以下几类 当前对象本身this 以参数形式传入到当前对象方法中的对象 当前对象的成员对象 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友 当前对象所创建的对象 和其它类的耦合度变低 工具类例外 ","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/","summary":"指导思想 可维护性：修改功能少，需要改动的地方越少，可维护性越好 可复用性：代码被以后重复使用，写出自己总结的类库 可扩展性：添加功能无需修改原来的代码 灵活性：代码接口可以灵活调用 原则 单一职责原则 SRP 一个类别太大，别太累。负责单一的职责 高内聚，低耦合 开闭原则 OCP 对扩展开放，对修改关闭：尽量不修改原来的代码进行扩展 抽象化，多态是开闭原则的关键 里氏替换原则 LSP 所有使用父类的方法，必须能够透明的使用子类对象 依赖倒置原则 DIP 依赖抽象，而不是依赖具体 面向抽象/接口编程 接口隔离原则 ISP 每一个接口应该承担独立的角色，不干自己不该干的事情 避免子类不需要实现的方法 需要对客户提供接口的时候，只需要暴露最小的接口 迪米特法则 LOD 尽量不要和陌生人说话 在迪米特法则中，对于一个对象，非陌生人包含以下几类 当前对象本身this 以参数形式传入到当前对象方法中的对象 当前对象的成员对象 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友 当前对象所创建的对象 和其它类的耦合度变低 工具类例外 ","title":"设计原则"},{"content":" 解释器模式是类的行为模式。给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子\n角色 抽象表达式(Expression)角色：声明一个所有的具体表达式角色都需要实现的抽象接口。这个接口主要是一个interpret()方法，称做解释操作 终结符表达式(Terminal Expression)角色：实现了抽象表达式角色所要求的接口 非终结符表达式(Nonterminal Expression)角色：文法中的每一条规则都需要一个具体的非终结符表达式 环境(Context)角色：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值 示例代码\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/","summary":"解释器模式是类的行为模式。给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子\n角色 抽象表达式(Expression)角色：声明一个所有的具体表达式角色都需要实现的抽象接口。这个接口主要是一个interpret()方法，称做解释操作 终结符表达式(Terminal Expression)角色：实现了抽象表达式角色所要求的接口 非终结符表达式(Nonterminal Expression)角色：文法中的每一条规则都需要一个具体的非终结符表达式 环境(Context)角色：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值 示例代码","title":"解释器模式"},{"content":" 状态模式，状态对象行为模式。允许对一个对象在其内部状态改变的时候改变其行为。这个对象看上去就像是改变了它的类一样\n状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变\n角色 环境角色:定义客户端所感兴趣的接口，并且保留一个具体状态类的实例。这个具体状态类的实例给出此环境对象的现有状态 抽象状态(State)角色：定义一个接口，用以封装环境（Context）对象的一个特定的状态所对应的行为 具体状态(ConcreteState)角色：每一个具体状态类都实现了环境（Context）的一个状态所对应的行为 认识状态模式 状态和行为\n所谓对象的状态，通常指的就是对象实例的属性的值；而行为指的就是对象的功能，再具体点说，行为大多可以对应到方法上。\n状态模式的功能就是分离状态的行为，通过维护状态的变化，来调用不同状态对应的不同功能。也就是说，状态和行为是相关联的，它们的关系可以描述为：状态决定行为。\n由于状态是在运行期被改变的，因此行为也会在运行期根据状态的改变而改变。\n行为的平行性\n注意平行线而不是平等性。所谓平行性指的是各个状态的行为所处的层次是一样的，相互独立的、没有关联的，是根据不同的状态来决定到底走平行线的哪一条。行为是不同的，当然对应的实现也是不同的，相互之间是不可替换的。\n策略模式的比较\n状态模式的结构和策略模式的结构完全一样，但是，它们的目的、实现、本质却是完全不一样的。还有行为之间的特性也是状态模式和策略模式一个很重要的区别，状态模式的行为是平行性的，不可相互替换的；而策略模式的行为是平等性的，是可以相互替换的。\n环境和状态处理对象\n在状态模式中，环境(Context)是持有状态的对象，但是环境(Context)自身并不处理跟状态相关的行为，而是把处理状态的功能委托给了状态对应的状态处理类来处理。\n在具体的状态处理类中经常需要获取环境(Context)自身的数据，甚至在必要的时候会回调环境(Context)的方法，因此，通常将环境(Context)自身当作一个参数传递给具体的状态处理类。\n客户端一般只和环境(Context)交互。客户端可以用状态对象来配置一个环境(Context)，一旦配置完毕，就不再需要和状态对象打交道了。客户端通常不负责运行期间状态的维护，也不负责决定后续到底使用哪一个具体的状态处理对象\n示例代码\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/","summary":"状态模式，状态对象行为模式。允许对一个对象在其内部状态改变的时候改变其行为。这个对象看上去就像是改变了它的类一样\n状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变\n角色 环境角色:定义客户端所感兴趣的接口，并且保留一个具体状态类的实例。这个具体状态类的实例给出此环境对象的现有状态 抽象状态(State)角色：定义一个接口，用以封装环境（Context）对象的一个特定的状态所对应的行为 具体状态(ConcreteState)角色：每一个具体状态类都实现了环境（Context）的一个状态所对应的行为 认识状态模式 状态和行为\n所谓对象的状态，通常指的就是对象实例的属性的值；而行为指的就是对象的功能，再具体点说，行为大多可以对应到方法上。\n状态模式的功能就是分离状态的行为，通过维护状态的变化，来调用不同状态对应的不同功能。也就是说，状态和行为是相关联的，它们的关系可以描述为：状态决定行为。\n由于状态是在运行期被改变的，因此行为也会在运行期根据状态的改变而改变。\n行为的平行性\n注意平行线而不是平等性。所谓平行性指的是各个状态的行为所处的层次是一样的，相互独立的、没有关联的，是根据不同的状态来决定到底走平行线的哪一条。行为是不同的，当然对应的实现也是不同的，相互之间是不可替换的。\n策略模式的比较\n状态模式的结构和策略模式的结构完全一样，但是，它们的目的、实现、本质却是完全不一样的。还有行为之间的特性也是状态模式和策略模式一个很重要的区别，状态模式的行为是平行性的，不可相互替换的；而策略模式的行为是平等性的，是可以相互替换的。\n环境和状态处理对象\n在状态模式中，环境(Context)是持有状态的对象，但是环境(Context)自身并不处理跟状态相关的行为，而是把处理状态的功能委托给了状态对应的状态处理类来处理。\n在具体的状态处理类中经常需要获取环境(Context)自身的数据，甚至在必要的时候会回调环境(Context)的方法，因此，通常将环境(Context)自身当作一个参数传递给具体的状态处理类。\n客户端一般只和环境(Context)交互。客户端可以用状态对象来配置一个环境(Context)，一旦配置完毕，就不再需要和状态对象打交道了。客户端通常不负责运行期间状态的维护，也不负责决定后续到底使用哪一个具体的状态处理对象\n示例代码","title":"状态模式"},{"content":" 类的行为模式。使用示例：Servlet的应用\n抽象类：将部分逻辑以具体的方法以及具体的构造函数的形式实现。然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的实现方式实现这些抽象方法，从而对剩余逻辑有不同的实现。\n模板方法所代表的行为称为顶级行为，其逻辑称为顶级逻辑\n角色 抽象模板：顶层逻辑骨架 具体模板：具体实现顶层逻辑 子类可以置换掉父类的可变部分，但是子类却不可以改变模板方法所代表的顶级逻辑\n方法 模板方法：一个抽象类可以有任意多个模板方法，而不限于一个。每一个模板方法都可以调用任意多个具体方法 基本方法： 抽象方法：一个抽象方法由抽象类声明，由具体子类实现 具体方法：一个具体方法由抽象类声明并实现，而子类并不实现或置换 钩子方法：一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个空实现，作为方法的默认实现 示例代码\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","summary":"类的行为模式。使用示例：Servlet的应用\n抽象类：将部分逻辑以具体的方法以及具体的构造函数的形式实现。然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的实现方式实现这些抽象方法，从而对剩余逻辑有不同的实现。\n模板方法所代表的行为称为顶级行为，其逻辑称为顶级逻辑\n角色 抽象模板：顶层逻辑骨架 具体模板：具体实现顶层逻辑 子类可以置换掉父类的可变部分，但是子类却不可以改变模板方法所代表的顶级逻辑\n方法 模板方法：一个抽象类可以有任意多个模板方法，而不限于一个。每一个模板方法都可以调用任意多个具体方法 基本方法： 抽象方法：一个抽象方法由抽象类声明，由具体子类实现 具体方法：一个具体方法由抽象类声明并实现，而子类并不实现或置换 钩子方法：一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个空实现，作为方法的默认实现 示例代码","title":"模板方法模式"},{"content":" 对象的行为模式。又称为快照模式，对象的行为模式。一个用来存储另外一个对象内部状态的快照对象。\n指在不破坏封装的条件下，将一个对象的状态捕捉住，并且外部化，进行存储，从而可以在将来合适的时候把这个对象还原存储起来的状态。备忘录模式常常与命令模式和迭代子模式一同使用\n角色 备忘录角色 备忘录角色又如下责任：\n（1）将发起人（Originator）对象的内战状态存储起来。备忘录可以根据发起人对象的判断来决定存储多少发起人（Originator）对象的内部状态。\n（2）备忘录可以保护其内容不被发起人（Originator）对象之外的任何对象所读取。\n备忘录有两个等效的接口：\n●　**窄接口：**负责人（Caretaker）对象（和其他除发起人对象之外的任何对象）看到的是备忘录的窄接口(narrow interface)，这个窄接口只允许它把备忘录对象传给其他的对象。\n●　**宽接口：**与负责人对象看到的窄接口相反的是，发起人对象可以看到一个宽接口(wide interface)，这个宽接口允许它读取所有的数据，以便根据这些数据恢复这个发起人对象的内部状态。\n发起人角色 发起人角色有如下责任：\n（1）创建一个含有当前的内部状态的备忘录对象。\n（2）使用备忘录对象存储其内部状态。\n负责人角色 负责人角色有如下责任：\n（1）负责保存备忘录对象。\n（2）不检查备忘录对象的内容。\n示例代码\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/","summary":"对象的行为模式。又称为快照模式，对象的行为模式。一个用来存储另外一个对象内部状态的快照对象。\n指在不破坏封装的条件下，将一个对象的状态捕捉住，并且外部化，进行存储，从而可以在将来合适的时候把这个对象还原存储起来的状态。备忘录模式常常与命令模式和迭代子模式一同使用\n角色 备忘录角色 备忘录角色又如下责任：\n（1）将发起人（Originator）对象的内战状态存储起来。备忘录可以根据发起人对象的判断来决定存储多少发起人（Originator）对象的内部状态。\n（2）备忘录可以保护其内容不被发起人（Originator）对象之外的任何对象所读取。\n备忘录有两个等效的接口：\n●　**窄接口：**负责人（Caretaker）对象（和其他除发起人对象之外的任何对象）看到的是备忘录的窄接口(narrow interface)，这个窄接口只允许它把备忘录对象传给其他的对象。\n●　**宽接口：**与负责人对象看到的窄接口相反的是，发起人对象可以看到一个宽接口(wide interface)，这个宽接口允许它读取所有的数据，以便根据这些数据恢复这个发起人对象的内部状态。\n发起人角色 发起人角色有如下责任：\n（1）创建一个含有当前的内部状态的备忘录对象。\n（2）使用备忘录对象存储其内部状态。\n负责人角色 负责人角色有如下责任：\n（1）负责保存备忘录对象。\n（2）不检查备忘录对象的内容。\n示例代码","title":"备忘录模式"},{"content":" 对象的创建模式。通过一个原型对象来指明所有创建的对象的类型，然后复用这个原型对象的方法来创建出更多同类型的对象。\n实现一个自身可以克隆的接口\n分类 简单形式 角色：\n客户角色 抽象原型角色 具体原型角色 登记形式 角色：\n客户角色 抽象原型角色 具体原型角色 原型管理角色 两种形式的比较 简单形式和登记形式的原型模式各有其长处和短处。\n如果需要创建的原型对象数目较少而且比较固定的话，可以采取第一种形式。在这种情况下，原型对象的引用可以由客户端自己保存。\n如果要创建的原型对象数目不固定的话，可以采取第二种形式。在这种情况下，客户端不保存对原型对象的引用，这个任务被交给管理员对象。在复制一个原型对象之前，客户端可以查看管理员对象是否已经有一个满足要求的原型对象。如果有，可以直接从管理员类取得这个对象引用；如果没有，客户端就需要自行复制此原型对象。\nJava中的克隆方法 Java的所有类都是从java.lang.Object类继承而来的，而Object类提供protected Object clone()方法对对象进行复制，子类当然也可以把这个方法置换掉，提供满足自己需要的复制方法。对象的复制有一个基本问题，就是对象通常都有对其他的对象的引用。当使用Object类的clone()方法来复制一个对象时，此对象对其他对象的引用也同时会被复制一份\nJava语言提供的Cloneable接口只起一个作用，就是在运行时期通知Java虚拟机可以安全地在这个类上使用clone()方法。通过调用这个clone()方法可以得到一个对象的复制。由于Object类本身并不实现Cloneable接口，因此如果所考虑的类没有实现Cloneable接口时，调用clone()方法会抛出CloneNotSupportedException异常。\n原型模式的优点 原型模式允许在运行时动态改变具体的实现类型。原型模式可以在运行期间，由客户来注册符合原型接口的实现类型，也可以动态地改变具体的实现类型，看起来接口没有任何变化，但其实运行的已经是另外一个类实例了。因为克隆一个原型就类似于实例化一个类。\n原型模式的缺点 原型模式最主要的缺点是每一个类都必须配备一个克隆方法。配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类来说不是很难，而对于已经有的类不一定很容易，特别是当一个类引用不支持序列化的间接对象，或者引用含有循环结构的时候。\n示例代码\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","summary":"对象的创建模式。通过一个原型对象来指明所有创建的对象的类型，然后复用这个原型对象的方法来创建出更多同类型的对象。\n实现一个自身可以克隆的接口\n分类 简单形式 角色：\n客户角色 抽象原型角色 具体原型角色 登记形式 角色：\n客户角色 抽象原型角色 具体原型角色 原型管理角色 两种形式的比较 简单形式和登记形式的原型模式各有其长处和短处。\n如果需要创建的原型对象数目较少而且比较固定的话，可以采取第一种形式。在这种情况下，原型对象的引用可以由客户端自己保存。\n如果要创建的原型对象数目不固定的话，可以采取第二种形式。在这种情况下，客户端不保存对原型对象的引用，这个任务被交给管理员对象。在复制一个原型对象之前，客户端可以查看管理员对象是否已经有一个满足要求的原型对象。如果有，可以直接从管理员类取得这个对象引用；如果没有，客户端就需要自行复制此原型对象。\nJava中的克隆方法 Java的所有类都是从java.lang.Object类继承而来的，而Object类提供protected Object clone()方法对对象进行复制，子类当然也可以把这个方法置换掉，提供满足自己需要的复制方法。对象的复制有一个基本问题，就是对象通常都有对其他的对象的引用。当使用Object类的clone()方法来复制一个对象时，此对象对其他对象的引用也同时会被复制一份\nJava语言提供的Cloneable接口只起一个作用，就是在运行时期通知Java虚拟机可以安全地在这个类上使用clone()方法。通过调用这个clone()方法可以得到一个对象的复制。由于Object类本身并不实现Cloneable接口，因此如果所考虑的类没有实现Cloneable接口时，调用clone()方法会抛出CloneNotSupportedException异常。\n原型模式的优点 原型模式允许在运行时动态改变具体的实现类型。原型模式可以在运行期间，由客户来注册符合原型接口的实现类型，也可以动态地改变具体的实现类型，看起来接口没有任何变化，但其实运行的已经是另外一个类实例了。因为克隆一个原型就类似于实例化一个类。\n原型模式的缺点 原型模式最主要的缺点是每一个类都必须配备一个克隆方法。配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类来说不是很难，而对于已经有的类不一定很容易，特别是当一个类引用不支持序列化的间接对象，或者引用含有循环结构的时候。\n示例代码","title":"原型模式"},{"content":" 命令模式属于对象的行为模式，又成交易模式或行动模式。　命令模式把一个请求或者操作封装到一个对象中。命令模式允许系统使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能\n角色 命令角色 具体命令角色 请求者角色 接收者角色 客户端角色 优点 更松散的耦合 更动态的控制 很自然的复合命令 更好的扩展性 代码示例\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/","summary":"命令模式属于对象的行为模式，又成交易模式或行动模式。　命令模式把一个请求或者操作封装到一个对象中。命令模式允许系统使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能\n角色 命令角色 具体命令角色 请求者角色 接收者角色 客户端角色 优点 更松散的耦合 更动态的控制 很自然的复合命令 更好的扩展性 代码示例","title":"命令模式"},{"content":" 将抽象部分与实现部分相分离，使他们都可以独立的变化。结构式模式\n角色 实现接口 抽象接口 具体实现 具体抽象实现 应用 具体到实际应用上，需要将抽象与实现分离开来，对客户端无感知的一种行为。\n示例代码\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/","summary":"将抽象部分与实现部分相分离，使他们都可以独立的变化。结构式模式\n角色 实现接口 抽象接口 具体实现 具体抽象实现 应用 具体到实际应用上，需要将抽象与实现分离开来，对客户端无感知的一种行为。\n示例代码","title":"桥接模式"},{"content":" 把一个类的接口变成客户端所期待的另一种接口，从而使原本因接口不匹配而无法完成一起工作的两个类可以一起工作\n结构 类的适配器模式 对象的适配器模式 类的适配器模式 把适配类的API转换成目标API\n角色：\n●　目标(Target)角色：这就是所期待得到的接口。注意：由于这里讨论的是类适配器模式，因此目标不可以是类。\n●　源(Adapee)角色：现在需要适配的接口。\n●　适配器(Adaper)角色：适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。\n对象的适配器模式 类的适配器模式一样，对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类\n类适配器和对象适配器的权衡 ●　类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。\n●　对于类适配器，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静态的关系，当适配器继承了Adaptee后，就不可能再去处理 Adaptee的子类了。\n对于对象适配器，一个适配器可以把多种不同的源适配到同一个目标。换言之，同一个适配器可以把源类和它的子类都适配到目标接口。因为对象适配器采用的是对象组合的关系，只要对象类型正确，是不是子类都无所谓。\n●　对于类适配器，适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。\n对于对象适配器，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。\n●　对于类适配器，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。\n对于对象适配器，需要额外的引用来间接得到Adaptee。\n建议尽量使用对象适配器的实现方式，多用合成/聚合、少用继承。当然，具体问题具体分析，根据需要来选用实现方式，最适合的才是最好的\n优点 复用性 扩展性 缺点 过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构\n代码示例\n缺省适配器模式 抽象类中实现顶层接口的默认实现\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","summary":"把一个类的接口变成客户端所期待的另一种接口，从而使原本因接口不匹配而无法完成一起工作的两个类可以一起工作\n结构 类的适配器模式 对象的适配器模式 类的适配器模式 把适配类的API转换成目标API\n角色：\n●　目标(Target)角色：这就是所期待得到的接口。注意：由于这里讨论的是类适配器模式，因此目标不可以是类。\n●　源(Adapee)角色：现在需要适配的接口。\n●　适配器(Adaper)角色：适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。\n对象的适配器模式 类的适配器模式一样，对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类\n类适配器和对象适配器的权衡 ●　类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。\n●　对于类适配器，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静态的关系，当适配器继承了Adaptee后，就不可能再去处理 Adaptee的子类了。\n对于对象适配器，一个适配器可以把多种不同的源适配到同一个目标。换言之，同一个适配器可以把源类和它的子类都适配到目标接口。因为对象适配器采用的是对象组合的关系，只要对象类型正确，是不是子类都无所谓。\n●　对于类适配器，适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。\n对于对象适配器，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。\n●　对于类适配器，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。\n对于对象适配器，需要额外的引用来间接得到Adaptee。\n建议尽量使用对象适配器的实现方式，多用合成/聚合、少用继承。当然，具体问题具体分析，根据需要来选用实现方式，最适合的才是最好的\n优点 复用性 扩展性 缺点 过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构\n代码示例\n缺省适配器模式 抽象类中实现顶层接口的默认实现","title":"适配器模式"},{"content":" 分离对象的的属性与创建过程，用户创建重的对象。\n写法分类：\n在Builder里面直接new对象的方式，MyBatis的SqlSessionFactoryBuilder就是这种写法，适用于属性之间关联不多且大量属性都有默认值的场景。 间接new的方式：例如Guava的Cache都是这种写法，适用于属性之间有一定关联性的场景。 建造者模式的优点及适用场景\n建造者模式这种设计模式，优缺点比较明显。从优点来说：\n客户端不比知道产品内部细节，将产品本身与产品创建过程解耦，使得相同的创建过程可以创建不同的产品对象 可以更加精细地控制产品的创建过程，将复杂对象分门别类抽出不同的类别来，使得开发者可以更加方便地得到想要的产品 想了想，说缺点，建造者模式说不上缺点，只能说这种设计模式的使用比较受限：\n产品属性之间差异很大且属性没有默认值可以指定，这种情况是没法使用建造者模式的，我们可以试想，一个对象20个属性，彼此之间毫无关联且每个都需要手动指定，那么很显然，即使使用了建造者模式也是毫无作用 代码示例\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E6%9E%84%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/","summary":"分离对象的的属性与创建过程，用户创建重的对象。\n写法分类：\n在Builder里面直接new对象的方式，MyBatis的SqlSessionFactoryBuilder就是这种写法，适用于属性之间关联不多且大量属性都有默认值的场景。 间接new的方式：例如Guava的Cache都是这种写法，适用于属性之间有一定关联性的场景。 建造者模式的优点及适用场景\n建造者模式这种设计模式，优缺点比较明显。从优点来说：\n客户端不比知道产品内部细节，将产品本身与产品创建过程解耦，使得相同的创建过程可以创建不同的产品对象 可以更加精细地控制产品的创建过程，将复杂对象分门别类抽出不同的类别来，使得开发者可以更加方便地得到想要的产品 想了想，说缺点，建造者模式说不上缺点，只能说这种设计模式的使用比较受限：\n产品属性之间差异很大且属性没有默认值可以指定，这种情况是没法使用建造者模式的，我们可以试想，一个对象20个属性，彼此之间毫无关联且每个都需要手动指定，那么很显然，即使使用了建造者模式也是毫无作用 代码示例","title":"构建者模式"},{"content":" 对象的行为模式。在不修改已有程序的前提下，通过添加额外的访问者来完成对已有代码功能的提升。\n将数据结构与操作分离\n角色：\n抽象访问者: 声明了一个或者多个方法操作，形成所有的具体访问者角色必须实现的接口 具体访问者: 实现抽象访问者所声明的接口，也就是抽象访问者所声明的各个访问操作 抽象节点: 声明一个接受操作，接受一个访问者对象作为一个参数 具体节点: 实现了抽象节点所规定的接受操作 结构对象: 遍历结构的元素 访问者模式优点：\n扩展性好，可以在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能； 符合单一职责原则，通过访问者将无关的行为分离，使职责单一；\n访问者模式缺点：\n违反了迪米特原则，因为具体元素对访问者公布细节； 违反了依赖倒置原则，依赖了具体类，没有依赖抽象； 对象结构变化困难，若对象结构发生了改变，访问者的接口和访问者的实现也都要发生相应的改变；\n使用场景：\n对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作； 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作\u0026quot;污染\u0026quot;这些对象的类，也不希望在增加新操作时修改这些类。\n访问者模式示例\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/","summary":"对象的行为模式。在不修改已有程序的前提下，通过添加额外的访问者来完成对已有代码功能的提升。\n将数据结构与操作分离\n角色：\n抽象访问者: 声明了一个或者多个方法操作，形成所有的具体访问者角色必须实现的接口 具体访问者: 实现抽象访问者所声明的接口，也就是抽象访问者所声明的各个访问操作 抽象节点: 声明一个接受操作，接受一个访问者对象作为一个参数 具体节点: 实现了抽象节点所规定的接受操作 结构对象: 遍历结构的元素 访问者模式优点：\n扩展性好，可以在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能； 符合单一职责原则，通过访问者将无关的行为分离，使职责单一；\n访问者模式缺点：\n违反了迪米特原则，因为具体元素对访问者公布细节； 违反了依赖倒置原则，依赖了具体类，没有依赖抽象； 对象结构变化困难，若对象结构发生了改变，访问者的接口和访问者的实现也都要发生相应的改变；\n使用场景：\n对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作； 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作\u0026quot;污染\u0026quot;这些对象的类，也不希望在增加新操作时修改这些类。\n访问者模式示例","title":"访问者模式"},{"content":" 迭代器模式又叫做游标模式，作用：提供一种方法访问一个容器元素中的各个对象，而又不暴露该对象的内部细节\n角色：\n迭代器角色 具体迭代器角色 容器角色 具体容器角色 ","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/","summary":" 迭代器模式又叫做游标模式，作用：提供一种方法访问一个容器元素中的各个对象，而又不暴露该对象的内部细节\n角色：\n迭代器角色 具体迭代器角色 容器角色 具体容器角色 ","title":"迭代器模式"},{"content":" 代理模式是一种使用代理对象来执行目标对象的方法并在代理对象中增强目标对象方法的一种设计模式\n静态代理 动态代理 静态代理的特点如下：\n使用静态代理时，通常客户类不需要感知RealSubject。 静态代理的缺点：代理对象需要与目标对象实现一样的接口，因此接口较多时需要定义和维护大量的代理类代码。 与适配器的差异：适配器通常考虑改变接口形态，而代理则不会也不能改变接口形态。 与装饰器的差异：被代理对象由代理对象创建，客户端甚至不需要知道被代理类的存在；被装饰对象则由客户端创建并传给装饰对象，可以层层嵌套，层层装饰。代理模式常用于控制被代理对象的访问，而装饰模式是增加被装饰者的功能。\nJDK动态代理的特点如下：\n通过实现InvocationHandler接口完成代理逻辑。 通过反射代理方法，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。 代理类必须实现接口。 代理模式\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","summary":"代理模式是一种使用代理对象来执行目标对象的方法并在代理对象中增强目标对象方法的一种设计模式\n静态代理 动态代理 静态代理的特点如下：\n使用静态代理时，通常客户类不需要感知RealSubject。 静态代理的缺点：代理对象需要与目标对象实现一样的接口，因此接口较多时需要定义和维护大量的代理类代码。 与适配器的差异：适配器通常考虑改变接口形态，而代理则不会也不能改变接口形态。 与装饰器的差异：被代理对象由代理对象创建，客户端甚至不需要知道被代理类的存在；被装饰对象则由客户端创建并传给装饰对象，可以层层嵌套，层层装饰。代理模式常用于控制被代理对象的访问，而装饰模式是增加被装饰者的功能。\nJDK动态代理的特点如下：\n通过实现InvocationHandler接口完成代理逻辑。 通过反射代理方法，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。 代理类必须实现接口。 代理模式","title":"代理模式"},{"content":" 对象的结构模式，以共享的方式高效的支持大量的细粒度对象\njava中String类型就是享元模式 享元模式采用一个共享来避免大量拥有相同内容对象的开销\n分类 单纯享元模式 所有的享元对象都是可以共享的\n角色：\n抽象享元(Flyweight)角色：抽象接口 具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口 享元工厂(FlyweightFactory)角色：本角色负责创建和管理享元角色 复合享元模式 抽象享元(Flyweight)角色：抽象接口 具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口 复合享元角色：复合享元角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解成为多个本身是单纯享元对象的组合。复合享元角色又称作不可共享的享元对象 享元工厂(FlyweightFactory)角色：本角色负责创建和管理享元角色 ","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/","summary":" 对象的结构模式，以共享的方式高效的支持大量的细粒度对象\njava中String类型就是享元模式 享元模式采用一个共享来避免大量拥有相同内容对象的开销\n分类 单纯享元模式 所有的享元对象都是可以共享的\n角色：\n抽象享元(Flyweight)角色：抽象接口 具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口 享元工厂(FlyweightFactory)角色：本角色负责创建和管理享元角色 复合享元模式 抽象享元(Flyweight)角色：抽象接口 具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口 复合享元角色：复合享元角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解成为多个本身是单纯享元对象的组合。复合享元角色又称作不可共享的享元对象 享元工厂(FlyweightFactory)角色：本角色负责创建和管理享元角色 ","title":"享元模式"},{"content":" 描述部分与整体的关系，组装树形结构\n角色 抽象构件角色 树叶构件角色 树枝构件角色 分类 透明式：在该方式中，由于抽象构件声明了所有子类中的全部方法，所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的 安全式：在该方式中，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题，但由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性 组合模式代码\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/","summary":"描述部分与整体的关系，组装树形结构\n角色 抽象构件角色 树叶构件角色 树枝构件角色 分类 透明式：在该方式中，由于抽象构件声明了所有子类中的全部方法，所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的 安全式：在该方式中，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题，但由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性 组合模式代码","title":"组合模式"},{"content":" 观察者模式-对象行为模式。发布/订阅模式，模型-视图模式、源-监听器模式，从属者模式。\n定义一对多的依赖关系，让多个观察者同时监听某一个主题对象。这个对象在状态上发生变化时，会通知所有观察者对象，是它们能够主动更新自己的状态。\n角色：\n抽象主题角色：提供一个接口，可以增加和减少观察者对象，抽象主题角色又叫做抽象被观察者角色。 具体主题角色：将有关状态存入具体观察者对象 抽象观察者角色：为所有的观察者提供一个接口，在得到主题的通知时更新自己。 具体观察者角色：存储与主题状态自恰的状态。 模式分类：\n推模式\n主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。\n拉模式 主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。\njava对观察者模式的支持\nObserver接口： 观察者 Observable类： 被观察者 示例代码\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","summary":"观察者模式-对象行为模式。发布/订阅模式，模型-视图模式、源-监听器模式，从属者模式。\n定义一对多的依赖关系，让多个观察者同时监听某一个主题对象。这个对象在状态上发生变化时，会通知所有观察者对象，是它们能够主动更新自己的状态。\n角色：\n抽象主题角色：提供一个接口，可以增加和减少观察者对象，抽象主题角色又叫做抽象被观察者角色。 具体主题角色：将有关状态存入具体观察者对象 抽象观察者角色：为所有的观察者提供一个接口，在得到主题的通知时更新自己。 具体观察者角色：存储与主题状态自恰的状态。 模式分类：\n推模式\n主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。\n拉模式 主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。\njava对观察者模式的支持\nObserver接口： 观察者 Observable类： 被观察者 示例代码","title":"观察者模式"},{"content":" 对象的行为模式，允许你将请求沿着处理链进行发送。收到请求后，每个处理者可对请求进行处理，或将其传递给链上的下个处理者\n角色：\n抽象处理者：定义处理请求的接口。 具体处理者：具体处理者接到请求，可以将请求处理，或者将请求传给下家。 示例代码\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/","summary":"对象的行为模式，允许你将请求沿着处理链进行发送。收到请求后，每个处理者可对请求进行处理，或将其传递给链上的下个处理者\n角色：\n抽象处理者：定义处理请求的接口。 具体处理者：具体处理者接到请求，可以将请求处理，或者将请求传给下家。 示例代码","title":"责任链模式"},{"content":" 动态的将责任添加到对象上，动态添加功能。\n分类：\n父组件，供子组件使用 装饰者：组合其他组件，一部分功能是自己的，调用被装饰者，等同于保留被装饰者的功能 具体组件：实现具体方法 饮料添加各种配料，返回最终的价格。\n代码示例\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/","summary":"动态的将责任添加到对象上，动态添加功能。\n分类：\n父组件，供子组件使用 装饰者：组合其他组件，一部分功能是自己的，调用被装饰者，等同于保留被装饰者的功能 具体组件：实现具体方法 饮料添加各种配料，返回最终的价格。\n代码示例","title":"装饰者模式"},{"content":" 门面模式对外，调停者模式对内\n对象的行为模式，调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显引用。从而使它们可以较松散地耦合。当这些对象中的某些对象之间的相互作用发生改变时，不会立即影响到其他的一些对象之间的相互作用。从而保证这些相互作用可以彼此独立地变化\n角色：\n抽象调停者角色 具体调停者角色 抽象同事类角色 具体公式类角色 示例代码\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E8%B0%83%E5%81%9C%E8%80%85%E6%A8%A1%E5%BC%8F/","summary":"门面模式对外，调停者模式对内\n对象的行为模式，调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显引用。从而使它们可以较松散地耦合。当这些对象中的某些对象之间的相互作用发生改变时，不会立即影响到其他的一些对象之间的相互作用。从而保证这些相互作用可以彼此独立地变化\n角色：\n抽象调停者角色 具体调停者角色 抽象同事类角色 具体公式类角色 示例代码","title":"调停者模式"},{"content":" 提供高层次的接口，统一门面对象进行，使得子系统易于使用。\n选择性的暴露方法\n角色分类：\n门面角色: 客户端可以调用这个角色的方法 子系统角色：可以同时有一个或者多个子系统 门面模式示例代码\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/","summary":"提供高层次的接口，统一门面对象进行，使得子系统易于使用。\n选择性的暴露方法\n角色分类：\n门面角色: 客户端可以调用这个角色的方法 子系统角色：可以同时有一个或者多个子系统 门面模式示例代码","title":"门面模式"},{"content":" 任何可以产生对象的方法和类，都可以被称为工厂。\n创建型设计模式，父类提供创建对象的方法，允许子类决定实例化对象的类型\n分类 根据产品是具体产品还是具体工厂：\n简单工厂模式 工厂方法模式 根据工厂的抽象程度\n工厂方法模式 抽象工厂模式 简单工厂模式 只对不同类对象的创建进行了一层薄薄的封装，通过向工厂传递类型来指定要创建的对象。\n工厂方法模式 工厂方法模式将生产具体产品的任务分发给具体的产品工厂\n抽象工厂模式 针对不同产品的创建。在工厂方法模式下，在抽象工厂里面增加创建产品的接口，并在具体子工厂中实现产品的创建\n工厂模式代码示例合\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","summary":"任何可以产生对象的方法和类，都可以被称为工厂。\n创建型设计模式，父类提供创建对象的方法，允许子类决定实例化对象的类型\n分类 根据产品是具体产品还是具体工厂：\n简单工厂模式 工厂方法模式 根据工厂的抽象程度\n工厂方法模式 抽象工厂模式 简单工厂模式 只对不同类对象的创建进行了一层薄薄的封装，通过向工厂传递类型来指定要创建的对象。\n工厂方法模式 工厂方法模式将生产具体产品的任务分发给具体的产品工厂\n抽象工厂模式 针对不同产品的创建。在工厂方法模式下，在抽象工厂里面增加创建产品的接口，并在具体子工厂中实现产品的创建\n工厂模式代码示例合","title":"工厂模式"},{"content":" 对于做同一件事有多种方法，Comparator接口。\nContext：环境类 Strategy: 抽象策略类 ConcreteStrategy: 具体策略类 使用场景 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。\n策略模式示例代码\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","summary":"对于做同一件事有多种方法，Comparator接口。\nContext：环境类 Strategy: 抽象策略类 ConcreteStrategy: 具体策略类 使用场景 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。\n策略模式示例代码","title":"策略模式"},{"content":" 保持内存中只有一个对象\n分类：\n是否加载实例\n饿汉式 饱汉式 是否线程安全\n安全 不安全 特殊实现方式：\n静态内部类 枚举 单例模式代码\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","summary":"保持内存中只有一个对象\n分类：\n是否加载实例\n饿汉式 饱汉式 是否线程安全\n安全 不安全 特殊实现方式：\n静态内部类 枚举 单例模式代码","title":"单例模式"},{"content":"使用场景 多用于子串匹配问题\n流程 在暴力解的过程当中有加速\n定义： 在该位置之前的前缀与后缀的长度，但不能取到字符串的整体长度，定义为指标信息\n解释：\n对匹配串建立上述指标信息 匹配过程 求解证明 x-r 与 y-r\u0026rsquo;是相同，从i位置匹配match串等同于从match的q位置进行匹配\ni位置到r位置一定不能匹配match\n验证：假设i位置到r位置，有个k位置能够匹配match串，那就说明从k位置到x位置是相同的，也就是match串y位置之前字符串的一个后缀，此时，与next的数组定义违反，出现了一个更长的。假设不成立。\nnext数组生成 match长度为M,时间复杂度为O(M)\nnext[0] = -1;\nnext[1] = 0;\nnext[2] = 0位置和1位置决定;\n求i位置的next[i]时候，前面所有位置都已经准备好\nnext证明 来到i位置next[i]最大为next[i+1]+1\n假设next[i]\u0026gt;next[i-1] + 1,\n那么说明next[i-1]求解错误，矛盾，不成立\n代码实现 public class Kmp { public static int getIndexOf(String s, String match) { if (s == null || match == null || match.length() \u0026lt; 1 || s.length() \u0026lt; match.length()) { return -1; } char[] strs = s.toCharArray(); char[] matchs = match.toCharArray(); int x = 0;// strs中当前匹配位置 int y = 0; // match中当前匹配位置、 int[] next = getNextArray(matchs); while (x \u0026lt; strs.length \u0026amp;\u0026amp; y \u0026lt; matchs.length) { if (strs[x] == matchs[y]) { x++; y++; } else if (next[y] == -1) { // y已经来到开头 或者写成y==0 x++; } else { y = next[y]; } } return y == matchs.length ? x - y : -1; } public static int[] getNextArray(char[] matchs) { if (matchs.length == 1) { return new int[]{-1}; } int[] next = new int[matchs.length]; next[0] = -1; // 人为规定 next[1] = 0; // 人为规定 int i = 2; // 从2开始 int cn = 0; // 和i-1位置比较的字符 while (i \u0026lt; matchs.length) { if (matchs[i - 1] == matchs[cn]) { next[i++] = ++cn; } else if (cn \u0026gt; 0) { // 往前跳 cn = next[cn]; } else { // 匹配不到 next[i++] = 0; } } return next; } } 时间复杂度-O(N) 对于上述代码的while循环处理\nx[最大到N] x-y[最大到N] 第一个分支 变大 不变 第二个分支 变大 变大 第三个分支 不变 变大 最大为2N,复杂度为O(N)\n","permalink":"https://AlfredNing.github.io/note/program/algorithm/kmp/","summary":"使用场景 多用于子串匹配问题\n流程 在暴力解的过程当中有加速\n定义： 在该位置之前的前缀与后缀的长度，但不能取到字符串的整体长度，定义为指标信息\n解释：\n对匹配串建立上述指标信息 匹配过程 求解证明 x-r 与 y-r\u0026rsquo;是相同，从i位置匹配match串等同于从match的q位置进行匹配\ni位置到r位置一定不能匹配match\n验证：假设i位置到r位置，有个k位置能够匹配match串，那就说明从k位置到x位置是相同的，也就是match串y位置之前字符串的一个后缀，此时，与next的数组定义违反，出现了一个更长的。假设不成立。\nnext数组生成 match长度为M,时间复杂度为O(M)\nnext[0] = -1;\nnext[1] = 0;\nnext[2] = 0位置和1位置决定;\n求i位置的next[i]时候，前面所有位置都已经准备好\nnext证明 来到i位置next[i]最大为next[i+1]+1\n假设next[i]\u0026gt;next[i-1] + 1,\n那么说明next[i-1]求解错误，矛盾，不成立\n代码实现 public class Kmp { public static int getIndexOf(String s, String match) { if (s == null || match == null || match.length() \u0026lt; 1 || s.length() \u0026lt; match.length()) { return -1; } char[] strs = s.toCharArray(); char[] matchs = match.","title":"Kmp"}]