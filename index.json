[{"content":" 动态的将责任添加到对象上，动态添加功能。\n分类：\n父组件，供子组件使用 装饰者：组合其他组件，一部分功能是自己的，调用被装饰者，等同于保留被装饰者的功能 具体组件：实现具体方法 饮料添加各种配料，返回最终的价格。\n代码示例\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/","summary":"动态的将责任添加到对象上，动态添加功能。\n分类：\n父组件，供子组件使用 装饰者：组合其他组件，一部分功能是自己的，调用被装饰者，等同于保留被装饰者的功能 具体组件：实现具体方法 饮料添加各种配料，返回最终的价格。\n代码示例","title":"装饰者模式"},{"content":" 门面模式对外，调停者模式对内\n对象的行为模式，调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显引用。从而使它们可以较松散地耦合。当这些对象中的某些对象之间的相互作用发生改变时，不会立即影响到其他的一些对象之间的相互作用。从而保证这些相互作用可以彼此独立地变化\n角色：\n抽象调停者角色 具体调停者角色 抽象同事类角色 具体公式类角色 示例代码\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E8%B0%83%E5%81%9C%E8%80%85%E6%A8%A1%E5%BC%8F/","summary":"门面模式对外，调停者模式对内\n对象的行为模式，调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显引用。从而使它们可以较松散地耦合。当这些对象中的某些对象之间的相互作用发生改变时，不会立即影响到其他的一些对象之间的相互作用。从而保证这些相互作用可以彼此独立地变化\n角色：\n抽象调停者角色 具体调停者角色 抽象同事类角色 具体公式类角色 示例代码","title":"调停者模式"},{"content":" 提供高层次的接口，统一门面对象进行，使得子系统易于使用。\n选择性的暴露方法\n角色分类：\n门面角色: 客户端可以调用这个角色的方法 子系统角色：可以同时有一个或者多个子系统 门面模式示例代码\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/","summary":"提供高层次的接口，统一门面对象进行，使得子系统易于使用。\n选择性的暴露方法\n角色分类：\n门面角色: 客户端可以调用这个角色的方法 子系统角色：可以同时有一个或者多个子系统 门面模式示例代码","title":"门面模式"},{"content":" 任何可以产生对象的方法和类，都可以被称为工厂。\n创建型设计模式，父类提供创建对象的方法，允许子类决定实例化对象的类型\n分类 根据产品是具体产品还是具体工厂：\n简单工厂模式 工厂方法模式 根据工厂的抽象程度\n工厂方法模式 抽象工厂模式 简单工厂模式 只对不同类对象的创建进行了一层薄薄的封装，通过向工厂传递类型来指定要创建的对象。\n工厂方法模式 工厂方法模式将生产具体产品的任务分发给具体的产品工厂\n抽象工厂模式 针对不同产品的创建。在工厂方法模式下，在抽象工厂里面增加创建产品的接口，并在具体子工厂中实现产品的创建\n工厂模式代码示例合\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","summary":"任何可以产生对象的方法和类，都可以被称为工厂。\n创建型设计模式，父类提供创建对象的方法，允许子类决定实例化对象的类型\n分类 根据产品是具体产品还是具体工厂：\n简单工厂模式 工厂方法模式 根据工厂的抽象程度\n工厂方法模式 抽象工厂模式 简单工厂模式 只对不同类对象的创建进行了一层薄薄的封装，通过向工厂传递类型来指定要创建的对象。\n工厂方法模式 工厂方法模式将生产具体产品的任务分发给具体的产品工厂\n抽象工厂模式 针对不同产品的创建。在工厂方法模式下，在抽象工厂里面增加创建产品的接口，并在具体子工厂中实现产品的创建\n工厂模式代码示例合","title":"工厂模式"},{"content":" 对于做同一件事有多种方法，Comparator接口。\nContext：环境类 Strategy: 抽象策略类 ConcreteStrategy: 具体策略类 使用场景 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。\n策略模式示例代码\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","summary":"对于做同一件事有多种方法，Comparator接口。\nContext：环境类 Strategy: 抽象策略类 ConcreteStrategy: 具体策略类 使用场景 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。\n策略模式示例代码","title":"策略模式"},{"content":" 保持内存中只有一个对象\n分类：\n是否加载实例\n饿汉式 饱汉式 是否线程安全\n安全 不安全 特殊实现方式：\n静态内部类 枚举 单例模式代码\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","summary":"保持内存中只有一个对象\n分类：\n是否加载实例\n饿汉式 饱汉式 是否线程安全\n安全 不安全 特殊实现方式：\n静态内部类 枚举 单例模式代码","title":"单例模式"},{"content":"使用场景 多用于子串匹配问题\n流程 在暴力解的过程当中有加速\n定义： 在该位置之前的前缀与后缀的长度，但不能取到字符串的整体长度，定义为指标信息\n解释：\n对匹配串建立上述指标信息 匹配过程 求解证明 x-r 与 y-r\u0026rsquo;是相同，从i位置匹配match串等同于从match的q位置进行匹配\ni位置到r位置一定不能匹配match\n验证：假设i位置到r位置，有个k位置能够匹配match串，那就说明从k位置到x位置是相同的，也就是match串y位置之前字符串的一个后缀，此时，与next的数组定义违反，出现了一个更长的。假设不成立。\nnext数组生成 match长度为M,时间复杂度为O(M)\nnext[0] = -1;\nnext[1] = 0;\nnext[2] = 0位置和1位置决定;\n求i位置的next[i]时候，前面所有位置都已经准备好\nnext证明 来到i位置next[i]最大为next[i+1]+1\n假设next[i]\u0026gt;next[i-1] + 1,\n那么说明next[i-1]求解错误，矛盾，不成立\n代码实现 public class Kmp { public static int getIndexOf(String s, String match) { if (s == null || match == null || match.length() \u0026lt; 1 || s.length() \u0026lt; match.length()) { return -1; } char[] strs = s.toCharArray(); char[] matchs = match.toCharArray(); int x = 0;// strs中当前匹配位置 int y = 0; // match中当前匹配位置、 int[] next = getNextArray(matchs); while (x \u0026lt; strs.length \u0026amp;\u0026amp; y \u0026lt; matchs.length) { if (strs[x] == matchs[y]) { x++; y++; } else if (next[y] == -1) { // y已经来到开头 或者写成y==0 x++; } else { y = next[y]; } } return y == matchs.length ? x - y : -1; } public static int[] getNextArray(char[] matchs) { if (matchs.length == 1) { return new int[]{-1}; } int[] next = new int[matchs.length]; next[0] = -1; // 人为规定 next[1] = 0; // 人为规定 int i = 2; // 从2开始 int cn = 0; // 和i-1位置比较的字符 while (i \u0026lt; matchs.length) { if (matchs[i - 1] == matchs[cn]) { next[i++] = ++cn; } else if (cn \u0026gt; 0) { // 往前跳 cn = next[cn]; } else { // 匹配不到 next[i++] = 0; } } return next; } } 时间复杂度-O(N) 对于上述代码的while循环处理\nx[最大到N] x-y[最大到N] 第一个分支 变大 不变 第二个分支 变大 变大 第三个分支 不变 变大 最大为2N,复杂度为O(N)\n","permalink":"https://AlfredNing.github.io/note/program/algorithm/kmp/","summary":"使用场景 多用于子串匹配问题\n流程 在暴力解的过程当中有加速\n定义： 在该位置之前的前缀与后缀的长度，但不能取到字符串的整体长度，定义为指标信息\n解释：\n对匹配串建立上述指标信息 匹配过程 求解证明 x-r 与 y-r\u0026rsquo;是相同，从i位置匹配match串等同于从match的q位置进行匹配\ni位置到r位置一定不能匹配match\n验证：假设i位置到r位置，有个k位置能够匹配match串，那就说明从k位置到x位置是相同的，也就是match串y位置之前字符串的一个后缀，此时，与next的数组定义违反，出现了一个更长的。假设不成立。\nnext数组生成 match长度为M,时间复杂度为O(M)\nnext[0] = -1;\nnext[1] = 0;\nnext[2] = 0位置和1位置决定;\n求i位置的next[i]时候，前面所有位置都已经准备好\nnext证明 来到i位置next[i]最大为next[i+1]+1\n假设next[i]\u0026gt;next[i-1] + 1,\n那么说明next[i-1]求解错误，矛盾，不成立\n代码实现 public class Kmp { public static int getIndexOf(String s, String match) { if (s == null || match == null || match.length() \u0026lt; 1 || s.length() \u0026lt; match.length()) { return -1; } char[] strs = s.toCharArray(); char[] matchs = match.","title":"Kmp"}]