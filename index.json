[{"content":"","permalink":"https://AlfredNing.github.io/note/program/sql/mysql%E9%AB%98%E7%BA%A7-%E4%BA%8B%E5%8A%A1/","summary":"","title":"MySql高级 事务"},{"content":"2023年上，看了浪潮之巅。\n20世纪不联网信息产业密度不断扩大，新型了各大历史上著名的公司，有的至今还在，有的早已灭亡。科学技术的不断发展，有的公司靠自己影响力，有的公司靠自己的垄断，有的公司在技术上的发展却无法商业变现。历史上著名的太阳公司，雅虎公司。好的公司里面必要有优秀的人才。\n每一个叫的名字的公司，之前都经历过一段痛苦时间，每一个站在行业顶端的互联网公司，都占据着市场上诸多的利润。不要看到大公司的今天，回头看看，他们的一路。任何事情也都是如此。\n下面的记录的一些定律：未来的一天这些定律也可能不复存在\n计算机行业的发展规律 摩尔定律 每18个月，计算机等IT产品的性能翻一番；或者是说相同性能的计算机等IT产品，每18个月价钱会降一半。【小范围适用于你买电子产品】\n安迪-比尔定律 安迪：英特尔公司传奇CEO\n比尔: 微软公司创始人比尔盖茨\n软件压榨着硬件的性能\n以微软为首的软件开发公司吃掉硬件提升带来的全部好处，迫使用户更新机器，让硬件厂商受益。硬件厂商继而研发，根据摩尔定律，提升硬件性能，为微软下一步更新软件做准备，形成完整生态链。\n反摩尔定律 一个IT公司如果今天和18个月前卖掉同样多的、同样的产品，它的营业额就会降一半。\n反摩尔定律逼着所有硬件公司都必须追赶上摩尔定律规定的更新速度。\n信息产业的规律性 70-20-10 行业老大吃掉市场的70%，老二吃掉20%，剩下的瓜分10%\n诺威格定律 一家公司的市场占有率超过50%，就无法在翻一番了。公司进行“横向扩展” 、业务转型\n基因决定定律 一家公司的基因决定了这家公司的发展\n","permalink":"https://AlfredNing.github.io/thinking/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%94%E6%89%80%E6%84%9F/","summary":"2023年上，看了浪潮之巅。\n20世纪不联网信息产业密度不断扩大，新型了各大历史上著名的公司，有的至今还在，有的早已灭亡。科学技术的不断发展，有的公司靠自己影响力，有的公司靠自己的垄断，有的公司在技术上的发展却无法商业变现。历史上著名的太阳公司，雅虎公司。好的公司里面必要有优秀的人才。\n每一个叫的名字的公司，之前都经历过一段痛苦时间，每一个站在行业顶端的互联网公司，都占据着市场上诸多的利润。不要看到大公司的今天，回头看看，他们的一路。任何事情也都是如此。\n下面的记录的一些定律：未来的一天这些定律也可能不复存在\n计算机行业的发展规律 摩尔定律 每18个月，计算机等IT产品的性能翻一番；或者是说相同性能的计算机等IT产品，每18个月价钱会降一半。【小范围适用于你买电子产品】\n安迪-比尔定律 安迪：英特尔公司传奇CEO\n比尔: 微软公司创始人比尔盖茨\n软件压榨着硬件的性能\n以微软为首的软件开发公司吃掉硬件提升带来的全部好处，迫使用户更新机器，让硬件厂商受益。硬件厂商继而研发，根据摩尔定律，提升硬件性能，为微软下一步更新软件做准备，形成完整生态链。\n反摩尔定律 一个IT公司如果今天和18个月前卖掉同样多的、同样的产品，它的营业额就会降一半。\n反摩尔定律逼着所有硬件公司都必须追赶上摩尔定律规定的更新速度。\n信息产业的规律性 70-20-10 行业老大吃掉市场的70%，老二吃掉20%，剩下的瓜分10%\n诺威格定律 一家公司的市场占有率超过50%，就无法在翻一番了。公司进行“横向扩展” 、业务转型\n基因决定定律 一家公司的基因决定了这家公司的发展","title":"浪潮之巔所感"},{"content":"索引 索引的分类 从功能逻辑划分 普通索引 唯一索引 主键索引 全文索引 从物理实现方法划分 聚簇索引 非聚簇索引 从作用字段划分 单列索引 联合索引 InnoDB: 支持B-Tree，FullText索引，不支持Hash索引\nMyISAM: 支持B-Tree，FullText索引，不支持Hash索引\nMemory: 支持B-Tree，Hash索引，不支持FullText索引\nNDB: 支持Hash索引，不支持 B-Tree, FullText索引\nArchive: 不支持 B-Tree, FullText,Hash索引\n创建索引 方式1- 创建表时候指定 普通索引 CREATE TABLE book( book_id INT , book_name VARCHAR(100), authors VARCHAR(100), info VARCHAR(100) , comment VARCHAR(100), year_publication YEAR, INDEX(year_publication) ); 创建唯一索引 CREATE TABLE test1( id INT NOT NULL, name varchar(30) NOT NULL, UNIQUE INDEX uk_idx_id(id) ); 主键索引 CREATE TABLE student ( id INT(10) UNSIGNED AUTO_INCREMENT, student_no VARCHAR(200), student_name VARCHAR(200), PRIMARY KEY(id) ); # 删除主键索引 ALTER TABLE student drop PRIMARY KEY ; 创建单列索引 CREATE TABLE test2( id INT NOT NULL, name CHAR(50) NULL, INDEX single_idx_name(name(20)) ); 创建组合索引 CREATE TABLE test3( id INT(11) NOT NULL, name CHAR(30) NOT NULL, age INT(11) NOT NULL, info VARCHAR(255), INDEX multi_idx(id,name,age) ); 全文索引 CREATE TABLE `papers` ( id` int(10) unsigned NOT NULL AUTO_INCREMENT, `title` varchar(200) DEFAULT NULL, `content` text, PRIMARY KEY (`id`), FULLTEXT KEY `title` (`title`,`content`) ) ENGINE=MyISAM DEFAULT CHARSET=utf8; SELECT * FROM papers WHERE MATCH(title,content) AGAINST (‘查询字符串’); 空间索引 CREATE TABLE test5( geo GEOMETRY NOT NULL, SPATIAL INDEX spa_idx_geo(geo) ) ENGINE=MyISAM; 方式2-已经创建表上的添加 alter 形式 ALTER TABLE table_name ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name[length],...) [ASC | DESC] create 形式 CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name ON table_name (col_name[length],...) [ASC | DESC] 删除索引-alter ALTER TABLE table_name DROP INDEX index_name; 删除索引-drop\nDROP INDEX index_name ON table_name; 添加Auto_Increment约束字段的唯一索引不能被删除\nMySQL8.0 - 新特性 降序索引 CREATE TABLE ts1(a int,b int,index idx_a_b(a,b desc)); 对InnoDB而言是支持的，Mysql之前是升序索引\n隐藏索引 -- 创建表时候指定 CREATE TABLE tablename( propname1 type1[CONSTRAINT1], propname2 type2[CONSTRAINT2], …… propnamen typen, INDEX [indexname](propname1 [(length)]) INVISIBLE ); -- 已经创建表的指定 CREATE INDEX indexname ON tablename(propname[(length)]) INVISIBLE; -- alter table 指定 ALTER TABLE tablename ADD INDEX indexname (propname [(length)]) INVISIBLE; -- 切换隐藏索引状态 ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; #切换成隐藏索引 ALTER TABLE tablename ALTER INDEX index_name VISIBLE; #切换成非隐藏索引 -- 是隐藏索引对查询优化器可见设置 -- 1. 查看优化器设置 select @@optimizer_switch set session optimizer_switch=\u0026#34;use_invisible_indexes=on\u0026#34; -- 开启 索引的设计原则 哪些情况适合创建索引 1. 字段的数值有唯一的限制 索引本身可以起到约束的作用，比如唯一索引、主键索引都可以起到唯一性约束的，因此在我们的数据表中，如果某个字段是唯一的，就可以直接创建唯一性索引，或者主键索引。这样可以更快速地通过该索引来确定某条记录\n业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba）\n说明：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的。\n2. 经常性作为where条件查询的字段 某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率\n3. 经常group by 和order by 的列 如果只是group by 或者order by单列字段，建立单列索引。\n如果既有group by 也有order by 建立联合索引\n4. UPDATE、DELETE 的 WHERE 条件列 对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。\n5. DISTINCT字段需要创建索引 有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。\n6. 多表创建索引注意事项 首先，连接表的数量尽量不要超过 3 张，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。\n其次，对 WHERE 条件创建索引，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。\n最后，对用于连接的字段创建索引，并且该字段在多张表中的类型必须一致。虽然这里能查询，但存在隐式转换，使用到了函数\n7. 使用列的类型小的创建索引 这里所说的类型大小指的就是该类型表示的数据范围的大小。\n数据类型越小，在查询时进行的比较操作越快 数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘I/O带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。 这个建议对于表的主键来说更加适用，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/O。\n8. 使用字符串前缀创建索引 计算公式\nselect count(distinct left(列名, 索引长度))/count(*) from table_name; --比值越接近1越好 -- 尝试 select count(distinct left(列名, 10))/count(*) as sub10 from table_name; select count(distinct left(列名, 15))/count(*) as sub15 from table_name; select count(distinct left(列名, 20))/count(*) as sub20 from table_name; select count(distinct left(列名, 25))/count(*) as sub25 from table_name; Alibaba《Java开发手册》\n【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。\n说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90% 以上\n索引类前缀对排序的影响 使用了索引列前缀的方式无法支持使用索引排序，只能使用文件排序，可能造成排序结果有偏差\n9. 区分度高(散列性高)的列适合作为索引 列的基数指的是某一列中不重复数据的个数，比方说某个列包含值2,5,8,2,5,8,2,5,8，虽然有9条记录，但该列的基数却是3。也就是说，**在记录行数一定的情况下，列的基数越大，该列中的值越分散；列的基数越小，该列中的值越集中。**这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列建立索引，为基数太小的列建立索引效果可能不好。\n可以使用公式select count(distinct a)/count(*) from t1计算区分度，越接近1越好，一般超过33%就算是比较高效的索引了。\n拓展：联合索引把区分度高（散列性高）的列放在前面。\n10. 使用最频繁的列放到联合索引的左侧 最左前缀匹配原则\n10. 在多个字段都要创建索引的情况下，联合索引优于单值索引 索引的数量限制 在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量不超过6个。原因：\n每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。 索引会影响INSERT、DELETE、UPDATE等语句的性能，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加MySQL优化器生成执行计划时间，降低查询性能。 不适合创建索引的情况 1. 在where,groupby orderby 使用不到的字段不需要创建 2. 数据量小的表不要使用索引 3. 有大量重复数据的列上不要创建索引 当数据重复度 大于10%，不需要创建索引\n4. 避免对经常更新的表创建过多的索引 频繁更新的字段不一定要创建索引 对经常更新的表避免创建过多的索引 5. 不建议用无序的值作为索引 身份证，uuid(索引比较时候转换为ASCII, 并且插入时可能造成页分裂，md5, hash，无序列长字符串)\n6. 删除不再使用或者使用很少的索引 7. 不要定义冗余或者重复的索引 冗余索引：联合索引含有的字段，有定义了单列索引\n重复索引\n性能分析工具 数据库优化步骤 查看系统参数 show [global | session] status like \u0026#39;参数名\u0026#39; 统计SQL的查询成本 SHOW STATUS LIKE \u0026#39;last_query_cost\u0026#39;; 使用场景：它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。\nSQL 查询是一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论：\n位置决定效率。如果页就在数据库缓冲池中，那么效率是最高的，否则还需要从内存或者磁盘中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。 批量决定效率。如果我们从磁盘中对单一页进行随机读，那么效率是很低的（差不多10ms），而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。 所以说，遇到I/O并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是经常使用的数据就要尽量放到缓冲池中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。\n定位慢SQL 1. 开启慢查询日志参数 set global slow_query_log=\u0026#39;ON\u0026#39;; # 查看 慢日志文件位置 show variables like `%slow_query_log%`; 2. 修改long_query_time阈值 # 该参数设置之后，仅对新连接的会话有效 set global long_query_time = 1; show global variables like \u0026#39;%long_query_time%\u0026#39;; # 对当前会话生效 set long_query_time=1; show variables like \u0026#39;%long_query_time%\u0026#39;; # 如果一直生效的话 该配置文件，重启 3. 查看慢查询数目 SHOW GLOBAL STATUS LIKE \u0026#39;%Slow_queries%\u0026#39;; 4. 慢查询日志分析工具 mysqldumpslow #得到返回记录集最多的10个SQL mysqldumpslow -s r -t 10 /var/lib/mysql/mysql-log.log #得到访问次数最多的10个SQL mysqldumpslow -s c -t 10 /var/lib/mysql/mysql-log.log #得到按照时间排序的前10条里面含有左连接的查询语句 mysqldumpslow -s t -t 10 -g \u0026#34;left join\u0026#34; /var/lib/mysql/mysql-log.log #另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况 mysqldumpslow -s r -t 10 /var/lib/mysql/mysql-log | more 5. 关闭慢查询日志 开发当中，如果不涉及调优尽量关闭\n永久关闭\n[mysqld] slow_query_log=OFF #或 [mysqld] #slow_query_log =OFF 重启服务器 临时关闭\nSET GLOBAL slow_query_log=off; 查看SQL执行成本 - profiling show variables like \u0026#39;profiling\u0026#39;; #开启 set profiling = \u0026#39;ON\u0026#39;; #查看 show profiles; show profile cpu,block io for query 2; profiling 常用参数\n日常开发注意点：\nconvert heap to MyISAM: 查询结果太大，内存不够，落盘 Creating tmp table: 创建临时表。先拷贝数据到临时表，用完后在删除临时表 Coping to tmp table on disk: 把内存中临时表复制到磁盘上 locked 如果在show profile诊断结果中出现了以上4条结果中的任何一条，则sql语句需要优化\n注意：show profile 命令将弃用，可以从information_schema中的profiling数据表进行查看\n分析查询语句 EXPLAIN EXPLAIN SELECT select_options #或者 DESCRIBE SELECT select_options EXPLAIN 语句输出的各个列的作用如下：\n列名 描述 id 在一个大的查询语句中每个SELECT关键字都对应一个唯一的id select_type SELECT关键字对应的那个查询的类型 table 表名 partitions 匹配的分区信息 type 针对单表的访问方法 possible_keys 可能用到的索引 key 实际上使用的索引 key_len 实际使用到的索引长度 ref 当使用索引列等值查询时，与索引列进行等值匹配的对象信息 rows 预估的需要读取的记录条数 filtered 某个表经过搜索条件过滤后剩余记录条数的百分比 Extra 一些额外的信息 Explain各列作用 1. table 记录查询时候的表名，MySQL规定EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，有时候不是真实的名字，可能是简称。排在前面的是驱动表，排在后面的是被驱动表\n2. id 在一个大的查询每个select 关键字对应一个id, 但并不是绝对。SQL优化器会帮我们优化。\nid如果相同，可以认为是一组，从上往下顺序执行 在所有组中，id值越大，优先级越高，越先执行 关注点：id号每个号码，表示一趟独立的查询,一个sql的查询趟数越少越好 3. select type MySQL为每一个SELECT关键字代表的小查询都定义了select_type属性。表示这小查询在大查询里面扮演着什么角色。\nselect type 描述 SIMPLE 简单的SELECT语句（不包括UNION操作或子查询操作） PRIMARY 查询中最外层的SELECT（如两表做UNION或者存在子查询的外层的表操作为PRIMARY，内层的操作为UNION） UNION UNION操作中，查询中处于内层的SELECT（内层的SELECT语句与外层的SELECT语句没有依赖关系） DEPENDENT UNION UNION操作中，查询中处于内层的SELECT（内层的SELECT语句与外层的SELECT语句有依赖关系） 相关子查询 UNION RESULT UNION操作的结果，id值通常为NULL SUBQUERY 子查询中首个SELECT（如果有多个子查询存在） DEPENDENT SUBQUERY 子查询中首个SELECT，但依赖于外层的表（如果有多个子查询存在） DERIVED 被驱动的SELECT子查询（子查询位于FROM子句） MATERIALIZED 被物化的子查询 UNCACHEABLE SUBQUERY 对于外层的主表，子查询不可被物化，每次都需要计算（耗时操作） UNCACHEABLE UNION UNION操作中，内层的不可被物化的子查询（类似于UNCACHEABLE SUBQUERY） 4. partitions 代表分区的命中情况，非分区表，该项为null\n5. type - 关键点 结果值从最好到最坏依次是： system \u0026gt; const \u0026gt; eq_ref \u0026gt; ref \u0026gt; fulltext \u0026gt; ref_or_null \u0026gt; index_merge \u0026gt; unique_subquery \u0026gt; index_subquery \u0026gt; range \u0026gt; index \u0026gt; ALL\nSQL性能优化的目标：至少要达到 range级别，要求是ref级别，最好是consts级别。\n6. possible_keys和key possible_keys: 可能使用到的key, 并不是越多越好，需要筛选\nkey: 使用到的key\n7. key_len - 关键点 多数场景对于联合索引，使用到的索引长度。越大越好\n计算公式：\nvarchar(10)变长字段且允许NULL = 10 * ( character set： utf8=3,gbk=2,latin1=1)+1(NULL)+2(变长字段) varchar(10)变长字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+2(变长字段) char(10)固定字段且允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+1(NULL) char(10)固定字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1) 8. ref 当使用索引列等值查询时候，与索引列匹配的对象信息\n9. rows 需要读取的记录条数。该值越小越好\n10. filtered 某个表经过搜索条件后过滤剩下的记录条数百分比。越大越好\n对于单表查询来说，filtered值没有什么意义，但对于连接查询来说。驱动表对应执行计划的filtered值，它决定了被驱动表要执行的次数（rows * filtered)\n11. Extra 一些额外的信息，非常多。更准确的理解MySQL到底如何执行给定的查询语句\n类型 描述 distinct 在select部分使用了distinc关键字 Using index Condition 使用到了索引下推 Using where 表明使用了where过滤 Using join buffer 表明使用了连接缓存 impossible where where子句的值总是false，不能用来获取任何元组 no tables used 不带from字句的查询或者From dual查询。 使用not in()形式子查询或not exists运算符的连接查询，这种叫做反连接。即，一般连接查询是先查询内表，再查询外表，反连接就是先查询外表，再查询内表。 using filesort 排序时无法使用到索引时，就会出现这个。常见于order by和group by语句中 using index 查询时不需要回表查询，直接通过索引就可以获取查询的数据。 using_union 表示使用or连接各个使用索引的条件时，该信息表示从处理结果获取并集 using intersect 表示使用and的各个索引的条件时，该信息表示是从处理结果获取交集 using sort_union和using sort_intersection 与前面两个对应的类似，只是他们是出现在用and和or查询信息量大时，先查询主键，然后进行排序合并后，才能读取记录并返回。 using temporary 表示使用了临时表存储中间结果。临时表可以是内存临时表和磁盘临时表，执行计划中看不出来，需要查看status变量，used_tmp_table，used_tmp_disk_table才能看出来 filtered 使用explain extended时会出现这个列，5.7之后的版本默认就有这个字段，不需要使用explain extended了。这个字段表示存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例，注意是百分比，不是具体记录数 Using index:\n覆盖索引：根据索引查找，由于select字段在B+树叶子节点已经存在，直接使用索引查找。\n索引下推: 假设查询语句中含有类似like语句 根据索引查找到主键，主键在回表查找，匹配对应like字段，这种方式会产生随机IO。另外一种做法是在索引字段上进行like匹配，之后再次回表查询，使用到了索引下推。\n示例测试SQL数据\nExplain四种格式 传统格式 不加任何关键字信息\nJSON格式 explain format=JSON QUERY, 这里可以查看执行成本cost_info信息\nTree格式 TREE格式是8.0.16版本之后引入的新格式，主要根据查询的各个部分之间的关系和各部分的执行顺序来描述如何查询。\n可视化格式 借助WorkBench\nSHOW WARNINGS的使用 执行完Explain之后，可以使用SHOW WARNINGS,查看优化后执行的sql语句\n分析优化器执行计划 - Trace Trace是5.6追踪MySQL优化器执行过程\n# 开启 SET optimizer_trace=\u0026#34;enabled=on\u0026#34;,end_markers_in_json=on; # 设置大小 set optimizer_trace_max_mem_size=1000000; # 使用 select * from student where id \u0026lt; 10; select * from information_schema.optimizer_trace\\G 监控视图 sys schema -- 索引相关 #1. 查询冗余索引 select * from sys.schema_redundant_indexes; #2. 查询未使用过的索引 select * from sys.schema_unused_indexes; #3. 查询索引的使用情况 select index_name,rows_selected,rows_inserted,rows_updated,rows_deleted from sys.schema_index_statistics where table_schema=\u0026#39;dbname\u0026#39; ; -- 表相关 # 1. 查询表的访问量 select table_schema,table_name,sum(io_read_requests+io_write_requests) as io from sys.schema_table_statistics group by table_schema,table_name order by io desc; # 2. 查询占用bufferpool较多的表 select object_schema,object_name,allocated,data from sys.innodb_buffer_stats_by_table order by allocated limit 10; # 3. 查看表的全表扫描情况 select * from sys.statements_with_full_table_scans where db=\u0026#39;dbname\u0026#39;; -- 语句相关 #1. 监控SQL执行的频率 select db,exec_count,query from sys.statement_analysis order by exec_count desc; #2. 监控使用了排序的SQL select db,exec_count,first_seen,last_seen,query from sys.statements_with_sorting limit 1; #3. 监控使用了临时表或者磁盘临时表的SQL select db,exec_count,tmp_tables,tmp_disk_tables,query from sys.statement_analysis where tmp_tables\u0026gt;0 or tmp_disk_tables \u0026gt;0 order by (tmp_tables+tmp_disk_tables) desc; -- io相关 #1. 查看消耗磁盘IO的文件 select file,avg_read,avg_write,avg_read+avg_write as avg_io from sys.io_global_by_file_by_bytes order by avg_read limit 10; -- innodb相关 #1. 行锁阻塞情况 select * from sys.innodb_lock_waits; 索引优化与查询优化 物理查询优化： 索引、表连接 逻辑查询优化: 通过SQL等价变换提升查询效率，换一种写法 大多数情况下都（默认）采用B+树来构建索引。只是空间列类型的索引使用R-树，并且MEMORY表还支持hash索引。\n其实，用不用索引，最终都是优化器说了算。优化器是基于什么的优化器？基于cost开销(CostBaseOptimizer)，它不是基于规则(Rule-BasedOptimizer)，也不是基于语义。怎么样开销小就怎么来。另外，SQL语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。\n索引失效场景 任何时候都不是绝对的，基于成本分析\n全值匹配 按照索引进行匹配，不会失效\n最佳左前缀法则 - age建立索引 name建立索引 使用 EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age = 30 AND student.name = \u0026#39;abcd\u0026#39;;\t-- 只有索引age classid name 下面不会使用索引 但现在没有这样的索引，idx_age_classid_name的字段顺序是先找age，所以不符合，所以此时不能用索引 EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.classid = 1 AND student.name = \u0026#39;abcd\u0026#39;;\tEXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age = 30 AND student.name = \u0026#39;abcd\u0026#39;; # 现在，删除idx_age和idx_age_classid，发现用到idx_age_classid_name，而key_len=5,即只用到age字段，int(4)+null(1) #因为索引完age后没有classid了，不能再查找到name 在MySQL建立联合索引时会遵守最佳左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。\n结论：MySQL可以为多个字段创建索引，一个索引可以包括16个字段。对于多列索引，**过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。**如果查询条件中没有使用这些字段中第1个字段时，多列（或联合）索引不会被使用。\n主键插入顺序 在定义表时，让主键auto_increment，否则，插入一条数据时可能会移动大量数据。 如，往 1 5 8 10 15 … 100 中插9，会放在8 10 中间，因为索引默认升序排列。那么10往后的数据都要挪动，页不够时又要放到下一页，每插一条数据都这样挪一次，开销很大 我们自定义的主键列id 拥有AUTO_INCREMENT 属性，在插入记录时存储引擎会自动为我们填入自增的主键值。这样的主键占用空间小，顺序写入，减少页分裂。\n计算、函数、类型转换(自动或手动)导致索引失效 ##### 例1：3 EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name LIKE \u0026#39;abc%\u0026#39;;\t#更好，能够使用上索引 # type=range 使用了索引中的排序 EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name,3) = \u0026#39;abc\u0026#39;;\t# left(text,num_chars):截取左侧n个字符 # type = all 全表的访问 # 该语句的执行过程：针对每一条数据，一个一个取出，先作用一遍函数，再拿函数结果与abc对比，用不上b+树 CREATE INDEX idx_name ON student(NAME); ##### 例2： CREATE INDEX idx_sno ON student(stuno); EXPLAIN SELECT SQL_NO_CACHE id,stuno,NAME FROM student WHERE stuno+1 = 900001; # type = all 需要做运算，无法直接用索引找值 EXPLAIN SELECT SQL_NO_CACHE id,stuno,NAME FROM student WHERE stuno = 900000; # type = ref 类型转换导致索引失效 # 未使用到索引 EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE NAME=123;\t# 这里使用了隐式转换 # 使用到索引 EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE NAME=\u0026#39;123\u0026#39;; # name本身就是字符串类型 范围条件右边的列索引失效 -- 存在索引 age classId name 但是下面只会使用到 age classId EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age = 30 AND student.classId \u0026gt; 20 AND student.name = \u0026#39;abc\u0026#39;;\t--改写 添加所以你 age name classId 使用到了索引 EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age = 30 AND student.name = \u0026#39;abc\u0026#39; AND student.classId \u0026gt; 20 ;\t创建的联合索引中，必须把涉及到范围的字段写在最后。 不等于(!= 或者\u0026lt;\u0026gt;)索引失效 -- 不等于(!= 或者\u0026lt;\u0026gt;)索引失效 CREATE INDEX idx_name ON student(NAME); EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name \u0026lt;\u0026gt; \u0026#39;abc\u0026#39;;\t# 索引失效 索引查的是等于 这里是* 结论：最好在设计表结构的时候将字段设置为not null约束，比如可以将int 默认值设置成0。 将字符类型设置为空字符串\n同理：在查询中not like 也无法使用到索引，导致全表扫描\nis null 可以使用索引 is not null 无法使用索引 is null : 触发索引\nlike以通配符%开头索引失效 # like以通配符%开头索引失效 EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE NAME LIKE \u0026#39;ab%\u0026#39;;\t# 可用索引 EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE NAME LIKE \u0026#39;%ab\u0026#39;;\t# type = all 索引失效 页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。\nOR 前后存在非索引的列，索引失效 EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 10 OR classid = 100;\t# 未使用索引，索引+全表扫描-\u0026gt;全表扫描 -- age是存在索引的，classId是没有索引的，导致全表all -- 给classId添加索引 此时type为 index_merge,key = idx_age,idx_cid 数据库和表的字符集统一使用utf8mb4 统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的字符集进行比较前需要进行转换会造成索引失效。\n总结：\n对于单利索引，进来选择对当前query过滤更好的索引 对于选择组合索引，对当前query过滤更好的索引字段顺序中，位置越靠前越好 在选择组合索引，尽量选择能够包含当前query的where字句中更多字段的索引 在选择组合索引，如果某个字段包含范围查询，尽量把这个字段放在索引次序的最后面 关联查询优化 外连接的关联条件中，两个关联字段的类型、字符集一定要保持一致，否则索引会失效。外连接查询优化器也会做驱动表与被驱动表的修改。\n结论1：对于内连接来说，查询优化器可以决定谁来作为驱动表，谁作为被驱动表出现\n结论2：对于内连接来讲，如果表的连接条件中只能有一个字段有索引，则有索引的字段所在的表会被作为被驱动表\n结论3：对于内连接来说，在两个表的连接条件都存在索引的情况下，会选择小表作为驱动表。小表驱动大表\n内连接优化器可以决定（被）驱动表。在只有一个表存在索引的情况下，会选择存在索引的表作为被驱动表(因为被驱动表查询次数更多，建立索引以后可以避免全表扫描)\nJOIN的底层原理 1. 驱动表与被驱动表 驱动表就是主表，被驱动表就是从表\n内连接，外连接优化器会根据优化结果选择先查询哪张表，这张表就是主表驱动表。\n2. Simple Nested Loop Join 简单嵌套循环连接 算法过程：从A表取出一条数据，遍历B表所有数据进行匹配。驱动表A每一条记录与B进行匹配\n效率非常低\n3. Index Nested Loop Join 索引嵌套循环 优化思路是减少内层表的数据匹配次数，所以要求对被驱动表建立索引。这样查询的转换成B+树的高度。通过外层表匹配条件直接与内层索引进行匹配，避免和内层表的每条记录进行比较，这样极大地减少了对内层表的匹配次数。 驱动表中的每条记录通过被驱动表的索引进行访问，因为索引查询的成本是比较固定的，故 MySQL 优化器都倾向于使用有索引的表作为被驱动表（减少被驱动表的多次全表扫描）\n如果被驱动表加索引，效率是非常高的，如果索引不是主键索引，所以还得进行一次回表查询。相比，被驱动表的索引是主键索引，效率会更高\n4. Blocked Nested Loop Join 块嵌套循环连接 如果存在索引，使用INLJ进行，如果join列没有索引，匹配的扫描次数又大大增加。每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把驱动表的记录再加载到内存匹配，这样周而复始，大大增加了 IO 次数。为了减少被驱动表的 IO 次数，就出现了 Block Nested-Loop Join 的方式。\n不再是逐条获取驱动表的数据，而是一块一块的获取，引入了 join buffer 缓冲区，将驱动表 join 相关的部分数据列（大小受 join buffer 的限制）缓存到 join buffer 中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和 join buffer 中的所有驱动表记录进行匹配（内存中操作），将简单嵌套循环中的多次比较合并成一次，降低了被动表的访问频率。\n注意： 这里缓存的不只是关联表的列，select 后面的列也会缓存起来 在一个有 N 个 join 关联的 SQL 中会分配 N-1 个 join buffer。所以查询的时候尽量减少不必要的字段，可以 让 join buffer 中存放更多的列。 Join Buffe参数设置\nblock_nested_loop\n通过 show variables like '%optimizer_switch%' 查看 block_nested_loop 状态。默认是开启的。\njoin_buffer_size\n驱动表能不能一次加载完，要看 join buffer 能不能存储所有的数据，默认情况下 join_buffer_size = 256K。\njoin buffer size 的最大值在 32 位系统可以申请 4G，而在 64 位操做系统下可以申请大于 4G 的 join_buffer空间（64 位 Windows 除外，其大值会被截断为 4GB并发出警告）。\n小结 保证被驱动表的 JOIN 字段已经创建了索引（减少内层表的循环匹配次数） 需要 JOIN 的字段，数据类型保持绝对一致。 LEFT JOIN 时，选择小表作为驱动表， 大表作为被驱动表 。减少外层循环的次数。 INNER JOIN 时，MySQL 会自动将小结果集的表选为驱动表 。选择相信 MySQL 优化策略。 能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数) 不建议使用多层嵌套子查询，建议将子查询 SQL 拆开结合程序多次查询，或使用 JOIN 来代替子查询。 衍生表建不了索引 默认效率比较：INLJ \u0026gt; BNLJ \u0026gt; SNLJ 正确理解小表驱动大表：大小不是指表中的记录数，而是永远用小结果集驱动大结果集（其本质就是减少外层循环的数据数量）。 比如A表有100条记录，B表有1000条记录，但是where条件过滤后，B表结果集只留下50个记录，A表结果集有80条记录，此时就可能是B表驱动A表。其实上面的例子还是不够准确，因为结果集的大小也不能粗略的用结果集的行数表示，而是表行数 每行大小。其实要理解你只需要结合Join Buffer就好了，因为表行数 每行大小越小，其占用内存越小,就可以在Join Buffer中尽量少的次数加载完了。 HashJoin 从 MySQL 8.0.20 版本开始将废弃 BNLJ，因为加入了 hash join 默认都会使用 hash join\nNested Loop：\n对于被连接的数据子集较小的情况，Nested Loop 是个较好的选择。\nHash Join 是做 大数据集连接 时的常用方法，优化器使用两个表中较小（相对较小）的表利用 join key 在内存中建立 散列表，然后扫描较大的表并探测散列表，找出与 Hash 表匹配的行。\n这种方式适用于较小的表完全可以放于内存中的情况，这样总成本就是访问两个表的成本之和 在表很大的情况下并不能完全放入内存，这时优化器会将它分割成 若干不同的分区，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高 I/O 的性能。 它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。大多数人都说它是 Join 的重型升降机。Hash Join 只能应用于等值连接（如 WHERE A.COL1 = B.COL2），这是由 Hash 的特点决定的。 类型 Nested Loop Hash Join 使用条件 任何条件 等值连接（=） 相关资源 CPU、磁盘 I/O 内存、临时空间 特点 当有高选择性索引或进行限制性搜索时效率比较高，能够快速返回第一次的搜索结果 当缺乏索引或者索引条件模糊时，Hash Join 比 Nested Loop 有效。在数据仓库环境下，如果表的记录数多，效率高 缺点 当索引丢失或者查询条件限制不够时，效率很低；当表的记录数较多，效率低 为遍历哈希表，需要大量内存。第一次的结果返回较慢 子查询优化 MySQL 从 4.1 版本开始支持子查询，使用子查询可以进行 SELECT 语句的嵌套查询，即一个 SELECT 查询的结果作为另一个 SELECT 语句的条件。子查询可以一次性完成很多逻辑上需要多个步骤才能完成的操作 。\n子查询是 MySQL 的一项重要的功能，可以帮助我们通过一个 SQL 语句实现比较复杂的查询。但是，子查询的执行效率不高。\n原因:\n执行子查询时，MySQL 需要为内层查询语句的查询结果建立一个临时表 ，然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表 。这样会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都 不会存在索引 ，所以查询性能会受到一定的影响。 对于返回结果集比较大的子查询，其对查询性能的影响也就越大。 在 MySQL 中，可以使用连接（JOIN）查询来替代子查询。 连接查询 不需要建立临时表，其 速度比子查询要快，如果查询中使用索引的话，性能就会更好。\n#创建班级表中班长的索引 CREATE INDEX idx_monitor ON class(monitor); #查询班长的信息 EXPLAIN SELECT * FROM student stu1 WHERE stu1.`stuno` IN ( SELECT monitor FROM class c WHERE monitor IS NOT NULL ); -- 改写 EXPLAIN SELECT stu1.* FROM student stu1 JOIN class c ON stu1.`stuno` = c.`monitor` WHERE c.`monitor` IS NOT NULL; #查询不为班长的学生信息 EXPLAIN SELECT SQL_NO_CACHE a.* FROM student a WHERE a.stuno NOT IN ( SELECT monitor FROM class b WHERE monitor IS NOT NULL); -- 改写 EXPLAIN SELECT SQL_NO_CACHE a.* FROM student a LEFT OUTER JOIN class b ON a.stuno =b.monitor WHERE b.monitor IS NULL; TIP：尽量不要使用 NOT IN 或者 NOT EXISTS，用 LEFT JOIN xxx ON xx WHERE xx IS NULL 替代\n排序优化 问题：在 WHERE 条件字段上加索引，但是为什么在 ORDER BY 字段上还要加索引呢？\n在 MySQL 中，支持两种排序方式，分别是 FileSort 和 Index 排序。 Index 排序中，索引可以保证数据的有序性，就不需要再进行排序，效率更更高。 FileSort 排序则一般在 内存中 进行排序，占用 CPU 较多。如果待排序的结果较大，会产生临时文件 I/O 到磁盘进行排序的情况，效率低。 优化建议:\nSQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中 避免全表扫描，在 ORDER BY 子句 避免使用 FileSort 排序。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。 尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列；如果不同就使用联合索引。 无法使用 Index 时，需要对 FileSort 方式进行调优。 -- 当前age classId,name 是有索引的 EXPLAIN SELECT SQL_NO_CACHE * FROM student ORDER BY age,classid; 1\tSIMPLE\tstudent\tALL\t498881\t100.00\tUsing filesort -- 没有使用索引的原因是，优化器通过计算分析，发现最终还是需要回表，使用索引的性能代价反而比不上不用索引的 EXPLAIN SELECT SQL_NO_CACHE age,classid,name,id FROM student ORDER BY age,classid; -- 这里就使用到了索引,覆盖索引 EXPLAIN SELECT SQL_NO_CACHE * FROM student ORDER BY age,classid LIMIT 10; -- 使用limit使用到了索引，因为优化器发现只需要10条，先根据索引查询，在回表返回10条数据 order by 时顺序错误，索引失效 order by 时规则不一致, 索引失效 （顺序错，不索引；方向反，不索引） 规则： 同时升序或者同时降序 顺序：索引建立的顺序 无过滤，不索引 上述是与其数据量有关的\nINDEX a_b_c(a,b,c) order by 能使用索引最左前缀\nORDER BY a ORDER BY a,b ORDER BY a,b,c ORDER BY a DESC,b DESC,c DESC 如果 WHERE 使用索引的最左前缀定义为常量，则 order by 能使用索引 WHERE a = const ORDER BY b,c WHERE a = const AND b = const ORDER BY c WHERE a = const ORDER BY b,c WHERE a = const AND b \u0026gt; const ORDER BY b,c 不能使用索引进行排序\nORDER BY a ASC,b DESC,c DESC /* 排序不一致 */ WHERE g = const ORDER BY b,c /丢失a索引/ WHERE a = const ORDER BY c /丢失b索引/ WHERE a = const ORDER BY a,d /d不是索引的一部分/ WHERE a in (…) ORDER BY b,c /对于排序来说，多个相等条件也是范围查询 filesort算法 排序的字段不在索引列上，filesort会有两种算法: 双路排序和单路排序\n双路排序 - 慢\nMySQL4.1之前使用双路排序。两次扫描磁盘，最终得到数据。读取行指针和order by 列，然后从扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出。从磁盘读取字段，在buffer排序，在从磁盘读取其他字段，产生随机IO,比较耗时\n单路排序 - 块 从磁盘读取查询需要的 所有列 ，按照 order by 列在 buffer 对它们进行排序，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据。并且把随机 IO 变成了顺序 IO，但是它会使用更多的空间， 因为它把每一行都保存在内存中了。\n由于单路是后出的，总体而言好过双路 但是用单路有问题 在 sort_buffer 中，单路比多路要 多占用很多空间，因为单路是把所有字段都取出，所以可能取出的数据的总大小超出了 sort_buffer 的容量，导致每次只能取 sort_buffer 容量大小的数据，进行排序（创建 temp 文件，多路合并），排完再取 sort_buffer 容量大小，再排…从而多次I/O。 单路本来想省一次 I/O 操作，反而导致了大量的 I/O 操作，反而得不偿失。\n优化策略：\n提高 sort_buffer_size 提高max_length_for_sort_data SHOW VARIABLES LIKE \u0026lsquo;%max_length_for_sort_data%\u0026rsquo;; 但是如果设的太高，数据总容量超出 sort_buffer_size 的概率就增大，明显症状是高的磁盘 I/O 活动和低的处理器使用率。如果需要返回的列的总长度大于 max_length_for_sort_data，使用双路算法，否则使用单路算法。1024-8192字节之间调整。\nOrder by 时 select 是一个大忌。最好只Query需要的字段。\n当 Query 的字段大小综合小于 max_length_for_sort_data，而且排序字段不是 TEXT|BLOG 类型时，会改进后的算法——单路排序，否则用老算法——多路排序。 两种算法的数据都有可能超出 sort_buffer_size 的容量，超出之后，会创建 tmp 文件进行合并排序，导致多次 I/O，但是用单路排序算法的风险会更大一些，所以要提高 sort_buffer_size\nGroup By优化 group by 使用索引的原则几乎跟 order by 一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引。\ngroup by 先排序再分组，遵照索引建的最佳左前缀法则\n当无法使用索引列，增大 max_length_for_sort_data 和 sort_buffer_size 参数的设置\nwhere 效率高于 having，能写在 where 限定的条件就不要写在 having 中了\n减少使用 order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct 这些语句较为耗费 CPU，数据库的 CPU 资源是极其宝贵的\n包含了 order by、group by、distinct 这些查询的语句，where 条件过滤出来的结果集请保持在 1000 行以内，否则 SQL 会很慢\n分页查询优化 一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见有非常头疼的问题就是 limit 2000000,10，此时需要 MySQL 排序前 2000010 记录，仅仅返回 2000000-2000010 的记录，其他记录丢弃，查询排序的代价非常大。\nEXPLAIN SELECT * FROM student LIMIT 2000000,10; 优化思路1 该方案适用于主键自增的表，可以把 Limit 查询转换成某个位置的查询\nEXPLAIN SELECT * FROM student WHERE id \u0026gt; 2000000 LIMIT 10; 优化思路2 在索引完成排序分页操作，最后根据主键关联到原表进行查询所需要的其它列内容\nEXPLAIN SELECT * FROM student t,(SELECT id FROM student order by id limit 2000000, 10) a where t.id = a.id 覆盖索引 覆盖索引的定义 索引列+主键 包含 SELECT 到 FROM 之间查询的列，不需要进行回表\n定义规则，再进行打破\n利弊 好处 避免InnoDB表进行回表 在覆盖索引中，二级索引的键值中可以获取所要的数据，避免了对主键的二次查询，减少了 IO 操作，提升了查询效率。 把随机IO变成顺序IO 由于覆盖索引是按键值的顺序存储的，对于 I/O 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 I/O 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 I/O 转变成索引查找的顺序 I/O。 由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。 弊端 索引字段的维护 总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务 DBA，或者称为业务数据架构师的工作。\n索引条件下推 需要回表，条件下推才有意义，如果是聚餐索引查询或者覆盖索引使用不到\n索引下推（Index Condition Pushdown, 简称ICP）是MySQL 5.6 版本的新特性，它能减少回表查询次数，提升检索效率。\n使用前后 在不使用ICP索引扫描的过程：\nstorage层：只将满足index key条件的索引记录对应的整行记录取出，返回给server层\nserver 层：对返回的数据，使用后面的where条件过滤，直至返回最后一行。\n使用ICP扫描的过程：\nstorage层：首先将index key条件满足的索引记录区间确定，然后在索引上使用index filter进行过滤。将满足的index filter条件的索引记录才去回表取出整行记录返回server层。不满足index filter条件的索引记录丢弃，不回表、也不会返回server层。\nserver 层：对返回的数据，使用table filter条件做最后的过滤。\n适用条件 当需要访问整表行时，ICP用于range、ref、eq_ref和ref_or_null访问方法。 ICP可以用于InnoDB和MyISAM表，包括分区的InnoDB和MyISAM表。 对于InnoDB表，ICP仅用于二级索引。ICP的目标是减少整行读取的数量，从而减少I/O操作。对于InnoDB聚集索引，完整的记录已经读入InnoDB缓冲区。在这种情况下使用ICP并不能减少I/O。（注意：Ⅰ说明减少完整记录（一条完整元组）读取的个数；Ⅱ是说明对于InnoDB聚集索引无效，只能是对SECOND INDEX这样的非聚集索引有效。） 在虚拟生成的列上创建的辅助索引不支持ICP。InnoDB支持虚拟生成列的二级索引。 引用子查询的条件不能向下推。 引用存储函数的条件不能向下推。存储引擎不能调用存储函数。 触发条件不能下推。 ICP的开启和关闭 索引条件默认启用“下推”。可以通过设置index_condition_pushdown标志来控制optimizer_switch系统变量: SET optimizer_switch = \u0026#39;index_condition_pushdown=off\u0026#39;; SET optimizer_switch = \u0026#39;index_condition_pushdown=on\u0026#39;; 其他查询优化策略 exists 与 in 区分 # 大表A驱动小表cc时用in；即当A表的数据量大于B表的数据量时 SELECT * FROM A WHERE cc IN (SELECT CC FROM B); # 当A表的数据量小于B表的数据量时 # 小表A驱动大表cc时用EXISTS ，因为执行时每次是从A中取一条数据到SELECT cc FROM B WHERE B.cc = a.cc中执行，A小一点更合适 SELECT * FROM A WHERE EXISTS (SELECT cc FROM B WHERE B.cc = a.cc) COUNT(*)与COUNT(具体字段)效率 COUNT(*)与COUNT(1)都是统计表的所有数量，效率差别不大 如果使用MyISAM存储引擎，统计数据表的行数只需要O(1)的复杂度 如果使用InnoDB存储引擎，使用O(n)的复杂度 在InnoDB存储引擎中，如果使用Count(具体字段)来统计数据行数，尽量采用二级索引，如果没有二级索引，才使用主键索引来使用 select 字段 在表查询中，建议明确字段，不要使用*作为查询的字段列表，推荐使用SELECT\u0026lt;字段列表\u0026gt;查询。原因： ①MySQL在解析的过程中，会通过查询数据字典将\u0026#34;*\u0026#34;按序转换成所有列名，这会大大的耗费资源和时间。 ②无法使用覆盖索引 limit 1 对优化的影响 针对的是会扫描全表的SQL语句，如果你可以确定结果集只有一条，那么加上LIMIT 1 的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。 如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上LIMIT 1 了。 多使用COMMIT 只要有可能，在程序中尽量多使用COMMIT，这样程序的性能得到提高，需求也会因为COMMIT所释放的资源而减少。 COMMIT所释放的资源： 回滚段上用于恢复数据的信息 被程序语句获得的锁 redo/ undo log buffer 中的空间 管理上述3种资源中的内部花费 淘宝数据库主键如何设计 自增ID问题 业务系统做主键 尽量不要用根业务有关的字段做主键，比较作为项目的设计人员，我们谁也无法预测在项目的整个生命周期中，哪个业务字段会因为业务的需求有重复，或者重用的情况出现。\n刚开始使用MySQL时候，很多人都很容易犯的错误喜欢用业务字段做主键，想当然的认为了解业务需求，但实际情况往往出乎意料，而更改主键设置的成本非常高\n淘宝的主键设计 订单ID = 时间 + 去重字段 + 用户ID后6位尾号\n推荐的主键设计 主键设计至少应该是全局唯一且是单调递增。 UUID SELECT uuid() FROM DUAL; 特点 全局唯一，占用36字节，数据无序，插入性能查\nMySQL UUID组成 UUID = 时间+UUID版本（16字节）- 时钟序列（4字节） - MAC地址（12字节）\n改造UUID MySQL 8.0可以更换时间低位和时间高位的存储方式，这样UUID就是有序的UUID了。 如果不是MySQL8.0 如何解决 手动赋值字段做主键\n","permalink":"https://AlfredNing.github.io/note/program/sql/mysql/mysql%E9%AB%98%E7%BA%A7-%E5%88%86%E6%9E%90_%E7%B4%A2%E5%BC%95/","summary":"索引 索引的分类 从功能逻辑划分 普通索引 唯一索引 主键索引 全文索引 从物理实现方法划分 聚簇索引 非聚簇索引 从作用字段划分 单列索引 联合索引 InnoDB: 支持B-Tree，FullText索引，不支持Hash索引\nMyISAM: 支持B-Tree，FullText索引，不支持Hash索引\nMemory: 支持B-Tree，Hash索引，不支持FullText索引\nNDB: 支持Hash索引，不支持 B-Tree, FullText索引\nArchive: 不支持 B-Tree, FullText,Hash索引\n创建索引 方式1- 创建表时候指定 普通索引 CREATE TABLE book( book_id INT , book_name VARCHAR(100), authors VARCHAR(100), info VARCHAR(100) , comment VARCHAR(100), year_publication YEAR, INDEX(year_publication) ); 创建唯一索引 CREATE TABLE test1( id INT NOT NULL, name varchar(30) NOT NULL, UNIQUE INDEX uk_idx_id(id) ); 主键索引 CREATE TABLE student ( id INT(10) UNSIGNED AUTO_INCREMENT, student_no VARCHAR(200), student_name VARCHAR(200), PRIMARY KEY(id) ); # 删除主键索引 ALTER TABLE student drop PRIMARY KEY ; 创建单列索引 CREATE TABLE test2( id INT NOT NULL, name CHAR(50) NULL, INDEX single_idx_name(name(20)) ); 创建组合索引 CREATE TABLE test3( id INT(11) NOT NULL, name CHAR(30) NOT NULL, age INT(11) NOT NULL, info VARCHAR(255), INDEX multi_idx(id,name,age) ); 全文索引 CREATE TABLE `papers` ( id` int(10) unsigned NOT NULL AUTO_INCREMENT, `title` varchar(200) DEFAULT NULL, `content` text, PRIMARY KEY (`id`), FULLTEXT KEY `title` (`title`,`content`) ) ENGINE=MyISAM DEFAULT CHARSET=utf8; SELECT * FROM papers WHERE MATCH(title,content) AGAINST (‘查询字符串’); 空间索引 CREATE TABLE test5( geo GEOMETRY NOT NULL, SPATIAL INDEX spa_idx_geo(geo) ) ENGINE=MyISAM; 方式2-已经创建表上的添加 alter 形式 ALTER TABLE table_name ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name[length],.","title":"MySql高级 索引_集群"},{"content":"前介 构建用户界面的渐进式的框架\n渐进式：可以在项目中一点点使用\n","permalink":"https://AlfredNing.github.io/note/program/front_end/vue/","summary":"前介 构建用户界面的渐进式的框架\n渐进式：可以在项目中一点点使用","title":"Vue"},{"content":" DDD是软件核心复杂性的应对之道\n调整程序的结构，该解耦的解耦，该拆分的拆分，在实现新的功能，才能保证设计质量\n运用DDD，当系统业务变得复杂，将对业务的理解绘制出领域模型正确知道软件开发\n微服务： 小而专\n软件开发方式 DL驱动开发 数据驱动设计 DDD驱动设计 DL驱动开发 DeadLine驱动开发，给定截至日期。我挂你他喵的写成什么样，完成就好。\n数据驱动设计 **良好的设计数据库表，**通过数据流串联对应的业务流程。适合小型系统，基本可以应付大多数的应用场景。\n确定对应的数据实体 完成库表设计 DDD领域驱动设计 应对软件架构复杂设计方法论\n整洁架构 软件退化 软件的本质是对真实世界的模拟 软件中业务逻辑正确与否的唯一标准就是是否与真实世界一致 软件要做成什么样，不由我们决定，也不用用户决定，而是由真实世界决定 产品为什么提出变更需求，因为他们对真实世界的理解也不是完全正确，跳过需要，建立在对真实世界理解的基础上进行开发。但认识真实世界是一件非常难的事情，最初只能认识真实世界中那些简单、清晰、易于理解的业务逻辑，完成该部分的软件 根源 第一版软件是完美的，但随后随着业务需求变动，软件的业务逻辑越来越接近真实世界，使得我们的软件越来越专业，同时业务逻辑也越来越复杂，软件规模也越来越大。简单软件有简单软件的设计，复杂软件有复杂软件的设计\n每次软件变更，逐步调整软件的程序结构，由简单程序转变为复杂程序结构，而不是一味的塞代码，赛代码才是最终根源。\n杜绝软件退化的两顶帽子 软件的发展规律是逐步从简单软件转换为复杂软件\n发生在每次新需求变更的时候，采用一下设计方法\n在不添加新功能的前提下，重构代码，调整原有程序结构，以适应新功能实现新的功能 实现新功能 过渡设计 每一种初始所谓的“灵活设计”只能应对一种需求变更，不能真正解决未来变更的问题，被称为“过度设计”\n活在今天的格子里，做今天的事。为当前的需求进行设计，使其刚刚满足当前的需求 解决思路：\n每次需求变更额设计，只有保证每次需求变更时候做出正确的设计，才能使得软件以良性循环维护下午\n两顶帽子的实现思路 困难的是第一步，如何调整程序设计以适应新功能\n多次变更，难以理清思路，设计开始迷失方向\n最终解决 领域驱动的思想： 将真实世界与软件世界进行对应。每次需求变更，将变更还原到真实世界，看看真实世界，在根据真实世界进行变更设计，保持领域驱动。\n领域驱动核心要求：领域模型 每次变更，先回到领域模型，基于业务进行领域模型的变更，然后在根据领域模型的变更指导程序变更\n电商功能演练DDD 首要需求 采用领域分析 先进行需求分析，设计领域模型\n领域模型图\n1. 需求变更 分析付款与折扣的关系？\n单一职责原则：软件系统中的每个元素都只负责自己职责范围内的事情，而将其他的事情交给别人去做，我只是去调用。\n职责如何定义？ 错误理解：做某件事，和这件事相关的一切所有的事都是它的职责\n正确理解：一个职责就是软件变化的原因\n什么是高质量的代码？\n用户提出需求变更，为了实现这个变更而修改软件的成本越低，软件的设计质量就越高。\n这就要求每次需求变更的时候只修改一个模块的代码来实现新需求。\n需要平时不断的整理代码，将因同一个原因而变更的代码放在一起，将因不同原因的代码而放在不同的模块中、不同类中。\n单一职责原则要求在维护软件的过程中需要不断的进行整理，将软件变化的同一个原因的代码放在一起，将软件变化的不同原因分开放。\n如何分析不同原因？\n答案是否定，说明是不同原因。\n2. 需求变更 答案是否定的\n3. 需求变更 支付方式变更\nDDD落地到数据库设计 早期系统设计 缺陷：\n先进行数据库设计，但数据库设计只能描述数据结构，而不能描述系统对这些数据结构的处理\n面向对象的软件设计系统设计 领域模型对象持久化 插入记录就是新增一个领域对象 修改就是根据key值去修改对应的领域对象 删除就是催毁这个领域对象 领域模型对象持久化存储的思想：将暂时不用的领域对象持久化存储到磁盘，再次使用这个领域对象，从数据库恢复成领域对象。\n数据库设计发生剧烈的变化，但唯一不变的是领域对象。数据操作底层发生变更，上层业务代码不修改\nDDD数据库设计的核心 以领域模型为核心，如何将领域模型转换成数据库的设计的过程。将类转换为表的过程\n关系转换 一对一 一对多 多对一 多对多 继承关系（上面四种属于传统关系） 一对一 多对一 一对多 多对多关系 领域模型总，无论功能还是属性，在命名都是采用中文 数据库设计，细化为英文命名，或者汉语拼音首字母，同时要确定字段类型是否为空等其他属性 继承关系 第一种方案 冗余设计\n表稀疏： 大量字段为空，浪费存储空间，影响查询速度\n第二种方案 采用主键生成器，公用同一个主键\n优缺点：\n单独查询一张表比较快，如果查询所有表就比较慢。\n第三种方案 NoSQL数据库的设计 需要join的查询，直接写到单表中进行分布式存储，这张表成为“宽表”\nDDD落地到程序设计 领域模型的最终落地是三种类型的对象：服务、实体、值对象\n设计思路：贫血模型与充血模式\n服务 标识在领域对象之外的操作行为，接收用户的请求和执行某些操作。\n当用户在界面发送请求，服务接收处理，最终将以实体或者值对象的数据持久化到数据库中\n实体 通过一个唯一标识字段来区分真实世界中每一个个体的领域对象。属性随着时间不断变化。\n值对象 代表的是真实世界中那些一成不变的、本质性的事物，这样的领域对象叫做“值对象”。如：行业、地理位置、币种、职位\n实体和值对象的区分 可变性是实体的特点，不变性是值对象的本质\n注意实体和值对象在不同业务设计下是不同的，例如菜单可以设计成实体，认为每个菜单都是不一样的。设计成值对象，认为所有的菜单都是一样的，进行应用\n将业务领域模型转换为程序设计 贫血模型 在软件设计中，有很多的pojo对象除了有一堆的get/set方法，几乎没有任何业务逻辑。\n变更成本提高\n充血模型 直接执行会员的打折方法，维护成本降低\n保持了领域模型的原貌，直接映射了程序的变更，保持了对象的封装性。\n两种模型对比 贫血模型比充血模型简单易行\n充血模型需要更强的OOA/D能力，分析业务、业务建模与设计能力\n充血模型需要有交强的团队协作能力\n贫血模型更容易应对复杂的业务处理场景，划分独立步骤，分给多个service串联进行执行\n工程实践选择 没有唯一的标准，适合才是最好的。\n将需要封装的业务逻辑放到领域对象，进行充血模型设计 除此之外的其他业务逻辑放到service中，按照贫血模型设计 需要封装的业务逻辑进行充血模型设计：\n领域模型中出现继承，多态的情况 在软件设计过程中，出现类型或者编码转换 表现领域对象之间的关系 “聚合”，在真实世界中那些代表整体与部分的事物 不必过多纠结于是实体还是值对象，更多的精力放在业务理解上，结合充血模型与贫血模式双重设计\n核心概念 聚合 表达的是整体与部分的关系。整体封装了部分的实例。\n识别整体与部分，当整体不存在，部分就变得没有意义。例如：订单包含订单明细。\n如何判断聚合关系：整体不存在，部分是是否存在。如果不存在就是聚合，反之，非聚合。\n对部分的操作必须是整体访问\n聚合根 外部系统访问内部的唯一标准。领域驱动设计适合增删改业务操作系统，不适合分析统计系统。\n仓库 之前设计，通过订单DAO与订单明细DAO完成数据库的保存，由订单service去添加事务保证。设计缺乏集合、缺乏封装性，不利于日后的维护。\n实现仓库对完成对数据库的访问\n仓库与订单访问DAO的区别 当数据添加或者查询数据库，都是查询访问单表 在领域建模设定对象之间的关系，将其设定为聚合 工厂 调用仓库，进行补填。\n通过仓库与工厂，对所有DAO进行了一层封装，加入聚合、装配将操作步骤封装起来，对上层的客户程序屏蔽\n聚合实现整体与部分的关系\n对缓存、对数据库的操作都封装在仓库与工厂中\n数据的查询通过工厂进行补填与装配，而不是通过之前的sql join\n限界上下文 将整个系统划分成\u0026quot;问题域\u0026quot;。如果某个子域复杂，可以划分成更多的子域。以子域模型为构建，称为限界上下文。\n单一职责原则：每个限界上下文中实现的都是软件变化同一个原因的业务。\n限界上下文的高内聚：每个限界上下文实现的功能都是软件变换的同一个原因的代码。\nDDD实现思路 业务分析 -\u0026gt; 战略设计 -\u0026gt; 战术设计：不同阶段的输出都是下一阶段的输入\n业务分析：在这个阶段需要集齐项目团队的成员主要包括领域专家、设计人员、开发人员等一起对业务问题域以及业务期望进行全面的梳理，厘请业务中的统一语言，在业务领域中发现领域事件、领域对象及其对应的领域行为，搞清楚他们各自的关联关系。\n战略设计：通过DDD的理论，对业务进行领域划分构建领域模型，梳理出相应的限界上下文，通过统一的领域语言从战略层面进行领域划分以及构建领域模型。在构建领域模型的过程中需要梳理出对应的聚合、实体、以及值对象。\n战术设计：以领域模型为战术设计的输入，以限界上下文作为微服务划分的边界进行微服务拆分，在每个微服务中进行领域分层，实现领域模型对于代码的映射，从而实现DDD的真正落地实施。\n相关概念 值对象：不需要唯一表示 实体： 具有唯一标识。 对应业务对象的业务属性和行为 值对象以及实体都是领域模型中的领域对象，是组成领域模型的基础元素，一起实现领域内的最基本的核心领域逻辑。\n聚合：有业务关联关系的的实体以及值对象的集合，通过实体、值对象以及各自之间的业务逻辑聚合在一起完成某个业务节点。根据业务的单一职责以及高内聚的设计原则来划分 聚合根: 是一类特殊实体，具备唯一标识，具有独立的声明周期。用来协调实体以及值对象完成业务逻辑的功能。保证聚合内的数据修改复核聚合中的业务规则。一个聚合只有一个聚合根，聚合根在聚合之内采用引用依赖的方式对实体和值对象进行组织和协调，聚合根和聚合根之间通过唯一id进行聚合之间的协同。 微服务拆分 微服务解决单点系统的可用性问题\n单体应用的问题 维护难 更新难 稳定难 拆分手段 业务能力 所谓业务能力就是平台的具体实现的业务功能是什么，这就好比在电商业务中物流域我们按照业务可以划分为仓储、运输、配送、计费等业务领域。大的领域划分出来之后，我们可以用真实的业务流程来串联这些业务领域。\n通用能力 对于微服务本身来说，通用能力就是将各个微服务都涉及到的通用能力进行抽象形成单独的微服务。但是对于整个业务平台来说，通用能力实际就是业务中台\n通用服务: 所谓通用服务就是在各个微服务之间都会碰到的问题，比如说接口的鉴权、日志的监控和管理、服务状态的监控和管理以及服务幂等等分布式系统问题 业务中台: 电商的业务形态有很多种，就阿里巴巴来说，有淘宝、天猫、主打生鲜的盒马、天猫超市等等。不管上层的业务形态有怎样的变化，实际上他们都是有比较核心的业务域是通用的，比如用户、支付、仓储、物流等等。那么实际上这些通用的业务对于整个电商平台来说实际就是通用能力，因此我们需要将这些通用的公共的能力进行下沉，形成业务中台，实现企业级的通用业务能力复用 拆分原则 拆分合理： 防止微服务爆炸，增加平台出现bug，增加业务成本 拆分过程逐步迭代。软件平台架构的演进过程必定会经历现有平台以及新架构平台先共存，后替代的过程。因此我们可以先从平台的非核心功能开始再到核心功能这样逐步拆分的方式进行迭代拆分，避免一上来就要大刀阔斧的进行微服务拆分以及架构调整，否则就会陷入旧平台不稳定而新平台又不完善的尴尬处境 确保微服务高内聚低耦合: 在进行微服务拆分之前，应该对平台进行完整的领域划分，建立合适的领域模型，确定好边界上下文，并以此作为微服务拆分的指导。将领域模型的稳定与不断变化的外部需求进行隔离，保证核心领域模型的稳定，避免领域模型之间的强依赖。从而达到实现微服务高内聚低耦合的目的。 工程化落地 基础设施层反向依赖领域层？\n业务领域是核心域：核心域对外部的依赖越少越好，实现技术复杂度与业务复杂度相分离\n领域层就是核心层因此它的对外依赖越少越好，也就是说应该是非核心依赖核心而不是核心依赖非核心\n技术实现细节依赖于接口抽象，例如：将repo层的定义放在domain层，具体实现由基础设施层完成\n各层数据流转 结构设计 采用4层结构。有的还有五层、六层结构\nInterfaces 接口层 负责向用户显示信息和解释用户命令，请求应用层以获取用户所需要展现的数据(比如获取首页的商品数据)\n前端应用通过这一层的接口，向应用服务获取展现所需的数据。这一层主要用来处理用户发送的 Restful 请求，解析用户输入的配置文件，并将数据传递给 Application 层。数据的组装、数据传输格式以及 Facade 接口等代码都会放在这一层目录里。\nAssembler： 实现 DTO 与领域对象之间的相互转换和数据交换。一般来说 Assembler 与 DTO 总是一同出现。\nDto： 它是数据传输的载体，内部不存在任何业务逻辑，我们可以通过 DTO 把内部的领域对象与外界隔离\nFacade： 提供较粗粒度的调用接口，将用户请求委派给一个或多个应用服务进行处理。\nApplication: 应用层 相对于领域层,应用层是很薄的一层,应用层定义了软件要完成的任务,要尽量简单。\n应用服务向下基于微服务内的领域服务或外部微服务的应用服务完成服务的编排和组合，向上为用户接口层提供各种应用数据展现支持服务。应用服务和事件等代码会放在这一层目录里。\nApplication 的代码目录结构有：event 和 service\n**Event（事件）：**这层目录主要存放事件相关的代码。\n它包括两个子目录：publish 和 subscribe。前者主要存放事件发布相关代码，后者主要存放事件订阅相关代码（事件处理相关的核心业务逻辑在领域层实现）。\n这里提示一下：虽然应用层和领域层都可以进行事件的发布和处理，但为了实现事件的统一管理，我建议你将微服务内所有事件的发布和订阅的处理都统一放到应用层，事件相关的核心业务逻辑实现放在领域层。通过应用层调用领域层服务，来实现完整的事件发布和订阅处理流程。\n**Service（应用服务）：**这层的服务是应用服务。\n应用服务会对多个领域服务或外部应用服务进行封装、编排和组合，对外提供粗粒度的服务。应用服务主要实现服务组合和编排，是一段独立的业务逻辑。你可以将所有应用服务放在一个应用服务类里，也可以把一个应用服务设计为一个应用服务类，以防应用服务类代码量过大。\nDomain：领域层 它主要存放领域层核心业务逻辑相关的代码。\n领域层可以包含多个聚合代码包，它们共同实现领域模型的核心业务逻辑。聚合以及聚合内的实体、方法、领域服务和事件等代码会放在这一层目录里。\nentity: :具有唯一标识的对象 值对象(Value Objects): 无需唯一标识的对象 领域服务(Domain Services): 一些行为无法归类到实体对象或值对象上,本质是一些操作,而非事物(与本例中domain/service包下的含义不同) 聚合/聚合根(Aggregates,Aggregate Roots): 聚合是指一组具有内聚关系的相关对象的集合,每个聚合都有一个root和boundary 工厂(Factories): 创建复杂对象,隐藏创建细节 仓储(Repository): 提供查找和持久化对象的方法 Infrastructure（基础层） 它主要存放基础资源服务相关的代码\n为应用层 传递消息(比如通知) 为领域层 提供持久化机制(最底层的实现) 为用户界面层 提供组件配置 基础设施层还能够通过架构框架来支持四个层次间的交互模式。 代码结构示例\n","permalink":"https://AlfredNing.github.io/note/program/architecture/ddd/","summary":"DDD是软件核心复杂性的应对之道\n调整程序的结构，该解耦的解耦，该拆分的拆分，在实现新的功能，才能保证设计质量\n运用DDD，当系统业务变得复杂，将对业务的理解绘制出领域模型正确知道软件开发\n微服务： 小而专\n软件开发方式 DL驱动开发 数据驱动设计 DDD驱动设计 DL驱动开发 DeadLine驱动开发，给定截至日期。我挂你他喵的写成什么样，完成就好。\n数据驱动设计 **良好的设计数据库表，**通过数据流串联对应的业务流程。适合小型系统，基本可以应付大多数的应用场景。\n确定对应的数据实体 完成库表设计 DDD领域驱动设计 应对软件架构复杂设计方法论\n整洁架构 软件退化 软件的本质是对真实世界的模拟 软件中业务逻辑正确与否的唯一标准就是是否与真实世界一致 软件要做成什么样，不由我们决定，也不用用户决定，而是由真实世界决定 产品为什么提出变更需求，因为他们对真实世界的理解也不是完全正确，跳过需要，建立在对真实世界理解的基础上进行开发。但认识真实世界是一件非常难的事情，最初只能认识真实世界中那些简单、清晰、易于理解的业务逻辑，完成该部分的软件 根源 第一版软件是完美的，但随后随着业务需求变动，软件的业务逻辑越来越接近真实世界，使得我们的软件越来越专业，同时业务逻辑也越来越复杂，软件规模也越来越大。简单软件有简单软件的设计，复杂软件有复杂软件的设计\n每次软件变更，逐步调整软件的程序结构，由简单程序转变为复杂程序结构，而不是一味的塞代码，赛代码才是最终根源。\n杜绝软件退化的两顶帽子 软件的发展规律是逐步从简单软件转换为复杂软件\n发生在每次新需求变更的时候，采用一下设计方法\n在不添加新功能的前提下，重构代码，调整原有程序结构，以适应新功能实现新的功能 实现新功能 过渡设计 每一种初始所谓的“灵活设计”只能应对一种需求变更，不能真正解决未来变更的问题，被称为“过度设计”\n活在今天的格子里，做今天的事。为当前的需求进行设计，使其刚刚满足当前的需求 解决思路：\n每次需求变更额设计，只有保证每次需求变更时候做出正确的设计，才能使得软件以良性循环维护下午\n两顶帽子的实现思路 困难的是第一步，如何调整程序设计以适应新功能\n多次变更，难以理清思路，设计开始迷失方向\n最终解决 领域驱动的思想： 将真实世界与软件世界进行对应。每次需求变更，将变更还原到真实世界，看看真实世界，在根据真实世界进行变更设计，保持领域驱动。\n领域驱动核心要求：领域模型 每次变更，先回到领域模型，基于业务进行领域模型的变更，然后在根据领域模型的变更指导程序变更\n电商功能演练DDD 首要需求 采用领域分析 先进行需求分析，设计领域模型\n领域模型图\n1. 需求变更 分析付款与折扣的关系？\n单一职责原则：软件系统中的每个元素都只负责自己职责范围内的事情，而将其他的事情交给别人去做，我只是去调用。\n职责如何定义？ 错误理解：做某件事，和这件事相关的一切所有的事都是它的职责\n正确理解：一个职责就是软件变化的原因\n什么是高质量的代码？\n用户提出需求变更，为了实现这个变更而修改软件的成本越低，软件的设计质量就越高。\n这就要求每次需求变更的时候只修改一个模块的代码来实现新需求。\n需要平时不断的整理代码，将因同一个原因而变更的代码放在一起，将因不同原因的代码而放在不同的模块中、不同类中。\n单一职责原则要求在维护软件的过程中需要不断的进行整理，将软件变化的同一个原因的代码放在一起，将软件变化的不同原因分开放。\n如何分析不同原因？\n答案是否定，说明是不同原因。\n2. 需求变更 答案是否定的\n3. 需求变更 支付方式变更","title":"DDD"},{"content":"系统配置 字符集的设置 show variables like \u0026#39;character%\u0026#39;; character_set_server：服务器级别的字符集 character_set_database：当前数据库的字符集 character_set_client：服务器解码请求时使用的字符集 character_set_connection：服务器处理请求时会把请求字符串从character_set_client转为character_set_connection character_set_results：服务器向客户端返回数据时使用的字符集 小结\n如果创建或修改列时没有显式的指定字符集和比较规则，则该列默认用表的字符集和比较规则 如果创建表时没有显式的指定字符集和比较规则，则该表默认用数据库的字符集和比较规则 如果创建数据库时没有显式的指定字符集和比较规则，则该数据库默认用服务器的字符集和比较规则 请求到响应过程中字符集的变化 graph TB A(客户端) --\u0026gt; |\u0026#34;使用操作系统的字符集编码请求字符串\u0026#34;| B(从character_set_client转换为character_set_connection) B --\u0026gt; C(从character_set_connection转换为具体的列使用的字符集) C --\u0026gt; D(将查询结果从具体的列上使用的字符集转换为character_set_results) D --\u0026gt; |\u0026#34;使用操作系统的字符集解码响应的字符串\u0026#34;| A SQL大小写的设置 show variables like \u0026#39;%lower_case_table_names%\u0026#39; 该参数只适用于5.7版本 默认为0 大小写敏感 设置为1，大小写不敏感，创建的表都是以小写方式存放在磁盘上，对于sql语句都是转换为小写对表和数据库查找 设置为2，创建的表和数据库依据语句上存放，凡是查找都是转换为小写进行 SQL编写建议 关键字和函数名称全部大写 数据库名、表名、表别名、字段名、字段别名等全部小写 SQL语句必须以分号结尾 SQL_MODE的设置 宽松模式 严格模式 MySQL的sql_mode合理设置\nsql_mode是个很容易被忽视的变量,默认值是空值,在这种设置下是可以允许一些非法操作的,比如允许一些非法数据的插入。在生产环境必须将这个值设置为严格模式,所以开发、测试环境的数据库也必须要设置,这样在开发测试阶段就可以发现问题.\nsql model 常用来解决下面几类问题\n通过设置sql mode, 可以完成不同严格程度的数据校验，有效地保障数据准备性。\n通过设置sql model 为宽松模式，来保证大多数sql符合标准的sql语法，这样应用在不同数据库之间进行迁移时，则不需要对业务sql 进行较大的修改。\n3. 在不同数据库之间进行数据迁移之前，通过设置SQL Mode 可以使MySQL 上的数据更方便地迁移到目标数据库中。\n# 临时设置 set global sql_mode = \u0026#39;\u0026#39;; -- 全局生效 set session sql_mode = \u0026#39;\u0026#39;; -- 会话生效 # my.cnf可以修改，永久设置，设置完毕重启 生成环境： 临时设置 + 全局设置。重启也会永久生效 数据目录 show variables like \u0026#39;%datadir%\u0026#39;; 数据库与文件系统的关系 存储引擎把表存储在文件系统上\n四个默认数据库\nmysql: 用户、权限等 information_schema: 维护所有其他数据库的信息 performance_schema: mysql运行状态信息 sys: 通过视图的形式把information_schema与performance_schema结合起来，帮助开发人员和系统管理人员监控MYSQL的技术性能 表在文件系统的表示 InnoDB db.opt: 针对该数据库的信息 *.frm: 存储表结构 *.ibd: 存储表数据，也可以放在ibdata1: 系统表空间 系统表空间（system tablespace） 默认情况下，InnoDB会在数据目录下创建一个名为ibdata1、大小为12M的自拓展文件，这个文件就是对应的系统表空间在文件系统上的表示。 独立表空间(file-per-table tablespace) 在MySQL5.6.6以及之后的版本中，InnoDB并不会默认的把各个表的数据存储到系统表空间中，而是为每一个表建立一个独立表空间，也就是说我们创建了多少个表，就有多少个独立表空间。使用独立表空间来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同。 MySQL8.0中不再单独提供表名.frm，而是合并在表名.ibd文件中，也没有db.opt文件\n利用ibd2sdi 可以查看ibd文件\n系统表空间与独立表空间的设置 可以自己指定使用系统表空间还是独立表空间来存储数据，这个功能由启动参数innodb_file_per_table控制\n[server] innodb_file_per_table=0 # 0：代表使用系统表空间； 1：代表使用独立表空间 其他类型的表空间 随着MySQL的发展，除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间，比如通用表空间（general tablespace）、临时表空间（temporary tablespace）等。\nMyISAM 在MyISAM中的索引全部都是二级索引，该存储引擎的数据和索引是分开存放的。所以在文件系统中也是使用不同的文件来存储数据文件和索引文件，同时表数据都存放在对应的数据库子目录下。\n表结构： *.frm, MySQL8.0 改为了 b.xxx.sdi 表数据：*.myd 表索引：*.myi Mysql架构 C/S架构，既Client/Server架构，服务端使用mysqld\nMysql5.7架构图\n连接层 三握手建立TCP连接 身份认证、权限认证 服务层 SQL Interface: SQL接口 接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT … FROM就是调用SQL Interface MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口 Parser: 解析器 在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。 在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建语法树，并根据数据字典丰富查询语法树，会验证该客户端是否具有执行该查询的权限。创建好语法树后，MySQL还会对SQL查询进行语法上的优化，进行查询重写。 Optimizer: 查询优化器 SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个执行计划。 这个执行计划表明应该使用哪些索引进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。 它使用**“选取-投影-连接”**策略进行查询。例如： SELECT id,name FROM student WHERE gender = \u0026#39;女\u0026#39;; 这个SELECT查询先根据WHERE语句进行选取，而不是将表全部查询出来以后再进行gender过滤。 这个SELECT查询先根据id和name进行属性投影，而不是将属性全部取出以后再进行过滤，将这两个查询条件连接起来生成最终查询结果。\nCaches \u0026amp; Buffers： 查询缓存组件 MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。 这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。 这个查询缓存可以在不同客户端之间共享。 从MySQL 5.7.20开始，不推荐使用查询缓存，并在MySQL 8.0中删除 引擎层 插件式存储引擎层（ Storage Engines），真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作，服务层通过API与存储引擎进行通信。开发人员也可以定制属于自己的引擎\nSQL执行 MySQL执行流程 查询缓存。缓存中发现这条语句，返回结果。但是由于命中率并不高。MySQL8.0取消缓存设置\n查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。这就意味着查询匹配的鲁棒性大大降低，只有相同的查询操作才会命中查询缓存。两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。因此 MySQL 的 查询缓存命中率不高 。\n同时，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql、 information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。\n此外，既然是缓存，那就有它缓存失效的时候。MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了INSERT、UPDATE、DELETE、TRUNCATE TABLE、ALTER TABLE、DROP TABLE或DROP DATABASE语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！对于更新压力大的数据库来说，查询缓存的命中率会非常低。\n解析器\n词法分析：识别字符串 语法分析：识别语法规则 优化器：确定SQL的执行路径，是全表扫描，还是索引检索\n逻辑优化 物理查询 执行器：在执行之前需要判断该用户是否具备权限。如果没有，就会返回权限错误。如果具备权限，就执行 SQL查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存\n**SQL 语句在 MySQL 中的流程是： SQL语句→查询缓存→解析器→优化器→执行器 **\nshow VARIABLES like \u0026#39;%query_cache_type%\u0026#39; # mysql8.0之后没有该参数 有三个值 0:关闭查询缓存 1:代表开启On 2: DEMAND, 按需开启， 指定为2时候，使用下面开启/关闭缓存 SELECT SQL_CACHE * FROM users; # 开启 SELECT SQL_NO_CACHE * FROM users; # 关闭 建议在静态表使用查询缓存，静态表：更新不频繁 # 查看缓存信息 show STATUS like \u0026#39;%Qcache%\u0026#39;; # mysql8.0之后没有该参数 # 开启sql记录执行 select @@profiling; set profiling = 1; #开启 session级别 SELECT * from job_history; select @@profiling; show PROFILES; -- 最近一次 show profile; -- 查询指定 show profile for query 98; # 查看cpu, io show profile cpu,block io for query 137; 数据库缓冲池 Buff - Pool InnoDB存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。而磁盘 I/O 需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请占用内存来作为数据缓冲池，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的Buffer Pool之后才可以访问。\n这样做的好处是可以让磁盘活动最小化，从而减少与磁盘直接进行 I/O 的时间。要知道，这种策略对提升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。\n缓冲池 缓存原则 位置 * 频次这个原则，可以帮我们对 I/O 访问效率进行优化。\n首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。\n其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有 200G，但是内存只有 16G，缓冲池大小只有 1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会优先对使用频次高的热数据进行加载。\n缓冲池的预读特性 在读取部分数据同时，会预先读取部分数据的上下可能引用的数据。\n读取数据 缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。\n-- 查看缓冲池大小 show variables like \u0026#39;innodb_buffer_pool_size\u0026#39;; -- 修改缓冲池，也可以修改配置文件 全局修改 set global innodb_buffer_pool_size = 268435456; -- 将单个buffer poll 拆分成小的buffer pool show variables like \u0026#39;innodb_buffer_pool_instances\u0026#39;; /** 配置文件修改 buffer_poll [server] innodb_buffer_pool_instances = */ 计算每个buffer poll占比： innodb_buffer_pool_size/innodb_buffer_pool_instances 更新数据流程 更新某个数据，如果数据在Buffer Pool不存在，会先将数据从磁盘中国加载，修改完成之后，放入缓冲池当中，当达到一定的落盘时机，才会刷入磁盘中\n缓冲池无论是5.7还是8.0都存在，查询缓存在8.0中不存在\n存储引擎 MyISAM InnoDB Memory Blackhole CSV Performance_Schema Archive Federated Mrg_Myisam InnoDB - 具有外键的支持事物引擎 MySQL从3.23.34a开始就包含InnoDB存储引擎。大于等于5.5之后，默认采用InnoDB引擎。 InnoDB是MySQL的默认事务型引擎，它被设计用来处理大量的短期(short-lived)事务。可以确保事务的完整提交(Commit)和回滚(Rollback)。 除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。 除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。 数据文件结构： 表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中） 表名.ibd 存储数据和索引 InnoDB是为处理巨大数据量的最大性能设计。 在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除了。比如：.frm，.par，.trn，.isl，.db.opt等都在MySQL8.0中不存在了。 对比MyISAM的存储引擎，InnoDB写的处理效率差一些，并且会占用更多的磁盘空间以保存数据和索引。 MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响。 MyISAM - 主要的非事务处理存储引擎 MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM不支持事务、行级锁、外键，有一个毫无疑问的缺陷就是崩溃后无法安全恢复。 5.5之前默认的存储引擎 优势是访问的速度快，对事务完整性没有要求或者以SELECT、INSERT为主的应用 针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高 数据文件结构： 表名.frm 存储表结构 表名.MYD 存储数据 (MYData) 表名.MYI 存储索引 (MYIndex) 应用场景：只读应用或者以读为主的业务 Archive：用于数据存档 Blackhole 丢弃写操作，读操作会返回空内容\nCSV 存储数据时，以逗号分隔各个数据项，作为数据交互\nMemory 置于内存的表\nFederated 访问远程表，默认禁用\nMerge引擎 管理多个MyISAM表构成的表集合\nNDB引擎 MySQL集群专用存储引擎\nInnoDB 与 MyISAM对比 阿里巴巴 Percona为Mysql数据库做了改进，新建存储引擎Xtradb替代Innodb, 并且在性能和并发上做的更好，阿里巴巴大部分数据库基于percona的原型进行修改\n索引 减少IO次数，降低查询时间\n索引具体实现与其存储引擎相关\n索引及其优缺点 索引概述 索引是帮助MySQL高效获取数据的数据结构\n**索引的本质：**索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现高级查找算法。\n优点 提高检索数据的效率，降低IO成本 可以创建唯一索引，保证数据库的每一行的唯一性 加速表和表之间的连接 在使用分组和排序字句时候，可以减少分组和排序的时间，降低CPU消耗 缺点 创建索引和维护索引需要耗费时间，随着数据量的增加，时间也会增加 索引需要占据磁盘空间 索引提高查询速度，同时会降低表的更新速度。当对表中的数据进行增加、删除和修改的时候，索引也需要动态维护，降低了数据的维护成本 TIP:\n索引提高查询速度，影响插入记录的速度。这种情况下，先删除表得索引，在插入数据，插入数据完成之后，再去恢复索引3的\nInnoDB索引推演 索引之前的查找 SELECT [列名列表] FROM 表名 WHERE 列名 = xxx; 在一个页的查找 假设目前表中的记录比较少，所有的记录都可以被存放在一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：\n以主键为搜索条件 可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。 以其他列作为搜索条件 因为在数据页中并没有对非主键建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从最小记录开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。 在很多页中查找 大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤：\n定位到记录所在的页。 从所在的页内查找相应的记录。 在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据我们上面的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是超级耗时的。\n设计索引 mysql\u0026gt; CREATE TABLE index_demo( -\u0026gt; c1 INT, -\u0026gt; c2 INT, -\u0026gt; c3 CHAR(1), -\u0026gt; PRIMARY KEY(c1) -\u0026gt; ) ROW_FORMAT = Compact; 这个新建的index_demo表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键，这个表使用Compact行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图：\nrecord_type：记录头信息的一项属性，表示记录的类型，0表示普通记录、1表示目录项记录、2表示最小记录、3表示最大记录。 next_record：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁。 各个列的值：这里只记录在index_demo表中的三个列，分别是c1、c2和c3。 其他信息：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。 将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：\n记录放到页中示意图\n简单的设计索引方案 在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们想快速的定位到需要查找的记录在哪些数据页中该咋办？我们可以为快速定位记录所在的数据页而建立一个目录，建这个目录必须完成下边这些事：\n下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值 给所有的页建立一个目录项 以页28为例，它对应目录项2，这个目录项中包含着该页的页号28以及该页中用户记录的最小主键值5。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为20的记录，具体查找过程分两步：\n先从目录项中根据二分法快速确定出主键值为20的记录在目录项3中（因为 12 \u0026lt; 20 \u0026lt; 209 ），它对应的页是页9。 再根据前边说的在页中查找记录的方式去页9中定位具体的记录。 页分裂：对页中的纪录进行增删改查，需要通过一些列诸如移动的操作，使得状态成立，下一个数据页记录的主键值大于上一个页中记录的主键值，这个过程被称为页分裂。\nInnoDB的索引方案 迭代1次：目录项记录的目录页 从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调目录项记录和普通的用户记录的不同点：\n目录项记录的record_type值是1，而普通用户记录的record_type值是0。 目录项记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有InnoDB自己添加的隐藏列。 了解：记录头信息里还有一个叫min_rec_mask的属性，只有在存储目录项记录的页中的主键值最小的目录项记录的min_rec_mask值为1，其他别的记录的min_rec_mask值都是0 现在以查找主键为20的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：\n先到存储目录项记录的页，也就是页30中通过二分法快速定位到对应目录项，因为 12 \u0026lt; 20 \u0026lt; 209 ，所以定位到对应的记录所在的页就是页9。 再到存储用户记录的页9中根据二分法快速定位到主键值为20的用户记录。 迭代2次：多个目录项记录的页 从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：\n为存储该用户记录而新生成了页31。 因为原先存储目录项记录的页30的容量已满（我们前边假设只能存储4条目录项记录），所以不得不需要一个新的页32来存放页31对应的目录项。 现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为20的记录为例：\n确定目录项记录页我们现在的存储目录项记录的页有两个，即页30和页32，又因为页30表示的目录项的主键值的范围是 [1, 320) ，页32表示的目录项的主键值不小于 320 ，所以主键值为20的记录对应的目录项记录在页30中。 通过目录项记录页确定用户记录真实所在的页。在一个存储目录项记录的页中通过主键值定位一条目录项记录的方式说过了。 在真实存储用户记录的页中定位到具体的记录。 迭代3次：目录项记录页的目录页 如图，我们生成了一个存储更高级目录项的页33，这个页中的两条记录分别代表页30和页32，如果用户记录的主键值在[1, 320)之间，则到页30中查找更详细的目录项记录，如果主键值不小于320的话，就到页32中查找更详细的目录项记录。\n这个数据结构，它的名称是B+树。\nB+Tree 一个B+树的节点其实可以分成好多层**，规定最下边的那层，也就是存放我们用户记录的那层为第0层**，之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页最多存放3条记录，存放目录项记录的页最多存放4条记录。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放100条用户记录，所有存放目录项记录的内节点代表的数据页可以存放1000条目录项记录，那么：\n如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放100条记录。 如果B+树有2层，最多能存放1000×100=10,0000条记录。 如果B+树有3层，最多能存放1000×1000×100=1,0000,0000条记录。 如果B+树有4层，最多能存放1000×1000×1000×100=1000,0000,0000条记录。相当多的记录！！！ 所以一般情况下，我们用到的B+树都不会超过4层，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的Page Directory（页目录），所以在页面内也可以通过二分法实现快速定位记录。\n常见索引概念 聚簇索引 索引既数据\n特点 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：\n页内的记录是按照主键的大小顺序排成一个单向链表。\n各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。\n存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。\nB+树的叶子节点存储的是完整的用户记录。\n所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。\n优点 数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快 聚簇索引对于主键的排序查找和范围查找速度非常快 按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以节省了大量的io操作。 缺点 插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增ID列为主键 更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新 二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据 限制 对于MySQL数据库目前只有InnoDB支持聚簇索引，而MyISAM不支持 每个MySQL的表只能有一个聚簇索引 如果没有定义主键，选择非空唯一索引代替。如果没有这样的索引,InnoDB隐式定义一个主键作为聚簇索引 innodb的表主键尽量选择有序的顺序id，不建议使用无序id 二级索引【辅助索引，非聚簇索引】 叶子节点存放主键值\n概念：回表 我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到聚簇索引中再查一遍，这个过程称为回表。也就是根据c2列的值查询一条完整的用户记录需要使用到2棵B+树！\n联合索引 也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照c2和c3列的大小进行排序，这个包含两层含义：\n先把各个记录和页按照c2列进行排序。\n在记录的c2列相同的情况下，采用c3列进行排序\n注意一点，以c2和c3列的大小为排序规则建立的B+树称为联合索引，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：\n建立联合索引只会建立如上图一样的1棵B+树。\n为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。\n聚簇索引的叶子节点存储的是我们的数据记录，非聚簇索引存储的是数据位置。非聚簇索引不会影响数据表的物理存储顺序 一个表只能由一个聚餐索引，因为只能有一种排序存储的方式，但可以有多个非聚餐索引，多个索引目录提供数据检索 使用聚餐索引的时候，数据的查询效率高，但如果对数据进行插入、更新、删除等操作，效率会比非聚簇索引低 InnoDB的B+树注意事项 1. 根页面位置万年不动 真实创建B+树过程：\n每当为某个表创建一个B+树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个根节点页面。最开始表中没有数据的时候，每个B+树索引对应的根节点中既没有用户记录，也没有目录项记录。 随后向表中插入用户记录时，先把用户记录存储到这个根节点中。 当根节点中的可用空间用完时继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如页a中，然后对这个新页进行页分裂的操作，得到另一个新页，比如页b。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到页a或者页b中，而根节点便升级为存储目录项记录的页。 这个过程特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是InnoDB存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。\n2. 内节点中目录项记录的唯一性 道B+树索引的内节点中目录项记录的内容是索引列+页号的搭配，但是这个搭配对于二级索引来说有点不严谨。还拿index_demo表为例，假设这个表中的数据是这样的：\nc1 c2 c3 1 1 \u0026lsquo;u\u0026rsquo; 3 1 \u0026rsquo;d' 5 1 \u0026lsquo;y\u0026rsquo; 7 1 \u0026lsquo;a\u0026rsquo; 如果二级索引中目录项的内容只是索引号+页号的搭配的话，那么为c2列建立索引后的B+树应该长这样： 如果我们想要新插入一行记录，其中c1、c2、c3的值分别是：9、1、c，那么在修改这个为c2列建立的二级索引对应的B+树时便碰到了个大问题：由于页3中存储的目录项记录是由c2列+页号的值构成的，页3中的两条目录项记录对应的c2列的值都是1，那么我们这条新插入的记录到底应该放在页4中，还是应该放在页5中啊？答案是：对不起，懵了。\n为了让新插入记录能找到自己在哪个页里，我们需要**保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的。**所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：\n索引列的值 主键值 页号 也就是我们把主键值也添加到二级索引内节点中的目录项记录了，这样就能保证B+树每一层节点中各条目录项记录除页号这个字段外是唯一的，所以我们为c2列建立二级索引后的示意图实际上应该是这样子的：\n这样我们再插入记录(9, 1, 'c')时，由于页3中存储的目录项记录是由c2列+主键+页号的值构成的，可以先把新记录的c2列的值和页3中各目录项记录的c2列的值作比较，如果c2列的值相同的话，可以接着比较主键值，因为B+树同一层中不同目录项记录的c2列+主键的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新记录应该被插入到页5中。\n一个页面最少存储2条记录 一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错！这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问的存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢？那就是目录层级非常非常非常多，而且最后的那个存放真实数据的目录中存放一条记录。费了半天劲只能存放一条真实的用户记录？所以InnoDB的一个数据页至少可以存放两条记录\nMyISAM的索引方案 B树索引适用存储引擎如表所示：\n索引/存储引擎 MyISAM InnoDB Memory B-Tree索引 支持 支持 支持 即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索引是Btree索引；而Memory默认的索引是Hash索引。\nMyISAM引擎使用B+Tree作为索引结构，叶子节点的data域存放的是数据记录的地址。\nMyISAM的原理 MyISAM与 InnoDB对比 在InnoDB存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录，而在MyISAM中却需要进行一次回表操作，意味着MyISAM中建立的索引相当于全部都是二级索引。\nInnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。\nInnoDB的非聚簇索引data域存储相应记录主键的值，而MyISAM索引记录的是地址。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。\nMyISAM的回表操作是十分快速的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。\nInnoDB要求表必须有主键（MyISAM可以没有）。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。\n索引代价 空间上的代价 每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用16KB的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。\n时间上的代价 每次对表中的数据进行增、删、改操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收等操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。\nMySQL数据结构的合理性 全表扫描 Hash索引 加速查找速度的数据结构，常见有两类：\n树：平衡二叉树等 哈希：例如hashmap hash索引对于范围查询不太友好 多余对于组合索引查询，会把组合查询键当做一个key进行计算，对于单独键不太使用 多余有大量重复key来说，会产生哈希冲突，从而查询时间退化 二叉搜索树 为了提高查询效率，就需要减少磁盘IO数。为了减少磁盘IO的次数，就需要尽量降低树的高度，需要把原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好\nAVL树 二叉平衡树\nB-Tree 一个 M 阶的 B 树（M\u0026gt;2）有以下的特性：\n根节点的儿子数的范围是 [2,M]。\n每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 = 关键字的数量 +1，k 的取值范围为[ceil(M/2), M]。\n叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M/2), M]。\n假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i] \u0026lt;Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …,P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k]指向关键字大于 Key[k-1] 的子树。\n所有叶子节点位于同一层。\n上面那张图所表示的 B 树就是一棵 3 阶的 B 树。我们可以看下磁盘块 2，里面的关键字为（8，12），它有 3 个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8，(9，10) 在 8 和 12 之间，而 (13，15)大于 12，刚好符合刚才我们给出的特征。\n然后我们来看下如何用 B 树进行查找。假设我们想要查找的关键字是 9，那么步骤可以分为以下几步：\n我们与根节点的关键字 (17，35）进行比较，9 小于 17 那么得到指针 P1；\n按照指针 P1 找到磁盘块 2，关键字为（8，12），因为 9 在 8 和 12 之间，所以我们得到指针 P2；\n按照指针 P2 找到磁盘块 6，关键字为（9，10），然后我们找到了关键字 9。\n叶子节点和非叶子节点都要存储数据\nB+ Tree 有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 = 关键字数，而 B 树中，孩子数量 = 关键字数+1。 非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）。 非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中， 非叶子节点既保存索引，也保存数据记录。 所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。 R树 支持geometry数据类型，常用于地理位置计算\n思考题 为了减少IO，索引树会一次性加载吗 当然不会\n数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个G。 当我们利用索引查询时候，是不可能将全部几个G的索引都加载进内存的，我们能做的只能是：逐一加载每一个磁盘页，因为磁盘页对应着索引树的节点。 B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT(占用4个字节)或BIGINT(占用8个字节)，指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值，因为是估算，为了方便计算，这里的K取值为103。也就是说一个深度为3的B+Tree索引可以维护103 * 10^3 * 10^3 = 10亿条记录。（这里假定一个数据页也存储10^3条行记录数据了）\n实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2~4层。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作\n为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引 B+树的磁盘读写代价更低 B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对于B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。\nB+树的查询效率更加稳定 由于非终结点并不是最终指向文件内容的节点，而只是叶子结点中关键字的索引。所有任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。\nHash索引与B+树索引的区别 Hash索引不能进行范围查询，而B+树可以。这是因为Hash索引指向的数据是无序的，而B+树的叶子节点是个有序的链表。\nHash索引不支持联合索引的最左侧原则（即联合索引的部分索引无法使用），而B+树可以。对于联合索引来说，Hash索引在计算Hash值的时候是将索引键合并后再一起计算Hash值，所以不会针对每个索引单独计算Hash值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。\nHash索引不支持 ORDER BY 排序，因为Hash索引指向的数据是无序的，因此无法起到排序优化的作用，而B+树索引数据是有序的，可以起到对该字段ORDER BY 排序优化的作用。同理，我们也无法用Hash索引进行模糊查询，而B+树使用LIKE进行模糊查询的时候，LIKE后面后模糊查询（比如%结尾）的话就可以起到优化作用。\nInnoDB不支持哈希索引\nInnodb的数据存储结构 数据库的存储结构：页 索引结构给我们提供了高效的索引方式，不过索引信息以及数据记录都保存在文件上的，确切说是存储在页结构中。另一方面，索引是在存储引擎中实现的，MySQL服务器上的存储引擎负责对表中数据的读取和写入工作。不同存储引擎中存放的格式一般不同的，甚至有的存储引擎比如Memory都不用磁盘来存储数据。\n磁盘与内存交互基本单位：页 InnoDB将数据划分为若干个页，InnoDB中页的大小默认为16KB。\n以页作为磁盘和内存之间交互的基本单位，也就是一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。也就是说，**在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页（Page），数据库I/O操作的最小单位是页。**一个页中可以存储多个行记录。\n记录是按照行来存储的，但是数据库的读取并不以行为单位，否则一次读取（也就是一次I/O操作）只能处理一行数据，效率会非常低。\n页结构概述 页a、页b、页c…页n这些页可以不在物理结构上相连，只要通过双向链表相关联即可。每个数据页中的记录会按照主键值从小到大的顺序组成一个单向链表，每个数据页都会为存储在它里边的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应的分组中的记录即可快速找到指定的记录\n页的上层结构 区（Extent）是比页大一级的存储结构，在InnoDB存储引擎中，一个区会分配64个连续的页。因为InnoDB中的页大小默认是16KB，所以一个区的大小是64*16KB=1MB。\n段（Segment）由一个或多个区组成，区在文件系统是一个连续分配的空间（在InnoDB中是连续的64个页），不过在段中不要求区与区之间是相邻的。段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。\n表空间（Tablespace）是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间、用户表空间、撤销表空间、临时表空间等。\n页的内部结构 文件头部和文件尾部 文件头部 38字节\n描述各种页的通用信息。（比如页的编号、其上一页、下一页是谁等）\nFIL_PAGE_OFFSET（4字节）：每一个页都有一个单独的页号，就跟你的身份证号码一样，InnoDB通过页号可以唯一定位一个页 FIL_PAGE_TYPE（2字节）：这个代表当前页的类型。 FIL_PAGE_PREV（4字节）和FIL_PAGE_NEXT（4字节）：InnoDB都是以页为单位存放数据的，如果数据分散到多个不连续的页中存储的话需要把这些页关联起来，FIL_PAGE_PREV和FIL_PAGE_NEXT就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，保证这些页之间不需要是物理上的连续，而是逻辑上的连续。 FIL_PAGE_SPACE_OR_CHKSUM（4字节）：代表当前页面的校验和（checksum）。文件头部和文件尾部都有属性：FIL_PAGE_SPACE_OR_CHKSUM FIL_PAGE_LSN（8字节）：页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number） 文件校验和的作用 InnoDB存储引擎以页为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候断电了，造成了该页传输的不完整。\n为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况），这时可以通过文件尾的校验和（checksum 值）与文件头的校验和做比对，如果两个值不相等则证明页的传输有问题，需要重新进行传输，否则认为页的传输已经完成。\n文件尾部 8字节\n前4个字节代表页的校验和：这个部分是和File Header中的校验和相对应的。 后4个字节代表页面被最后修改时对应的日志序列位置（LSN）：这个部分也是为了校验页的完整性的，如果首部和尾部的LSN值校验不成功的话，就说明同步过程出现了问题。 空闲空间、用户记录和最小最大记录 空闲空间 存储的记录会按照指定的行格式存储到User Records部分。但是在一开始生成页的时候，其实并没有User Records这个部分，每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了\n用户记录 User Records中的这些记录按照指定的行格式一条一条摆在User Records部分，相互之间形成单链表\nInfimum + Supremum（最小最大记录） 记录可以比较大小吗？ 是的，记录可以比大小，对于一条完整的记录来说，比较记录的大小就是比较主键的大小。比方说我们插入的4行记录的主键值分别是：1、2、3、4，这也就意味着这4条记录是从小到大依次递增。\nInnoDB规定的最小记录与最大记录这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的\n这两条记录不是我们自己定义的记录，所以它们并不存放在页的User Records部分，他们被单独放在一个称为Infimum + Supremum的部分\n页目录与页头 Page Directory 页目录 在页中，记录是以单向链表的形式进行存储的。单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。因此在页结构中专门设计了页目录这个模块，专门给记录做一个目录，通过二分查找法的方式进行检索，提升效率。\n页目录，二分法查找\n将所有的记录分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录。 第 1 组，也就是最小记录所在的分组只有 1 个记录； 最后一组，就是最大记录所在的分组，会有 1-8 条记录； 其余的组记录数量在 4-8 条之间。 这样做的好处是，除了第 1 组（最小记录所在组）以外，其余组的记录数会尽量平分。 在每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段。 页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），每个槽相当于指针指向了不同组的最后一个记录。 页面头部 为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫Page Header的部分，这个部分占用固定的56个字节，专门存储各种状态信息。\nInnoDB行格式 语法规则 -- 查看默认行格式 select @@innodb_default_row_format; -- 查看表的格式 show table status like \u0026#39;employees\u0026#39;; -- 创建表指定格式 create table table_name (...) row_format=compact; -- 修改表格式 alter table table_name row_format=compact; Compact格式 MySQL5.1默认\n一条记录记录额外信息和记录的真实数据\n变长字段列表 MySQL支持一些变长的数据类型，比如VARCHAR(M)、VARBINARY(M)、TEXT类型，BLOB类型，这些数据类型修饰列称为变长字段。\n边长字段存储多少字节的数据是不固定的。所以我们在存储数据把这些数据占用的字节数也存起来。\n这里面存储的变长长度和字段顺序是反过来的。比如两个varchar字段在表结构的顺序是a(10)，b(15)。那么在变长字段长度列表中存储的长度顺序就是15，10，是反过来的。\nNull值列表 Compact行格式会把Null值的类统一管理起来，存在一个标记为Null值列表中。如果表中没有NULL的列，则NULL值列表并不会存在\n为什么需要NULL值列表\n因为底层数据是需要对其的，如果每一标注null值，你想你去存储的时候给a/b值，他是放在那一列上合适呢。使用一个特殊的符号放到相应的数据位置表示，可以达到，但是会浪费空间。所以直接在行数据得头部开辟一块空间用来记录行数据哪些是非空数据、哪些是空数据\n二进制位的值为1时，代表该列的值为NULL。 二进制位的值为0时，代表该列的值不为NULL。 注意：同样顺序也是反过来存放的 记录的头信息 五个字节\ndelete_mask：这个属性标记着当前记录是否被删除，占用1个二进制位\n值为0：代表记录并没有被删除 值为1：代表记录被删除掉了 被删除的数据为什么还在页中存储？\n性能考虑，如果每次剔除一条数据，记录重新排列，是会特别浪费空间的，就会JVM垃圾清理一个意思。所以这里只是打上一个删除标记。所有被删除的记录都会组成一个所谓的垃圾链表。在这个链表中的记录占用的空间称之为可重用空间，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。\nmin_rec_mask：B+树的每层非叶子节点中的最小记录都会添加该标记，min_rec_mask值为1。我们自己插入的四条记录的min_rec_mask值都是0，意味着它们都不是B+树的非叶子节点中的最小记录。 record_type：这个属性表示当前记录的类型，一共有4种类型的记录： 0：表示普通记录 1：表示B+树非叶节点记录 2：表示最小记录 3：表示最大记录 heap_no：这个属性表示当前记录在本页中的位置。 MySQL会自动给每个页里加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为伪记录或者虚拟记录。这两个伪记录一个代表最小记录，一个代表最大记录。最小记录和最大记录的heap_no值分别是0和1，也就是说它们的位置最靠前\nn_owned：页目录中每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段 next_record：记录头信息里该属性非常重要，它表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量 一个表没有定义主键，则会选取Unique作为主键，如果没有Unique字段，则会为表添加一个隐藏的row_id隐藏列作为字段。所以row_id是在没有自定义主键以及Unique键的情况下才会存在的。\nDynamic 与Compressed格式 行溢出 create table varchar_size_demo( c varchar(65535) ) CHARSET = ascii row_format = compact; -- 创建失败 create table varchar_size_demo1( c varchar(65532) ) CHARSET = ascii row_format = compact; -- 创建成功 65532 + 2个字节变长长度记录 + 1个字节null值标识 create table varchar_size_demo2( c varchar(65533) not null ) CHARSET = ascii row_format = compact; -- 创建成功 65532 + 2个字节变长长度记录 最大字节是65535，页大学是16KB 16384字节，表面在存储数据时候，会发生当前行数据溢出。\n在Compact和Reduntant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中进行分页存储，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页。这称为页的扩展。\n在MySQL 8.0中，默认行格式就是Dynamic，Dynamic、Compressed行格式和Compact行格式挺像，只不过在处理行溢出数据时有分歧\nCompressed和Dynamic两种记录格式对于存放在BLOB中的数据采用了完全的行溢出的方式。如图，在数据页中只存放20个字节的指针（溢出页的地址），实际的数据都存放在Off Page（溢出页）中。 Compact和Redundant两种格式会在记录的真实数据处存储一部分数据（存放768个前缀字节）。 区 段 碎片 表空间 区是什么 B+树的每一个层的页都会形成双向链表数据结构，如果以页来分配单位，实际存储的物理位置可能理的非常远，造成物理读取时候随机读取，尽可能让链表相邻的页的物理位置相邻，进行范围查询的时候使用顺序IO\n引入区的概念，一个区就是物理位置上连续的64个页。因为InnoDB中的页的大小默认是16KB，所以一个区的大小是64*16KB=1MB。在表中数据量大的时候，为某个索引分配空间的时候就不再按照页的单位分配了，而是按照区为单位分配，甚至在表中的数据特别多的时候，可以一次性分配多个连续的区。虽然可能造成一点点空间的浪费（数据不足以填充满整个区），但是从性能角度看，可以消除很多的随机I/O，功大于过！\n段是什么 范围查询，如果对B+树叶子节点得记录不进行区分，如果把所有代表节点得页面放到申请的区中，造成性能不太好。所有采用了区分对待\n叶子节点段 非叶子节点段 回滚段 数据段 索引段 数据段即为B+树的叶子节点，索引段即为B+树的非叶子节点。\n在InnoDB存储引擎中，对段的管理都是由引擎自身所完成，DBA不能也没有必要对其进行控制。这从一定程度上简化了DBA对于段的管理。\n段其实不对应表空间中的某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。\n碎片区 默认情况下，一个使用InnoDB存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的，一个区默认占用1M（64*16KB=1024KB）存储空间，所以**默认情况下一个只存在几条记录的小表也需要2M的存储空间么？**以后每次添加一个索引都要多申请2M的存储空间么？这对于存储记录比较少的表简直是天大的浪费。这个问题的症结在于到现在为止我们介绍的区都是非常纯粹的，也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用。\n为了考虑以完整的区为单位分配给某个段对于数据量较小的表太浪费存储空间的这种情况，InnoDB提出了一个碎片（fragment）区的概念。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页面用于段A，有些页面用于段B，有些页甚至哪个段都不属于。碎片区直属于表空间，并不属于任何一个段。\n所以此后为某个段分配存储空间的策略是这样的：\n在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。 当某个段已经占用了32个碎片区页面之后，就会申请以完整的区为单位来分配存储空间。 所以现在段不能仅定义为是某些区的集合，更精确的应该是某些零散的页面已经一些完整的区的集合。\n区分类 空闲的区(FREE)：现在还没有用到这个区中的任何页面。 有剩余空间的碎片区(FREE_FRAG)：表示碎片区中还有可用的页面。 没有剩余空间的碎片区(FULL_FRAG)：表示碎片区中的所有页面都被使用，没有空闲页面。 附属于某个段的区(FSEG)：每一索引都可以分为叶子节点段和非叶子节点段 处于FREE、FREE_FRAG以及FULL_FRAG这三种状态的区都是独立的，直属于表空间。而处于FSEG状态的区是附属于某个段的\n表空间 表空间是Innodb存储结构逻辑层的最高层，所有的数据放在表空间中。\n逻辑容器，表空间存储对象是段，一个表空间可以有多个段，一个段只能属于一个表空间。表空间数据库由一个或多个表空间组成。\n系统表空间 独立表空间 撤销表空间 临时表空间 空间可以回收，drop可以自动回收，也可以在删除大量数据，统计分析或者是日志表之后执行：alter table tableName engine=innodb\n","permalink":"https://AlfredNing.github.io/note/program/sql/mysql/mysql%E9%AB%98%E7%BA%A7-%E5%BC%95%E6%93%8E_%E5%BA%95%E5%B1%82%E6%96%87%E4%BB%B6/","summary":"系统配置 字符集的设置 show variables like \u0026#39;character%\u0026#39;; character_set_server：服务器级别的字符集 character_set_database：当前数据库的字符集 character_set_client：服务器解码请求时使用的字符集 character_set_connection：服务器处理请求时会把请求字符串从character_set_client转为character_set_connection character_set_results：服务器向客户端返回数据时使用的字符集 小结\n如果创建或修改列时没有显式的指定字符集和比较规则，则该列默认用表的字符集和比较规则 如果创建表时没有显式的指定字符集和比较规则，则该表默认用数据库的字符集和比较规则 如果创建数据库时没有显式的指定字符集和比较规则，则该数据库默认用服务器的字符集和比较规则 请求到响应过程中字符集的变化 graph TB A(客户端) --\u0026gt; |\u0026#34;使用操作系统的字符集编码请求字符串\u0026#34;| B(从character_set_client转换为character_set_connection) B --\u0026gt; C(从character_set_connection转换为具体的列使用的字符集) C --\u0026gt; D(将查询结果从具体的列上使用的字符集转换为character_set_results) D --\u0026gt; |\u0026#34;使用操作系统的字符集解码响应的字符串\u0026#34;| A SQL大小写的设置 show variables like \u0026#39;%lower_case_table_names%\u0026#39; 该参数只适用于5.7版本 默认为0 大小写敏感 设置为1，大小写不敏感，创建的表都是以小写方式存放在磁盘上，对于sql语句都是转换为小写对表和数据库查找 设置为2，创建的表和数据库依据语句上存放，凡是查找都是转换为小写进行 SQL编写建议 关键字和函数名称全部大写 数据库名、表名、表别名、字段名、字段别名等全部小写 SQL语句必须以分号结尾 SQL_MODE的设置 宽松模式 严格模式 MySQL的sql_mode合理设置\nsql_mode是个很容易被忽视的变量,默认值是空值,在这种设置下是可以允许一些非法操作的,比如允许一些非法数据的插入。在生产环境必须将这个值设置为严格模式,所以开发、测试环境的数据库也必须要设置,这样在开发测试阶段就可以发现问题.\nsql model 常用来解决下面几类问题\n通过设置sql mode, 可以完成不同严格程度的数据校验，有效地保障数据准备性。\n通过设置sql model 为宽松模式，来保证大多数sql符合标准的sql语法，这样应用在不同数据库之间进行迁移时，则不需要对业务sql 进行较大的修改。\n3. 在不同数据库之间进行数据迁移之前，通过设置SQL Mode 可以使MySQL 上的数据更方便地迁移到目标数据库中。\n# 临时设置 set global sql_mode = \u0026#39;\u0026#39;; -- 全局生效 set session sql_mode = \u0026#39;\u0026#39;; -- 会话生效 # my.","title":"MySQL高级-引擎_底层文件"},{"content":"分布式数据库 分布式数据库的介绍 数据库产品特点\n抽象程度高，用户仅从使用层面解除 商业氛围一直很浓厚 基本概念 分布式数据库的核心： 数据分片、数据同步\n数据分片 讲数据分散到多个节点，以更高效、更灵活的方式来处理数据 分类：\n水平分片：按行进行数据分割，数据被切割成一个个数据组，分散到不同节点 垂直分片：按列进行数据分割，一个数据表的模式（Schema）被切割为多个小的模式 数据同步 数据一致性的保证，分布式数据库的底线\n早期的关系型商业数据库的分布式能力可以满足大部分用户的场景，因此产生了如 Oracle 等几种巨无霸数据库产品；\nOLAP 领域首先寻求突破，演化出了大数据技术与 MPP 类型数据库，提供功能更强的数据分析能力；\n去IOE 引入数据库中间件，并结合应用平台与开源单机数据库形成新一代解决方案，让商业关系型数据库走下神坛，NoSQL 数据库更进一步\u0026gt;打破了关系型数据库唯我独尊的江湖地位；\n新一代分布式 OLTP 数据库正式完成了分布式领域对数据库核心特性的完整支持，它代表了分布式数据库从此走向了成熟，也表明了 OLAP 与 OLTP 分布式场景下，分别在各自领域内取得了胜利；\nHTAP 和多模式数据处理的引入，再一次将 OLAP 与 OLTP 融合，从而将分布式数据库推向如传统商业关系型数据库数十年前那般的盛况，而其产生的影响要比后者更为深远\nSQL的发展史 最初的数据管理“关系模型”是指由 IBM 研究人员 E.F. Codd 在 20 世纪 70 年代初设计的，并在 System R 及后续许多数据库系统中得到了普及。 由于 Schema（模式）的预定义，数据库获得存储相对紧凑，从而导致其性能较为优异；之后就是经典的 ACID 给业务带来了可控性，而基于标准化 SQL 的数据访问模式给企业级应用带来了更多的红利，因为“标准即是生产力”\n缺点：\n对前期设计要求高，因为后期修改 Schema 往往需要停机，没有考虑分布式场景，在扩展性和可用性层面缺乏支持；而分布式是 21 世纪应用必备的技能。\nNoSQL数据库和SQL数据库的区别 NoSQL的缺点 由于缺乏ACID, 应用时需要非常小心处理数据一致性问题；同时其数据模型只针对特定的应用场景，一般不能使用一种 NoSQL 数据库来完成整个应用的构建，导致设计层面的复杂和维护的困难。\nNew SQL 基于NoSQL模式构建的分布式数据库，它通常采用现有的 SQL 类关系型数据库为底层存储或自研引擎，并在此之上加入分布式系统，从而对终端用户屏蔽了分布式管理的细节。\n分类：\n在一个个独立运行的 SQL 数据库实例之上提供了一个自动数据分片管理层 包括 NuoDB、VoltDB 和 Clustrix 等，它们构建了新的分布式存储引擎，虽然仍有或多或少的功能阉割，但可以给用户一个完整的 SQL 数据库体验。 Distributed SQL 它在 NewSQL 的功能基础上，往往提供的是“地理分布”功能，用户可以跨可用区、区域甚至在全球范围内分布数据。CockroachDB、Google的Spanner、OceanBase 和 PingCAP 的 TiDB 就是很好的例子，这些引擎通常比 NewSQL 的目标更高。\n数据分片 分片是将大数据表分解为较小的表(称为分片)的过程，这些分片在多个数据库集群节点上。分片本质上可以被看作传统数据库中的分区表，是一种水平扩展的手段。每个分片上包含原有总数据集的一个子集，从而可以将总负载分散在各个分区上。\n水平分片：在不同的数据库节点上存储同一表的不同行 垂直分片：在不同的数据库节点上存储同一表的不同表列 分片理念其实来源于经济学的边际收益理论：如果投资持续增加，但收益的增幅开始下降时，被称为边际收益递减状态。而刚好要开始下降的那个点被称为边际平衡点。\n该理论应用在数据库计算能力上往往被表述为：如果数据库处理能力遇到瓶颈，最简单的方式是持续提高系统性能，如更换更强劲的 CPU、更大内存等，这种模式被称为垂直扩展。当持续增加资源以提升数据库能力时，垂直扩展有其自身的限制，最终达到边际平衡，收益开始递减。\n而此时，对表进行水平分片意味着可以引入更多的计算能力处理数据与交易。从而，将边际递减扭转为边际递增状态。同时，通过持续地平衡所有节点上的处理负载和数据量，分片模式还可以获得 1+1\u0026gt;2 的效果，即集群平均处理能力大于单节点处理能力。\n优势 增加数据库集群总容量并加快处理速度，同时可以使用比垂直扩展更低的成本提供更高的可用性。\n分片算法 水平分片算法 哈希分片 算法原理 获取分片键 根据特定哈希算法计算哈希值 根据哈希值确定数据被放置在哪个分区中 使用场景 适合随机读写场景，很好分散系统负载，弊端不利于范围扫描查询操作\n范围分片 算法原理 根据数据值或键空间的范围对数据进行划分，相邻的分片键更有可能落入相同的分片上。\n范围分片需要选择合适的分片键，这些分片键需要尽量不包含重复数值，也就是其候选数值尽可能地离散。同时数据不要单调递增或递减，否则，数据不能很好地在集群中离散，从而造成热点。\n使用场景 适合范围查找，但是其随机读写性能弱\n融合算法 建立一个多级分片策略，该策略在最上层使用哈希算法，而在每个基于哈希的分片单元中，数据将按顺序存储\n地理位置算法 该算法一般用于 NewSQL 数据库，提供全球范围内分布数据的能力。\n在基于地理位置的分片算法中，数据被映射到特定的分片，而这些分片又被映射到特定区域以及这些区域中的节点。\n然后在给定区域内，使用哈希或范围分片对数据进行分片。例如，在美国、中国和日本的 3 个区域中运行的集群可以依靠 User 表的 Country_Code 列，将特定用户（User）所在的数据行映射到符合位置就近规则的区域中。\n手动分片 、自动分片 手动分片 设置静态规则来将数据根据分片算法分散到数据库节点\n由于用户使用的数据库不支持自动的分片，如 MySQL、Oracle 等 在应用层面上做数据分片来解决，也可以使用简单的数据库中间件或 Proxy 来设置静态的分片规则来解决 特点 数据分布不均匀。数据分布不均可能导致数据库负载极其不平衡，从而使其中一些节点过载，而另一些节点访问量较少。\n但如果精心设计，且数据分布变化不大，采用手动分片也是一个较为简单、维护成本低廉的方案。\n自动分片 自动分片意味着计算节点与分片算法可以相互配合，从而使数据库进行弹性伸缩。\n使用基于范围的分片很容易实现自动分片：只需拆分或合并每个分片。\n而使用基于哈希的分片的系统实现自动分片代价很高昂，因为添加数据库节点之后，需要进行数据迁移与再平衡操作\n分区算法案例【 Apache ShardingShpere】 分区键生成 常用的算法有 UUID 和 Snowfalke 两种无状态生成算法。\nUUID 是最简单的方式，但是生成效率不高，且数据离散度一般。因此目前生产环境中会采用后一种算法。\n灵活的分区算法 为了保证分片计算的灵活性，ShardingShpere 提供了标准分片算法和一些工具，帮助用户实现个性化算法。\nPreciseShardingAlgorithm 配合哈希函数使用，可以实现哈希分片。RangeShardingAlogrithm 可以实现范围分片。 使用 ComplexShardingStrategy 可以使用多个分片键来实现融合分片算法。 有的时候，数据表的分片模式不是完全一致。对于一些特别的分片模式，可以使用 HintShardingStrategy 在运行态制定特殊的路由规则，而不必使用统一的分片配置。 如果用户希望实现诸如地理位置算法等特殊的分片算法，可以自定义分片策略。使用 inline 表达式或 Java 代码进行编写，前者基于配置不需要编译，适合简单的个性化分片计算；后者可以实现更加复杂的计算，但需要编译打包的过程。 自动分片 ShardingShpere 提供了 Sharding-Scale 来支持数据库节点弹性伸缩，该功能就是其对自动分片的支持\n复制技术 保留数据副本，提供数据冗余。\n提高数据查询性能 保证数据库的可用性 复制技术需要考虑 数据一致 RPO 和业务连续性 RTO\n单主复制 也叫做主从复制\n写入主节点的数据都需要复制到从节点，即存储数据库副本的节点。当客户要写入数据库时，他们必须将请求发送给主节点，而后主节点将这些数据转换为复制日志或修改数据流发送给其所有从节点。从使用者的角度来看，从节点都是只读的\n复制同步模式 同步复制: 如果由于从库已崩溃，存在网络故障或其他原因而没有响应，则主库也无法写入该数据。 半同步复制: 其中部分从库进行同步复制，而其他从库进行异步复制。也就是，如果其中一个从库同步确认，主库可以写入该数据。 异步复制： 不管从库的复制情况如何，主库可以写入该数据。而此时，如果主库失效，那么还未同步到从库的数据就会丢失。 复制延迟 每次写入都需要同步所有从节点，会造成一部分从节点已经有数据，但是主节点还没写入数据。而异步复制的问题是从节点的数据可能不是最新的\n复制与高可用性 节点故障处理\n从节点故障：只需要知道发生故障前处理的最后一个事务，凭借此信息从主节点或其他节点恢复自己的数据 主节点故障： 采用故障转移。从节点中选择一个新的成为主节点 根据超时时间确定主节点离线 选择新的主节点，新的主节点通常应该与旧的主节点数据最为接近 重置系统，让其成为新的主节点 复制方式 基于语句的复制 日志（WAL）同步 行复制 ETL 工具 多主复制 也称为主主复制。数据库集群内存在多个对等的主节点，它们可以同时接受写入。每个主节点同时充当主节点的从节点\n多主节点的架构模式最早来源于 DistributedSQL 这一类多数据中心，跨地域的分布式数据库。在这样的物理空间相距甚远，有多个数据中心参与的集群中，每个数据中心内都有一个主节点。而在每个数据中心的内部，却是采用常规的单主复制模式\nCAP理论 一致性： 每个操作都保持一致性 可用性：可用性是用于衡量系统能成功处理每个请求并作出响应的能力 分区容错性 可用性要求任何无故障的节点都可以提供服务，而一致性要求结果需要线性一致\nCP系统 一致且容忍分区的系统。更倾向于减少服务时间，而不是将不一致的数据提供出去\n需要引入共识算法\nAP系统 可用且具有分区容忍性的系统。它放宽了一致性要求，并允许在请求期间提供可能不一致的值。一般是列式存储，NoSQL 数据库会倾向于 AP，如 Apache Cassandra。但是它们会通过不同级别的一致性模式调整来提供高一致性方案。\nAP 系统只要一个副本就能启动，数据库会始终接受写入和读取服务。它可能最终会丢失数据或产生不一致的结果。这里可以使用客户端模式或 Session 模型，来提供一致性的解决方案。\n使用CAP理论的限制条件 CAP 讨论的是网络分区，而不是节点崩溃或任何其他类型的故障。这意味着网络分区后的节点都可能接受请求，从而产生不一致的现象。但是崩溃的节点将完全不受响应，不会产生上述的不一致问题。 CAP 意味着即使所有节点都在运行中，我们也可能会遇到一致性问题，这是因为它们之间存在连接性问题。 为什么不能选择CA 如果我们选择了 CA 而放弃了 P，那么当发生分区现象时，为了保证 C，系统需要禁止写入。也就是，当有写入请求时，系统不可用。这与 A 冲突了，因为 A 要求系统是可用的。因此，分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构.\nCA 类系统是不存在的\n一致性模型 滞后性：它是数据改变的时刻与其副本接收到数据的时刻 顺序性。讨论的是各种操作在系统所有副本上执行的顺序状态 严格一致性 严格的一致性类似于不存在复制过程：任何节点的任何写入都可立即用于所有节点的后续读取\n只是理论模型，现实中无法实现。因为各种物理限制使分布式数据不可能一瞬间去同步这种变化\n线性一致性 线性一致性是最严格的且可实现的单对象单操作一致性模型。在这种模型下，写入的值在调用和完成之间的某个时间点可以被其他节点读取出来。且所有节点读到数据都是原子的，即不会读到数据转换的过程和中间未完成的状态。\n顺序一致性 顺序一致性是指所有的进程以相同的顺序看到所有的修改。读操作未必能及时得到此前其他进程对同一数据的写更新，但是每个进程读到的该数据的不同值的顺序是一致的。\n因果一致性 相比于顺序一致性，因果一致性的要求会低一些：它仅要求有因果关系的操作顺序是一致的，没有因果关系的操作顺序是随机的。\n因果相关的要求有如下几点。\n本地顺序：本进程中，事件执行的顺序即为本地因果顺序。 异地顺序：如果读操作返回的是写操作的值，那么该写操作在顺序上一定在读操作之前。 闭包传递：和时钟向量里面定义的一样，如果 a-\u0026gt;b、b-\u0026gt;c，那么肯定也有 a-\u0026gt;c。 事务隔离级别与一致性模型 ACID 和 CAP 中的“C”是都是一致性，但是它们的内涵完全不同。其中 ADI 都是数据库提供的能力保障，但是 C（一致性）却不是，它是业务层面的一种逻辑约束。\n一致性模型关心的是单一操作，而事务是由一组操作组成的。\n事务隔离是描述并行事务之间的行为，而一致性是描述非并行事务之间的行为\n分布式索引 分布式数据库的核心是以提供数据检索服务为主，数据写入要服务于数据查询\n读取路径 寻找分片和目标节点 检查数据是否在缓存与缓冲中 检查数据是否在磁盘文件中； 合并结果 索引数据表 含有索引的数据表有索引组织表和哈希组织表。其实，我们在分布式数据库中最常见的是 Google 的 BigTable 论文所提到的 SSTable（排序字符串表）。\nSSTable 用于 BigTable 内部数据存储。SSTable 文件是一个排序的、不可变的、持久化的键值对结构，其中键值对可以是任意字节的字符串，支持使用指定键来查找值，或通过给定键范围遍历所有的键值对。每个 SSTable 文件包含一系列的块。SSTable 文件中的块索引（这些块索引通常保存在文件尾部区域）用于定位块，这些块索引在 SSTable 文件被打开时加载到内存。在查找时首先从内存中的索引二分查找找到块，然后一次磁盘寻道即可读取到相应的块。另一种方式是将 SSTable 文件完全加载到内存，从而在查找和扫描中就不需要读取磁盘\n内存缓冲 分布式数据库的存储引擎中，有一种结构因其简单而被广泛地使用，那就是跳表（SkipList）。\n布隆过滤 先初始化里面所有的值为 0；而后对数据中的键做哈希转换，将结果对应的二进制表示形式映射到这个位数组里面，这样有一部分 0 转为 1；然后将数据表中所有建都如此映射进去\n二级索引 二级索引一般都是稀疏索引，也就是索引与数据是分离的。索引的结果一般保存的是主键，而后根据主键去查找数据\n如果要使用键值对实现二级索引，那么索引结果会有如下几种组合方式。\n急迫模式：将索引结果快速合并到一个 value 中，而后一次查询就可以查到所以结果。 正常模式：使用多个键值对保留数据。 键组合模式：把索引与结果全都放在 key 上，value 是空的。 总体来说，三种模式读取性能接近，但急迫模式的写入性能会低一些。但是对于不同的 key-value 底层实现，其性能会有差别，比如 wisckey（将在第 11 讲中介绍）实现的键值分离模式，使用组合模式就有意义。同时由于键组合模式比较简单，且适合键扫描算法的实现，故是一种比较常见二级索引形式。\n事务处理与恢复 数据库崩溃后如何恢复 事务特性 A: 原子性 保证事务内的所有操不可分割，要么全部成功，要么全部失败。\n成功的标识：事务的最后有提交操作\n失败的情况：执行回滚或者数据库进程崩溃退出\nC: 一致性 一致性其实是受用户与数据库共同控制的，而不只是数据库提供的一个服务。\nI：隔离性 不同的事务在运行的时候可以互相不干扰。\n一般数据库会定义多种的隔离级别来提供不同等级的并发处理能力，也就是一个事务在较低隔离级别下很可能被其他事务看见\nD：持久性 事务一旦被提交，那么它对数据库的修改就可以保留下来。这里要注意这个“保存下来”不仅仅意味着别的事务能查询到，更重要的是在数据库面临系统故障、进程崩溃等问题时，提交的数据在数据库恢复后，依然可以完整地读取出来。\n事务管理器 事务主要由事务管理器来控制，它负责协调、调度和跟踪事务状态和每个执行步骤。当然这与分布式事务两阶段提交（2PC）中的事务管理器是不同的。\n页缓存 页缓存（Page Cache）或者缓冲池（Buffer Pool），它是磁盘和存储引擎其他组件的一个中间层。\n数据首先被写入到缓存里，而后同步到数据磁盘上。它一般对于其他组件，特别是对于写入来说是透明的，写入组件以为是将数据写入磁盘，实际上是写入了缓存中。这个时候如果系统出现故障，数据就会有丢失的风险，\n作用：\n缓存首先解决了内存与磁盘之间的速度差，同时可以在不改变算法的情况下优化数据库的性能。\n刷盘时需要注意，脏页（被修改的页缓存）如果被其他对象引用，那么刷盘后不能马上释放空间，需要等到它没有引用的时候再从缓存中释放。刷盘操作同时需要与提交日志检查点进行配合，从而保证 D，也就是持久性。\n当缓存到达一定阈值后，就不得不将有些旧的值从缓存中移除。这个时候就需要缓存淘汰算法来帮忙释放空间。这里有 FIFO、LRU、表盘（Clock）和 LFU 等算法。\n日志管理器 日志管理器，它保存了一组数据的历史操作记录。缓存内的数据没有刷入磁盘前，系统就崩溃了，通过回放日志，缓存中的数据可以恢复出来。另外，在回滚场景，这些日志可以将修改前的数据恢复出来。\n锁管理器 它保证了事务访问共享资源时不会打破这些资源的完整性约束。同时，它也可以保证事务可以串行执行。\n如何恢复事务 提交日志 提交日志，即 CommitLog 或 WAL（Write-Ahead Log）：记录数据库的所有操作，并使用追加模式记录到磁盘的日志文件中。\n写操作首先是写入了缓存，而后再刷入磁盘中。但是在刷盘之前，其实这些数据已经以日志的形式保存在了磁盘的提交日志里面。当数据没有刷入磁盘而仅仅驻留在缓存时，这些日志可以保证数据的持久性。也就是，一旦数据库遭遇故障，可以从日志中恢复出来数据。\n特性 日志顺序写入且不可变。顺序写入：保证写入的高性能，不可变保证了读取可以安全地从前到后读取里面的数据。 提交日志一般都会被分配一个序列号作为唯一键，这个序号不是一个自增数字，就是一个时间戳。 每条日志都非常小，有些数据库会将它们进行缓存而后批量写入磁盘。这就导致，默写情况下日志不能完全恢复数据库，这是对于性能的考虑，大部分数据库会给出不同的参数来描述日志缓存刷盘的行为，用户可在性能与恢复数据完整性上作出平衡。 事务在提交的时候，一定要保证其日志已经写入提交日志中。也就是事务内容完全写入日志是事务完成的一个非常重要的标志。 志在理论上可以无限增长，但实际上没有意义。因为一旦数据从缓存中被刷入磁盘，该操作之前的日志就没有意义了，此时日志就可以被截断（Trim），从而释放空间。而这个被截断的点，我们一般称为检查点。检查点之前的页缓存中的脏页需要被完全刷入磁盘中。 日志在实现的时候，一般是由一组文件组成。日志在文件中顺序循环写入，如果一个文件中的数据都是检查点之前的旧数据，那么新日志就可以覆盖它们，从而避免新建文件的问题。同时，将不同文件放入不同磁盘，以提高日志系统的可用性 物理日志 Redo Log 与逻辑日志 Undo Log 事务对数据的修改其实是一种状态的改变，比如将 3 改为 5。这里我们将 3 称为前镜像（before-image），而 5 称为后镜像（after-image）。我们可以得到如下公式：\n前镜像+redo log=后镜像 后镜像+undo log=前镜像 redo log 存储了页面和数据变化的所有历史记录，我们称它为物理日志。而 undo log 需要一个原始状态，同时包含相对这个状态的操作，所以又被称为逻辑日志。我们使用 redo 和 undo 就可以将数据向前或向后进行转换，这其实就是事务操作算法的基础。\nSteal 与 Force 策略 redo 和 undo 有两种写入策略：steal 和 force。\nsteal 策略是说允许将事务中未提交的缓存数据写入数据库，而 no-steal 则是不能。可以看到如果是 steal 模式，说明数据从后镜像转变为前镜像了，这就需要 undo log 配合，将被覆盖的数据写入 undo log，以备事务回滚的时候恢复数据，从而可以恢复到前镜像状态。\nforce 策略是说事务提交的时候，需要将所有操作进行刷盘，而 no-force 则不需要。可以看到如果是 no-force，数据在磁盘上还是前镜像状态。这就需要 redo log 来配合，以备在系统出现故障后，从 redo log 里面恢复缓存中的数据，从而能转变为后镜像状态。\nARIES 数据恢复算法 这个算法全称为 Algorithm for Recovery and Isolation Exploiting Semantics。\n该算法同时使用 undo log 和 redo log 来完成数据库故障崩溃后的恢复工作，其处理流程分为如下三个步骤。\n首先数据库重新启动后，进入分析模式。检查崩溃时数据库的脏页情况，用来识别需要从 redo 的什么位置开始恢复数据。同时搜集 undo 的信息去回滚未完成的事务。 进入执行 redo 的阶段。该过程通过 redo log 的回放，将在页缓存中但是没有持久化到磁盘的数据恢复出来。这里注意，除了恢复了已提交的数据，一部分未提交的数据也恢复出来了。 进入执行 undo 的阶段。这个阶段会回滚所有在上一阶段被恢复的未提交事务。为了防止该阶段执行时数据库再次崩溃，存储引擎会记录下已执行的 undo 操作，防止它们重复被执行。 如何控制并发事务 隔离级别 序列化的概念与事务调度（Schedule）密切相关。一个调度包含该事务的全部操作。我们可以用 CPU 调度理论来类比，当一个事务被调度后，它可以访问数据库系统的全部资源，同时会假设没有其他事务去影响数据库的状态。\n序列化是最强的事务隔离级别，它是非常完美的隔离状态，可以让并行运行的事务感知不到对方的存在，从而安心地进行自己的操作。但在实现数据库事务时，序列化存在实现难度大、性能差等问题。故数据库理论家提出了隔离级别的概念，用来进行不同程度的妥协。在详解隔离级别之前，来看看我们到底可以“妥协”什么。\n读异常：脏读、不可重复读，幻读\n写异常：丢失更新 写偏序\n可重读允许幻读的产生。幻读是事务里面读取一组数据后，再次读取这组数据会发现它们可能已经被修改了。幻读对应的写异常是写偏序**。写偏序从写入角度发现，事务内读取一批数据进行修改，由于幻读的存在，造成最终修改的结果从整体上看违背了数据一致性约束。**\n读到已提交在可重读基础上放弃了不可重读。与幻读类似，但不可重读针对的是一条数据。也就是只读取一条数据，而后在同一个事务内，再读取它数据就变化了 不可重读对应的是丢失更新，与写偏序类似，丢失更新是多个事务操作一条数据造成的。\n最低的隔离级别就是读到未提交，它允许脏读的产生。脏读比较简单，它描述了事务可以读到其他事务为提交的数据，我们可以理解为完全没有隔离性。 脏读本身也会造成写异常：脏写。脏写就是由于读到未提交的数据而造成的写异常。\nMVCC快照隔离技术\n可以被理解为可重读隔离级别，也就是不允许不可重读。但是在可重读隔离下，是可以保证读取不到数据被修改的。但快照隔离的行为是：一旦读到曾经读过的数据被修改，将立即终止当前事务，也就是进行回滚操作。在多并发事务下，也就是只有一个会成功\n并发控制 乐观与悲观 乐观控制使用的场景是并行事务不太多的情况，也就是只需要很少的时间来解决冲突。\n常用的方案是进行提交前冲突检查。冲突检查有多种实现模式，比如最常用的多版本模式。\n悲观控制也不仅仅只有锁这一种方案。一种可能的无锁实现是首先设置两个全局时间戳，最大读取时间与最大写入时间。如果一个读取操作发生的时间小于最大写入时间，那么该操作所在的事务被认为应该终止，因为读到的很可能是旧数据。而一个写操作如果小于最大读取时间，也被认为是异常操作，因为刚刚已经有读取操作发生了，当前事务就不能去修改数据了。而这两个值是随着写入和读取操作而更新的。这个悲观控制被称为 Thomas Write Rule\n虽然乐观与悲观分别有多种实现方案，但乐观控制最为常见的实现是多版本控制，而悲观控制最常见的就是锁控制\n多版本 它将每行数据设置一个版本号，且使用一个单调递增的版本号生成器来产生这些版本号，从而保证每条记录的版本号是唯一的。同时给每个事物分为一个 ID 或时间戳，从而保证读取操作可以读到事务提交之前的旧值。\nMVCC 需要区分提交版本与未提交版本。最近一次提交的版本被认为是当前版本，从而可以被所有事务读取出来。而根据隔离级别的不同，读取操作能或者不能读取到未提交的版本。\n使用 MVCC 最经典的用法是实现快照隔离。事务开始的时候，记录当前时间，而后该事务内所有的读取操作只能读到当前提交版本小于事务开始时间的数据，而未提交的数据和提交版本大于事务开始时间点的数据是不能读取出来的。如果事务读取的数据已经被其他事务修改，那么该数据应该在上一讲提到的 undo log 中，当前事务还是能够读取到这份数据的。故 undo log 的数据不能在事务提交的时候就清除掉，因为很可能有另外的事务正在读取它。\n而当事务提交的时候，数据其实已经写入完成。只需要将版本状态从未提交版本改为提交版本即可。所以 MVCC 中的提交操作是非常快的，这点会对分布式事务有很多启示。\n基于锁的控制 基于锁的控制是典型的悲观控制。它会使用显示的锁来控制共享资源，而不是通过调度手段来实现。锁控制可以很容易实现“序列化操作”，但是它同时存在锁竞争和难扩展等问题。\n锁技术-两阶段锁（2PL), 它将锁操作总结为两个阶段。\n锁膨胀阶段。在该过程中，事务逐步获得它所有的锁，同是不释放任何的锁。期间内可以对加锁的数据进行操作。 锁收缩阶段。在该过程中，在上一步中获得锁逐步进行释放。这个事务是逐步的，这期间事务还可以对持有的锁的数据进行操作。 上述是针对一次性加锁提出来的，一次性加锁的缺点是没有并发度，性能低；而两阶段锁可以保证一定的并发度，但其缺点是会有死锁的产生。\n死锁检测 死锁是两个事务互相持有对方的锁，从而造成它们都无法继续运行。解决死锁需要引入超时机制，但超时机制又有明显的性能缺憾。此时，人们会引入死锁检测机制来尽早发现死锁。一般实现手段是将所有事务的锁依赖构建成一棵依赖图，而后使用图算法来发现其中的环形死锁结构，从而快速判断死锁的产生。\n闩 锁相对的一个概念就是“闩”（latch，读“shuān”）。一般资料说闩是轻量的，锁是重量的，这其实体现在两个方面。\n一是说它们处理的对象。闩一般用在粒度很小的数据中，比如数据块、索引树的节点等。而锁一般作用在大颗粒操作，如锁定多行数据、事务和修改存储结构等。\n二是它们本身的实现不同。闩一般使用 CAS 执行，是基于比较而后设置的无锁指令级别的操作。如果原始值发生变化就重新进行以上操作，这个过程叫自旋（spin）。而锁是使用独立的资源，且有锁管理器来控制。可想而知，调度锁也是一个比较耗时且复杂的过程。\n当前流行的存储引擎 如何评估存储引擎的好坏 缓存的使用方式 数据是可变的还是不可变的 存储的数据是有顺序的还是没有顺序的 缓存形式 缓存是说存储引擎在数据写入的时候，首先将它们写入到内存的一个片段，目的是进行数据汇聚，而后再写入磁盘中。这个小片段由一系列块组成，块是写入磁盘的最小单位。理想状态是写入磁盘的块是满块，这样的效率最高\n可变/不可变数据 存储的数据是可变的还是不可变的，这是判断存储引擎特点的另一个维度。不可变性一般都是以追加日志的形式存在的，其特点是写入高效；而可变数据，以经典 B 树为代表，强调的是读取性能。故一般认为可变性是区分 B 树与 LSM 树的重要指标。但 BW-Tree 这种 B 树的变种结构虽然结构上吸收了 B 树的特点，但数据文件是不可变的。\n当然不可变数据并不是说数据一直是不变的，而是强调了是否在最影响性能的写入场景中是否可变。LSM 树的合并操作，就是在不阻塞读写的情况下，进行数据文件的合并与分割操作，在此过程中一些数据会被删除。\n排序 排序的好处是对范围扫描非常友好，可以实现 between 类的数据操作。同时范围扫描也是实现二级索引、数据分类等特性的有效武器。如本模块介绍的 LSM 树和 B+ 树都是支持数据排序的。\n而不排序一般是一种对于写入的优化。可以想到，如果数据是按照写入的顺序直接存储在磁盘上，不需要进行重排序，那么其写入性能会很好，下面我们要介绍的 WiscKey 和 Bitcask 的写入都是直接追加到文件末尾，而不进行排序的。\n分布式系统 无状态分布式系统 有状态分布式系统 失败模型 分布式系统是由多个节点参与其中的，它们直接通过网络进行互联。每个节点会保存本地的状态，通过网络来互相同步这些状态。\n同时节点需要访问时间组件来获取当前时间。对于分布式系统来说，时间分为逻辑时间与物理时间。逻辑时间一般被实现为一个单调递增的计数器，而物理时间对应的是一个真实世界的时间，一般由操作系统提供。\n“不可靠”贯穿了分布式系统的整个生命周期\n引起失败的原因 时间问题 网络问题，远程节点处理请求时也可能发生故障。一个比较常见的误区就是认为远程执行会马上返回结果，但这种假设是非常不可靠的。因为远程节点的处理能力、运行环境其实是未知的 误解是所有节点时间是一致的，这种误解是非常普遍并且危险的。虽然可以使用工具去同步集群内的时间，但是要保持系统内时间一致是非常困难的。而如果我们使用不同节点产生的物理时间来进行一致性计算或排序，那么结果会非常不靠谱。所以大部分分布式数据库会用一个单独的节点来生成全局唯一的逻辑时间以解决上面的问题。而有些分布式数据库，如 Spanner 会使用原子钟这种精密服务来解决时间一致的问题。 本地物理时间的另一个问题是会产生回溯，也就是获取一个时间并执行若干步骤后，再去获取当前时间，而这个时间有可能比之前的时间还要早。也就是说不能认为系统的物理时间是单调递增的，这就是为什么要使用逻辑时间的另一个重要的原因。\n网络分区问题 网络分区，它指的是分布式系统的节点被网络故障分割为不同的小块。而最棘手的是，这些小块内的节点依然可以提供服务。但它们由于不能很好地感知彼此的存在，会产生不一致的问题\n级联故障的产生 一个单一读故障可能会引起大规模级联反映，从而放大故障的影响面，也就是著名的雪崩现象。\n这种故障放大现象很可能来源于一个为了稳定系统而设计的机制。比如，当系统出现瓶颈后，一个新节点被加入进来，但它需要同步数据才能对外提供服务，而大规模同步数据很可能造成其他节点资源紧张，特别是网络带宽，从而导致整个系统都无法对外提供服务。\n解决级联故障 解决级联故障的方式有退避算法和断路。退避算法大量应用在 API 的设计中，由于上文提到远程节点会存在暂时性故障，故需要进行重试来使访问尽可能成功地完成。而频繁地重试会造成远程节点资源耗尽而崩溃，退避算法正是依靠客户端来保证服务端高可用的一种手段。而从服务端角度进行直接保护的方式就是断路，如果对服务端的访问超过阈值，那么系统会中断该服务的请求，从而缓解系统压力。\n崩溃失败模式 当遭遇故障后，进程完全停止工作被称为崩溃失败。这是最简单的一种失败情况，同时结果也非常好预测。这种失败模式也称为崩溃停止失败，特别强调失败节点不需要再参与回分布式系统内部了。\n优缺点 我们说这种模式是最容易预测的，是因为失败节点退出后，其他节点感知到之后可以继续提供服务，而不用考虑它重新回归所带来的复杂问题。\n虽然失败停止模式有以上的优点，但实际的分布式系统很少会采用。因为它非常明显地会造成资源浪费，所以我们一般采用崩溃恢复模式，从而重复利用资源。提到崩溃节点恢复，一般都会想到将崩溃节点进行重启，而后经过一定的恢复步骤再加入网络中。虽然这是一种主流模式，但其实通过数据复制从而生成备份节点，而后进行快速热切换才是最为主流的模式。\n崩溃失败可以被认为是遗漏失败的一种特殊情况\n遗漏失败 遗漏失败相比于崩溃失败来说更为不可预测，这种模式强调的是消息有没有被远程节点所执行。\n这其中的故障可能发生在：\n消息发送后没有送达远程节点； 远程节点跳过消息的处理或根本无法执行（一种特例就是崩溃失败，节点无法处理消息）； 后者处理的结果无法发送给其他节点。 总之，从其他节点的角度看，发送给该节点的消息石沉大海，没有任何响应了\n网络分区是遗漏失败的典型案例，其中一部分节点间消息是能正常收发的，但是部分节点之间消息发送存在困难。而如果崩溃失败出现，集群中所有节点都将无法与其进行通讯。\n另一种典型情况就是一个节点的处理速度远远慢于系统的平均水平，从而导致它的数据总是旧的，而此时它没有崩溃，依然会将这些旧数据发送给集群内的其他节点。\n当远程节点遗漏消息时，我们是可以通过重发等可靠连接手段来缓解该问题的。但是如果最终还是无法将消息传递出去，同时当前节点依然在继续提供服务，那么此时遗漏失败才会产生。除了以上两种产生该失败的场景，遗漏失败还会发生在网络过载、消息队列满等场景中\n拜占庭将军问题 拜占庭失败又称为任意失败，它相比于上述两种失败是最不好预测的。所谓任意失败是，参与的节点对请求产生不一致的响应，一个说当前数据是 A，而另一个却说它是 B。\n这个故障往往是程序 Bug 导致的，可以通过严格软件开发流程管理来尽可能规避。但我们都清楚，Bug 在生产系统中是很难避免的，特别是系统版本差异带来的问题是极其常见的。故在运行态，一部分系统并不信任直接从远程节点获得的数据，而是采用交叉检测的方式来尽可能得到正确的结果。\n另一种任意失败是一些节点故意发送错误消息，目的是想破坏系统的正常运行，从而牟利。采用区块链技术的数字货币系统则是使用正面奖励的模式（BFT），来保证系统内大部分节点不“作恶”（做正确事的收益明显高于作恶）。\n错误侦测与领导选举 解决失败问题，首先进行侦测\n错误侦测一个重要应用领域就是领导选举。使用错误侦测技术来检测领导节点的健康状态，从而决定是否选择一个新节点来替代已经故障的领导节点。\n领导节点的一个主要作用就是缓解系统发生失败的可能。系统中如果进行对等同步状态的代价是很高昂的，如果能选择一个领导节点来统一进行协调，那么会大大降低系统负载，从而避免一些失败的产生。\n复制与一致性 故障容忍系统（Fault-tolerant）一般使用复制技术产生多个副本，来提供系统的可用性。这样可以保证当系统总部分节点发生故障后，仍然可以提供正常响应。而多个副本会产生数据同步的需求，一致性就是保证数据同步的前提。\n共识算法 共识算法是为了解决拜占庭将军问题而产生的。简单来说，在从前，拜占庭将军问题被认为是一个逻辑上的困境，它说明了一群拜占庭将军在试图就下一步行动达成统一意见时，可能存在的沟通问题。\n该困境假设每个将军都有自己的军队，每支军队都位于他们打算攻击的城市周围的不同位置，这些将军需要就攻击或撤退达成一致。只要所有将军达成共识，即协调后决定共同执行，无论是攻击还是撤退都无关紧要。\n基于著名的 FLP 不可能问题的研究，拜占庭将军们面临三种困境：\n将军们没有统一的时间（没法对表）； 无法知道别的将军是否被击败； 将军们之间的通讯是完全异步的。 由于以上的困境，我们是没有任何办法使将军们最终在特定时间内达成一致性意见的，也就是说共识算法在上述困境下是完全不可能的。\n但是共识算法使用逻辑时钟来提供统一时间，并引入错误侦测技术来确定参与节点的情况，从而在完全异步的通讯情况下可以实现分布式系统的共识。本模块最后一部分，我会介绍几种经典的共识算法，并介绍它们的使用案例。\n共识可以解决遗漏失败，因为只要系统内大部分节点达成共识，剩下的节点即使遗漏该消息，也能对外提供正确的数据。\n分布式系统安全协调 领导选举 分布式系统中所有节点都是平等的关系，任何节点都可以承担领导角色。节点一旦成为领导，一般在相当长的时间内会一直承担领导的角色，但这不是一个永久性的角色。原因也比较容易想到：节点会崩溃，从而不能履行领导职责。\n领导节点职责：\n控制广播消息的总顺序； 收集并保存全局状态； 接收消息，并在节点之间传播和同步它们； 进行系统重置，一般是在发生故障后、初始化期间，或重要系统状态更新时操作。 触发选举 在初始化时触发选举，称为首次选举领导； 当前一位领导者崩溃或无法通信时。 选举算法的关键属性\n莱斯利·兰伯特（ L.Lamport——分布式计算的开创者）提出\n安全性 活跃性 选举规则:\n选举必须要产生一个领导 对应安全性 选举必须要有结果 对应活跃性 第一条规则消除了脑裂的可能性\n脑裂：\n集群被分成两个以上部分，并产生多个互相不知道对方存在的领导节点\n第二规则：它保证了在绝大多数时候，集群内都会有一个领导者，选举最终会完成并产生这个领导，即系统不应无限期地处于选举状态。\n领导选举与分布式锁 领导选举和分布式锁在算法层面有很高的重合性，前者选择一个节点作为领导，而后者则是作为锁持有者。\n分布式锁是保证在并发环境中，一些互斥的资源，比如事务、共享变量等，同一时间内只能有一个节点进行操作。它也需要满足安全性和活跃性，即排他锁每次只能分配给一个节点，同时该节点不会无限期持有锁。\n区别：\n如果一个节点持有排他锁，那么对于其他节点来说，不需要知道谁现在持有这个锁，只要满足锁最终将被释放，允许其他人获得它。\n选举过程完全不是这样，集群中的节点必须要知道目前系统中谁是领导节点，因为集群中其他节点需要感知领导节点的活性，从而判断是否需要进入到选举流程中。因此，新当选的领导人必须将自己的角色告知给它的下属。\n如果分布式锁算法对特定的节点或节点组有偏好，也就是非公平锁，它最终会导致一些非优先节点永远都获得不了共享资源，这与“活跃性”是矛盾的。与其相反，我们一般希望领导节点尽可能长时间地担任领导角色，直到它停止或崩溃，因为“老”领导者更受大家的欢迎\n经典领导选举算法：Bully 算法 最常用的一种领导选举算法，它使用节点 ID的大小来选举新领导者。在所有活跃的节点中，选取节点 ID 最大或者最小的节点为主节点。\n每个节点都会获得分配给它的唯一 ID。在选举期间，ID 最大的节点成为领导者。因为 ID 最大的节点“逼迫”其他节点接受它成为领导者，它也被称为君主制领导人选举：类似于各国王室中的领导人继承顺位，由顺位最高的皇室成员来继承皇位。如果某个节点意识到系统中没有领导者，则开始选举，或者先前的领导者已经停止响应请求。\n步骤 集群中每个活着的节点查找比自己 ID 大的节点，如果不存在则向其他节点发送 Victory 消息，表明自己为领导节点； 如果存在比自己 ID 大的节点，则向这些节点发送 Election 消息，并等待响应； 如果在给定的时间内，没有收到这些节点回复的消息，则自己成为领导节点，并向比自己 ID 小的节点发送 Victory 消息； 节点收到比自己 ID 小的节点发送的 Election 消息，则回复 Alive 消息 缺点 它违反了“安全性”原则（即一次最多只能选出一位领导人）。在存在网络分区的情况下，在节点被分成两个或多个独立工作的子集的情况下，每个子集选举其领导者。\n算法优化 故障转移节点列表\n节点分角色 邀请算法 客户端一致性 完整的一致性模型\n粉色代表网络分区后完全不可用。也就是 CP 类的数据库。 黄色代表严格可用。当客户端一直访问同一个数据库节点，那么遭遇网络分区时，在该一致性下依然是可用的。它在数据端或服务端，被认为是 AP 数据库；而从客户端的角度被认为是 CP 数据库。 蓝色代表完全可用。可以看到其中全都是客户端一致性，所以它们一般被认为是 AP 数据库。 写跟随读 WFR 的另一个名字是回话因果（session causal）。可以看到它与因果一致的区别是，它只针对一个客户端。故你可以对比记忆，它是对于一个客户端，如果一次读取到了写入的值 V1，那么这次读取之后写入了 V2。从其他节点看，写入顺序一定是 V1、V2。\nWFR 的延迟性问题可以描述为：当写入 V1 时，是允许复制延迟的。但一旦 V1 被读取，就需要认为所有副本中 V1 已经被写入了，从而保证从副本写入 V2 时的正确性。\n管道随机访问存储（PRAM）/FIFO 管道随机访问存储的名字来源于共享内存访问模型。\n它被描述为从一个节点发起的写入操作，其他节点与该节点的执行顺序是一致的。它与顺序一致性最大的区别是，后者是要求所有节点写入都是有一个固定顺序的；而 PRAM 只要求一个节点自己的操作有顺序，不同节点可以没有顺序。\nPRAM 可以拆解为以下三种一致性。\n读到已写入（Read Your Write）：一个节点写入数据后，在该节点或其他节点上是能读取到这个数据的。 单增读（Monotonic Read）：它强调一个值被读取出来，那么后续任何读取都会读到该值，或该值之后的值。 单增写（Monotonic Write）：如果从一个节点写入两个值，它们的执行顺序是 V1、V2。那么从任何节点观察它们的执行顺序都应该是 V1、V2。 同时满足 RYW、MR 和 MW 的一致性就是 PRAM。PRAM 的实现方式一般是客户端一直连接同一个节点，因为读写同一个节点，故不存在延迟性的问题。\n最终一致性 最终一致性是非常著名的概念。随着互联网和大型分布式系统的发展，这一概念被广泛地传播。它被表述为副本之间的数据复制完全是异步的，如果数据停止修改，那么副本之间最终会完全一致。而这个最终可能是数毫秒到数天，乃至数月，甚至是“永远”。\n最终一致性具有最高的并发度，因为数据写入与读取完全不考虑别的约束条件。如果并发写入修改同一份数据，一般采用之前提到的一些并发冲突解决手段来处理，比如最后写入成功或向量时钟等。\n但是，最终一致性在分布式数据库中是完全不可用的。它至少会造成各种偏序（skew）现象，比如写入数据后读取不出来，或者一会儿能读取出来，一会儿又读取不出来。因为数据库系统是底层核心系统，许多应用都构建在它上面，此种不稳定表现在分布式数据库设计中是很难被接受的。故我们经常采用可调节的最终一致性，来实现 AP 类的分布式数据库。\n反熵理论 在封闭系统内且没有外力作用下，熵总是增的。而时间也是跟随熵增一起向前流动的\n一般都表示系统总是向混乱的状态变化。在最终一致性系统中，就表示数据最终有向混乱方向发展的趋势，这个时候我们就要引入“反熵”机制来施加“外力”，从而消除自然状态的“熵增”所带来的影响。\n通过一些外部手段，将分布式数据库中各个节点的数据达到一致状态。\n前台同步 前台同步是通过读与写这两个前台操作，同步性地进行数据一致性修复。它们分别称为读修复（Read Repair）和暗示切换（Hinted Handoff）。\n读修复 请求由一个总的协调节点来处理，这个协调节点会从一组节点中查询数据，如果这组节点中某些节点有数据缺失，该协调节点就会把缺失的数据发送给这些节点，从而修复这些节点中的数据，达到反熵的目的。\n读修复可以使用阻塞模式与异步模式两种。阻塞模式如上图所示，在修复完成数据后，再将最终结果返还给客户端；而异步模式会启动一个异步任务去修复数据，而不必等待修复完成的结果，即可返回到客户端\n暗示切换 客户端首先写入协调节点。而后协调节点将数据分发到两个节点中，这个过程与可调节一致性中的写入是类似的。正常情况下，可以保证写入的两个节点数据是一致的。如果其中的一个节点失败了，系统会启动一个新节点来接收失败节点之后的数据，这个结构一般会被实现为一个队列（Queue），即暗示切换队列（HHQ）\n一旦失败的节点恢复了回来，HHQ 会把该节点离线这一个时间段内的数据同步到该节点中，从而修复该节点由于离线而丢失的数据。这就是在写入节点进行反熵的操作。\n后台异步 后台异步方案主要面向已经写入较长时间的数据，也就是不活跃的数据。进而使用这种方案也可以进行全量的数据一致性修复工作。\n前台方案重点放在修复数据，而后台方案由于需要比较和处理大量的非活跃数据，故需要重点解决如何使用更少的资源来进行数据比对。\nMerkle 树 哈希树，完整性校验\n比较数据一致性，最直观的方式进行全量比较，但是效率低下。实际生产中不可能实行。而通过 Merkle 树我们可以快速找到两份数据之间的差异\n树构造的过程是：\n将数据划分为多个连续的段。而后计算每个段的哈希值，得到 hash1 到 hash4 这四个值； 而后，对这四个值两两分组，使用 hash1 和 hash2 计算 hash5、用 hash3 和 hash4 计算 hash6； 最后使用 hash5 和 hash6 计算 top hash。 Merkle 树结合了 checksum 校验与二叉树的特点，可以帮助我们快速判断两份数据是否存在差异。但如果我们想牺牲一定精准性来控制参与比较的数据范围\n位图版本向量 算法利用了位图这一种对内存非常友好的高密度数据格式，将节点近期的数据同步状态记录下来；而后通过比较各个节点间的位图数据，从而发现差异，修复数据\nGossip 协议 节点间主动地互相交换信息，最终达到将消息快速传播的目的。而该协议又是基于病毒传播模型设计的\nGossip 模式非常适合于无主集群的数据同步，也就是不管集群中有多少节点参与，消息都可以很健壮地在集群内传播。当然，消息会重复传播到同一个节点上，在实现算法的时候，我们需要尽量减少这种重复数据。\n分布式事务 原子提交：它们可以使一组操作看起来是原子化的，即要么全部成功要么全部失败，而且其中一些操作是远程操作。\nOpen/X 组织提出 XA 分布式事务标准就是原子化提交的典型代表，XA 被主流数据库广泛地实现，相当长的一段时间内竟成了分布式事务的代名词。\n随着 Percolator 的出现，基于快照隔离的原子提交算法进入大众的视野，在 TiDB 实现 Percolator 乐观事务后，此种方案逐步达到生产可用的状态。\n两阶段提交 历史悠久 其定义是很模糊的，它首先不是一个协议，更不是一个规范，而仅仅是作为一个概念存在 两阶段提交包含协调器与参与者两个角色。\n在第一个阶段，协调器将需要提交的数据发送给参与者，同时询问参与者是否能够提交该数据，而后参与者返回投票结果。 在第二阶段，协调器根据参与者的投票结果，决定是提交还是取消这次事务，而后将结果发送给每个参与者，参与者根据结果来提交本地的事务。 可以看到两阶段提交的核心是协调器。它一般被实现为一个领导节点，你可以回忆一下领导选举那一讲。我们可以使用多种方案来选举领导节点，并根据故障检测机制来探测领导节点的健康状态，从而确定是否要重新选择一个领导节点作为协调器。另外一种常见的实现是由事务发起者来充当协调器，这样做的好处是协调工作被分散到多个节点上，从而降低了分布式事务的负载\n事务过程 准备阶段。协调器向所有参与节点发送 Propose 消息，该消息中包含了该事务的全部信息。而后所有参与节点收到该信息后，进行提交决策——是否可以提交该事务，如果决定提交该事务，它们就告诉协调器同意提交；否则，它们告诉协调器应该终止该事务。协调器和所有参与者分别保存该决定的结果，用于故障恢复。 提交或终止。如果有任何一个参与者终止了该事务，那么所有参与者都会收到终止该事务的结果，即使他们自己认为是可以提交该事务的。而只有当所有参与者全票通过该事务时，协调器才会通知它们提交该事务。这就是原子提交的核心理念：全部成功或全部失败。 异常处理流程 参与者在准备阶段失败。当协调者发起投票后，有一个参与者没有任何响应（超时）。协调者就会将这个事务标记为失败，这与该阶段投票终止该事务是同样的结果。这虽然保证了事务的一致性，但却降低了分布式事务整体的可用性。下一讲我会介绍 Spanner 使用 Paxos groups 来提高参与者的可用度。 参与者在投票后失败。这种场景描述了参与者投赞成票后失败了，这个时候必须保证该节点是可以恢复的。在其恢复流程里，需要首先与协调器取得联系，确认该事务最终的结果。然后根据其结果，来取消或者提交该事务。 协调器在投票后失败。这是第二个阶段，此时协调器和参与者都已经把投票结果记录下来了。如果协调器失败，我们可以将备用协调器启动，而后读取那个事务的投票结果，再向所有参与者发送取消或者提交该事务的消息。 协调器在准备阶段失败。这是在第一阶段，该阶段存在一个两阶段提交的缺点。在该阶段，协调器发送消息没有收到投票结果，这里所说的没有收到结果主要指结果没有记录到日志里面。此时协调器失败了，那么备用协调器由于缺少投票结果的日志，是不能恢复该事务的。甚至其不知道有哪些参与者参与了这个事务，从而造成参与者无限等待。所以两阶段提交又称为阻塞提交算法。 三阶段提交 三阶段相比于两阶段主要是解决上述第 4 点中描述的阻塞状态。\n它的解决方案是在两阶段中间插入一个阶段，第一阶段还是进行投票，第二阶段将投票后的结果分发给所有参与者，第三阶段是提交操作。其关键点是在第二阶段，如果协调者在第二阶段之前崩溃无法恢复，参与者可以通过超时机制来释放该事务。一旦所有节点通过第二阶段，那么就意味着它们都知道了当前事务的状态，此时，不管协调者还是参与者崩溃都不会影响事务执行。\n阶段事务会存在两阶段不存在的一个问题，在第二阶段的时候，一些参与者与协调器失去联系，它们由于超时机制会中断事务。而如果另外一些参与者已经收到可以提交的指令，就会提交数据，从而造成脑裂的情况。\n快照隔离 它的隔离级别高于“读到已提交”，解决的是读到已提交无法避免的读偏序问题，也就是一条数据在事务中被读取，重复读取后可能会改变。\n举一个快照隔离的读取例子，有甲乙两个事务修改同一个数据 X，其初始值为 2。甲开启事务，但不提交也不回退。此时乙将该数值修改为 10，提交事务。而后甲重新读取 X，其值仍然为 2，并没有读取到已经提交的最新数据 。\n那么并发提交同一条数据呢？由于没有锁的存在，会出现写入冲突，通常只有其中的一个事务可以提交数据。这种特性被称为首先提交获胜机制。\n快照隔离与序列化之间的区别是前者不能解决写偏序的问题，也就是并发事务操作的数据集不相交，当事务提交后，不能保证数据集的结果一致性。举个例子，对于两个事务 T1：b=a+1 和 T2：a=b+1，初始化 a=b=0。序列化隔离级别下，结果只可能是 (a=2,b=1) 或者 (a=1,b=2)；而在快照隔离级别下，结果可能是 (a=1,b=1)。这在某些业务场景下是不能接受的。当然，目前有许多手段来解决快照隔离的写偏序问题，即序列化的快照隔离（SSI）。\n实现 SSI 的方式有很多种，如通过一个统一的事务管理器，在提交时去询问事务中读取的数据在提交时是否已经被别的事务的提交覆盖了，如果是，就认为当前事务应标记为失败。另一些是通过在数据行上加锁，来阻止其他事务读取该事务锁定的数据行，从而避免写偏序的产生。\n分布式事务模式实现分类 Spanner Calvin 共识算法 解决分布式系统比较棘手的失败问题，通过内置的失败检测机制可以发现失败节点、领导选举机制保证数据高效处理、一致性模式保证了消息的一致性。\n属性 正确性（Validity）：诚实节点最终达成共识的值必须是来自诚实节点提议的值。 一致性（Agreement）：所有的诚实节点都必须就相同的值达成共识。 终止性（Termination）：诚实的节点必须最终就某个值达成共识。 原子广播协议 广播协议是一类将数据从一个节点同步到多个节点的协议。\n广播过程产生了一个问题，那就是这个协调节点是明显的单点，它的可靠性至关重要。要保障其可靠，首先要解决的问题是需要检查这个节点的健康状态。我们可以通过各种健康检查方式去发现其健康情况。\n如果它失败了，会造成消息传播到一部分节点中，而另外一部分节点却没有这一份消息，这就违背了“一致性”。那么应该怎解决这个问题呢？\n一个简单的算法就是使用“漫灌”机制，这种机制是一旦一个消息被广播到一个节点，该节点就有义务把该消息广播到其他未收到数据节点的义务。这就像水田灌溉一样，最终整个系统都收到了这份数据。\n当然以上的模式有个明显的缺点，就是会产生N2的消息。其中 N 是目前系统剩下的未同步消息的节点，所以我们的一个优化目标就是要减少消息的总数量。\n协议要求：\n原子性：所有参与节点都收到并传播该消息；或相反，都不传播该消息。 顺序性：所有参与节点传播消息的顺序都是一致的。 ZAB 常见的原子广播协议：Zookeeper Atomic Broadcast（ZAB）。\nZAB 协议由于 Zookeeper 的广泛使用变得非常流行。它是一种原子广播协议，可以保证消息顺序的传递，且消息广播时的原子性保障了消息的一致性。\nZAB 协议中，节点的角色有两种。\n领导节点。领导是一个临时角色，它是有任期的。这么做的目的是保证领导角色的活性。领导节点控制着算法执行的过程，广播消息并保证消息是按顺序传播的。读写操作都要经过它，从而保证操作的都是最新的数据。如果一个客户端连接的不是领导节点，它发送的消息也会转发到领导节点中。 跟随节点。主要作用是接受领导发送的消息，并检测领导的健康状态 选举原则：\n明确两个 ID：数据 ID 与节点 ID。前者可以看作消息的时间戳，后者是节点的优先级。选举的原则是：在同一任职周期内，节点的数据 ID 越大，表示该节点的数据越新，数据 ID 最大的节点优先被投票。所有节点的数据 ID 都相同，则节点 ID 最大的节点优先被投票。当一个节点的得票数超过节点半数，则该节点成为主节点。\nZAB 选举的优势是，如果领导节点一直健康，即使当前任期过期，选举后原领导节点还会承担领导角色，而不会触发领导节点切换，这保证了该算法的稳定。另外，它的节点恢复比较高效，通过比较各个节点的消息 ID，找到最大的消息 ID，就可以从上面恢复最新的数据了。最后，它的消息广播可以理解为没有投票过程的两阶段提交，只需要两轮消息就可以将消息广播出去。\nPaxos Paxos 算法，是为了解决来自客户端的值被发送到集群中的任意一点，而后集群中的所有节点为该值达成共识的一种协调算法。同时这个值伴随一个版本号，可以保证消息是有顺序的，该顺序在集群中任何一点都是一致的。\n基本的 Paxos 算法非常简单，它由三个角色组成。\nProposer：Proposer 可以有多个，Proposer 提出议案（value）。所谓 value，可以是任何操作，比如“设置某个变量的值为 value”。不同的 Proposer 可以提出不同的 value。但对同一轮 Paxos 过程，最多只有一个 value 被批准。 Acceptor：Acceptor 有 N 个，Proposer 提出的 value 必须获得 Quorum 的 Acceptor 批准后才能通过。Acceptor 之间完全对等独立。 Learner：上面提到只要 Quorum 的 Accpetor 通过即可获得通过，那么 Learner 角色的目的就是把通过的确定性取值同步给其他未确定的 Acceptor。 这三个角色其实已经描述了一个值被提交的整个过程。其实基本的 Paxos 只是理论模型，因为在真实场景下，我们需要处理许多连续的值，并且这些值都是并发的。如果完全执行上面描述的过程，那性能消耗是任何生产系统都无法承受的，因此我们一般使用的是 Multi-Paxos。\n原子广播与共识算法 ZAB 其实与 Multi-Paxos 是非常类似的。本质上，它们都需要大部分节点“同意”一个值，并都有 Leader 节点，且 Leader 都是临时的。真是越说越相似，但本质上它们却又是不同的。\n简单来说，ZAB 来源于主备复制场景，就是我们之前介绍的复制技术；而共识算法是状态机复制系统。\n所谓状态机复制系统，是指集群中每个节点都是一个状态机，如果有一组客户端并发在系统中的不同状态机上提交不同的值，该系统保证每个状态机都可以保证执行相同顺序的客户端请求。可以看到请求一旦被提交，其顺序是有保障的。但是未提交之前，顺序是由 Leader 决定的，且这个顺序可以是任意的。一旦 Leader 被重选，新的 Leader 可以任意排序未提交的值。\n而 ZAB 这种广播协议来自主备复制，强调的是消息的顺序是 Leader 产生的，并被 Follower 严格执行，其中没有协调的关系。更重要的区别是，Leader 重选后，新 Leader 依然会按照原 Leader 的排序来广播数据，而不会自己去排序。\n由于共识算法如 Paxos 为了效率的原因引入了 Leader。在正常情况下，两者差异不是很大，而差异主要在选举 Leader 的流程上。\nRaft算法 Raft 可以看成是 Multi-Paxos 的改进算法，因为其作者曾在斯坦福大学做过关于 Raft 与 Multi-Paxos 的比较演讲，因此我们可以将它们看作一类算法。\nRaft 算法可以说是目前最成功的分布式共识算法，包括 TiDB、FaunaDB、Redis 等都使用了这种技术。原因是 Multi-Paxos 没有具体的实现细节，虽然它给了开发者想象空间，但共识算法一般居于核心位置，一旦存在潜在问题必然带给系统灾难性的后果。而 Raft 算法给出了大量的实现细节，且处理方式相比于 Multi-Paxos 有两点优势。\n发送的请求的是连续的，也就是说 Raft 的写日志操作必须是连续的；而 Multi-Paxos 可以并发修改日志，这也体现了“Multi”的特点。 选主必须是最新、最全的日志节点才可以当选，这一点与 ZAB 算法有相同的原则；而 Multi-Paxo 是随机的。因此 Raft 可以看成是简化版本的 Multi-Paxos，正是这个简化，造就了 Raft 的流行。 Multi-Paxos 随机性使得没有一个节点有完整的最新的数据，因此其恢复流程非常复杂，需要同步节点间的历史记录；而 Raft 可以很容易地找到最新节点，从而加快恢复速度。当然乱序提交和日志的不连续也有好处，那就是写入并发性能会大大提高，从而提高吞吐量。所以这两个特性并不是缺点，而是权衡利弊的结果。当然 TiKV 在使用 Raft 的时候采用了多 RaftGroup 的模式，提高了单 Raft 结构的并发度，这可以被看作是向 Multi-Paxos 的一种借鉴。\n同时 Raft 和 Multi-Paxos 都使用了任期形式的 Leader。好处是性能很高，缺点是在切主的时候会拒绝服务，造成可用性下降。因此一般我们认为共识服务是 CP 类服务（CAP 理论）。但是有些团队为了提高可用性 ，转而采用基础的 Paxos 算法，比如微信的 PaxosStore 都是用了每轮一个单独的 Paxos 这种策略。\n以上两点改进使 Raft 更好地落地，可以说目前最新数据库几乎都在使用该算法\n","permalink":"https://AlfredNing.github.io/note/program/sql/distributed_database/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA/","summary":"分布式数据库 分布式数据库的介绍 数据库产品特点\n抽象程度高，用户仅从使用层面解除 商业氛围一直很浓厚 基本概念 分布式数据库的核心： 数据分片、数据同步\n数据分片 讲数据分散到多个节点，以更高效、更灵活的方式来处理数据 分类：\n水平分片：按行进行数据分割，数据被切割成一个个数据组，分散到不同节点 垂直分片：按列进行数据分割，一个数据表的模式（Schema）被切割为多个小的模式 数据同步 数据一致性的保证，分布式数据库的底线\n早期的关系型商业数据库的分布式能力可以满足大部分用户的场景，因此产生了如 Oracle 等几种巨无霸数据库产品；\nOLAP 领域首先寻求突破，演化出了大数据技术与 MPP 类型数据库，提供功能更强的数据分析能力；\n去IOE 引入数据库中间件，并结合应用平台与开源单机数据库形成新一代解决方案，让商业关系型数据库走下神坛，NoSQL 数据库更进一步\u0026gt;打破了关系型数据库唯我独尊的江湖地位；\n新一代分布式 OLTP 数据库正式完成了分布式领域对数据库核心特性的完整支持，它代表了分布式数据库从此走向了成熟，也表明了 OLAP 与 OLTP 分布式场景下，分别在各自领域内取得了胜利；\nHTAP 和多模式数据处理的引入，再一次将 OLAP 与 OLTP 融合，从而将分布式数据库推向如传统商业关系型数据库数十年前那般的盛况，而其产生的影响要比后者更为深远\nSQL的发展史 最初的数据管理“关系模型”是指由 IBM 研究人员 E.F. Codd 在 20 世纪 70 年代初设计的，并在 System R 及后续许多数据库系统中得到了普及。 由于 Schema（模式）的预定义，数据库获得存储相对紧凑，从而导致其性能较为优异；之后就是经典的 ACID 给业务带来了可控性，而基于标准化 SQL 的数据访问模式给企业级应用带来了更多的红利，因为“标准即是生产力”\n缺点：\n对前期设计要求高，因为后期修改 Schema 往往需要停机，没有考虑分布式场景，在扩展性和可用性层面缺乏支持；而分布式是 21 世纪应用必备的技能。\nNoSQL数据库和SQL数据库的区别 NoSQL的缺点 由于缺乏ACID, 应用时需要非常小心处理数据一致性问题；同时其数据模型只针对特定的应用场景，一般不能使用一种 NoSQL 数据库来完成整个应用的构建，导致设计层面的复杂和维护的困难。","title":"分布式数据库理论"},{"content":"调优工具 jConsole Visual VM eclipse MAT JProfiler Arthas Java Mission Control Flame Graphs（火焰图） Tprofiler Btrace YourKit JProbe Spring Insight OOM 案例 堆溢出 报错信息 java.lang.OutOfMemoryError: Java heap space\n参数配置 -XX:+PrintGCDetails -XX:MetaspaceSize=64m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=heap/heapdump.hprof -XX:+PrintGCDateStamps -Xms200M -Xmx200M -Xloggc:log/gc-oomHeap.log 原因及解决 原因\n1、代码中可能存在大对象分配\n2、可能存在内存泄漏，导致在多次GC之后，还是无法找到一块足够大的内存容纳当前对象。\n解决方法\n1、检查是否存在大对象的分配，最有可能的是大数组分配\n2、通过jmap命令，把堆内存dump下来，使用MAT等工具分析一下，检查是否存在内存泄漏的问题\n3、如果没有找到明显的内存泄漏，使用 -Xmx 加大堆内存\n4、还有一点容易被忽略，检查是否有大量的自定义的 Finalizable 对象，也有可能是框架内部提供的，考虑其存在的必要性\n分析GC日志\n元空间溢出 方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、即时编译器编译后的代码等数据。虽然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。\nJava 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。垃圾收集行为在这个区域是比较少出现的，其内存回收目标主要是针对常量池的回收和对类型的卸载。当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。\n报错信息 java.lang.OutOfMemoryError: Metaspace\n参数配置 -XX:+PrintGCDetails -XX:MetaspaceSize=60m -XX:MaxMetaspaceSize=60m -Xss512K -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=heap/heapdumpMeta.hprof -XX:SurvivorRatio=8 -XX:+TraceClassLoading -XX:+TraceClassUnloading -XX:+PrintGCDateStamps -Xms60M -Xmx60M -Xloggc:log/gc-oomMeta.log 原因及其解决 JDK8后，元空间替换了永久代，元空间使用的是本地内存\n原因：\n运行期间生成了大量的代理类，导致方法区被撑爆，无法卸载\n应用长时间运行，没有重启\n元空间内存设置过小\n解决方法：\n因为该 OOM 原因比较简单，解决方法有如下几种：\n检查是否永久代空间或者元空间设置的过小\n检查代码中是否存在大量的反射操作\ndump之后通过mat检查是否存在大量由于反射生成的代理类\nGC overhead limit exceeded 系统在频繁性的做FULL GC，但是却没有回收掉多少空间，那么引起的原因可能是因为内存不足，也可能是存在内存泄漏的情况\n线程溢出 报错信息 java.lang.OutOfMemoryError : unable to create new native Thread\n原因及其解决 出现这种异常，基本上都是创建了大量的线程导致的\n解决：\n通过 -Xss 设置每个线程栈大小的容量\nJDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K。\n正常情况下，在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右。\n能创建的线程数的具体计算公式如下：\n(MaxProcessMemory - JVMMemory - ReservedOsMemory) / (ThreadStackSize) = Number of threads\n——————————————————————————————————————\nMaxProcessMemory 指的是进程可寻址的最大空间\nJVMMemory JVM内存\nReservedOsMemory 保留的操作系统内存\nThreadStackSize 线程栈的大小\n——————————————————————————————————————\n在Java语言里， 当你创建一个线程的时候，虚拟机会在JVM内存创建一个Thread对象同时创建一个操作系统线程，而这个系统线程的内存用的不是JVMMemory，而是系统中剩下的内存(MaxProcessMemory - JVMMemory - ReservedOsMemory)。\n由公式得出结论：你给JVM内存越多，那么你能创建的线程越少，越容易发生java.lang.OutOfMemoryError: unable to create new native thread\n综上，在生产环境下如果需要更多的线程数量，建议使用64位操作系统，如果必须使用32位操作系统，可以通过调整Xss的大小来控制线程数量。\n线程总数也受到系统空闲内存和操作系统的限制，检查是否该系统下有此限制：\n/proc/sys/kernel/pid_max 系统最大pid值，在大型系统里可适当调大\n/proc/sys/kernel/threads-max 系统允许的最大线程数\nmaxuserprocess（ulimit -u） 系统限制某用户下最多可以运行多少进程或线程\n/proc/sys/vm/max_map_count\nmax_map_count文件包含限制一个进程可以拥有的VMA(虚拟内存区域)的数量。虚拟内存区域是一个连续的虚拟地址空间区域。在进程的生命周期中，每当程序尝试在内存中映射文件，链接到共享内存段，或者分配堆空间的时候，这些区域将被创建。调优这个值将限制进程可拥有VMA的数量。限制一个进程拥有VMA的总数可能导致应用程序出错，因为当进程达到了VMA上线但又只能释放少量的内存给其他的内核进程使用时，操作系统会抛出内存不足的错误。如果你的操作系统在NORMAL区域仅占用少量的内存，那么调低这个值可以帮助释放内存给内核用。\n调优的基本问题 为什么要调优 防止出现OOM，进行JVM规划和预调优 解决程序运行中各种OOM 减少Full GC出现的频率，解决运行慢、卡顿问题 调优的大方向 合理地编写代码 充分并合理的使用硬件资源 合理地进行JVM调优 不同阶段的考虑 上线前 项目运行阶段 线上出现OOM 调优，从业务场景开始，没有业务场景的调优都是耍流氓！ 无监控，不调优！ 调优监控的依据 运行日志 异常堆栈 GC日志 线程快照 堆转储快照 性能优化的步骤 第1步：熟悉业务场景 第2步（发现问题）：性能监控 GC 频繁 cpu load过高 OOM 内存泄漏 死锁 程序响应时间较长 第3步（排查问题）：性能分析 打印GC日志，通过GCviewer或者 http://gceasy.io来分析日志信息 灵活运用 命令行工具，jstack，jmap，jinfo等 dump出堆文件，使用内存分析工具分析文件 使用阿里Arthas，或jconsole，JVisualVM来实时查看JVM状态 jstack查看堆栈信息 第4步（解决问题）：性能调优 适当增加内存，根据业务背景选择垃圾回收器 优化代码，控制内存使用 增加机器，分散节点压力 合理设置线程池线程数量 使用中间件提高程序效率，比如缓存，消息队列等 性能评价/测试指标 停顿时间（或响应时间） 吞吐量 并发数 内存占用 相互间的关系 案例 案例1 - 调整堆大小提高服务吞吐量 修改tomcat的配置 setenv.sh\nexport CATALINA_OPTS=\u0026#34;$CATALINA_OPTS -Xms30m\u0026#34; export CATALINA_OPTS=\u0026#34;$CATALINA_OPTS -XX:SurvivorRatio=8\u0026#34; export CATALINA_OPTS=\u0026#34;$CATALINA_OPTS -Xmx30m\u0026#34; export CATALINA_OPTS=\u0026#34;$CATALINA_OPTS -XX:+UseParallelGC\u0026#34; export CATALINA_OPTS=\u0026#34;$CATALINA_OPTS -XX:+PrintGCDetails\u0026#34; export CATALINA_OPTS=\u0026#34;$CATALINA_OPTS -XX:MetaspaceSize=64m\u0026#34; export CATALINA_OPTS=\u0026#34;$CATALINA_OPTS -XX:+PrintGCDateStamps\u0026#34; export CATALINA_OPTS=\u0026#34;$CATALINA_OPTS -Xloggc:/opt/tomcat8.5/logs/gc.log\u0026#34; JMeter测试 修改参数，重启tomcat export CATALINA_OPTS=\u0026#34;$CATALINA_OPTS -Xms120m\u0026#34; export CATALINA_OPTS=\u0026#34;$CATALINA_OPTS -XX:SurvivorRatio=8\u0026#34; export CATALINA_OPTS=\u0026#34;$CATALINA_OPTS -Xmx120m\u0026#34; export CATALINA_OPTS=\u0026#34;$CATALINA_OPTS -XX:+UseParallelGC\u0026#34; export CATALINA_OPTS=\u0026#34;$CATALINA_OPTS -XX:+PrintGCDetails\u0026#34; export CATALINA_OPTS=\u0026#34;$CATALINA_OPTS -XX:MetaspaceSize=64m\u0026#34; export CATALINA_OPTS=\u0026#34;$CATALINA_OPTS -XX:+PrintGCDateStamps\u0026#34; export CATALINA_OPTS=\u0026#34;$CATALINA_OPTS -Xloggc:/opt/tomcat8.5/logs/gc.log\u0026#34; 再次测试结果 案例2 - JVM优化之JIT优化 栈是空间分配的唯一选择吗？ 在《深入理解Java虚拟机中》关于Java堆内存有这样一段描述：\n随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。\n在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析(Escape Analysis)后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。\n此外，前面提到的基于OpenJDK深度定制的TaoBaoVM，其中创新的GCIH（GC invisible heap）实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。\n编译的开销 时间开销 编译的时间开销：\n解释器的执行，抽象的看是这样的:\n输入的代码 -\u0026gt; [ 解释器 解释执行 ] -\u0026gt; 执行结果\nJIT编译然后再执行的话，抽象的看则是:\n输入的代码 -\u0026gt; [ 编译器 编译 ] -\u0026gt; 编译后的代码 -\u0026gt; [ 执行 ] -\u0026gt; 执行结果\n注意：\n说JIT比解释快，其实说的是“执行编译后的代码”比“解释器解释执行”要快，并不是说“编译”这个动作比“解释”这个动作快。JIT编译再怎么快，至少也比解释执行一次略慢一些，而要得到最后的执行结果还得再经过一个“执行编译后的代码”的过程。所以，对“只执行一次”的代码而言，解释执行其实总是比JIT编译执行要快。怎么算是只执行一次的代码呢？粗略说，下面条件同时满足时就是严格的`只执行一次。\n只被调用一次，例如类的构造器（class initializer，()）\n没有循环，对只执行一次的代码做JIT编译再执行，可以说是得不偿失。\n对只执行少量次数的代码，JIT编译带来的执行速度的提升也未必能抵消掉最初编译带来的开销。\n只有对频繁执行的代码（热点代码），JIT编译才能保证有正面的收益。\n空间开销 对一般的Java方法而言，编译后代码的大小相对于字节码的大小，膨胀比达到10+是很正常的。同上面说时间开销一样，这里的空间开销也是，只有对执行频繁的代码才值得编译，如果把所有代码都编译则会显著增加代码所占空间，导致代码爆炸。这也就解释了为什么有些JVM会选择不总是做JIT编译，而是选择用解释器+JIT编译器的混合执行引擎。\n逃逸分析 逃逸是指对象引用是否只在本方法内使用\n代码举例 /** * 逃逸分析 * * 如何快速的判断是否发生了逃逸分析，大家就看new的对象实体是否有可能在方法外被调用。 */ public class EscapeAnalysis { public EscapeAnalysis obj; /* 方法返回EscapeAnalysis对象，发生逃逸 */ public EscapeAnalysis getInstance(){ return obj == null? new EscapeAnalysis() : obj; } /* 为成员属性赋值，发生逃逸 */ public void setObj(){ this.obj = new EscapeAnalysis(); } //思考：如果当前的obj引用声明为static的，会发生逃逸吗？会！ /* 对象的作用域仅在当前方法中有效，没有发生逃逸 */ public void useEscapeAnalysis(){ EscapeAnalysis e = new EscapeAnalysis(); } /* 引用成员变量的值，发生逃逸 */ public void useEscapeAnalysis1(){ EscapeAnalysis e = getInstance(); //getInstance().xxx()同样会发生逃逸 } /* * 也发生了逃逸 * */ public void operate(EscapeAnalysis e){ // e } } 优化 栈上分配 定义：将堆分配改为栈分配。需要在堆上分配内存，也无需进行垃圾回收。可以减少垃圾回收时间和次数。\nJIT编译器在编译期间根据逃逸分析的结果，发现一个对象并没有逃逸出一个方法的话，就可能被优化上栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间回收，局部变量对象也被回收。无需进行垃圾回收\n/** * 栈上分配测试 * -Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails * * 只要开启了逃逸分析，就会判断方法中的变量是否发生了逃逸。如果没有发生了逃逸，则会使用栈上分配 * */ public class StackAllocation { public static void main(String[] args) { long start = System.currentTimeMillis(); for (int i = 0; i \u0026lt; 10000000; i++) { alloc(); } // 查看执行时间 long end = System.currentTimeMillis(); System.out.println(\u0026#34;花费的时间为： \u0026#34; + (end - start) + \u0026#34; ms\u0026#34;); // 为了方便查看堆内存中对象个数，线程sleep try { Thread.sleep(1000000); } catch (InterruptedException e1) { e1.printStackTrace(); } } private static void alloc() { User user = new User();//是否发生逃逸？ 没有！ } static class User { } } // 启用栈上分配，默认开启： -Xmx1G -Xms1G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails // 查看是否开启： jinfo -flag DoEscapeAnalysis 29500 参数设置 在JDK 6u23版本之后，HotSpot中默认就已经开启了逃逸分析。 如果使用的是较早的版本，开发人员则可以通过： 通过选项“-XX:+DoEscapeAnalysis”显式开启逃逸分析 通过选项“-XX：+PrintEscapeAnalysis”查看逃逸分析的筛选结果。 结论：\n开发中能使用局部变量的，就不要使用在方法外定义。\n同步消除（省略） 如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步\n线程同步的代价是相当高的，同步的后果是降低并发性和性能。 在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。 /** * 同步省略 */ public class SynchronizedTest { public void f() { /* * 代码中对hollis这个对象进行加锁，但是hollis对象的生命周期只在f()方法中， * 并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉。 * * 问题：字节码文件中会去掉hollis吗？ * */ Object hollis = new Object(); synchronized(hollis) { System.out.println(hollis); } /* * 优化后； * Object hollis = new Object(); * System.out.println(hollis); * */ } } 标量替换 标量(Scalar) : 是指无法在分解成更小数据的数据。Java的原始数据类型就是标量\n聚合量(Aggregate): 可以分解的数据，Java的对象就是聚合量。因为其可以分配成其它聚合量和标量。\n标量替换：在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替，这个过程被称为\u0026quot;标量替换\u0026quot;\n/** * 标量替换测试 * -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGCDetails -XX:-EliminateAllocations * 对于EliminateAllocations的开启一定要保证DoEscapeAnalysis的开启，否则是没有意义的 * 结论：Java中的逃逸分析，其实优化的点就在于对栈上分配的对象进行标量替换。 */ public class ScalarReplace { public static class User { public int id; public String name; } public static void alloc() { User u = new User();//未发生逃逸 u.id = 5; u.name = \u0026#34;www.atguigu.com\u0026#34;; } public static void main(String[] args) { long start = System.currentTimeMillis(); for (int i = 0; i \u0026lt; 10000000; i++) { alloc(); } long end = System.currentTimeMillis(); System.out.println(\u0026#34;花费的时间为： \u0026#34; + (end - start) + \u0026#34; ms\u0026#34;); } } 逃逸分析小结 逃逸分析小结：逃逸分析并不成熟\n关于逃逸分析的论文在1999年就已经发表了，但直到JDK 1.6才有实现，而且这项技术到如今也并不是十分成熟的。 其根本原因就是无法保证非逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。 一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。 虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。 注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。 目前很多书籍还是基于JDK 7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。 案例3 - 合理分配堆内存 依据的原则是根据Java Performance里面的推荐公式来进行设置。\nJava整个堆大小设置，Xmx 和 Xms设置为老年代存活对象的3-4倍，即FullGC之后的老年代内存占用的3-4倍。 方法区（永久代 PermSize和MaxPermSize 或 元空间 MetaspaceSize 和 MaxMetaspaceSize）设置为老年代存活对象的1.2-1.5倍。 年轻代Xmn的设置为老年代存活对象的1-1.5倍。 老年代的内存大小设置为老年代存活对象的2-3倍。\n但是，上面的说法也不是绝对的，也就是说这给的是一个参考值，根据多种调优之后得出的一个结论，大家可以根据这个值来设置一下我们的初始化内存，在保证程序正常运行的情况下，我们还要去查看GC的回收率，GC停顿耗时，内存里的实际数据来判断，Full GC是基本上不能有的，如果有就要做内存Dump分析，然后再去做一个合理的内存分配。\n如何计算老年代存活对象 方式1 - 查看日志 推荐的方法\nJVM参数中添加GC日志，GC日志中会记录每次FullGC之后各代的内存大小，观察老年代GC之后的空间大小。可观察一段时间内（比如2天）的FullGC之后的内存情况，根据多次的FullGC之后的老年代的空间大小数据来预估FullGC之后老年代的存活对象大小（可根据多次FullGC之后的内存大小取平均值）。\n方式2 - 强制触发 影响线上服务，谨慎使用\n强制触发FullGC，会造成线上服务停顿（STW），要谨慎！建议的操作方式为，在强制FullGC前先把服务节点摘除，FullGC之后再将服务挂回可用节点，对外提供服务，在不同时间段触发FullGC，根据多次FullGC之后的老年代内存情况来预估FullGC之后的老年代存活对象大小。\njmap -dump:live,format=b,file=heap.bin 将当前的存活对象dump到文件，此时会触发FullGC jmap -histo:live 打印每个class的实例数目,内存占用,类全名信息.live子参数加上后,只统计活的对象数量. 此时会触发FullGC 在性能测试环境，可以通过Java监控工具来触发FullGC，比如使用VisualVM和JConsole，VisualVM集成了JConsole，VisualVM或者JConsole上面有一个触发GC的按钮。 配置参数 JVM设置如下： -XX:+PrintGCDetails -XX:MetaspaceSize=64m -Xss512K -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=heap/heapdump3.hprof -XX:SurvivorRatio=8 -XX:+PrintGCDateStamps -Xms1024M -Xmx1024M -Xloggc:log/gc-oom3.log 结论 在内存相对紧张的情况下，可以按照上述的方式来进行内存的调优， 找到一个在GC频率和GC耗时上都可接受的一个内存设置，可以用较小的内存满足当前的服务需要。\n但当内存相对宽裕的时候，可以相对给服务多增加一点内存，可以减少GC的频率，GC的耗时相应会增加一些。 一般要求低延时的可以考虑多设置一点内存， 对延时要求不高的，可以按照上述方式设置较小内存。\n如果在垃圾回收日志中观察到OutOfMemoryError,尝试把Java堆的大小扩大到物理内存的80%~90%。尤其需要注意的是堆空间导致的OutOfMemoryError以及一定要增加空间。\n比如说，增加-Xms和-Xmx的值来解决old代的OutOfMemoryError\n增加-XX:PermSize和-XX:MaxPermSize来解决permanent代引起的OutOfMemoryError（jdk7之前）；增加-XX:MetaspaceSize和-XX:MaxMetaspaceSize来解决Metaspace引起的OutOfMemoryError（jdk8之后）\n记住一点Java堆能够使用的容量受限于硬件以及是否使用64位的JVM。在扩大了Java堆的大小之后，再检查垃圾回收日志，直到没有OutOfMemoryError为止。如果应用运行在稳定状态下没有OutOfMemoryError就可以进入下一步了，计算活动对象的大小。\n估算GC频率 正常情况我们应该根据我们的系统来进行一个内存的估算，这个我们可以在测试环境进行测试，最开始可以将内存设置的大一些，比如4G这样，当然这也可以根据业务系统估算来的。\n比如从数据库获取一条数据占用128个字节，需要获取1000条数据，那么一次读取到内存的大小就是（128 B/1024 Kb/1024M）* 1000 = 0.122M ，那么我们程序可能需要并发读取，比如每秒读取100次，那么内存占用就是0.122100 = 12.2M ，如果堆内存设置1个G，那么年轻代大小大约就是333M，那么333M80% / 12.2M =21.84s ，也就是说我们的程序几乎每分钟进行两到三次youngGC。这样可以让我们对系统有一个大致的估算。\n0.122M * 100 = 12.2M /秒 \u0026mdash;Eden区\n1024M * 1/3 * 80% = 273M\n273 / 12.2M = 22.38s \u0026mdash;\u0026gt; YGC 每分钟2-3次YGC\n特殊问题：自适应调整策略 现象设置 /** * 使用ParallelGC的情况下，不管是否开启了UseAdaptiveSizePolicy参数，默认Eden与Survivor的比例都为：6:1:1 * * 第一次运行设置: -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xms300M -Xmx300M -Xloggc:log/gc.log jps -l jmap -heap jpsId SurvivorRatio是8:1:1 可是实际计算是6:1:1 * * @author shkstart * @create 12:53 */ public class AdaptiveSizePolicyTest { public static void main(String[] args) { try { Thread.sleep(1000000); } catch (InterruptedException e) { e.printStackTrace(); } } } 参数AdaptiveSizePolicy JDK1.8默认使用了UseParallelGC 垃圾回收器，该垃圾回收器默认启动了 AdaptiveSizePolicy，会根据GC的情况自动计算Eden,From和To区的大小。所以这是由于JDK1.8的自适应大小策略导致的。\n开启：-XX:+UseAdaptiveSizePolicy\n关闭：-XX:-UseAdaptiveSizePolicy\n注意事项 在 JDK 1.8 中，如果使用 CMS，无论 UseAdaptiveSizePolicy 如何设置，都会将 UseAdaptiveSizePolicy 设置为 false；不过不同版本的JDK存在差异。\nUseAdaptiveSizePolicy不要和SurvivorRatio参数显示设置搭配使用，一起使用会导致参数失效；\n由于UseAdaptiveSizePolicy会动态调整 Eden、Survivor 的大小，有些情况存在Survivor 被自动调为很小，比如十几MB甚至几MB的可能，这个时候YGC回收掉 Eden区后，还存活的对象进入Survivor 装不下，就会直接晋升到老年代，导致老年代占用空间逐渐增加，从而触发FULL GC，如果一次FULL GC的耗时很长（比如到达几百毫秒），那么在要求高响应的系统就是不可取的。对于面向外部的大流量、低延迟系统，不建议启用此参数，建议关闭该参数。\n如果不想动态调整内存大小，以下是解决方案：\n保持使用 UseParallelGC，显式设置 -XX:SurvivorRatio=8 使用 CMS 垃圾回收器。CMS 默认关闭 AdaptiveSizePolicy。配置参数 -XX:+UseConcMarkSweepGC 补充 关于堆内存的自适应调节有如下三个参数：调整堆是按照每次20%增长，按照每次5%收缩\nyoung区增长量（默认20%）：-XX:YoungGenerationSizeIncrement=\nold区增长量（默认20%）：-XX:TenuredGenerationSizeIncrement=\n收缩量（默认5%）：-XX:AdaptiveSizeDecrementScaleFactor=\n案例4 - CPU占用很高排查方案 案例复习 /** * \u0026lt;pre\u0026gt; * @author : shkstart * desc : jstack 死锁案例 * \u0026lt;/pre\u0026gt; */ public class JstackDeadLockDemo { /** * 必须有两个可以被加锁的对象才能产生死锁，只有一个不会产生死锁问题 */ private final Object obj1 = new Object(); private final Object obj2 = new Object(); public static void main(String[] args) { new JstackDeadLockDemo().testDeadlock(); } private void testDeadlock() { Thread t1 = new Thread(() -\u0026gt; calLock_Obj1_First()); Thread t2 = new Thread(() -\u0026gt; calLock_Obj2_First()); t1.start(); t2.start(); } /** * 先synchronized obj1，再synchronized obj2 */ private void calLock_Obj1_First() { synchronized (obj1) { sleep(); System.out.println(\u0026#34;已经拿到obj1的对象锁，接下来等待obj2的对象锁\u0026#34;); synchronized (obj2) { sleep(); } } } /** * 先synchronized obj2，再synchronized obj1 */ private void calLock_Obj2_First() { synchronized (obj2) { sleep(); System.out.println(\u0026#34;已经拿到obj2的对象锁，接下来等待obj1的对象锁\u0026#34;); synchronized (obj1) { sleep(); } } } /** * 为了便于让两个线程分别锁住其中一个对象， * 一个线程锁住obj1，然后一直等待obj2， * 另一个线程锁住obj2，然后一直等待obj1， * 然后就是一直等待，死锁产生 */ private void sleep() { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } } 排查方案 查看java进程ID, jps -l # 31695 根据进行进程ID, 查看异常线程ID, top -Hp 31695 把线程pid变为16进制如 31695 -\u0026gt; 7bcf 然后得到0x7bcf jstack 1456 \u0026gt; jstack.log 得到相关进程的代码 (鉴于我们当前代码量比较小，线程也比较少，所以我们就把所有的信息全部导出来) 打开jstack.log文件，查找一下刚刚我们转换完的16进制ID是否存在 jstack命令生成的thread dump信息包含了JVM中所有存活的线程，里面确实是存在我们定位到的线程 ID ，在thread dump中每个线程都有一个nid，在nid=0x5b9的线程调用栈中，我们发现两个线程在互相等待对方释放资源 解决方案 调整锁的顺序，保持一致 或者采用定时锁，一段时间后，如果还不能获取到锁就释放自身持有的所有锁。 案例5 - G1并发执行的线程数对性能的影响 配置信息 硬件配置 8核linux\nexport CATALINA_OPTS=\u0026quot;$CATALINA_OPTS -XX:+UseG1GC\u0026quot;\nexport CATALINA_OPTS=\u0026quot;$CATALINA_OPTS -Xms30m\u0026quot;\nexport CATALINA_OPTS=\u0026quot;$CATALINA_OPTS -Xmx30m\u0026quot;\nexport CATALINA_OPTS=\u0026quot;$CATALINA_OPTS -XX:+PrintGCDetails\u0026quot;\nexport CATALINA_OPTS=\u0026quot;$CATALINA_OPTS -XX:MetaspaceSize=64m\u0026quot;\nexport CATALINA_OPTS=\u0026quot;$CATALINA_OPTS -XX:+PrintGCDateStamps\u0026quot;\nexport CATALINA_OPTS=\u0026quot;$CATALINA_OPTS -Xloggc:/opt/tomcat8.5/logs/gc.log\u0026quot;\nexport CATALINA_OPTS=\u0026quot;$CATALINA_OPTS -XX:ConcGCThreads=1\u0026quot;\n说明：最后一个参数可以在使用G1GC测试初始并发GCThreads之后再加上。\n初始化内存和最大内存调整小一些，目的发生 FullGC，关注GC时间\n关注点是：GC次数，GC时间，以及 Jmeter的平均响应时间\n总结 配置完线程数之后，请求的平均响应时间和GC时间都有一个明显的减少了，仅从效果上来看，我们这次的优化是有一定效果的。大家在工作中对于线上项目进行优化的时候，可以考虑到这方面的优化。\n案例6 - 调整垃圾回收器提高服务的吞吐量 初始配置 系统配置是单核，显示DefNew，说明我们用的是串行收集器，SerialGC\n优化配置1 使用并行垃圾收集器\nexport CATALINA_OPTS=\u0026quot;$CATALINA_OPTS -Xms60m\u0026quot;\nexport CATALINA_OPTS=\u0026quot;$CATALINA_OPTS -Xmx60m\u0026quot;\nexport CATALINA_OPTS=\u0026quot;$CATALINA_OPTS -XX:+UseParallelGC\u0026quot;\nexport CATALINA_OPTS=\u0026quot;$CATALINA_OPTS -XX:+PrintGCDetails\u0026quot;\nexport CATALINA_OPTS=\u0026quot;$CATALINA_OPTS -XX:MetaspaceSize=64m\u0026quot;\nexport CATALINA_OPTS=\u0026quot;$CATALINA_OPTS -XX:+PrintGCDateStamps\u0026quot;\nexport CATALINA_OPTS=\u0026quot;$CATALINA_OPTS -Xloggc:/opt/tomcat8.5/logs/gc6.log\u0026quot;\n查看吞吐量，997.6/sec，吞吐量并没有明显变化，究其原因，本身UseParallelGC是并行收集器，但是我们的服务器是单核。\n修改配置 把服务器改为8核\n优化配置2 export CATALINA_OPTS=\u0026quot;$CATALINA_OPTS -XX:+UseG1GC\u0026quot;\nexport CATALINA_OPTS=\u0026quot;$CATALINA_OPTS -Xms60m\u0026quot;\nexport CATALINA_OPTS=\u0026quot;$CATALINA_OPTS -Xmx60m\u0026quot;\nexport CATALINA_OPTS=\u0026quot;$CATALINA_OPTS -XX:+PrintGCDetails\u0026quot;\nexport CATALINA_OPTS=\u0026quot;$CATALINA_OPTS -XX:MetaspaceSize=64m\u0026quot;\nexport CATALINA_OPTS=\u0026quot;$CATALINA_OPTS -XX:+PrintGCDateStamps\u0026quot;\nexport CATALINA_OPTS=\u0026quot;$CATALINA_OPTS -Xloggc:/opt/tomcat8.5/logs/gc6.log\u0026quot;\n吞吐量也是比串行收集器效果更佳，而且没有了FullGC。此次优化成功\n案例7 - 日均百万级订单交易系统如何设置JVM参数 首先估算每秒产生对象例如2M 触发MinorGc的时间 解决措施：\n水平扩容更多的机器，控制每台jvm处理的请求 提高新生代，降低GC频率，减少fullGC 多次的FULLGC，对系统影响性能较大。\n面试小结 12306遭遇春节大规模抢票如何支撑？ 12306号称是国内并发量最大的秒杀网站，并发量达到百万级别。\n普通电商订单\u0026ndash;\u0026gt; 下单 \u0026ndash;\u0026gt; 订单系统（IO）减库存 \u0026mdash;\u0026gt; 等待用户付款\n12306一种可能的模型：下单 \u0026ndash;\u0026gt; 减库存和订单（redis、kafka）同时异步进行 \u0026ndash;\u0026gt; 等付款\n但减库存最后还会把压力压到一台服务器上。如何？\n解决措施： 分布式本地库存+单独服务器做库存均衡\n有一个50万PV的资料类网站（从磁盘提取文档到内存）原服务器是32位的，1.5G的堆，用户反馈网站比较缓慢。因此公司决定升级，新的服务器为64位，16G的堆内存，结果用户反馈卡顿十分严重，反而比以前效率更低了！ 为什么原网站慢？ 频繁的GC,STW时间比较长，响应时间慢！ 为什么会更卡顿？ 内存空间越大，FGC时间更长，延迟时间更长 解决措施 垃圾回收器 parallel GC ParNew + CMS G1 配置GC参数： -XX:MaxGCPauseMillis 、 -XX:ConcGCThreads 根据log日志、dump文件分析，优化内存空间的比例： jstat jinfo jstack jmap 系统CPU经常100%，如何调优？ CPU100%的话，一定是有线程占用系统资源。分析进程线程\n系统内存飙高，如何查找问题？ jmap -heap 、jstat 、\u0026hellip; ; gc日志情况 dump文件分析 如何监控JVM 命令行工具 图形化界面工具 ","permalink":"https://AlfredNing.github.io/note/program/jvm/%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B/","summary":"调优工具 jConsole Visual VM eclipse MAT JProfiler Arthas Java Mission Control Flame Graphs（火焰图） Tprofiler Btrace YourKit JProbe Spring Insight OOM 案例 堆溢出 报错信息 java.lang.OutOfMemoryError: Java heap space\n参数配置 -XX:+PrintGCDetails -XX:MetaspaceSize=64m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=heap/heapdump.hprof -XX:+PrintGCDateStamps -Xms200M -Xmx200M -Xloggc:log/gc-oomHeap.log 原因及解决 原因\n1、代码中可能存在大对象分配\n2、可能存在内存泄漏，导致在多次GC之后，还是无法找到一块足够大的内存容纳当前对象。\n解决方法\n1、检查是否存在大对象的分配，最有可能的是大数组分配\n2、通过jmap命令，把堆内存dump下来，使用MAT等工具分析一下，检查是否存在内存泄漏的问题\n3、如果没有找到明显的内存泄漏，使用 -Xmx 加大堆内存\n4、还有一点容易被忽略，检查是否有大量的自定义的 Finalizable 对象，也有可能是框架内部提供的，考虑其存在的必要性\n分析GC日志\n元空间溢出 方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、即时编译器编译后的代码等数据。虽然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。\nJava 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。垃圾收集行为在这个区域是比较少出现的，其内存回收目标主要是针对常量池的回收和对类型的卸载。当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。\n报错信息 java.lang.OutOfMemoryError: Metaspace\n参数配置 -XX:+PrintGCDetails -XX:MetaspaceSize=60m -XX:MaxMetaspaceSize=60m -Xss512K -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=heap/heapdumpMeta.","title":"调优案例"},{"content":"GC日志参数 -verbose:gc 输出gc日志信息，默认输出到标准输出\n-XX:+PrintGC 输出GC日志。类似：-verbose:gc\n-XX:+PrintGCDetails 在发生垃圾回收时打印内存回收详细的日志，\n并在进程退出时输出当前内存各区域分配情况\n-XX:+PrintGCTimeStamps 输出GC发生时的时间戳\n-XX:+PrintGCDateStamps 输出GC发生时的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）\n-XX:+PrintHeapAtGC 每一次GC前和GC后，都打印堆信息\n-Xloggc: 表示把GC日志写入到一个文件中去，而不是打印到标准输出中\n测试代码 import java.util.ArrayList; /** * -Xms60m -Xmx60m -XX:SurvivorRatio=8 -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:./logs/gc.log * * @author Alfred.Ning * @since 2023年05月04日 22:54:00 */ public class GLogTest { public static void main(String[] args) { ArrayList\u0026lt;byte[]\u0026gt; bytes = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 500; i++) { byte[] arr = new byte[1024 * 1024]; bytes.add(arr); try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } } } } 在线分析GC日志代码 gc日志分析在线\n","permalink":"https://AlfredNing.github.io/note/program/jvm/gc%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/","summary":"GC日志参数 -verbose:gc 输出gc日志信息，默认输出到标准输出\n-XX:+PrintGC 输出GC日志。类似：-verbose:gc\n-XX:+PrintGCDetails 在发生垃圾回收时打印内存回收详细的日志，\n并在进程退出时输出当前内存各区域分配情况\n-XX:+PrintGCTimeStamps 输出GC发生时的时间戳\n-XX:+PrintGCDateStamps 输出GC发生时的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）\n-XX:+PrintHeapAtGC 每一次GC前和GC后，都打印堆信息\n-Xloggc: 表示把GC日志写入到一个文件中去，而不是打印到标准输出中\n测试代码 import java.util.ArrayList; /** * -Xms60m -Xmx60m -XX:SurvivorRatio=8 -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:./logs/gc.log * * @author Alfred.Ning * @since 2023年05月04日 22:54:00 */ public class GLogTest { public static void main(String[] args) { ArrayList\u0026lt;byte[]\u0026gt; bytes = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 500; i++) { byte[] arr = new byte[1024 * 1024]; bytes.add(arr); try { Thread.","title":"GC日志分析"},{"content":"概述 什么是垃圾 运行程序中没有任何指针指向的对象。如果垃圾对象一直保留在内存空间，严重情况下，导致内存溢出\n为什么需要GC 垃圾回收器: garbage collector 垃圾回收行为：gargage collection 如果不进行垃圾回收，内存迟早被消耗完 释放没用的对象，清楚内存的记录碎片。JVM将整理出来的内存分配给新的对象 随着应用程序所交付的业务越来越复杂。没有GC就不能保证应用程序的正常进行。经常造成STW的GC跟不上实际的需求，所以才会尝试不断的对GC进行优化 对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。 此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见OutOfMemoryError时，快速地根据错误异常日志定位问题和解决问题。 当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。 java垃圾回收区域中重点区域是 垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收。其中，Java堆是垃圾收集器的工作重点。 从次数上讲：\n频繁收集Young区 较少收集Old区 基本不动Perm区（或元空间） 早期的GC 这种方式可以灵活控制内存释放的时间，但是会给开发人员带来频繁申请和释放内存的管理负担。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生内存泄漏，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。 在有了垃圾回收机制后，上述代码块极有可能变成这样：\n现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势。可以说，这种自动化的内存分配和垃圾回收的方式己经成为现代开发语言必备的标准。\n垃圾回收算法 垃圾判别阶段算法 JVM中究竟是如何标记一个死亡对象呢\n简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。\n引用计数算法 引用计数算法(Reference Counting)比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。\n原理及其基本思路 对于一个对象A来说，只要有任何一个对象引用了A,则A的应用计数器就加1，当引用失效时，引用计数器就减1。只要对象A的引用计数器值为0，则表示对象A不可能再被使用，可进行回收。\n优点 实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。\n缺点 需要单独的字段存储计数器，这样的做法增加了存储空间的开销。 每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。 引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java 的垃圾回收器中没有使用这类算法。 如果使用该算法，如何解决循环引用 引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。\n具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。\nJava并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。\nPython如何解决循环引用？\n手动解除：很好理解，就是在合适的时机，解除引用关系。\n使用弱引用weakref， weakref是Python提供的标准库，旨在解决循环引用。\n可达性分析算法 - [目前常用算法] 原理及其基本思路 原理 将对象和对象的引用关系看做是一个图，选定活动的对象作为GC ROOTS，然后跟踪引用链条，如果一个对象和一个GC ROOTS之间不可达，也就是不存在引用链条，那么认为是可回收的对象。\n基本思路 可达性分析算法是以根对象集合(GC Roots)为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链(Reference Chain) 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。 优点 实现简单，执行高效 ，有效的解决循环引用的问题，防止内存泄漏。\nGC ROOTS 在Java 语言中， GC Roots 包括以下几类元素：\n虚拟机栈中引用的对象 比如：各个线程被调用的方法中使用到的参数、局部变量等。 本地方法栈内JNI(通常说的本地方法)引用的对象 类静态属性引用的对象 比如：Java类的引用类型静态变量 方法区中常量引用的对象 比如：字符串常量池（String Table）里的引用 所有被同步锁synchronized持有的对象 Java虚拟机内部的引用。 基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器。 反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。 除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收（Partial GC）。 如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。 tip:\n由于Root 采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root 。\n垃圾清除阶段算法 当成功区分出内存中存活对象和死亡对象后， GC 接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是标记－清除算法（ Mark-Sweep ）、复制算法（ Copying ）、标记 - 压缩算法（ Mark-Compact ）\n标记 - 清除算法 背景：\n标记 - 清除算法（ Mark-Sweep ）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。\n执行过程：\n当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。\n标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。 清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。 缺点 1、效率比较低：递归与全堆对象遍历两次\n2、在进行GC的时候，需要停止整个应用程序，导致用户体验差\n3、这种方式清理出来的空闲内存是不连续的，产生内存碎片。\n注意：何为清除?\n这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放。 复制算法 将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。\n优缺点 优点：\n没有标记和清除过程，实现简单，运行高效 复制过去以后保证空间的连续性，不会出现“碎片”问题。\n缺点：\n此算法的缺点也是很明显的，就是需要两倍的内存空间。 对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。 特别的：如果系统中的存活对象很多，复制算法不会很理想。因为复制算法需要复制的存活对象数量并不会太大,或者说非常低才行。 标记压缩算法 背景：\n**复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。**这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。\n标记－清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM 的设计者需要在此基础之上进行改进。标记 - 压缩（Mark - Compact）算法由此诞生。\n执行过程：\n第一阶段和标记-清除算法一样，从根节点开始标记所有被引用对象\n第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。\n之后， 清理边界外所有的空间。 标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩(Mark-Sweep-Compact)算法。\n二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。\n可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。\n指针碰撞 如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞（Bump the Pointer）。\n优缺点 优点：（此算法消除了“标记-清除”和“复制”两个算法的弊端。）\n消除了标记/清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。\n消除了复制算法当中，内存减半的高额代价。\n缺点：\n从效率上来说，标记-压缩算法要低于复制算法。\n效率不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。\n对于老年代每次都有大量对象存活的区域来说，极为负重。\n移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。\n移动过程中，需要全程暂停用户应用程序。即：STW\n分代收集算法 效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。\n而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。\n分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。\n在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。\n目前几乎所有的GC都是采用分代收集（Generational Collecting）算法执行垃圾回收的。\n在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。\n年轻代(Young Gen) 年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。\n这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。\n老年代(Tenured Gen) 老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。\n这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。\nMark阶段的开销与存活对象的数量成正比。 Sweep阶段的开销与所管理区域的大小成正相关。 Compact阶段的开销与存活对象的数据成正比。 以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。\n分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代。\n增量收集算法 上述现有的算法，在垃圾回收过程中，应用软件将处于一种Stop the World 的状态。在Stop the World 状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。\n基本思想 如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。\n总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。\n缺点 使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。\n分区算法 \u0026ndash; G1 GC使用的算法 分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。\n每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。\n一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。\n相关概念 System.gc 在默认情况下，通过System.gc()或者Runtime.getRuntime().gc()的调用，会显式触发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。\n然而System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用。\nJVM实现者可以通过System.gc()调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()。\nfinalize()方法详解 inalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。\n作用 finalize()与C++中的析构函数不是对应的。C++中的析构函数调用的时机是确定的（对象离开作用域或delete掉），但Java中的finalize的调用具有不确定性 不建议用finalize方法完成“非内存资源”的清理工作，但建议用于： 清理本地对象(通过JNI创建的对象)； 作为确保某些非内存资源(如Socket、文件等)释放的一个补充：在finalize方法中显式调用其他资源释放方法。 问题 一些与finalize相关的方法，由于一些致命的缺陷，已经被废弃了，如System.runFinalizersOnExit()方法、Runtime.runFinalizersOnExit()方法 System.gc()与System.runFinalization()方法增加了finalize方法执行的机会，但不可盲目依赖它们 Java语言规范并不保证finalize方法会被及时地执行、而且根本不会保证它们会被执行 finalize方法可能会带来性能问题。因为JVM通常在单独的低优先级线程中完成finalize的执行 对象再生问题：finalize方法中，可将待回收对象赋值给GC Roots可达的对象引用，从而达到对象再生的目的 finalize方法至多由GC执行一次(用户当然可以手动调用对象的finalize方法，但并不影响GC对finalize的行为) 执行过程 - 声明周期 大致描述一下finalize流程：\n当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。 否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。\n内存泄露与内存溢出 内存溢出 内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。\n由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现OOM的情况。\n大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用。\njavadoc中对OutOfMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。\n内存不够的原因 首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够。原因有二： （1）Java虚拟机的堆内存设置不够。\n比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数-Xms、-Xmx来调整。\n（2）代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）\n对于老版本的Oracle JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息， 会标记出来和永久代相关：“java.lang.OutOfMemoryError: PermGen space”。\n随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的OOM有所改观，出现OOM，异常信息则变成了：“java.lang.OutOfMemoryError: Metaspace”。直接内存不足，也会导致OOM。\nOOM 前必有GC 这里面隐含着一层意思是，在抛出OutOfMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。\n例如：在引用机制分析中，涉及到JVM会去尝试回收软引用指向的对象等。\n在java.nio.BIts.reserveMemory()方法中，我们能清楚的看到，System.gc()会被调用，以清理空间。\n当然，也不是在任何情况下垃圾收集器都会被触发的\n比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutOfMemoryError。\n内存泄露 称作“存储渗漏”。严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。\n但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏”。\n尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OutOfMemory异常，导致程序崩溃。\n注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。\n内存泄露与内存溢出的关系 严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。\n但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏”。\n内存泄漏与内存溢出的关系：\n内存泄漏（memory leak ） 申请了内存用完了不释放，比如一共有 1024M 的内存，分配了 512M 的内存一直不回收，那么可以用的内存只有 512M 了，仿佛泄露掉了一部分； 通俗一点讲的话，内存泄漏就是【占着茅坑不拉shi】。\n内存溢出（out of memory） 申请内存时，没有足够的内存可以使用； 通俗一点儿讲，一个厕所就三个坑，有两个站着茅坑不走的（内存泄漏），剩下最后一个坑，厕所表示接待压力很大，这时候一下子来了两个人，坑位（内存）就不够了，内存泄漏变成内存溢出了。\n可见，内存泄漏和内存溢出的关系：内存泄漏的增多，最终会导致内存溢出。\n泄漏的分类 经常发生：发生内存泄露的代码会被多次执行，每次执行，泄露一块内存；\n偶然发生：在某些特定情况下才会发生；\n一次性：发生内存泄露的方法只会执行一次；\n隐式泄漏：一直占着内存不释放，直到执行结束；严格的说这个不算内存泄漏，因为最终释放掉了，但是如果执行时间特别长，也可能会导致内存耗尽。\njava内存泄露的8种情况 静态集合类 静态集合类，如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与JVM程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。\npublic class MemoryLeak { static List list = new ArrayList(); public void oomTests() { Object obj = new Object();//局部变量 list.add(obj); } } 单例模式 单例模式，和静态集合导致内存泄露的原因类似，因为单例的静态特性，它的生命周期和 JVM 的生命周期一样长，所以如果单例对象如果持有外部对象的引用，那么这个外部对象也不会被回收，那么就会造成内存泄漏。\n内部类持有外部类 内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象。\n这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄漏。\npublic class HandlerDemoActivity extends Activity implements OnClickListener { private static final int MESSAGE_INCRESE = 0; private static final int MESSAGE_DECRESE = 1; private TextView tv_demo_number; private Button btn_demo_increase; private Button btn_demo_decrease; private Button btn_demo_pause; private Handler handler = new Handler(){ //回调方法 public void handleMessage(android.os.Message msg) { String strNum = tv_demo_number.getText().toString(); //转换为整型数据,获取当前显示的数值 int num = Integer.parseInt(strNum); switch(msg.what){ case MESSAGE_INCRESE: num++; tv_demo_number.setText(num + \u0026#34;\u0026#34;); if(num == 20){ Toast.makeText(HandlerDemoActivity.this, \u0026#34;已达到最大值\u0026#34;, 0).show(); btn_demo_pause.setEnabled(false); return; } //发送延迟的+1的消息 sendEmptyMessageDelayed(MESSAGE_INCRESE, 300);//指的是延迟处理，而不是延迟发送 break; case MESSAGE_DECRESE: num--; tv_demo_number.setText(num + \u0026#34;\u0026#34;); if(num == 0){ Toast.makeText(HandlerDemoActivity.this, \u0026#34;已达到最小值\u0026#34;, 0).show(); btn_demo_pause.setEnabled(false); return; } //发送延迟的-1的消息 sendEmptyMessageDelayed(MESSAGE_DECRESE, 300);//指的是延迟处理，而不是延迟发送 break; } } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_handler_demo); init(); } private void init() { tv_demo_number = (TextView) findViewById(R.id.tv_demo_number); btn_demo_increase = (Button) findViewById(R.id.btn_demo_increase); btn_demo_decrease = (Button) findViewById(R.id.btn_demo_decrease); btn_demo_pause = (Button) findViewById(R.id.btn_demo_pause); btn_demo_increase.setOnClickListener(this); btn_demo_decrease.setOnClickListener(this); btn_demo_pause.setOnClickListener(this); } @Override public void onClick(View v) { .... } } 各种连接 各种连接，如数据库连接、网络连接和IO连接等。\n在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。\n否则，如果在访问数据库的过程中，对Connection、Statement或ResultSet不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。\npublic static void main(String[] args) { try { Connection conn = null; Class.forName(\u0026#34;com.mysql.jdbc.Driver\u0026#34;); conn = DriverManager.getConnection(\u0026#34;url\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;); Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery(\u0026#34;....\u0026#34;); } catch (Exception e) { //异常日志 } finally { //1.关闭结果集 Statement // 2.关闭声明的对象 ResultSet // 3.关闭连接 Connection } } 不合理的作用域 变量不合理的作用域。一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生。\npublic class UsingRandom { private String msg; public void receiveMsg(){ //private String msg; readFromNet();// 从网络中接受数据保存到msg中 saveDB();// 把msg保存到数据库中 //msg = null; } } 如上面这个伪代码，通过readFromNet方法把接受的消息保存在变量msg中，然后调用saveDB方法把msg的内容保存到数据库中，此时msg已经就没用了，由于msg的生命周期与对象的生命周期相同，此时msg还不能回收，因此造成了内存泄漏。 实际上这个msg变量可以放在receiveMsg方法内部，当方法使用完，那么msg的生命周期也就结束，此时就可以回收了。还有一种方法，在使用完msg后，把msg设置为null，这样垃圾回收器也会回收msg的内存空间。 改变哈希值 改变哈希值，当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了。\n否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄漏。\n这也是 String 为什么被设置成了不可变类型，我们可以放心地把 String 存入 HashSet，或者把 String 当做 HashMap 的 key 值；\n当我们想把自己定义的类保存到散列表的时候，需要保证对象的 hashCode 不可变。\n/** * 演示内存泄漏 * * @author shkstart * @create 14:43 */ public class ChangeHashCode { public static void main(String[] args) { HashSet set = new HashSet(); Person p1 = new Person(1001, \u0026#34;AA\u0026#34;); Person p2 = new Person(1002, \u0026#34;BB\u0026#34;); set.add(p1); set.add(p2); p1.name = \u0026#34;CC\u0026#34;; set.remove(p1); System.out.println(set);//2个对象！ // set.add(new Person(1001, \u0026#34;CC\u0026#34;)); // System.out.println(set); // set.add(new Person(1001, \u0026#34;AA\u0026#34;)); // System.out.println(set); } } class Person { int id; String name; public Person(int id, String name) { this.id = id; this.name = name; } @Override public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof Person)) return false; Person person = (Person) o; if (id != person.id) return false; return name != null ? name.equals(person.name) : person.name == null; } @Override public int hashCode() { int result = id; result = 31 * result + (name != null ? name.hashCode() : 0); return result; } @Override public String toString() { return \u0026#34;Person{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } 举例2: /** * 演示内存泄漏 * @author shkstart * @create 14:47 */ public class ChangeHashCode1 { public static void main(String[] args) { HashSet hs = new HashSet(); Point cc = new Point(); cc.setX(10);//hashCode = 41 hs.add(cc); cc.setX(20);//hashCode = 51 System.out.println(\u0026#34;hs.remove = \u0026#34; + hs.remove(cc));//false hs.add(cc); System.out.println(\u0026#34;hs.size = \u0026#34; + hs.size());//size = 2 } } class Point { int x; public int getX() { return x; } public void setX(int x) { this.x = x; } @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + x; return result; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Point other = (Point) obj; if (x != other.x) return false; return true; } } 缓存泄露 内存泄漏的另一个常见来源是缓存，一旦你把对象引用放入到缓存中，他就很容易遗忘。比如：之前项目在一次上线的时候，应用启动奇慢直到夯死，就是因为代码中会加载一个表中的数据到缓存（内存）中，测试环境只有几百条数据，但是生产环境有几百万的数据。\n对于这个问题，可以使用WeakHashMap代表缓存，此种Map的特点是，当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值。\n监听器和回调 内存泄漏另一个常见来源是监听器和其他回调，如果客户端在你实现的API中注册回调，却没有显式的取消，那么就会积聚。\n需要确保回调立即被当作垃圾回收的最佳方法是只保存它的弱引用，例如将他们保存成为WeakHashMap中的键。\nSTW Stop-the-World ，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。\n可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿。\n分析工作必须在一个能确保一致性的快照中进行\n一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上\n如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证\n被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生。\nSTW事件和采用哪款GC无关，所有的GC都有这个事件。\n哪怕是G1也不能完全避免Stop-the-world 情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。\nSTW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。\n开发中不要用System.gc();会导致Stop-the-world的发生。\n垃圾回收的并行与并发 并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：\n并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。 串行（Serial） 相较于并行的概念，单线程执行。 如果内存不够，则程序暂停，启动jvm垃圾回收器进行垃圾回收。回收完，再启动程序的线程。 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。 用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上； 如：CMS、G1 并行 当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，我们称之为并行(Parallel)。 其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行。 适合科学计算，后台处理等弱交互场景 并发 在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。 并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段(时间区间)，然后在这几个时间区间之间来回切换，由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。 对比 并发，指的是多个事情，在同一时间段内同时发生了。\n并行，指的是多个事情，在同一时间点上同时发生了。\n并发的多个任务之间是互相抢占资源的。\n并行的多个任务之间是不互相抢占资源的。\n只有在多CPU或者一个CPU多核的情况中，才会发生并行。\n否则，看似同时发生的事情，其实都是并发执行的。\n并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：\n并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。 如ParNew、Parallel Scavenge、Parallel Old； 串行（Serial） 相较于并行的概念，单线程执行。 如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。 用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上； 如：CMS、G1 安全点与安全区域 安全点 程序执行时并非在所有地方都能停顿下来开始 GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safepoint）”。\nSafe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。\n如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？\n抢先式中断：（目前没有虚拟机采用了） 首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。\n主动式中断： 设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。\n安全区域 Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入 GC 的 Safepoint 。但是，程序“不执行”的时候呢？例如线程处于 Sleep 状态或 Blocked 状态，这时候线程无法响应 JVM 的中断请求，“走”到安全点去中断挂起，JVM 也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。\n安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。我们也可以把 Safe Region 看做是被扩展了的 Safepoint。\n实际执行时：\n当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程； 当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止； 五种引用 强应用 不回收\n在Java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就是我们最常见的普通对象引用，也是默认的引用类型。\n当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。\n强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。\n对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。\n相对的， 软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，强引用是造成Java内存泄漏的主要原因之一。\n软引用 内存不足即回收\n软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。\n软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。\n垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。\n类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。\n在JDK 1.2版之后提供了java.lang.ref.SoftReference类来实现软引用。\nObject obj = new Object(); //声明强引用\nSoftReference sf = new SoftReference(obj);\nobj = null; //销毁强引用\n弱引用 发现即回收\n弱引用也是用来描述那些非必需对象，只被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。\n但是，由于垃圾回收器的线程通常优先级很低，因此, 并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。\n弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。\n弱引用非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。\n在JDK 1.2版之后提供了java.lang.ref.WeakReference类来实现弱引用。\nObject obj = new Object(); //声明强引用\nWeakReference wr = new WeakReference(obj);\nobj = null; //销毁强引用\n弱引用对象与软引用对象的最大不同就在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。弱引用对象更容易、更快被GC回收。\n终结器引用 它用以实现对象的finalize()方法，也可以称为终结器引用。 无需手动编码，其内部配合引用队列使用。 在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize()方法，第二次GC时才能回收被引用对象。 垃圾回收器 GC 分类 串行VS并行 按线程数分，可以分为串行垃圾回收器和并行垃圾回收器。\n串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。 在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的Client模式下的JVM中 在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。 和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-world”机制 并发式VS独占式 按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。\n并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。 独占式垃圾回收器(Stop the world)一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。 压缩式VS非压缩式 按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器。\n压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。 再分配对象空间使用：指针碰撞 非压缩式的垃圾回收器不进行这步操作。 再分配对象空间使用：空闲列表 年轻代VS老年代\n按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器。\nGC评估指标 吞吐量：程序的运行时间（程序的运行时间＋内存回收的时间） 垃圾收集开销：吞吐量的补数，垃圾收集器所占时间与总时间的比例。 暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。 收集频率：相对于应用程序的执行，收集操作发生的频率。 内存占用： Java 堆区所占的内存大小。 快速： 一个对象从诞生到被回收所经历的时间。 吞吐量优先：单位时间内，STW的时间最短：0.2 + 0.2 = 0.4\n响应时间优先：尽可能让单次STW的时间最短：0.1 + 0.1 + 0.1 + 0.1 + 0.1 = 0.5\n这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。\n吞吐量 \u0026mdash;\u0026gt;吞吐量越大越好！ 暂停时间（或响应时间） \u0026ndash;\u0026gt; 追求低延迟\n吞吐量 吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。 比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。 这种情况下，应用程序能容忍较高的暂停时间。因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的。 吞吐量优先，意味着在单位时间内，STW的时间最短：0.2 + 0.2 = 0.4 咋听\n暂停时间 “暂停时间”是指一个时间段内应用程序线程暂停，让GC线程执行的状态 例如，GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。 暂停时间优先，意味着尽可能让单次STW的时间最短：0.1 + 0.1 + 0.1 + 0.1 + 0.1 = 0.5 评估GC的性能指标：吞吐量vs暂停时间\n高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。 低暂停时间（低延迟）较好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，具有低的较大暂停时间是非常重要的，特别是对于一个交互式应用程序。 不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。 因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC需要更长的暂停时间来执行内存回收。 相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。 在设计（或使用）GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。\n现在JVM调优标准：在最大吞吐量优先的情况下，降低停顿时间。\n垃圾回收器的分类 GC发展史 有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection，对应的产品我们称为Garbage Collector。\n1999年随JDK1.3.1一起来的是串行方式的Serial GC ，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本 2002年2月26日，Parallel GC 和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布 Parallel GC在JDK6之后成为HotSpot默认GC。 2012年，在JDK1.7u4版本中，G1可用。-XX:+UseG1GC 2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。 2018年3月，JDK 10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。 2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为\u0026quot;No-Op（无操作）\u0026ldquo;回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器(Experimental)。 2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC(Experimental)。 2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。 2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macOS和Windows上的应用 七种组合关系 不同厂商、不同版本的虚拟机实现差别很大。HotSpot虚拟机在JDK7/8后所有收集器及组合（连线），如下图：（更新到了JDK14）\n两个收集器间有连线，表明它们可以搭配使用： Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1； 其中Serial Old作为CMS出现\u0026quot;Concurrent Mode Failure\u0026quot;失败的后备预案。 (红色虚线)由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP 173），并在JDK 9中完全取消了这些组合的支持（JEP214），即：移除。 (绿色虚线)JDK 14中：弃用Parallel Scavenge和SerialOld GC组合 （JEP 366） (青色虚线)JDK 14中：删除CMS垃圾回收器 （JEP 363） 为什么会有这么多的GC 为什么要有很多收集器，一个不够吗？因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。\n虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以我们选择的只是对具体应用最合适的收集器。\n如何查看默认的GC **-XX:+PrintCommandLineFlags：**查看命令行相关参数（包含使用的垃圾收集器）\n使用命令行指令：jinfo –flag 相关垃圾回收器参数 进程ID\nSerial GC : 串行回收 概述 Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。 Serial收集器作为HotSpot中Client模式下的默认新生代垃圾收集器。 Serial 收集器采用复制算法、串行回收和”Stop-the-World”机制的方式执行内存回收。 除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial Old收集器。Serial Old 收集器同样也采用了串行回收和”Stop the World”机制，只不过内存回收算法使用的是标记-压缩算法。 Serial Old是运行在Client模式下默认的老年代的垃圾回收器 Serial Old在Server模式下主要有两个用途：① 与新生代的Parallel Scavenge配合使用 ② 作为老年代CMS收集器的后备垃圾收集方案 这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时**，必须暂停其他所有的工作线程**，直到它收集结束（Stop The World）。\n优势 优势：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。\n运行在Client模式下的虚拟机是个不错的选择。\n在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms）,只要不频繁发生，使用串行回收器是可以接受的。\n参数 在HotSpot虚拟机中，使用 -XX:+UseSerialGC 参数可以指定年轻代和老年代都使用串行收集器。 等价于 新生代用Serial GC，且老年代用Serial Old GC 小结 在HotSpot虚拟机中，使用 -XX:+UseSerialGC 参数可以指定年轻代和老年代都使用串行收集器。 等价于 新生代用Serial GC，且老年代用Serial Old GC ParNew GC: 并行回收 概述 如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的多线程版本。\nPar是Parallel的缩写，New：只能处理的是新生代\nParNew 收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、\u0026ldquo;Stop-the-World\u0026quot;机制。\nParNew 是很多JVM运行在Server模式下新生代的默认垃圾收集器。\n对于新生代，回收次数频繁，使用并行方式高效。 对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源） ParNew GC 是否更高效 由于ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比Serial收集器更高效？\nParNew 收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。\n但是在单个CPU的环境下，ParNew收集器不比Serial 收集器更高效。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。\n因为除Serial外，目前只有ParNew GC能与CMS收集器配合工作\n参数 在程序中，开发人员可以通过选项\u0026rdquo;-XX:+UseParNewGC\u0026quot;手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。\n-XX:ParallelGCThreads 限制线程数量，默认开启和CPU数据相同的线程数。\nParallel GC: 吞吐量优先 概述 HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了复制算法、并行回收和”Stop the World”机制。\n那么Parallel收集器的出现是否多此一举？\n和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput），它也被称为吞吐量优先的垃圾收集器。\n自适应调节策略也是Parallel Scavenge与ParNew一个重要区别。\n高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。\nParallel 收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel Old收集器，用来代替老年代的Serial Old收集器。\nParallel Old收集器采用了标记-压缩算法，但同样也是基于并行回收和”Stop-the-World”机制。\n在程序吞吐量优先的应用场景中， Parallel 收集器和Parallel Old收集器的组合，在Server模式下的内存回收性能很不错。 在Java8中，默认是此垃圾收集器。 参数 参数配置：\n-XX:+UseParallelGC 手动指定年轻代使用Parallel并行收集器执行内存回收任务。\n-XX:+UseParallelOldGC 手动指定老年代都是使用并行回收收集器。\n分别适用于新生代和老年代。默认jdk8是开启的。\n上面两个参数，默认开启一个，另一个也会被开启。（互相激活）\n-XX:ParallelGCThreads 设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。\n在默认情况下，当CPU 数量小于8个， ParallelGCThreads 的值等于CPU 数量。\n当CPU数量大于8个，ParallelGCThreads 的值等于3+[5*CPU_Count]/8] 。\n-XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间(即STW的时间)。单位是毫秒。\n为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数。\n对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。\n该参数使用需谨慎。\n-XX:GCTimeRatio垃圾收集时间占总时间的比例（= 1 / (N + 1))。用于衡量吞吐量的大小。\n取值范围（0,100）。默认值99，也就是垃圾回收时间不超过1%。\n与前一个-XX:MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。\n-XX:+UseAdaptiveSizePolicy 设置Parallel Scavenge收集器具有自适应调节策略\n在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。\n在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMills），让虚拟机自己完成调优工作。\nCMS: 低延迟 概述 在 JDK 1.5 时期，HotSpot 推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：CMS (Concurrent-Mark-Sweep)收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。\nCMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。\n目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。\nCMS的垃圾收集算法采用标记-清除算法，并且也会”Stop-the-world”\n不幸的是，CMS 作为老年代的收集器，却无法与 JDK 1.4.0 中已经存在的新生代收集器Parallel Scavenge 配合工作，所以在JDK 1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。\n在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。\n初始标记（STW）：暂时时间非常短，标记与GC Roots直接关联的对象。\n并发标记（最耗时）：从GC Roots开始遍历整个对象图的过程。不会停顿用户线程\n重新标记：（STW）：修复并发标记环节，因为用户线程的执行，导致数据的不一致性问题\n并发清理（最耗时）\n收集过程 CMS整个过程比之前的收集器要复杂,整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。\n初始标记（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“Stop-the-World”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。\n并发标记（Concurrent-Mark）阶段：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。\n重新标记（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（比如：由不可达变为可达对象的数据），这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。\n并发清除（Concurrent-Sweep）阶段：此阶段**清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。**由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的\n补充说明 尽管CMS收集器采用的是并发回收（非独占式），但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“Stop-the-World”，只是尽可能地缩短暂停时间。\n由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。\n另外，由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是**当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。**要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。\nCMS收集器的垃圾收集算法采用的是标记—清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。\n为什么不适用标记压缩算法 因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark-Compact更适合“Stop the World”这种场景下使用\n优缺点 优点：\n并发收集 低延迟 缺点\n会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC。 CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。 CMS收集器无法处理浮动垃圾。可能出现“Concurrent Mode Failure”失败而导致另一次 Full GC 的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。 参数 -XX:+UseConcMarkSweepGC 手动指定使用CMS 收集器执行内存回收任务。\n开启该参数后会自动将-XX:+UseParNewGC打开。即：ParNew(Young区用)+CMS(Old区用)+Serial Old的组合。\n-XX:CMSlnitiatingOccupanyFraction 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。\nJDK5及以前版本的默认值为68,即当老年代的空间使用率达到68%时，会执行一次CMS 回收。JDK6及以上版本默认值为92%\n如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Full GC 的执行次数。\n-XX:+UseCMSCompactAtFullCollection 用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。\n-XX:CMSFullGCsBeforeCompaction设置在执行多少次Full GC后对内存空间进行压缩整理。\n-XX:ParallelCMSThreads 设置CMS的线程数量。\nCMS 默认启动的线程数是（ParallelGCThreads+3)/4，ParallelGCThreads 是年轻代并行收集器的线程数。当CPU 资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。\n如何选择GC 如果你想要最小化地使用内存和并行开销，请选Serial GC；\n如果你想要最大化应用程序的吞吐量，请选Parallel GC；\n如果你想要最小化GC的中断或停顿时间，请选CMS GC。\n新特性 JDK9新特性：CMS被标记为Deprecate了(JEP291)\n如果对JDK 9及以上版本的HotSpot虚拟机使用参数-XX：+UseConcMarkSweepGC来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。\nJDK14新特性：删除CMS垃圾回收器(JEP363)\n移除了CMS垃圾收集器，如果在JDK14中使用-XX:+UseConcMarkSweepGC的话，JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM\nG1 GC : 区域化分代式 为什么需要G1 原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1（Garbage-First）垃圾回收器是在Java7 update 4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。\n与此同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。\n官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望。\n为什么叫G1 因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。 G1 GC有计划地避免在整个Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。 由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First）。 概述 G1（Garbage-First）是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。\n在JDK1.7版本正式启用，移除了Experimental的标识，是JDK 9以后的默认垃圾回收器，取代了CMS 回收器以及Parallel + Parallel Old组合。被Oracle官方称为“全功能的垃圾收集器”。\n与此同时，CMS已经在JDK 9中被标记为废弃（deprecated）。在jdk8中还不是默认的垃圾回收器，需要使用-XX:+UseG1GC来启用。\nG1（Garbage-First）是一款面向服务端应用的垃圾收集器，兼顾吞吐量和停顿时间的GC实现。\n在JDK1.7版本正式启用，是JDK 9以后的默认GC选项，取代了CMS 回收器。\n特点 与其他 GC 收集器相比，G1使用了全新的分区算法，其特点如下所示：\n并行与并发\n并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW 并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况 分代收集\n从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。\n将堆空间分为若干个区域（Region）,这些区域中包含了逻辑上的年轻代和老年代。\n和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代； 空间整合\nCMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理 G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是复制算法，**但整体上实际可看作是标记-压缩（Mark-Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，**分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。尤其是当Java堆非常大的时候，G1的优势更加明显。 可预测的停顿时间模型（即：软实时soft real-time） 这是 G1 相对于 CMS 的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。\n由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。 G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。 相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。 缺点：\n相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高。\n从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。\n参数 -XX：+UseG1GC 手动指定使用G1收集器执行内存回收任务。 -XX:G1HeapRegionSize 设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。 -XX:MaxGCPauseMillis 设置期望达到的最大GC停顿时间指标(JVM会尽力实现，但不保证达到)。默认值是200ms -XX:ParallelGCThread 设置STW时GC线程数的值。最多设置为8 -XX:ConcGCThreads 设置并发标记的线程数。将n设置为并行垃圾回收线程数(ParallelGCThreads)的1/4左右。 -XX:InitiatingHeapOccupancyPercent 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。 操作步骤 G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：\n第一步：开启G1垃圾收集器\n第二步：设置堆的最大内存\n第三步：设置最大的停顿时间\nG1中提供了三种垃圾回收模式：YoungGC、Mixed GC和Full GC，在不同的条件下被触发。\n使用场景 面向服务端应用，针对具有大内存、多处理器的机器。(在普通大小的堆里表现并不惊喜)\n最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案；\n如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）。\n用来替换掉JDK1.5中的CMS收集器；\n在下面的情况时，使用G1可能比CMS好：\n① 超过50％的Java堆被活动数据占用；\n② 对象分配频率或年代提升频率变化很大；\n③ GC停顿时间过长（长于0.5至1秒）。\nHotSpot 垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的JVM线程执行GC的多线程操作，而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。\nweb应用，java进程最大堆4G,每分钟1500个请求，45s年轻代的垃圾回收。\n31小时使用率达到了45%，则开发并发标记，进行混合回收。\n分区Region 分区Region：化整为零\n使用 G1 收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB,2MB,4MB,8MB,16MB,32MB。可以通过-XX:G1HeapRegionSize设定。所有的Region大小相同，且在JVM生命周期内不会被改变。\n虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。\n一个 region 有可能属于 Eden，Survivor 或者 Old/Tenured 内存区域。但是一个region只可能属于一个角色。图中的 E 表示该region属于Eden内存区域，S表示属于Survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。 G1 垃圾收集器还增加了一种新的内存区域，叫做 Humongous 内存区域，如图中的 H 块。主要用于存储大对象，如果超过1.5个region，就放到H。 设置H的原因：\n对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。\nBump – the – pointer 即：指针碰撞\nTLAB 垃圾回收过程 G1 GC的垃圾回收过程主要包括如下三个环节：\n年轻代GC （Young GC）\n老年代并发标记过程 （Concurrent Marking）\n混合回收（Mixed GC）\n（如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）\n顺时针，young gc -\u0026gt; young gc + concurrent mark-\u0026gt; Mixed GC顺序，进行垃圾回收。\n应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。\n当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。\n标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起被回收的。\n举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。\nG1回收器垃圾回收过程: Remembered Set\n一个对象被不同区域引用的问题\n一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？\n在其他的分代收集器，也存在这样的问题（而G1更突出）\n回收新生代也不得不同时扫描老年代？\n这样的话会降低Minor GC的效率；\n解决方法：\n无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描：\n每个Region都有一个对应的Remembered Set；\n每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；\n然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；\n如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；\n当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。\n过程1：年轻代GC G1回收过程一：年轻代GC\nJVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。\n年轻代垃圾回收只会回收Eden区和Survivor区。\nYGC时，首先G1停止应用程序的执行（Stop-The-World），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。\n然后开始如下回收过程：\n第一阶段，扫描根。\n根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。\n第二阶段，更新RSet。\n处理dirty card queue(见备注)中的card，更新RSet。此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用。\n第三阶段，处理RSet。\n识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。\n第四阶段，复制对象。\n此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到Old区中空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。\n第五阶段，处理引用。\n处理Soft，Weak，Phantom，Final，JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。\n过程2：并发标记过程 G1回收过程二：并发标记过程\n初始标记阶段：标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC。\n根区域扫描（Root Region Scanning）：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在young GC之前完成。\n3.并发标记(Concurrent Marking)：在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。\n再次标记(Remark)： 由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。\n独占清理(cleanup,STW)：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。\n这个阶段并不会实际上去做垃圾的收集 并发清理阶段：识别并清理完全空闲的区域。 过程3：混合回收 G1回收过程三：混合回收\n当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old Region。这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些Old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。\n并发标记结束以后，老年代中百分百为垃圾的内存region被回收了，部分为垃圾的内存region被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过-XX:G1MixedGCCountTarget设置）被回收。 混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。 由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，-XX:G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。 混合回收并不一定要进行8次。有一个阈值-XX:G1HeapWastePercent，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。 过程4：FullGC G1回收可选的过程四：Full GC\nG1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（Stop-The-World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。\n要避免Full GC的发生，一旦发生需要进行调整。什么时候会发生Full GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到full gc，这种情况可以通过增大内存解决。\n导致G1Full GC的原因可能有两个：\nEvacuation（回收阶段）的时候没有足够的to-space来存放晋升的对象； 并发处理过程完成之前空间耗尽。 G1优化建议 年轻代大小\n避免使用-Xmn或-XX:NewRatio等相关选项显式设置年轻代大小\n固定年轻代的大小会覆盖暂停时间目标\n暂停时间目标不要太过严苛\nG1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间\n评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。\n补充：\n从Oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回收一部分Region，停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中。另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。\n各个GC使用场景 截止JDK 1.8，一共有7款不同的垃圾收集器。每一款不同的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。\n如何选择GC Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。\n怎么选择垃圾收集器？\n优先调整堆的大小让JVM自适应完成。\n如果内存小于100M，使用串行收集器\n如果是单核、单机程序，并且没有停顿时间的要求，串行收集器\n如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行收集器\n如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器\n官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。\n最后需要明确两个观点：\n没有最好的收集器，更没有万能的收集； 调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器 GC新发展 GC仍然处于飞速发展之中，目前的默认选项G1 GC在不断的进行改进，很多我们原来认为的缺点，例如串行的Full GC、Card Table扫描的低效等，都已经被大幅改进，例如，JDK 10以后，Full GC已经是并行运行，在很多场景下，其表现还略优于Parallel GC的并行Full GC实现。\n即使是Serial GC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是GC相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，在Serverless等新的应用场景下，Serial GC找到了新的舞台。\n比较不幸的是CMS GC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在JDK9中已经被标记为废弃，并在JDK14版本中移除。\nEpsilon GC Epsilon GC （http://openjdk.java.net/jeps/318），只做内存分配，不做垃圾回收的GC，对于运行完就退出的程序非常适合。称为无操作的垃圾收集器。\nShenandoah GC Shenandoah，无疑是众多GC中最孤独的一个。是第一款不由Oracle公司团队领导开发的HotSpot垃圾收集器。不可避免的受到官方的排挤。比如号称OpenJDK和OracleJDK没有区别的Oracle公司仍拒绝在OracleJDK12中支持Shenandoah。\nShenandoah垃圾回收器最初由RedHat进行的一项垃圾收集器研究项目Pauseless GC的实现，旨在针对JVM上的内存回收实现低停顿的需求。在2014年贡献给OpenJDK。\nRed Hat研发Shenandoah团队对外宣称，Shenandoah垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为200 MB还是200GB，99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内。不过实际使用性能将取决于实际工作堆的大小和工作负载。\n革命性的ZGC 令人震惊、革命性的ZGC\nZGC与Shenandoah目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。\nZGC：是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-压缩算法的，以低延迟为首要目标的一款垃圾收集器。\nZGC的工作过程可以分为4个阶段：并发标记-并发预备重分配-并发重分配-并发重映射等。\nZGC几乎在所有地方并发执行的，除了初始标记的是STW的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。\n在ZGC的强项停顿时间测试上，它毫不留情的将Parallel、G1拉开了两个数量级的差距。无论平均停顿、95%停顿、99%停顿、99.9%停顿，还是最大停顿时间，ZGC都能毫不费劲控制在10毫秒以内。\n虽然ZGC还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。\n未来将在服务端、大内存、低延迟应用的首选垃圾收集器。\njdk14新特性\nJEP 364：ZGC应用在macOS上\nJEP 365：ZGC应用在Windows上\nJDK14之前，ZGC仅Linux才支持。\n尽管许多使用ZGC的用户都使用类Linux的环境，但在Windows和macOS上，人们也需要ZGC进行开发部署和测试。许多桌面应用也可以从ZGC中受益。因此，ZGC特性被移植到了Windows和macOS上。\n现在mac或Windows上也能使用ZGC了，示例如下：\n-XX:+UnlockExperimentalVMOptions -XX:+UseZGC\n其它GC AliGC是阿里巴巴JVM团队基于G1算法， 面向大堆(LargeHeap)应用场景。\n指定场景下的对比：\n当然，其他厂商也提供了各种独具一格的GC实现，例如比较有名的低延迟GC，Zing（https://www.infoq.com/articles/azul_gc_in_detail），有兴趣可以参考提供的链接。\n","permalink":"https://AlfredNing.github.io/note/program/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/","summary":"概述 什么是垃圾 运行程序中没有任何指针指向的对象。如果垃圾对象一直保留在内存空间，严重情况下，导致内存溢出\n为什么需要GC 垃圾回收器: garbage collector 垃圾回收行为：gargage collection 如果不进行垃圾回收，内存迟早被消耗完 释放没用的对象，清楚内存的记录碎片。JVM将整理出来的内存分配给新的对象 随着应用程序所交付的业务越来越复杂。没有GC就不能保证应用程序的正常进行。经常造成STW的GC跟不上实际的需求，所以才会尝试不断的对GC进行优化 对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。 此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见OutOfMemoryError时，快速地根据错误异常日志定位问题和解决问题。 当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。 java垃圾回收区域中重点区域是 垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收。其中，Java堆是垃圾收集器的工作重点。 从次数上讲：\n频繁收集Young区 较少收集Old区 基本不动Perm区（或元空间） 早期的GC 这种方式可以灵活控制内存释放的时间，但是会给开发人员带来频繁申请和释放内存的管理负担。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生内存泄漏，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。 在有了垃圾回收机制后，上述代码块极有可能变成这样：\n现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势。可以说，这种自动化的内存分配和垃圾回收的方式己经成为现代开发语言必备的标准。\n垃圾回收算法 垃圾判别阶段算法 JVM中究竟是如何标记一个死亡对象呢\n简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。\n引用计数算法 引用计数算法(Reference Counting)比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。\n原理及其基本思路 对于一个对象A来说，只要有任何一个对象引用了A,则A的应用计数器就加1，当引用失效时，引用计数器就减1。只要对象A的引用计数器值为0，则表示对象A不可能再被使用，可进行回收。\n优点 实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。\n缺点 需要单独的字段存储计数器，这样的做法增加了存储空间的开销。 每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。 引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java 的垃圾回收器中没有使用这类算法。 如果使用该算法，如何解决循环引用 引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。\n具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。\nJava并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。\nPython如何解决循环引用？\n手动解除：很好理解，就是在合适的时机，解除引用关系。\n使用弱引用weakref， weakref是Python提供的标准库，旨在解决循环引用。\n可达性分析算法 - [目前常用算法] 原理及其基本思路 原理 将对象和对象的引用关系看做是一个图，选定活动的对象作为GC ROOTS，然后跟踪引用链条，如果一个对象和一个GC ROOTS之间不可达，也就是不存在引用链条，那么认为是可回收的对象。\n基本思路 可达性分析算法是以根对象集合(GC Roots)为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链(Reference Chain) 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。 优点 实现简单，执行高效 ，有效的解决循环引用的问题，防止内存泄漏。\nGC ROOTS 在Java 语言中， GC Roots 包括以下几类元素：","title":"垃圾回收"},{"content":"执行引擎的定义 将字节码指令解释/编译为对应平台上的本地机器指令。将高级语言翻译成低级语言\n执行引擎的工作流程 从外观上来看，所有的Java虚拟机的执行引擎输入、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果。\n执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。 每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。 当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。 代码执行和编译的过程 过程1: javac.exe的执行 Java代码编译是由Java源码编译器来完成，流程图如下所示\njava.exe的执行： Java字节码的执行是由JVM执行引擎来完成，流程图如下所示 概念 前端编译器 .java文件转换为.class文件的过程\n后端运行期编译器 JIT 编译器，Just In Time Compiler: 把字节码转变成机器码的过程。\n静态提前编译器 AOT 编译器，Ahead Of Time Compiler: 直接把.java文件编译成本地机器代码的过程。\nHotSpot VM是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器并存的架构。\n解释器 当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。\n工作机制 解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。从这个角度说，java是解释语言。 当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。 解释器的分类 在Java的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。\n字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。 而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。 在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。 Interpreter模块：实现了解释器的核心功能 Code模块：用于管理HotSpot VM在运行时生成的本地机器指令 只用解释器的问题 由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C/C++程序员所调侃。 为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。 不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。 为什么说Java是半解释半编译的语言 JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。 现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。 JIT编译器 JIT（Just In Time Compiler)编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。\n为什么还保留解释器的问题 有些开发人员会感觉到诧异，既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。\n首先明确：\n当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。\n编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。\n所以：\n尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。在此模式下，当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。\n同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。\nHotSpot执行方式 当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。\n案例：注意解释执行与编译执行在线上环境微妙的辩证关系。机器在热机状态可以承受的负载要大于冷机状态。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。\n在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1/8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前l/2发布成功的服务器马上全部宕机，此故障说明了JIT 的存在。—— 阿里团队\n如何选择 热点代码及探测方式 当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用执行的频率而定。关于那些需要被编译为本地代码的字节码，也被称之为“热点代码”，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出深度优化，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。\n一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，或简称为OSR（On Stack Replacement）编译。\n一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。\n目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测。\n方法调用计数器 这个计数器就用于统计方法被调用的次数，它的默认阈值在 Client 模式下是 1500 次，在 Server 模式下是 10000 次。超过这个阈值，就会触发JIT编译。 这个阈值可以通过虚拟机参数**-XX:CompileThreshold**来人为设定。 当一个方法被调用时，会先检查该方法是否存在被 JIT 编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加 1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。 热度衰减 如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）。\n回变计数器 它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为 “回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发 OSR 编译。（On-Stack Replacement)\n编译器 Graal编译器 AOT编译器 jdk9引入了AOT编译器(静态提前编译器，Ahead Of Time Compiler)\nJava 9 引入了实验性 AOT 编译工具jaotc。它借助了 Graal 编译器，将所输入的 Java 类文件转换为机器码，并存放至生成的动态共享库之中。\n所谓 AOT 编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而 AOT 编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。\n.java -\u0026gt; .class -\u0026gt; .so\n最大好处：Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢”的不良体验。\n缺点：\n破坏了java“一次编译，到处运行”，必须为每个不同硬件、OS编译对应的发行包。 降低了Java链接过程的动态性，加载的代码在编译期就必须全部已知。 还需要继续优化中，最初只支持Linux x64 java base\n动态编译 动态编译(compile during run-time)，英文称Dynamic compilation；Just In Time也是这个意思\n在程序运行过程之中进行编译。\n监视器 HotSpot里运行着一个监视器（Profile Monitor），用来监视程序的运行状况。\nJava字节码（class文件）是以解释的方式被加载到虚拟机中**(默认启动时解释执行**)。 程序运行过程中，那一部分运用频率大，那些对程序的性能影响重要。对程序运行效率影响大的代码，称为热点（hotspot），HotSpot会把这些热点动态地编译成机器码（native code），同时对机器码进行优化，从而提高运行效率。对那些较少运行的代码，HotSpot就不会把他们编译。\nHotSpot对字节码有三层处理：\n不编译(字节码加载到虚拟机中时的状态。也就是当虚拟机执行的时候再编译)； 编译(把字节码编译成本地代码。虚拟机执行的时候已经编译好了，不要再编译了)； 编译并优化（不但把字节码编译成本地代码，而且还进行了优化）。 至于哪些程序那些不编译，那些编译，那些优化，则是由监视器（Profile Monitor）决定。\n为什么不静态编译 动态编译器在许多方面比静态编译器优越。静态编译器通常很难准确预知程序运行过程中究竟什么部分最需要优化。\n函数调用都是很浪费系统时间的，因为有许多进栈出栈操作。因此有一种优化办法，就是把原来的函数调用，通过编译器的编译，改成非函数调用，把函数代码直接嵌到调用出，变成顺序执行。\n面向对象的语言支持多态，静态编译无效确定程序调用哪个方法，因为多态是在程序运行中确定调用哪个方法。\nHotSpot VM执行方式【重点】 解释器与JIT并存的架构 缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。\n-Xint：完全采用解释器模式执行程序 -Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行 -Xmixed：采用解释器+即时编译器的混合模式共同执行程序 c1 c2编译器 在HotSpot VM中内嵌有两个JIT编译器，分为Client Complier与Server Complier。通常情况下简称为C1编译器和C2编译器。开发人员可以显示指定使用那种模式。\n-client：指定Java虚拟机运行在Client模式下，并使用C1编译器 C1编译器会对字节码进行简单和可靠的优化，耗时短。以达到更快的编译速度。 client启动快，占用内存小，执行效率没有server快，默认情况下不进行动态编译，适用于桌面应用程序。 -server：指定Java虚拟机运行在Server模式下，并使用C2编译器 C2进行耗时较长的优化，以及激进优化。但优化的代码执行效率更高 server启动慢，占用内存多，执行效率高，适用于服务器端应用； 两种编译器的优化策略 不同的编译器有不同的优化策略。\nC1编译器主要有方法内联，去虚拟化、冗余消除\n方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程。 虚拟化：对唯一的实现类进行内联。 冗余消除：在运行期间把一些不会执行的代码折叠掉。 C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：\n标量替换: 用标量值代替聚合对象的属性值 栈上分配：对于未逃逸的对象分配对象在栈而不是堆 同步消除：清除同步操作，通常指synchronized 总结:\n一般来讲，JIT编译出来的机器码性能比解释器高 C2编译器启动时长比C1编译器慢，系统稳定执行以后，C2编译器执行速度远远快于C1编译器。 ","permalink":"https://AlfredNing.github.io/note/program/jvm/%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/","summary":"执行引擎的定义 将字节码指令解释/编译为对应平台上的本地机器指令。将高级语言翻译成低级语言\n执行引擎的工作流程 从外观上来看，所有的Java虚拟机的执行引擎输入、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果。\n执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。 每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。 当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。 代码执行和编译的过程 过程1: javac.exe的执行 Java代码编译是由Java源码编译器来完成，流程图如下所示\njava.exe的执行： Java字节码的执行是由JVM执行引擎来完成，流程图如下所示 概念 前端编译器 .java文件转换为.class文件的过程\n后端运行期编译器 JIT 编译器，Just In Time Compiler: 把字节码转变成机器码的过程。\n静态提前编译器 AOT 编译器，Ahead Of Time Compiler: 直接把.java文件编译成本地机器代码的过程。\nHotSpot VM是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器并存的架构。\n解释器 当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。\n工作机制 解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。从这个角度说，java是解释语言。 当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。 解释器的分类 在Java的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。\n字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。 而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。 在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。 Interpreter模块：实现了解释器的核心功能 Code模块：用于管理HotSpot VM在运行时生成的本地机器指令 只用解释器的问题 由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C/C++程序员所调侃。 为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。 不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。 为什么说Java是半解释半编译的语言 JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。 现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。 JIT编译器 JIT（Just In Time Compiler)编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。\n为什么还保留解释器的问题 有些开发人员会感觉到诧异，既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。\n首先明确：\n当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。\n编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。\n所以：\n尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。在此模式下，当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。\n同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。\nHotSpot执行方式 当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。","title":"执行引擎"},{"content":"对象的实例化 创建对象的方式 new 关键字 Class的newInstance()：反射的方式，只能调用空参的构造器，权限必须是public Constructor的newInstance(X)：反射的方式，可以调用空参、带参的构造器，权限没有要求，实用性更广 使用clone: 不调用任何构造器，当前类只需要实现Clonable接口，默认是浅拷贝 使用反序列化：从文件、数据库当中、网络中获取一个对象的二进制流，反序列化为内存的对象 利用asm字节码技术，动态生成Constructor对象，第三方库Objensis 创建对象的步骤 字节码角度 new 后面来说一般都会跟着dup，因为在需要调用init方法，操作栈上要进行出栈\nNEW ：如果找不到Class对象，则进行类加载。加载成功后，则在堆中分配内存，从Object 开始到本类路径上的所有属性值都要分配内存。分配完毕之后，进行零值初始化。在分配过程中，注意引用是占据存储空间的，它是一个变量，占用4个字节。这个指令完毕后，将指向实例对象的引用变量压入虚拟机栈顶。 DUP ：在栈顶复制该引用变量，这时的栈顶有两个指向堆内实例对象的引用变量。如果 方法有参数，还需要把参数压人操作栈中。两个引用变量的目的不同，其中压至底下的引用用于赋值，或者保存到局部变量表，另一个栈顶的引用变量作为句柄调用相关方法。 INVOKESPECIAL ：调用对象实例方法，通过栈顶的引用变量调用＜init\u0026gt; 方法。\n执行步骤角度 - 面试回答 判断对象的类是否加载、链接、初始化 虚拟机遇到一条new指令，首选会去检查指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号所代表的类是否被加载、解析和初始化。（判断类元信息是否存在） 如果没有，在双亲委派模型下，使用当前类加载器以ClassLoader+包名+类名为key进行查找对应的.class文件 如果没有找到文件，抛出ClassNotFoundException异常 如果找到，则进行类加载，并生成对应的class类对象 为对象分配内存 首先计算对象占用空间的大小，接着在堆中划分一块内存给对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小 说明：选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。 指针碰撞 如果内存规整，使用指针碰撞 如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Pointer）来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。 如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。 一般使用带有compact（整理）过程的收集器时，使用指针碰撞。 空闲列表 如果内存不规整，虚拟机需要维护一个列表，使用空闲列表分配 如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式称为“空闲列表（Free List）”。 处理并发安全问题 分配内存空间问题，创建对象是很频繁的操作，虚拟机确保new对象的时候的线程安全，需要解决并发问题。虚拟机采用两种方式来解决并发问题 CAS 失败重试、区域加锁：保证指针更新操作的原子性 TLAB 把内存分配的动作按照不同的线程划分在不同的空间之中进行，即保证每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲区。（Thread Local Allocation Buffer)。虚拟机是否使用TLAB, 可以通过-XX:+/-UseTLAB参数决定 初始化分配到的内存空间 内存分配结束，虚拟机将分配到的内存空间都初始化为零值(不包括对象头)。这一步保证了对象的实例字段在Java代码中不用初始化就可以直接使用，程序能访问到这些字段的数据类型所对应的零值 设置对象的对象头 将对象的所属类（即类的元数据信息）、对象的hashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现 执行init方法的初始化 在Java程序的视角来看，初始化在正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量 因此一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。 对象的内存布局 对象头 对象自身运行的运行时元数据 哈希值：对象在堆空间中都有一个首地址值，栈空间的引用根据这个地址指向堆中的对象，这就是哈希值起的作用 GC分代年龄：对象是在Eden区创建，经过多次GC后，如果还没有进行回收，就会在survivor中来回移动，其对应的年龄计数器会发生变化，达到阈值后会进入养老区。 锁状态标志：在同步中判断该对象是否是锁 线程持有的锁 线程偏向ID 偏向时间戳 另一个是类型指针，执行元数据区的类元数据InstancClass,确定该对象所数据的类型 如果对象是数组，对象头中还必须要有一块用于记录数组的长度的数据 因为正常对象元数据就知道对象的确切大小。数组必须得知道长度 实例数据 对象真正存储的有效数据，包括代码中定义的各种类型的字段（包括从父类继承下来【包括父类私有】的和本身拥有的字段）\n规则：\n相同宽度的字段总是被分配在一起 父类中定义的变量会出现在子类之前（因为父类的加载是优先于子类加载的） 如果CompactFields参数为true(默认为true)：子类的窄变量可能插入到父类变量的空隙 对齐填充 不是必须的，仅仅起到占位符的作用\n对象的访问定位 创建对象的目的是使用它。JVM是通过栈帧的对象引用访问到内部的对象实例\n《java虚拟机规范》没有说明，所以对象访问方式由虚拟机实现而定。主流有两种方式：\n使用句柄访问 使用直接指针访问 句柄访问 实现：需要从堆中划分出一块内存来做句柄池，reference存储对象的句柄地址，句柄中包含对象的实例与类型数据各自的地址信息 好处：reference中存储稳定句柄地址，对象被移动时只改变句柄实例中数据的指针，reference本身不需要修改 直接使用指针访问 实现：reference存储对象的地址，如果只是访问对象本身的话，就不需要一次间接访问的开销 好处: 速度更快，java中对象访问频繁，每次访都节省了一次指针定位的时间开销 HotSpot采用指针访问\nJVM可以通过对象引用准确定位到Java堆区中的instanceOopDesc对象，这样既可成功访问到对象的实例信息，当需要访问目标对象的具体类型时，JVM则会通过存储在instanceOopDesc中的元数据指针定位到存储在方法区中的instanceKlass对象上。\n","permalink":"https://AlfredNing.github.io/note/program/jvm/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/","summary":"对象的实例化 创建对象的方式 new 关键字 Class的newInstance()：反射的方式，只能调用空参的构造器，权限必须是public Constructor的newInstance(X)：反射的方式，可以调用空参、带参的构造器，权限没有要求，实用性更广 使用clone: 不调用任何构造器，当前类只需要实现Clonable接口，默认是浅拷贝 使用反序列化：从文件、数据库当中、网络中获取一个对象的二进制流，反序列化为内存的对象 利用asm字节码技术，动态生成Constructor对象，第三方库Objensis 创建对象的步骤 字节码角度 new 后面来说一般都会跟着dup，因为在需要调用init方法，操作栈上要进行出栈\nNEW ：如果找不到Class对象，则进行类加载。加载成功后，则在堆中分配内存，从Object 开始到本类路径上的所有属性值都要分配内存。分配完毕之后，进行零值初始化。在分配过程中，注意引用是占据存储空间的，它是一个变量，占用4个字节。这个指令完毕后，将指向实例对象的引用变量压入虚拟机栈顶。 DUP ：在栈顶复制该引用变量，这时的栈顶有两个指向堆内实例对象的引用变量。如果 方法有参数，还需要把参数压人操作栈中。两个引用变量的目的不同，其中压至底下的引用用于赋值，或者保存到局部变量表，另一个栈顶的引用变量作为句柄调用相关方法。 INVOKESPECIAL ：调用对象实例方法，通过栈顶的引用变量调用＜init\u0026gt; 方法。\n执行步骤角度 - 面试回答 判断对象的类是否加载、链接、初始化 虚拟机遇到一条new指令，首选会去检查指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号所代表的类是否被加载、解析和初始化。（判断类元信息是否存在） 如果没有，在双亲委派模型下，使用当前类加载器以ClassLoader+包名+类名为key进行查找对应的.class文件 如果没有找到文件，抛出ClassNotFoundException异常 如果找到，则进行类加载，并生成对应的class类对象 为对象分配内存 首先计算对象占用空间的大小，接着在堆中划分一块内存给对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小 说明：选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。 指针碰撞 如果内存规整，使用指针碰撞 如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Pointer）来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。 如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。 一般使用带有compact（整理）过程的收集器时，使用指针碰撞。 空闲列表 如果内存不规整，虚拟机需要维护一个列表，使用空闲列表分配 如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式称为“空闲列表（Free List）”。 处理并发安全问题 分配内存空间问题，创建对象是很频繁的操作，虚拟机确保new对象的时候的线程安全，需要解决并发问题。虚拟机采用两种方式来解决并发问题 CAS 失败重试、区域加锁：保证指针更新操作的原子性 TLAB 把内存分配的动作按照不同的线程划分在不同的空间之中进行，即保证每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲区。（Thread Local Allocation Buffer)。虚拟机是否使用TLAB, 可以通过-XX:+/-UseTLAB参数决定 初始化分配到的内存空间 内存分配结束，虚拟机将分配到的内存空间都初始化为零值(不包括对象头)。这一步保证了对象的实例字段在Java代码中不用初始化就可以直接使用，程序能访问到这些字段的数据类型所对应的零值 设置对象的对象头 将对象的所属类（即类的元数据信息）、对象的hashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现 执行init方法的初始化 在Java程序的视角来看，初始化在正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量 因此一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。 对象的内存布局 对象头 对象自身运行的运行时元数据 哈希值：对象在堆空间中都有一个首地址值，栈空间的引用根据这个地址指向堆中的对象，这就是哈希值起的作用 GC分代年龄：对象是在Eden区创建，经过多次GC后，如果还没有进行回收，就会在survivor中来回移动，其对应的年龄计数器会发生变化，达到阈值后会进入养老区。 锁状态标志：在同步中判断该对象是否是锁 线程持有的锁 线程偏向ID 偏向时间戳 另一个是类型指针，执行元数据区的类元数据InstancClass,确定该对象所数据的类型 如果对象是数组，对象头中还必须要有一块用于记录数组的长度的数据 因为正常对象元数据就知道对象的确切大小。数组必须得知道长度 实例数据 对象真正存储的有效数据，包括代码中定义的各种类型的字段（包括从父类继承下来【包括父类私有】的和本身拥有的字段）","title":"对象内存布局"},{"content":"黑格尔的一句话: 凡是现实的都是合理的，凡是合理的都是现实的。All that is real is rational; and all that is rational is real\n意思是说: 现实存在的现象，当初产生它的时候必然有它产生的原因和理由。如果这个理由将来不存在了，终究有一天它也会消亡。\n巴菲特：成功的关键不在于做对了多少件事，而在于少犯多少错误\n","permalink":"https://AlfredNing.github.io/thinking/%E9%9A%8F%E8%AE%B0/","summary":"黑格尔的一句话: 凡是现实的都是合理的，凡是合理的都是现实的。All that is real is rational; and all that is rational is real\n意思是说: 现实存在的现象，当初产生它的时候必然有它产生的原因和理由。如果这个理由将来不存在了，终究有一天它也会消亡。\n巴菲特：成功的关键不在于做对了多少件事，而在于少犯多少错误","title":"随想1"},{"content":"信号处理 号是由操作系统传给进程的中断，会提早终止一个程序。在 UNIX、LINUX、Mac OS X 或 Windows 系统上，可以通过按 Ctrl+C 产生中断\n可以在程序捕获的信号\n信号 描述 SIGABRT 程序的异常终止，如调用 abort。 SIGFPE 错误的算术运算，比如除以零或导致溢出的操作。 SIGILL 检测非法指令。 SIGINT 接收到交互注意信号。 SIGSEGV 非法访问内存。 SIGTERM 发送到程序的终止请求。 signal函数： 捕获突发事件 raise函数：生成信号 c++多线程 基于进程 ： 程序的并发执行\n基于线程：同一程序的片段并发执行\n多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径\n使用 POSIX 编写多线程 C++ 程序。POSIX Threads 或 Pthreads 提供的 API 可在多种类 Unix POSIX 系统上可用，比如 FreeBSD、NetBSD、GNU/Linux、Mac OS X 和 Solaris\n创建线程 #include \u0026lt;pthread.h\u0026gt;pthread_create (thread, attr, start_routine, arg) 在这里，pthread_create 创建一个新的线程，并让它可执行。下面是关于参数的说明：\n参数 描述 thread 指向线程标识符指针。 attr 一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。 start_routine 线程运行函数起始地址，一旦线程被创建就会执行。 arg 运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。 创建线程成功时，函数返回 0，若返回值不为 0 则说明创建线程失败\n终止线程 用下面的程序，我们可以用它来终止一个 POSIX 线程：\n#include \u0026lt;pthread.h\u0026gt;pthread_exit (status) 在这里，pthread_exit 用于显式地退出一个线程。通常情况下，pthread_exit() 函数是在线程完成工作后无需继续存在时被调用。\n如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止\n向线程传递参数 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;pthread.h\u0026gt; using namespace std; #define NUM_THREADS 5 struct thread_data{ int thread_id; char *message; }; void *PrintHello(void *threadarg){ struct thread_data *my_data; my_data = (struct thread_data *) threadarg; cout \u0026lt;\u0026lt; \u0026#34;Thread ID : \u0026#34; \u0026lt;\u0026lt; my_data-\u0026gt;thread_id ; cout \u0026lt;\u0026lt; \u0026#34; Message : \u0026#34; \u0026lt;\u0026lt; my_data-\u0026gt;message \u0026lt;\u0026lt; endl; pthread_exit(NULL); } int main (){ pthread_t threads[NUM_THREADS]; struct thread_data td[NUM_THREADS]; int rc; int i; for( i=0; i \u0026lt; NUM_THREADS; i++ ){ cout \u0026lt;\u0026lt;\u0026#34;main() : creating thread, \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; td[i].thread_id = i; td[i].message = \u0026#34;This is message\u0026#34;; rc = pthread_create(\u0026amp;threads[i], NULL, PrintHello, (void *)\u0026amp;td[i]); if (rc){ cout \u0026lt;\u0026lt; \u0026#34;Error:unable to create thread,\u0026#34; \u0026lt;\u0026lt; rc \u0026lt;\u0026lt; endl; exit(-1); } } pthread_exit(NULL); return 0; } 连接和分离线程 pthread_join (threadid, status) pthread_detach (threadid) pthread_join() 子程序阻碍调用程序，直到指定的 threadid 线程终止为止。\n当创建一个线程时，它的某个属性会定义它是否是可连接的（joinable）或可分离的（detached）。\n只有创建时定义为可连接的线程才可以被连接。如果线程创建时被定义为可分离的，则它永远也不能被连接。\nSTL C++ 标准模板库的核心包括以下三个组件：\n组件 描述 容器（Containers） 容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。 算法（Algorithms） 算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。 迭代器（iterators） 迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。 三个组件都带有丰富的预定义函数，通过简单的方式处理复杂的任务\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main() { // 向量存储 vector\u0026lt;int\u0026gt; vec; int i; cout \u0026lt;\u0026lt; \u0026#34;vector size: \u0026#34; \u0026lt;\u0026lt; vec.size() \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; 5; i++) { vec.push_back(i); } cout \u0026lt;\u0026lt; \u0026#34;vector size: \u0026#34; \u0026lt;\u0026lt; vec.size() \u0026lt;\u0026lt; endl; for (i = 0; i \u0026lt; 5; i++) { cout \u0026lt;\u0026lt; \u0026#34;value of vec [\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;] = \u0026#34; \u0026lt;\u0026lt; vec[i] \u0026lt;\u0026lt; endl; } vector\u0026lt;int\u0026gt;::iterator v = vec.begin(); while (v != vec.end()) { cout \u0026lt;\u0026lt; \u0026#34;value of v = \u0026#34; \u0026lt;\u0026lt; *v \u0026lt;\u0026lt; endl; v++; } return 0; } c++标准库 C++ 标准库可以分为两部分：\n标准函数库： 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。 面向对象类库： 这个库是类及其相关函数的集合。 C++ 标准库包含了所有的 C 标准库，为了支持类型安全，做了一定的添加和修改。\n标准函数库 输入/输出 I/O 字符串和字符处理 数学 时间、日期和本地化 动态分配 其他 宽字符函数 面向对象类库 标准的 C++ 面向对象类库定义了大量支持一些常见操作的类，比如输入/输出 I/O、字符串处理、数值处理。面向对象类库包含以下内容：\n标准的 C++ I/O 类 String 类 数值类 STL 容器类 STL 算法 STL 函数对象 STL 迭代器 STL 分配器 本地化库 异常处理类 杂项支持库 ","permalink":"https://AlfredNing.github.io/note/program/game/c++/c++%E5%9F%BA%E7%A1%805/","summary":"信号处理 号是由操作系统传给进程的中断，会提早终止一个程序。在 UNIX、LINUX、Mac OS X 或 Windows 系统上，可以通过按 Ctrl+C 产生中断\n可以在程序捕获的信号\n信号 描述 SIGABRT 程序的异常终止，如调用 abort。 SIGFPE 错误的算术运算，比如除以零或导致溢出的操作。 SIGILL 检测非法指令。 SIGINT 接收到交互注意信号。 SIGSEGV 非法访问内存。 SIGTERM 发送到程序的终止请求。 signal函数： 捕获突发事件 raise函数：生成信号 c++多线程 基于进程 ： 程序的并发执行\n基于线程：同一程序的片段并发执行\n多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径\n使用 POSIX 编写多线程 C++ 程序。POSIX Threads 或 Pthreads 提供的 API 可在多种类 Unix POSIX 系统上可用，比如 FreeBSD、NetBSD、GNU/Linux、Mac OS X 和 Solaris\n创建线程 #include \u0026lt;pthread.h\u0026gt;pthread_create (thread, attr, start_routine, arg) 在这里，pthread_create 创建一个新的线程，并让它可执行。下面是关于参数的说明：\n参数 描述 thread 指向线程标识符指针。 attr 一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。 start_routine 线程运行函数起始地址，一旦线程被创建就会执行。 arg 运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。 创建线程成功时，函数返回 0，若返回值不为 0 则说明创建线程失败","title":"C++基础5"},{"content":"数据封装 面向对象编程中把数据和操作数据的函数绑定在一起的一个概念。同等概念既数据隐藏\n默认情况下，在类中定义的所有项目都是私有的。\n把一个类定义为另一个类的友元类，会暴露实现细节，从而降低了封装性。理想的做法是尽可能地对外隐藏每个类的实现细节\n设计策略 通常情况下，我们都会设置类成员状态为私有（private），除非我们真的需要将其暴露，这样才能保证良好的封装性。\n这通常应用于数据成员，但它同样适用于所有成员，包括虚函数\n接口（抽象类） 接口描述类的行为和功能，而不需要完成特定类的实现。\nc++中的接口是用抽象类来实现，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与数据分离开的概念\n抽象类: 类中至少有一个函数被声明为纯虚函数，纯虚函数是通过在声明中使用 \u0026ldquo;= 0\u0026rdquo; 来指定的\n设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。\n因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重载纯虚函数，就尝试实例化该类的对象，会导致编译错误。\n可用于实例化对象的类被称为具体类。\n#include \u0026lt;iostream\u0026gt; using namespace std; // 基类 class Shape {public: // 提供接口框架的纯虚函数 virtual int getArea() = 0; void setWidth(int w) { width = w; } void setHeight(int h) { height = h; }protected: int width; int height;}; // 派生类 class Rectangle: public Shape{public: int getArea() { return (width * height); }}; class Triangle : public Shape { public: int getArea() { return (width * height) / 2; } }; int main(void) { Rectangle Rect; Triangle Tri; Rect.setWidth(5); Rect.setHeight(7); // 输出对象的面积 cout \u0026lt;\u0026lt; \u0026#34;Total Rectangle area: \u0026#34; \u0026lt;\u0026lt; Rect.getArea() \u0026lt;\u0026lt; endl; Tri.setWidth(5); Tri.setHeight(7); // 输出对象的面积 cout \u0026lt;\u0026lt; \u0026#34;Total Triangle area: \u0026#34; \u0026lt;\u0026lt; Tri.getArea() \u0026lt;\u0026lt; endl; return 0; } 设计策略 面向对象的系统可能会使用一个抽象基类为所有的外部应用程序提供一个适当的、通用的、标准化的接口。然后，派生类通过继承抽象基类，就把所有类似的操作都继承下来。\n外部应用程序提供的功能（即公有函数）在抽象基类中是以纯虚函数的形式存在的。这些纯虚函数在相应的派生类中被实现。\n这个架构也使得新的应用程序可以很容易地被添加到系统中，即使是在系统被定义之后依然可以如此\n文件和流 标准库 fstream：从文件读取流和向文件写入流\n据类型 描述 ofstream 该数据类型表示输出文件流，用于创建文件并向文件写入信息。 ifstream 该数据类型表示输入文件流，用于从文件读取信息。 fstream 该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。 打开文件 在从文件读取信息或者向文件写入信息之前，必须先打开文件。ofstream 和 fstream 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 ifstream 对象\nvoid open(const char *filename, ios::openmode mode); ofstream outfile; // 写入文件模式 截断文件 outfile.open(\u0026#34;file.dat\u0026#34;, ios::out | ios::trunc ); // 打开文件，读写 fstream afile; afile.open(\u0026#34;file.dat\u0026#34;, ios::out | ios::in ); 模式标志 描述 ios::app 追加模式。所有写入都追加到文件末尾。 ios::ate 文件打开后定位到文件末尾。 ios::in 打开文件用于读取。 ios::out 打开文件用于写入。 ios::trunc 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。 关闭文件 在 C++ 编程中，使用流插入运算符（ \u0026laquo; ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里使用的是 ofstream 或 fstream 对象，而不是 cout 对象\n读取文件 使用流提取运算符（ \u0026raquo; ）从文件读取信息，对象是ofstream或fstream\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; using namespace std; int main() { char data[100]; // 写模式打开文件 ofstream outfile; outfile.open(\u0026#34;afile.dat\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;Write to the file \u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Enter your name \u0026#34; \u0026lt;\u0026lt; endl; cin.getline(data, 100); // 写文件写入 outfile \u0026lt;\u0026lt; data \u0026lt;\u0026lt; endl; // 读模式打开文件 ifstream infile; infile.open(\u0026#34;afile.dat\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;Reading from the file \u0026#34; \u0026lt;\u0026lt; endl; infile \u0026gt;\u0026gt; data; cout \u0026lt;\u0026lt; data \u0026lt;\u0026lt; endl; infile \u0026gt;\u0026gt; data; cout \u0026lt;\u0026lt; data \u0026lt;\u0026lt; endl; infile.close(); return 0; } 文件位置指针\nistream 和 ostream 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 seekg（\u0026ldquo;seek get\u0026rdquo;）和关于 ostream 的 seekp（\u0026ldquo;seek put\u0026rdquo;）。\nseekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 ios::beg（默认的，从流的开头开始定位），也可以是 ios::cur（从流的当前位置开始定位），也可以是 ios::end（从流的末尾开始定位）。\n文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。\n异常处理 throw： 当问题出现， 程序会抛出一个异常 catch: 捕获异常处理 try: try 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块 可以使用 throw 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。\n#include \u0026lt;iostream\u0026gt; using namespace std; double division(int a, int b) { if (b == 0) { throw \u0026#34;Diviision By Zero\u0026#34;; } return a / b; } int main() { try { double z = division(50, 0); cout \u0026lt;\u0026lt; z \u0026lt;\u0026lt; endl; } catch (const char* msg) { cerr \u0026lt;\u0026lt; msg \u0026lt;\u0026lt; endl; } return 0; } 标准异常 定义新的异常 通过继承和重载 exception 类来定义新的异常\n#include \u0026lt;iostream\u0026gt; using namespace std; struct MyException : public exception { const char* what() const throw() { return \u0026#34;C++ exception\u0026#34;; } }; int main() { try { throw MyException(); } catch (MyException\u0026amp; e) { cout \u0026lt;\u0026lt; \u0026#34;e: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; endl; } catch (exception\u0026amp; e) { // 其他错误 } return 0; } 动态内存 栈：在函数内部声明的所有变量都将占用栈内存 堆: 程序未使用的内存，在程序运行时候可用于动态内存分配 new运算符: 给定类型的变量在运行时分配堆内的内存，返回分配的内存地址\n如果不需要动态分配内存，使用delete运算符，删除之前由 new 运算符分配的内存\n包括数组在内的任意内置的数据类型，也可以是包括类或结构在内的用户自定义的任何数据类型。\nmalloc() 函数在 C 语言中就出现了，在 C++ 中仍然存在，但建议尽量不要使用 malloc() 函数。new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象\n#include \u0026lt;iostream\u0026gt; using namespace std; int main() { double* pvalue = NULL; // 初始化为null的指针 pvalue = new double; // 申请内存 *pvalue = 29494.99; // 在申请的内存存储值 cout \u0026lt;\u0026lt; \u0026#34;Value of pavlue: \u0026#34; \u0026lt;\u0026lt; *pvalue \u0026lt;\u0026lt; endl; delete pvalue; // 释放内存 return 0; } 数组的动态内存分配 char* pvalue = NULL; // 初始化为 null 的指针 pvalue = new char[20]; // 为变量请求内存 delete []pvalue; // 删除 pvalue 所指向的数组 // new 多维数组分配内存 int ROW = 2;int COL = 3; double **pvalue = new double* [ROW]; // 为行分配内存 // 为列分配内存 for(int i = 0; i \u0026lt; COL; i++) { pvalue[i] = new double[COL]; } // 释放多维数组内存： for(int i = 0; i \u0026lt; COL; i++) { delete[] pvalue[i]; } delete [] pvalue; 对象的动态内存分配 #include \u0026lt;iostream\u0026gt; using namespace std; class Box { public: Box() { cout \u0026lt;\u0026lt; \u0026#34;调用构造函数！\u0026#34; \u0026lt;\u0026lt; endl; } ~Box() { cout \u0026lt;\u0026lt; \u0026#34;调用析构函数！\u0026#34; \u0026lt;\u0026lt; endl; } };int main() { Box* myBoxArray = new Box[4]; delete[] myBoxArray; // Delete array return 0; } 如果要为一个包含四个 Box 对象的数组分配内存，构造函数将被调用 4 次，同样地，当删除这些对象时，析构函数也将被调用相同的次数（4次）。 命名空间 作为附加信息来区分不同库中相同名称的函数、类、变量等，使用了命名空间既定义了上下文。本质上，命名空间定义了一个范围\n定义命名空间 关键字 namespace后跟命名空间的名称\n为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称：name::code; // code 可以是变量或函数\n#include \u0026lt;iostream\u0026gt; using namespace std; namespace first_space { void func() { cout \u0026lt;\u0026lt; \u0026#34;Inside first_space \u0026#34; \u0026lt;\u0026lt; endl; } } namespace second_space { void func() { cout \u0026lt;\u0026lt; \u0026#34;Inside second_space \u0026#34; \u0026lt;\u0026lt; endl; } } int main() { first_space::func(); second_space::func(); return 0; } using指令 使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称 using 指令也可以用来指定命名空间中的特定项目\nusing 指令引入的名称遵循正常的范围规则。名称从使用 using 指令开始是可见的，直到该范围结束。此时，在范围以外定义的同名实体是隐藏的。\n#include \u0026lt;iostream\u0026gt; using namespace std; namespace first_space { void func() { cout \u0026lt;\u0026lt; \u0026#34;Inside first_space \u0026#34; \u0026lt;\u0026lt; endl; } } namespace second_space { void func() { cout \u0026lt;\u0026lt; \u0026#34;Inside second_space \u0026#34; \u0026lt;\u0026lt; endl; } } using namespace first_space; using std::cout; int main() { func(); second_space::func(); return 0; } 不连续的命名空间 命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。一个命名空间的各个组成部分可以分散在多个文件中\n所以，如果命名空间中的某个组成部分需要请求定义在另一个文件中的名称，则仍然需要声明该名称。下面的命名空间定义可以是定义一个新的命名空间，也可以是为已有的命名空间增加新的元素\n嵌套的命名空间 namespace namespace_name1 { // 代码声明 namespace namespace_name2 { // 代码声明 } } // 通过使用 :: 运算符来访问嵌套的命名空间中的成员 // 访问 namespace_name2 中的成员 using namespace namespace_name1::namespace_name2; // 访问 namespace:name1 中的成员 using namespace namespace_name1; 模板 模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。\n模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念\n可以使用模板来定义函数和类\n函数模板 #include \u0026lt;iostream\u0026gt; using namespace std; template \u0026lt;typename T\u0026gt; inline T const\u0026amp; Max(T const\u0026amp; a, T const\u0026amp; b) { return a \u0026lt; b ? b : a; } int main() { int i = 39; int j = 20; cout \u0026lt;\u0026lt; \u0026#34;Max(i,j): \u0026#34; \u0026lt;\u0026lt; Max(i, j) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Max(i, j): \u0026#34; \u0026lt;\u0026lt; Max(i, j) \u0026lt;\u0026lt; endl; double f1 = 13.5; double f2 = 20.7; cout \u0026lt;\u0026lt; \u0026#34;Max(f1, f2): \u0026#34; \u0026lt;\u0026lt; Max(f1, f2) \u0026lt;\u0026lt; endl; string s1 = \u0026#34;Hello\u0026#34;; string s2 = \u0026#34;World\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Max(s1, s2): \u0026#34; \u0026lt;\u0026lt; Max(s1, s2) \u0026lt;\u0026lt; endl; return 0; } 类模板 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;stdexcept\u0026gt; using namespace std; template \u0026lt;class T\u0026gt; class Stack { private: vector\u0026lt;T\u0026gt; elems; public: void push(T const\u0026amp;); void pop(); T top() const; bool empty() const { return elems.empty(); } }; template \u0026lt;class T\u0026gt; void Stack\u0026lt;T\u0026gt;::push(T const\u0026amp; elem) { elems.push_back(elem); } template \u0026lt;class T\u0026gt; void Stack\u0026lt;T\u0026gt;::pop() { if (elems.empty()) { throw out_of_range(\u0026#34;Stack\u0026lt;\u0026gt;::pop(): empty stack\u0026#34;); } elems.pop_back(); } template \u0026lt;class T\u0026gt; T Stack\u0026lt;T\u0026gt;::top() const { if (elems.empty()) { throw out_of_range(\u0026#34;Stack\u0026lt;\u0026gt;::pop(): empty stack\u0026#34;); } return elems.back(); } int main() { try { Stack\u0026lt;int\u0026gt; intStack; Stack\u0026lt;string\u0026gt; strStack; intStack.push(8); cout \u0026lt;\u0026lt; intStack.top() \u0026lt;\u0026lt; endl; strStack.push(\u0026#34;hello\u0026#34;); cout \u0026lt;\u0026lt; strStack.top() \u0026lt;\u0026lt; endl; strStack.pop(); strStack.pop(); } catch (exception const\u0026amp; ex) { cerr \u0026lt;\u0026lt; \u0026#34;Exception: \u0026#34; \u0026lt;\u0026lt; ex.what() \u0026lt;\u0026lt; endl; return -1; } return 0; } 预处理器 指令用在指示编译器在实际编译器之前完成所需完成的预处理\n所有的预处理器以#开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾 #include #define、#if、#else、#line 等 #define 预处理 #define 预处理指令用于创建符号常量。该符号常量通常称为宏\n函数宏 #define 来定义一个带有参数的宏\n#include \u0026lt;iostream\u0026gt; using namespace std; #define MIN(a,b) (a\u0026lt;b ? a : b) int main (){ int i, j; i = 100; j = 30; cout \u0026lt;\u0026lt;\u0026#34;较小的值为：\u0026#34; \u0026lt;\u0026lt; MIN(i, j) \u0026lt;\u0026lt; endl; return 0; } 条件编译 有几个指令可以用来有选择地对部分程序源代码进行编译。这个过程被称为条件编译。\n#ifndef NULL #define NULL 0 #endif // 调试 #ifdef DEBUG cerr \u0026lt;\u0026lt;\u0026#34;Variable x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; #endif #if 0 不进行编译的代码#endif #include \u0026lt;iostream\u0026gt; using namespace std; #define DEBUG #define MIN(a, b)( (b \u0026lt; a) ? b : a) int main() { int i, j; i = 100; j = 30; #ifdef DEBUG cerr \u0026lt;\u0026lt; \u0026#34;Trace: Inside main function\u0026#34; \u0026lt;\u0026lt; endl; #endif // DEBUG #if 0 /*注释部分*/ cout \u0026lt;\u0026lt; MKSTR(hello c++) \u0026lt;\u0026lt; endl; #endif cout \u0026lt;\u0026lt; \u0026#34;The minimum is \u0026#34; \u0026lt;\u0026lt; MIN(i, j) \u0026lt;\u0026lt; endl; #ifdef DEBUG cerr \u0026lt;\u0026lt; \u0026#34;Trace: Coming out of main function\u0026#34; \u0026lt;\u0026lt; endl; #endif // DEBUG return 0; } # 和 ## 运算符 # 和 ## 预处理运算符在 C++ 和 ANSI/ISO C 中都是可用的。# 运算符会把 replacement-text 令牌转换为用引号引起来的字符串\n## 运算符用于连接两个令牌\n预定义宏 宏 描述 LINE 这会在程序编译时包含当前行号。 FILE 这会在程序编译时包含当前文件名。 DATE 这会包含一个形式为 month/day/year 的字符串，它表示把源文件转换为目标代码的日期。 TIME 这会包含一个形式为 hour:minute:second 的字符串，它表示程序被编译的时间。 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;Value of __LINE__ : \u0026#34; \u0026lt;\u0026lt; __LINE__ \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Value of __FILE__ : \u0026#34; \u0026lt;\u0026lt; __FILE__ \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Value of __DATE__ : \u0026#34; \u0026lt;\u0026lt; __DATE__ \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Value of __TIME__ : \u0026#34; \u0026lt;\u0026lt; __TIME__ \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://AlfredNing.github.io/note/program/game/c++/c++%E5%9F%BA%E7%A1%804/","summary":"数据封装 面向对象编程中把数据和操作数据的函数绑定在一起的一个概念。同等概念既数据隐藏\n默认情况下，在类中定义的所有项目都是私有的。\n把一个类定义为另一个类的友元类，会暴露实现细节，从而降低了封装性。理想的做法是尽可能地对外隐藏每个类的实现细节\n设计策略 通常情况下，我们都会设置类成员状态为私有（private），除非我们真的需要将其暴露，这样才能保证良好的封装性。\n这通常应用于数据成员，但它同样适用于所有成员，包括虚函数\n接口（抽象类） 接口描述类的行为和功能，而不需要完成特定类的实现。\nc++中的接口是用抽象类来实现，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与数据分离开的概念\n抽象类: 类中至少有一个函数被声明为纯虚函数，纯虚函数是通过在声明中使用 \u0026ldquo;= 0\u0026rdquo; 来指定的\n设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。\n因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重载纯虚函数，就尝试实例化该类的对象，会导致编译错误。\n可用于实例化对象的类被称为具体类。\n#include \u0026lt;iostream\u0026gt; using namespace std; // 基类 class Shape {public: // 提供接口框架的纯虚函数 virtual int getArea() = 0; void setWidth(int w) { width = w; } void setHeight(int h) { height = h; }protected: int width; int height;}; // 派生类 class Rectangle: public Shape{public: int getArea() { return (width * height); }}; class Triangle : public Shape { public: int getArea() { return (width * height) / 2; } }; int main(void) { Rectangle Rect; Triangle Tri; Rect.","title":"C++基础4"},{"content":"指针 表示内存的地址。指针是一个变量，值为另一个变量的内存地址。内存位置的直接地址\n必须先声明，后使用 所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表存地址的长的十六进制数 不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同 概念 描述 C++ Null 指针 C++ 支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。 C++ 指针的算术运算 可以对指针进行四种算术运算：++、\u0026ndash;、+、- C++ 指针 vs 数组 指针和数组之间有着密切的关系。 C++ 指针数组 可以定义用来存储指针的数组。 C++ 指向指针的指针 C++ 允许指向指针的指针。 C++ 传递指针给函数 通过引用或地址传递参数，使传递的参数在调用函数中被改变。 C++ 从函数返回指针 C++ 允许函数返回指针到局部变量、静态变量和动态内存分配。 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int var = 20; // 指针变量声明 int* ip; double* dp; ip = \u0026amp;var; // 使用: 变量存储的地址 cout \u0026lt;\u0026lt; \u0026#34;ip: \u0026#34; \u0026lt;\u0026lt; ip \u0026lt;\u0026lt; endl; // 访问地址 cout \u0026lt;\u0026lt; *ip \u0026lt;\u0026lt; endl; return 0; } 引用 引用变量是一个别名，他是一件存在的变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。\n与指针比较 不存在空引用。引用必须连接到一块合法的内存。 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。 引用必须在创建时被初始化。指针可以在任何时间被初始化。 概念 描述 把引用作为参数 C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。 把引用作为返回值 可以从 C++ 函数中返回引用，就像返回其他数据类型一样。 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { // 简单变量 int i; double d; // 引用 int\u0026amp; r = i; double \u0026amp; s = d; i = 5; cout \u0026lt;\u0026lt; \u0026#34;Value of i: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Value of i reference: \u0026#34; \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; d = 11.8; cout \u0026lt;\u0026lt; \u0026#34;Value of d: \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Value of d reference: \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; } 时期和时间 c++标准库没有提供，继承c语言用于日期和时间操作结构和函数。使用时需要引入头部文件\n相关类型\nclock_t time_t size_t tm 类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数\n结构类型 tm 把日期和时间以 C 结构的形式保存\n序号 函数 \u0026amp; 描述 1 time_t time(time_t *time); 该函数返回系统的当前日历时间，自 1970 年 1 月 1 日以来经过的秒数。如果系统没有时间，则返回 .1。 2 char *ctime(const time_t *time); 该返回一个表示当地时间的字符串指针，字符串形式 day month year hours:minutes:seconds year\\n\\0。 3 struct tm *localtime(const time_t *time); 该函数返回一个指向表示本地时间的 tm 结构的指针。 4 clock_t clock(void); 该函数返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。如果时间不可用，则返回 .1。 5 char * asctime ( const struct tm * time ); 该函数返回一个指向字符串的指针，字符串包含了 time 所指向结构中存储的信息，返回形式为：day month date hours:minutes:seconds year\\n\\0。 6 struct tm *gmtime(const time_t *time); 该函数返回一个指向 time 的指针，time 为 tm 结构，用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。 7 time_t mktime(struct tm *time); 该函数返回日历时间，相当于 time 所指向结构中存储的时间。 8 double difftime ( time_t time2, time_t time1 ); 该函数返回 time1 和 time2 之间相差的秒数。 9 size_t strftime(); 该函数可用于格式化日期和时间为指定的格式。 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;iostream\u0026gt; #include \u0026lt;ctime\u0026gt; using namespace std; int main() { // 基于当前系统的当前日期/时间 time_t now = time(0); // 把 now 转换为字符串形式 char* dt = ctime(\u0026amp;now); cout \u0026lt;\u0026lt; \u0026#34;本地日期和时间：\u0026#34; \u0026lt;\u0026lt; dt \u0026lt;\u0026lt; endl; // 把 now 转换为 tm 结构 tm* gmtm = gmtime(\u0026amp;now); dt = asctime(gmtm); cout \u0026lt;\u0026lt; \u0026#34;UTC 日期和时间：\u0026#34; \u0026lt;\u0026lt; dt \u0026lt;\u0026lt; endl; tm* ltm = localtime(\u0026amp;now); cout \u0026lt;\u0026lt; \u0026#34;Year: \u0026#34; \u0026lt;\u0026lt; 1900 + ltm-\u0026gt;tm_year \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Month: \u0026#34; \u0026lt;\u0026lt; 1 + ltm-\u0026gt;tm_mon \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Day: \u0026#34; \u0026lt;\u0026lt; ltm-\u0026gt;tm_mday \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Time: \u0026#34; \u0026lt;\u0026lt; 1 + ltm-\u0026gt;tm_hour \u0026lt;\u0026lt; \u0026#34;:\u0026#34;; cout \u0026lt;\u0026lt; 1 + ltm-\u0026gt;tm_min \u0026lt;\u0026lt; \u0026#34;:\u0026#34;; cout \u0026lt;\u0026lt; 1 + ltm-\u0026gt;tm_sec \u0026lt;\u0026lt; endl; return 0; } 输入和输出 输入操作：外围设备流向内存\n输出操作：内存流向外围设备\nIO 库头文件 头文件 函数和描述 该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。 该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。 该文件为用户控制的文件处理声明服务 标准输出流 - cout 预定义的对象 cout 是 ostream 类的一个实例。cout 对象\u0026quot;连接\u0026quot;到标准输出设备，通常是显示屏。cout 是与流插入运算符 \u0026laquo; 结合使用的,endl 用于在行末添加一个换行符\n标准输入流 -cin 预定义的对象 cin 是 istream 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。cin 是与流提取运算符 \u0026raquo; 结合使用的。\nC++ 编译器根据要输入值的数据类型，选择合适的流提取运算符来提取值，并把它存储在给定的变量中。\n流提取运算符 \u0026raquo; 在一个语句中可以多次使用\n标准错误流 - cerr 预定义的对象 cerr 是 ostream 类的一个实例。cerr 对象附属到标准错误设备，通常也是显示屏，但是 cerr 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。cerr 也是与流插入运算符 \u0026laquo; 结合使用的\n标准日志流 - clog 预定义的对象 clog 是 ostream 类的一个实例。clog 对象附属到标准错误设备，通常也是显示屏，但是 clog 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲在，直到缓冲填满或者缓冲区刷新时才会输出。\nclog 也是与流插入运算符 \u0026laquo; 结合使用的\n#define _CRT_SECURE_NO_WARNINGS #include \u0026lt;iostream\u0026gt; using namespace std; int main() { char name[50]; cout \u0026lt;\u0026lt; \u0026#34;请输入名称：\u0026#34;; cin \u0026gt;\u0026gt; name; cout \u0026lt;\u0026lt; \u0026#34;name: \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl; char str[] = \u0026#34;unable to read\u0026#34;; clog \u0026lt;\u0026lt; \u0026#34;message info: \u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; cerr \u0026lt;\u0026lt; \u0026#34;mesage error: \u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; return 0; } 结构体 用户自定义可用的数据类型，表示存储不同类型的数据项。\n定义结构 访问成员运算符.: 成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;iostream\u0026gt; using namespace std; // 定义一个结构体 struct Books { char title[50]; char author[50]; char subject[100]; int book_id; }; int main() { // 定义结构体类型 Books Book1; Books Book2; strcpy(Book1.title, \u0026#34;浪潮之巅\u0026#34;); strcpy(Book1.author, \u0026#34;吴军\u0026#34;); strcpy(Book1.subject, \u0026#34;科技产业\u0026#34;); Book1.book_id, 1001; cout \u0026lt;\u0026lt; \u0026#34;book1.title: \u0026#34; \u0026lt;\u0026lt; Book1.title; cout \u0026lt;\u0026lt; \u0026#34;book1.author: \u0026#34; \u0026lt;\u0026lt; Book1.author; cout \u0026lt;\u0026lt; \u0026#34;book1.subject: \u0026#34; \u0026lt;\u0026lt; Book1.subject; cout \u0026lt;\u0026lt; \u0026#34;book1.book_id: \u0026#34; \u0026lt;\u0026lt; Book1.book_id; return 0; } 结构作为函数参数 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;iostream\u0026gt; using namespace std; void printBook(struct Books book); // 定义一个结构体 struct Books { char title[50]; char author[50]; char subject[100]; int book_id; }; int main() { // 定义结构体类型 Books Book1; Books Book2; strcpy(Book1.title, \u0026#34;浪潮之巅\u0026#34;); strcpy(Book1.author, \u0026#34;吴军\u0026#34;); strcpy(Book1.subject, \u0026#34;科技产业\u0026#34;); Book1.book_id = 1001; printBook(Book1); return 0; } void printBook(struct Books book) { cout \u0026lt;\u0026lt; \u0026#34;Book.title: \u0026#34; \u0026lt;\u0026lt; book.title; cout \u0026lt;\u0026lt; \u0026#34;Book.author: \u0026#34; \u0026lt;\u0026lt; book.author; cout \u0026lt;\u0026lt; \u0026#34;Book.subject: \u0026#34; \u0026lt;\u0026lt; book.subject; cout \u0026lt;\u0026lt; \u0026#34;Book.book_id: \u0026#34; \u0026lt;\u0026lt; book.book_id; } 指向结构的指针 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;iostream\u0026gt; using namespace std; void printBook(struct Books* book); /* 结构体指针定义：struct Books *struct_pointer; 为了查找结构变量的地址\u0026amp; 运算符放在结构名称的前面 使用指向该结构的指针访问结构的成员： 必须使用-\u0026gt; 运算符 */ // 定义一个结构体 struct Books { char title[50]; char author[50]; char subject[100]; int book_id; }; int main() { // 定义结构体类型 Books Book1; Books Book2; strcpy(Book1.title, \u0026#34;浪潮之巅\u0026#34;); strcpy(Book1.author, \u0026#34;吴军\u0026#34;); strcpy(Book1.subject, \u0026#34;科技产业\u0026#34;); Book1.book_id = 1001; printBook(\u0026amp;Book1); return 0; } void printBook(struct Books* book) { cout \u0026lt;\u0026lt; \u0026#34;Book.title: \u0026#34; \u0026lt;\u0026lt; book-\u0026gt;title; cout \u0026lt;\u0026lt; \u0026#34;Book.author: \u0026#34; \u0026lt;\u0026lt; book-\u0026gt;author; cout \u0026lt;\u0026lt; \u0026#34;Book.subject: \u0026#34; \u0026lt;\u0026lt; book-\u0026gt;subject; cout \u0026lt;\u0026lt; \u0026#34;Book.book_id: \u0026#34; \u0026lt;\u0026lt; book-\u0026gt;book_id; } typedof 更加简单的定义结构体方式\n#define _CRT_SECURE_NO_WARNINGS #include \u0026lt;iostream\u0026gt; using namespace std; // 定义一个结构体 typedef struct { char title[50]; char author[50]; char subject[100]; int book_id; } Books; void printBook(Books* book); /* 结构体指针定义：struct Books *struct_pointer; 为了查找结构变量的地址\u0026amp; 运算符放在结构名称的前面 使用指向该结构的指针访问结构的成员： 必须使用-\u0026gt; 运算符 */ int main() { // 定义结构体类型 Books Book1; Books Book2; strcpy(Book1.title, \u0026#34;浪潮之巅\u0026#34;); strcpy(Book1.author, \u0026#34;吴军\u0026#34;); strcpy(Book1.subject, \u0026#34;科技产业\u0026#34;); Book1.book_id = 1001; printBook(\u0026amp;Book1); // typedef 关键字来定义非结构类型 typedef long int* pint32; pint32 x, y, z; // x, y 和 z 都是指向长整型 long int 的指针。 return 0; } // 直接使用 Books 来定义 Books 类型的变量，而不需要使用 struct 关键字 void printBook(Books* book) { cout \u0026lt;\u0026lt; \u0026#34;Book.title: \u0026#34; \u0026lt;\u0026lt; book-\u0026gt;title; cout \u0026lt;\u0026lt; \u0026#34;Book.author: \u0026#34; \u0026lt;\u0026lt; book-\u0026gt;author; cout \u0026lt;\u0026lt; \u0026#34;Book.subject: \u0026#34; \u0026lt;\u0026lt; book-\u0026gt;subject; cout \u0026lt;\u0026lt; \u0026#34;Book.book_id: \u0026#34; \u0026lt;\u0026lt; book-\u0026gt;book_id; } 类和对象 用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类被称为类的成员。\n类 定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作\n类定义是以关键字 class 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表\n对象 类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样\n#include \u0026lt;iostream\u0026gt; using namespace std; class Box { public: double length; double width; double height; double breadth; }; int main() { // 对象声明 Box Box1; double volume = 0.0; Box1.height = 5.0; Box1.width = 5.0; Box1.length = 5.0; volume = Box1.height * Box1.length * Box1.width; cout \u0026lt;\u0026lt; \u0026#34;Box1 的体积：\u0026#34; \u0026lt;\u0026lt; volume \u0026lt;\u0026lt; endl; return 0; } 概念 描述 类成员函数 类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。 类访问修饰符 类成员可以被定义为 public、private 或 protected。默认情况下是定义为 private。 构造函数 \u0026amp; 析构函数 类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。 C++ 拷贝构造函数 拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。 C++ 友元函数 友元函数可以访问类的 private 和 protected 成员。 C++ 内联函数 通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。 C++ 中的 this 指针 每个对象都有一个特殊的指针 this，它指向对象本身。 C++ 中指向类的指针 指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。 C++ 类的静态成员 类的数据成员和函数成员都可以被声明为静态的 继承 继承代表了 is a 关系\n基类 \u0026amp; 派生类 一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名。\nclass derived-class: access-specifier base-class 其中，访问修饰符 access-specifier 是 public、protected 或 private 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private\n#include \u0026lt;iostream\u0026gt; using namespace std; class Shape { public: void setWidth(int w) { width = w; } void setHeight(int h) { height = h; } protected: int width; int height; }; // 派生类 class Rectangle : public Shape { public: int getArea() { return width * height; } }; int main() { Rectangle Rect; Rect.setWidth(4); Rect.setHeight(5); cout \u0026lt;\u0026lt; \u0026#34;Area is: \u0026#34; \u0026lt;\u0026lt; Rect.getArea() \u0026lt;\u0026lt; endl; return 0; } 访问控制 派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private\n访问 public protected private 同一个类 yes yes yes 派生类 yes yes no 外部的类 yes no no 一个派生类继承了所有的基类方法，但下列情况除外：\n基类的构造函数、析构函数和拷贝构造函数。 基类的重载运算符。 基类的友元函数。 继承类型 当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种类型。\n几乎不使用 protected 或 private 继承，通常使用 public 继承\n公有继承（public）：**当一个类派生自**公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。 保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。 私有继承（private）：**当一个类派生自**私有基类时，基类的公有和保护成员将成为派生类的私有成员。 多继承 多继承即一个子类可以有多个父类，它继承了多个父类的特性\n访问修饰符继承方式是 public、protected 或 private 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔\n#include \u0026lt;iostream\u0026gt; using namespace std; class Shape { public: void setWidth(int w) { width = w; } void setHeight(int h) { height = h; } protected: int width; int height; }; class PointCost { public: int getCost(int area) { return area * 70; } }; // 派生类 class Rectangle : public Shape, public PointCost{ public: int getArea() { return width * height; } }; int main() { int area; Rectangle Rect; Rect.setWidth(4); Rect.setHeight(5); area = Rect.getArea(); cout \u0026lt;\u0026lt; \u0026#34;Area is: \u0026#34; \u0026lt;\u0026lt; area \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Cost is: \u0026#34; \u0026lt;\u0026lt; Rect.getCost(area) \u0026lt;\u0026lt; endl; return 0; } 重载运算符和重载函数 同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载\n同一个作用域 函数名或具有相同名称的声明 形参列表和定义不同 编译器根据传入参数选择合适的重载函数或者重载运算符，该过程称为重载决策。\n函数重载 #include \u0026lt;iostream\u0026gt; using namespace std; class printData { public: void print(int t) { cout \u0026lt;\u0026lt; \u0026#34;int: \u0026#34; \u0026lt;\u0026lt; t \u0026lt;\u0026lt; endl; } void print(char* c) { cout \u0026lt;\u0026lt; \u0026#34;char: \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; } void print(double f) { cout \u0026lt;\u0026lt; \u0026#34;double: \u0026#34; \u0026lt;\u0026lt; f \u0026lt;\u0026lt; endl; } }; int main() { printData pd; // Call print to print integer pd.print(5); // Call print to print float pd.print(500.263); // Call print to print character char s[] = \u0026#34;hello\u0026#34;; pd.print(s); return 0; } 运算符重载 重定义或重载大部分 C++ 内置的运算符，自定义运算符\n重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。\n#include \u0026lt;iostream\u0026gt; using namespace std; class Box { public: double getVolume(void) { return length * breadth * height; } void setLength(double len) { length = len; } void setBreadth(double bre) { breadth = bre; } void setHeight(double hei) { height = hei; } Box operator+(const Box\u0026amp; b) { Box box; box.length = this-\u0026gt;length + b.length; box.breadth = this-\u0026gt;breadth + b.breadth; box.height = this-\u0026gt;height + b.height; return box; } private: double length; double breadth; double height; }; int main() { Box Box1; // 声明 Box1，类型为 Box Box Box2; // 声明 Box2，类型为 Box Box Box3; // 声明 Box3，类型为 Box double volume = 0.0; // 把体积存储在该变量中 // Box1 详述 Box1.setLength(6.0); Box1.setBreadth(7.0); Box1.setHeight(5.0); // Box2 详述 Box2.setLength(12.0); Box2.setBreadth(13.0); Box2.setHeight(10.0); // Box1 的体积 volume = Box1.getVolume(); cout \u0026lt;\u0026lt; \u0026#34;Volume of Box1 : \u0026#34; \u0026lt;\u0026lt; volume \u0026lt;\u0026lt; endl; // Box2 的体积 volume = Box2.getVolume(); cout \u0026lt;\u0026lt; \u0026#34;Volume of Box2 : \u0026#34; \u0026lt;\u0026lt; volume \u0026lt;\u0026lt; endl; // 把两个对象相加，得到 Box3 Box3 = Box1 + Box2; // Box3 的体积 volume = Box3.getVolume(); cout \u0026lt;\u0026lt; \u0026#34;Volume of Box3 : \u0026#34; \u0026lt;\u0026lt; volume \u0026lt;\u0026lt; endl; return 0; } 可重载运算符 + - * / % ^ \u0026amp; | ~ ! , = \u0026lt; \u0026gt; \u0026lt;= \u0026gt;= ++ \u0026ndash; \u0026laquo; \u0026raquo; == != \u0026amp;\u0026amp; || += -= /= %= ^= \u0026amp;= |= *= \u0026laquo;= \u0026raquo;= [] () -\u0026gt; -\u0026gt;* new new [] delete delete [] 不可重载运算符 :: .* . ?: 多态 调用成员函数，会根据调用函数的对象的类型执行不同的函数\n#include \u0026lt;iostream\u0026gt; using namespace std; class Shape { protected: int width, height; public: Shape(int a = 0, int b = 0) { width = a; height = b; } virtual int area() { cout \u0026lt;\u0026lt; \u0026#34;Parent class area :\u0026#34; \u0026lt;\u0026lt; endl; return 0; } };class Rectangle : public Shape { public: Rectangle(int a = 0, int b = 0) :Shape(a, b) { } int area() { cout \u0026lt;\u0026lt; \u0026#34;Rectangle class area :\u0026#34; \u0026lt;\u0026lt; (width * height) \u0026lt;\u0026lt; endl; return (width * height); } };class Triangle : public Shape { public: Triangle(int a = 0, int b = 0) :Shape(a, b) { } int area() { cout \u0026lt;\u0026lt; \u0026#34;Triangle class area :\u0026#34; \u0026lt;\u0026lt; (width * height / 2) \u0026lt;\u0026lt; endl; return (width * height / 2); } };// 程序的主函数 int main() { Shape* shape; Rectangle rec(10, 7); Triangle tri(10, 5); // 存储矩形的地址 shape = \u0026amp;rec; // 调用矩形的求面积函数 area shape-\u0026gt;area(); // 存储三角形的地址 shape = \u0026amp;tri; // 调用三角形的求面积函数 area shape-\u0026gt;area(); // 输出错误： Parent class area Parent class area /* 原因：调用函数 area() 被编译器设置为基类中的版本，这就是所谓的静态多态，或静态链接 - 函数调用在程序执行前就准备好了。有时候这也被称为早绑定，因为 area() 函数在程序编译期间就已经设置好了 添加关键字virtual */ return 0; } 虚函数 在基类中用关键字virtual声明的函数，在派生类中重新定义基类中定义的虚函数，会告诉编译器不要静态链接到该函数\n在程序中任意根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或者后期绑定\n纯虚函数 在基类中不给出默认的实现\nclass Shape { protected: int width, height; public: Shape( int a=0, int b=0) { width = a; height = b; } // pure virtual function virtual int area() = 0; // = 0 告诉编译器，函数没有主体，上面的虚函数是纯虚函数。 }; 数据抽象 定义：只向外界提供信息，并隐藏后台实现细节，既只表现必要的信息而不呈现细节\n数据抽象是一种依赖于接口和实现分离的编程技术。\n访问标签强制抽象 在 C++ 中，我们使用访问标签来定义类的抽象接口。一个类可以包含零个或多个访问标签：\n使用公共标签定义的成员都可以访问该程序的所有部分。一个类型的数据抽象视图是由它的公共成员来定义的。 使用私有标签定义的成员无法访问到使用类的代码。私有部分对使用类型的代码隐藏了实现细节。 访问标签出现的频率没有限制。每个访问标签指定了紧随其后的成员定义的访问级别。指定的访问级别会一直有效，直到遇到下一个访问标签或者遇到类主体的关闭右括号为止。\n好处 类的内部收到保护，不会因为用户的低级错误导致对象状态受损 类实现可能随着时间推移发生变化，以便应对不断变化的需求，或者应对那些要求不改变用户级代码的错误报告 如果只在类的私有部分定义数据成员，编写该类的作者就可以随意更改数据。如果实现发生改变，则只需要检查类的代码，看看这个改变会导致哪些影响。如果数据是公有的，则任何直接访问旧表示形式的数据成员的函数都可能受到影响\n#include \u0026lt;iostream\u0026gt; using namespace std; class Adder { public: Adder(int i = 0) { total = i; } // 对外接口 void addNum(int number) { total += number; } int getTotal() { return total; } private: // 对外界隐藏 int total; }; int main() { Adder a; a.addNum(10); a.addNum(20); cout \u0026lt;\u0026lt; \u0026#34;total: \u0026#34; \u0026lt;\u0026lt; a.getTotal() \u0026lt;\u0026lt; endl; return 0; } 设计策略 接口独立于实现，具体实现依赖于抽象。\n如果改变底层实现，接口也将保持不变\n在这种情况下，不管任何程序使用接口，接口都不会受到影响，只需要将最新的实现重新编译即可\n","permalink":"https://AlfredNing.github.io/note/program/game/c++/c++%E5%9F%BA%E7%A1%803/","summary":"指针 表示内存的地址。指针是一个变量，值为另一个变量的内存地址。内存位置的直接地址\n必须先声明，后使用 所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表存地址的长的十六进制数 不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同 概念 描述 C++ Null 指针 C++ 支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。 C++ 指针的算术运算 可以对指针进行四种算术运算：++、\u0026ndash;、+、- C++ 指针 vs 数组 指针和数组之间有着密切的关系。 C++ 指针数组 可以定义用来存储指针的数组。 C++ 指向指针的指针 C++ 允许指向指针的指针。 C++ 传递指针给函数 通过引用或地址传递参数，使传递的参数在调用函数中被改变。 C++ 从函数返回指针 C++ 允许函数返回指针到局部变量、静态变量和动态内存分配。 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int var = 20; // 指针变量声明 int* ip; double* dp; ip = \u0026amp;var; // 使用: 变量存储的地址 cout \u0026lt;\u0026lt; \u0026#34;ip: \u0026#34; \u0026lt;\u0026lt; ip \u0026lt;\u0026lt; endl; // 访问地址 cout \u0026lt;\u0026lt; *ip \u0026lt;\u0026lt; endl; return 0; } 引用 引用变量是一个别名，他是一件存在的变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。","title":"C++基础3"},{"content":"算法定义 有若干个样本a、c、d、e\u0026hellip; 类型假设是V\n在并查集一开始认为每个样本都在单独的集合里\n设计两个方法\n`isSameSet(V x, V y)： 查询两个样本x和有是否在同一个集合里面 union(V x, V y) : 把x和y各自所有集合的样本合并成一个集合 两个算法的时间复杂度越小越好\n算法流程 算法实现 import java.util.HashMap; import java.util.List; import java.util.Stack; /** * 并查集实现 * * @author Alfred.Ning * @since 2023年03月25日 09:23:00 */ public class UnionFindImpl { public static class Node\u0026lt;V\u0026gt; { V value; public Node(V v) { value = v; } } public static class UnionFind\u0026lt;V\u0026gt; { private HashMap\u0026lt;V, Node\u0026lt;V\u0026gt;\u0026gt; nodes; private HashMap\u0026lt;Node\u0026lt;V\u0026gt;, Node\u0026lt;V\u0026gt;\u0026gt; parents; private HashMap\u0026lt;Node\u0026lt;V\u0026gt;, Integer\u0026gt; sizeMap; public UnionFind(List\u0026lt;V\u0026gt; values) { nodes = new HashMap\u0026lt;\u0026gt;(); parents = new HashMap\u0026lt;\u0026gt;(); sizeMap = new HashMap\u0026lt;\u0026gt;(); for (V v : values) { Node\u0026lt;V\u0026gt; node = new Node\u0026lt;\u0026gt;(v); nodes.put(v, node); // 初始化各自集合 parents.put(node, node); // 初始化各自为代表点 sizeMap.put(node, 1); } } public boolean isSameSet(V a, V b) { if (!nodes.containsKey(a) || !nodes.containsKey(b)) { return false; } return findFather(nodes.get(a)) == findFather(nodes.get(b)); } public void union(V a, V b) { if (!nodes.containsKey(a) || !nodes.containsKey(b)) { return; } Node\u0026lt;V\u0026gt; aHead = findFather(nodes.get(a)); Node\u0026lt;V\u0026gt; bHead = findFather(nodes.get(b)); if (aHead != bHead) { int aSize = sizeMap.get(aHead); int bSize = sizeMap.get(bHead); Node\u0026lt;V\u0026gt; big = aSize \u0026gt;= bSize ? aHead : bHead; Node\u0026lt;V\u0026gt; small = big == aHead ? bHead : aHead; // 小挂大 parents.put(small, big); sizeMap.put(big, aSize + bSize); parents.remove(small); } } public int sets() { return sizeMap.size(); } public Node\u0026lt;V\u0026gt; findFather(Node\u0026lt;V\u0026gt; cur) { Stack\u0026lt;Node\u0026lt;V\u0026gt;\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); while (cur != parents.get(cur)) { stack.push(cur); cur = parents.get(cur); } // 扁平化 while (!stack.isEmpty()) { parents.put(stack.pop(), cur); } return cur; } } } findFather 解释 ","permalink":"https://AlfredNing.github.io/note/program/algorithm/%E5%B9%B6%E6%9F%A5%E9%9B%86/","summary":"算法定义 有若干个样本a、c、d、e\u0026hellip; 类型假设是V\n在并查集一开始认为每个样本都在单独的集合里\n设计两个方法\n`isSameSet(V x, V y)： 查询两个样本x和有是否在同一个集合里面 union(V x, V y) : 把x和y各自所有集合的样本合并成一个集合 两个算法的时间复杂度越小越好\n算法流程 算法实现 import java.util.HashMap; import java.util.List; import java.util.Stack; /** * 并查集实现 * * @author Alfred.Ning * @since 2023年03月25日 09:23:00 */ public class UnionFindImpl { public static class Node\u0026lt;V\u0026gt; { V value; public Node(V v) { value = v; } } public static class UnionFind\u0026lt;V\u0026gt; { private HashMap\u0026lt;V, Node\u0026lt;V\u0026gt;\u0026gt; nodes; private HashMap\u0026lt;Node\u0026lt;V\u0026gt;, Node\u0026lt;V\u0026gt;\u0026gt; parents; private HashMap\u0026lt;Node\u0026lt;V\u0026gt;, Integer\u0026gt; sizeMap; public UnionFind(List\u0026lt;V\u0026gt; values) { nodes = new HashMap\u0026lt;\u0026gt;(); parents = new HashMap\u0026lt;\u0026gt;(); sizeMap = new HashMap\u0026lt;\u0026gt;(); for (V v : values) { Node\u0026lt;V\u0026gt; node = new Node\u0026lt;\u0026gt;(v); nodes.","title":"并查集"},{"content":"c++运算符 算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 杂项运算符 算术运算符 假设变量 A 的值为 10，变量 B 的值为 20，则：\n运算符 描述 实例 + 把两个操作数相加 A + B 将得到 30 - 从第一个操作数中减去第二个操作数 A - B 将得到 -10 * 把两个操作数相乘 A * B 将得到 200 / 分子除以分母 B / A 将得到 2 % 取模运算符，整除后的余数 B % A 将得到 0 ++ 自增运算符，整数值增加 1 A++ 将得到 11 \u0026ndash; 自减运算符，整数值减少 1 A\u0026ndash; 将得到 9 关系运算符 假设变量 A 的值为 10，变量 B 的值为 20，则：\n运算符 描述 实例 == 检查两个操作数的值是否相等，如果相等则条件为真。 (A == B) 不为真。 != 检查两个操作数的值是否相等，如果不相等则条件为真。 (A != B) 为真。 \u0026gt; 检查左操作数的值是否大于右操作数的值，如果是则条件为真。 (A \u0026gt; B) 不为真。 \u0026lt; 检查左操作数的值是否小于右操作数的值，如果是则条件为真。 (A \u0026lt; B) 为真。 \u0026gt;= 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 (A \u0026gt;= B) 不为真。 \u0026lt;= 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 (A \u0026lt;= B) 为真 逻辑运算符 假设变量 A 的值为 1，变量 B 的值为 0，则：\n运算符 描述 实例 \u0026amp;\u0026amp; 称为逻辑与运算符。如果两个操作数都非零，则条件为真。 (A \u0026amp;\u0026amp; B) 为假。 || 称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。 (A || B) 为真。 ! 称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。 !(A \u0026amp;\u0026amp; B) 为真。 位运算符 位运算符作用于位，并逐位执行操作。\u0026amp;、 | 和 ^ 的真值表如下所示：\np q p \u0026amp; q p | q p ^ q 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 作用于数据\n下表显示了 C++ 支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则：\n运算符 描述 实例 \u0026amp; 如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。 (A \u0026amp; B) 将得到 12，即为 0000 1100 | 如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。 (A | B) 将得到 61，即为 0011 1101 ^ 如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。 (A ^ B) 将得到 49，即为 0011 0001 ~ 二进制补码运算符是一元运算符，具有\u0026quot;翻转\u0026quot;位效果，即0变成1，1变成0。 (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 \u0026laquo; 二进制左移运算符。左操作数的值向左移动右操作数指定的位数。 A \u0026laquo; 2 将得到 240，即为 1111 0000 \u0026raquo; 二进制右移运算符。左操作数的值向右移动右操作数指定的位数。 A \u0026raquo; 2 将得到 15，即为 0000 1111 赋值运算符 运算符 描述 实例 = 简单的赋值运算符，把右边操作数的值赋给左边操作数 C = A + B 将把 A + B 的值赋给 C += 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 C += A 相当于 C = C + A -= 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 C -= A 相当于 C = C - A *= 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 C *= A 相当于 C = C * A /= 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 C /= A 相当于 C = C / A %= 求模且赋值运算符，求两个操作数的模赋值给左边操作数 C %= A 相当于 C = C % A \u0026laquo;= 左移且赋值运算符 C \u0026laquo;= 2 等同于 C = C \u0026laquo; 2 \u0026raquo;= 右移且赋值运算符 C \u0026raquo;= 2 等同于 C = C \u0026raquo; 2 \u0026amp;= 按位与且赋值运算符 C \u0026amp;= 2 等同于 C = C \u0026amp; 2 ^= 按位异或且赋值运算符 C ^= 2 等同于 C = C ^ 2 |= 按位或且赋值运算符 C |= 2 等同于 C = C | 2 杂项运算符 下表列出了 C++ 支持的其他一些重要的运算符。\n运算符 描述 sizeof sizeof 运算符返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。 Condition ? X : Y 条件运算符。如果 Condition 为真 ? 则值为 X : 否则值为 Y。 , 逗号运算符会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。 .（点）和 -\u0026gt;（箭头） 成员运算符用于引用类、结构和共用体的成员。 Cast 强制转换运算符把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。 \u0026amp; 指针运算符 \u0026amp; 返回变量的地址。例如 \u0026amp;a; 将给出变量的实际地址。 * 指针运算符 * 指向一个变量。例如，*var; 将指向变量 var。 运算优先级 下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。\n类别 运算符 结合性 后缀 () [] -\u0026gt; . ++ - - 从左到右 一元 + - ! ~ ++ - - (type)* \u0026amp; sizeof 从右到左 乘除 * / % 从左到右 加减 + - 从左到右 移位 \u0026laquo; \u0026raquo; 从左到右 关系 \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= 从左到右 相等 == != 从左到右 位与 AND \u0026amp; 从左到右 位异或 XOR ^ 从左到右 位或 OR | 从左到右 逻辑与 AND \u0026amp;\u0026amp; 从左到右 逻辑或 OR || 从左到右 条件 ?: 从右到左 赋值 = += -= *= /= %=\u0026raquo;= \u0026laquo;= \u0026amp;= ^= |= 从右到左 逗号 , 从左到右 基本结构 循环 循环类型 C++ 编程语言提供了以下几种循环类型。点击链接查看每个类型的细节。\n循环类型 描述 while 循环 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。 for 循环 多次执行一个语句序列，简化管理循环变量的代码。 do\u0026hellip;while 循环 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。 嵌套循环 您可以在 while、for 或 do..while 循环内使用一个或多个循环。 循环控制语句 循环控制语句更改执行的正常序列。当执行离开一个范围时，所有在该范围中创建的自动对象都会被销毁。\nC++ 提供了下列的控制语句。点击链接查看每个语句的细节。\n控制语句 描述 break 语句 终止 loop 或 switch 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。 continue 语句 引起循环跳过主体的剩余部分，立即重新开始测试条件。 goto 语句 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。 无限循环 #include \u0026lt;iostream\u0026gt;using namespace std; int main (){ for( ; ; ) { printf(\u0026#34;This loop will run forever.\\n\u0026#34;); } return 0;} 判断 判断语句 语句 描述 if 语句 一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。 if\u0026hellip;else 语句 一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。 嵌套 if 语句 您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。 switch 语句 一个 switch 语句允许测试一个变量等于多个值时的情况。 嵌套 switch 语句 您可以在一个 switch 语句内使用另一个 switch 语句。 运算符: ?: Exp1 ? Exp2 : Exp3;\n函数 #include \u0026lt;iostream\u0026gt; int count; // 函数声明 在函数声明中，参数的名称并不重要，只有参数的类型是必需的 int funcDefine(int num1, int num2); // 也可以声明为： int funcDefine(int, int); // 一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，在调用函数的文件顶部声明函数 int main() { count = 5; // 调用函数 funcDefine(3, 4); return 0; } // 定义函数 int funcDefine(int num1, int num2) { /** * 函数组成 * 1. 返回类型 * 2. 函数名称 * 3. 参数 * 4. 函数主体 */ } 函数参数 必须声明接受参数值的变量。这些变量称为函数的形式参数\n形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁\n传递参数的方式 调用类型 描述 传值调用 该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。 指针调用 该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 引用调用 该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 lambda函数与表达式 C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)\nLambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。\nLambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:\n[capture](parameters)-\u0026gt;return-type{body} [](int x, int y){ return x \u0026lt; y ; } 没有参数可以表示为： []{++global_x;} [](int x, int y) -\u0026gt; int { int z = x + y; return z + x; } 在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定： [] // 沒有定义任何变量。使用未定义变量会引发错误。 [x, \u0026amp;y] // x以传值方式传入（默认），y以引用方式传入。 [\u0026amp;] // 任何被使用到的外部变量都隐式地以引用方式加以引用。 [=] // 任何被使用到的外部变量都隐式地以传值方式加以引用。 [=, x] // x显式地以传值方式加以引用。其余变量以引用方式加以引用。 [\u0026amp;, \u0026amp;z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。 对于[=]或[\u0026amp;]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入 [this]() { this-\u0026gt;someFunc(); }(); 数字操作 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { // 数字定义 short s; int i; long l; float f; double d; // 数字赋值 s = 10; i = 1000; l = 1000000; f = 230.447; d = 20334.242; // 数字输出 cout \u0026lt;\u0026lt; \u0026#34;short s :\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;int i :\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;long l :\u0026#34; \u0026lt;\u0026lt; l \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;float f :\u0026#34; \u0026lt;\u0026lt; f \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;double d :\u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; // 数学运算 cout \u0026lt;\u0026lt; \u0026#34;sin(d) :\u0026#34; \u0026lt;\u0026lt; sin(d) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;abs(i) :\u0026#34; \u0026lt;\u0026lt; abs(i) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;floor(d) :\u0026#34; \u0026lt;\u0026lt; floor(d) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;sqrt(f) :\u0026#34; \u0026lt;\u0026lt; sqrt(f) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;pow( d, 2) :\u0026#34; \u0026lt;\u0026lt; pow(d, 2) \u0026lt;\u0026lt; endl; // 随机数 int ii, j; // 设置种子 srand((unsigned)time( NULL)); for (ii = 0; ii \u0026lt; 10; ii++) { j = rand(); cout \u0026lt;\u0026lt; \u0026#34;随机数：\u0026#34; \u0026lt;\u0026lt; j \u0026lt;\u0026lt; endl; } return 0; } 数组 固定大小相同类型的元素集合。存储一系列数据。所有数组都是由连续的内存位置组成。最低的位置对应第一个元素，最高的位置对应最后一个元素\n#include \u0026lt;iostream\u0026gt; using namespace std; #include \u0026lt;iomanip\u0026gt; using std::setw; int main() { // 声明数组 type arrayName [arraySize] double balance[10]; // 初始化数组 double balance2[3] = { 10, 20, 30 }; // 大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目 // 如果省略掉了数组的大小，数组的大小则为初始化时元素的个数 double balance1[] = { 1000.0, 2.0, 3.4, 17.0, 50.0 }; // 访问数组元素 double salary = balance[9]; int n[10]; for (int i = 0; i \u0026lt; 10; i++) { n[i] = i + 100; } // setw: 格式化输出 cout \u0026lt;\u0026lt; \u0026#34;Element\u0026#34; \u0026lt;\u0026lt; setw(13) \u0026lt;\u0026lt; \u0026#34;Value\u0026#34; \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; 10; i++) { cout \u0026lt;\u0026lt; setw(7) \u0026lt;\u0026lt; i \u0026lt;\u0026lt; setw(13) \u0026lt;\u0026lt; n[i] \u0026lt;\u0026lt; endl; } return 0; } 概念 概念 描述 多维数组 C++ 支持多维数组。多维数组最简单的形式是二维数组。 指向数组的指针 您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。 传递数组给函数 您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。 从函数返回数组 C++ 允许从函数返回数组。 字符串 C 风格字符串 C++ 引入的 string 类类型 字符串的内存表示| C++ 编译器会在初始化数组时，自动把 \u0026lsquo;\\0\u0026rsquo; 放在字符串的末尾。\n字符串函数 序号 函数 \u0026amp; 目的 1 strcpy(s1, s2); 复制字符串 s2 到字符串 s1。 2 strcat(s1, s2); 连接字符串 s2 到字符串 s1 的末尾。 3 strlen(s1); 返回字符串 s1 的长度。 4 strcmp(s1, s2); 如果 s1 和 s2 是相同的，则返回 0；如果 s1\u0026lt;s2 则返回小于 0；如果 s1\u0026gt;s2 则返回大于 0。 5 strchr(s1, ch); 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 6 strstr(s1, s2); 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 #include \u0026lt;iostream\u0026gt; using namespace std; #include \u0026lt;iomanip\u0026gt; using std::setw; int main() { // c风格字符串 字符串实际上是使用 null 字符 \u0026#39;\\0\u0026#39; 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符 char greeting[6] = { \u0026#39;h\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;,\u0026#39;l\u0026#39;, \u0026#39;0\u0026#39; }; char greeting1[] = \u0026#34;hello\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Greeting message: \u0026#34;; cout \u0026lt;\u0026lt; greeting \u0026lt;\u0026lt; endl; return 0; } String类 c++标准库的类\n#include \u0026lt;iostream\u0026gt; using namespace std; #include \u0026lt;iomanip\u0026gt; using std::setw; #include \u0026lt;string\u0026gt; int main() { string str1 = \u0026#34;hello\u0026#34;; string str2 = \u0026#34;world\u0026#34;; string str3; int len; // 复制 str3 = str1; cout \u0026lt;\u0026lt; \u0026#34;str3: \u0026#34; \u0026lt;\u0026lt; str3 \u0026lt;\u0026lt; endl; // 连接 str3 = str1 + str2; cout \u0026lt;\u0026lt; \u0026#34;str3: \u0026#34; \u0026lt;\u0026lt; str3 \u0026lt;\u0026lt; endl; // 长度 len = str3.size(); cout \u0026lt;\u0026lt; \u0026#34;str3 size(): \u0026#34; \u0026lt;\u0026lt; len \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://AlfredNing.github.io/note/program/game/c++/c++%E5%9F%BA%E7%A1%802/","summary":"c++运算符 算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 杂项运算符 算术运算符 假设变量 A 的值为 10，变量 B 的值为 20，则：\n运算符 描述 实例 + 把两个操作数相加 A + B 将得到 30 - 从第一个操作数中减去第二个操作数 A - B 将得到 -10 * 把两个操作数相乘 A * B 将得到 200 / 分子除以分母 B / A 将得到 2 % 取模运算符，整除后的余数 B % A 将得到 0 ++ 自增运算符，整数值增加 1 A++ 将得到 11 \u0026ndash; 自减运算符，整数值减少 1 A\u0026ndash; 将得到 9 关系运算符 假设变量 A 的值为 10，变量 B 的值为 20，则：","title":"C++基础2"},{"content":"简介 C++一种静态类型、编译式、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。\nc++是一门中级语言，综合高级语言和低级语言的特点。\nC++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。\n静态类型的编程语言都是在编译时候执行类型检查，而不是在运行时候执行类型检查\n面向对象四大特点 封装 继承 抽象 多态 开发工具，window使用Visual Studio\n对象 - 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。 类 - 类可以定义为描述对象行为/状态的模板/蓝图。 方法 - 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。 即时变量 - 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。 程序结构 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello, world!\u0026#34; \u0026lt;\u0026lt; endl; return 0; } g++ hello.cpp$ ./a.outHello Wo 头文件：包含程序必须的或有用的信息 命名空间 main 函数程序开始 分号是语句结束符，每个语句必须以分号结束。c++不以行末作为结束符，一行可以放置多个语句 块是一组使用大括号括起来的按逻辑连接的语句 标识符 以字母A-Z或a-z或下划线_开始，后跟多个字母数字下划线\n关键字 asm else new this auto enum operator throw bool explicit private true break export protected try case extern public typedef catch false register typeid char float reinterpret_cast typename class for return union const friend short unsigned const_cast goto signed using continue if sizeof virtual default inline static void delete int static_cast volatile do long struct wchar_t double mutable switch while dynamic_cast namespace template 三字符组 用于表示另一个字符的三个字符系列，又称为三字符系列\n以两个问号开头 三字符序列不太常见，但 C++ 标准允许把某些字符指定为三字符序列。以前为了表示键盘上没有的字符，这是必不可少的一种方法。 三字符序列可以出现在任何地方，包括字符串、字符序列、注释和预处理指令 三字符组 替换 ??= # ??/ \\ ??' ^ ??( [ ??) ] ??! | ??\u0026lt; { ??\u0026gt; } ??- ~ 如果希望在源程序中有两个连续的问号，且不希望被预处理器替换，这种情况出现在字符常量、字符串字面值或者是程序注释中，可选办法是用字符串的自动连接：\u0026quot;\u0026hellip;?\u0026quot;\u0026quot;?\u0026hellip;\u0026ldquo;或者转义序列：\u0026rdquo;\u0026hellip;??\u0026hellip;\u0026quot;。 从Microsoft Visual C++ 2010版开始，该编译器默认不再自动替换三字符组。如果需要使用三字符组替换（如为了兼容古老的软件代码），需要设置编译器命令行选项/Zc:trigraphs、 g++仍默认支持三字符组，但会给出编译警告 空格 只包含空格的行，被称为空白行，可能带有注释，C++ 编译器会完全忽略它\n注释 单行注释：// 或者 /**/ 多行注释: /**/ 在 /* 和 / 注释内部，// 字符没有特殊的含义 数据类型 变量保留是所存储的值的内存地址，当创建一个变量，就会在内存中保留一些空间。\n七种基本的 C++ 基本内置数据类型 类型 关键字 类型 关键字 布尔型 bool 字符型 char 整型 int 浮点型 float 双浮点型 double 无类型 void 宽字符型 wchar_t 类型修饰符\nsigned unsigned short long 类型 位 范围 char 1 个字节 -128 到 127 或者 0 到 255 unsigned char 1 个字节 0 到 255 signed char 1 个字节 -128 到 127 int 4 个字节 -2147483648 到 2147483647 unsigned int 4 个字节 0 到 4294967295 signed int 4 个字节 -2147483648 到 2147483647 short int 2 个字节 -32768 到 32767 unsigned short int 2 个字节 0 到 65,535 signed short int 2 个字节 -32768 到 32767 long int 8 个字节 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 signed long int 8 个字节 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 unsigned long int 8 个字节 0 to 18,446,744,073,709,551,615 float 4 个字节 +/- 3.4e +/- 38 (~7 个数字) double 8 个字节 +/- 1.7e +/- 308 (~15 个数字) long double 8 个字节 +/- 1.7e +/- 308 (~15 个数字) wchar_t 2 或 4 个字节 1 个宽字符 #include \u0026lt;iostream\u0026gt; using namespace std; int main(){ cout \u0026lt;\u0026lt; \u0026#34;Size of char : \u0026#34; \u0026lt;\u0026lt; sizeof(char) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Size of int : \u0026#34; \u0026lt;\u0026lt; sizeof(int) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Size of short int : \u0026#34; \u0026lt;\u0026lt; sizeof(short int) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Size of long int : \u0026#34; \u0026lt;\u0026lt; sizeof(long int) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Size of float : \u0026#34; \u0026lt;\u0026lt; sizeof(float) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Size of double : \u0026#34; \u0026lt;\u0026lt; sizeof(double) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Size of wchar_t : \u0026#34; \u0026lt;\u0026lt; sizeof(wchar_t) \u0026lt;\u0026lt; endl; return 0; } // 结果会根据所使用的计算机而有所不同 typedef of 声明 为已有的类型取一个新名字\n#include \u0026lt;iostream\u0026gt; using namespace std; typedef int a; int main(){ a b = 10; cout \u0026lt;\u0026lt; b; return 0; } 枚举类型 派生数据类型，由用户定义的若干枚举常量的集合\nenum enum-name { list of names } var-list;\n#include \u0026lt;iostream\u0026gt; using namespace std; typedef int a; int main(){ // 默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推 enum color { red, blue, green } c ; c = blue; cout \u0026lt;\u0026lt; c; // 以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，green 的值为 5。 enum color { red, green = 5, blue }; return 0; } 变量类型 变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C++ 是大小写敏感的。\n前面的基本数据类型\n类型 描述 bool 存储值 true 或 false。 char 通常是一个八位字节（一个字节）。这是一个整数类型。 int 对机器而言，整数的最自然的大小。 float 单精度浮点值。 double 双精度浮点值。 void 表示类型的缺失。 wchar_t 宽字符类型。 c++ 也允许定义各种其他类型的变量，比如枚举、指针、数组、引用、数据结构、类等等\n变声类型 变量名\n声明的时候被初始化。\n不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。\n变量声明 变量声明保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。\n使用多个文件只在其中一个文件定义变量\nextern 关键字在任何地方声明一个变量。可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次\n#include \u0026lt;iostream\u0026gt; using namespace std; extern int a, b;extern int c; extern float f; int func(); // 函数声明 int main(){ // 变量定义 int a, b; int c; float f; // 实际初始化 a = 10; b = 20; c = a + b; cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; f = 70.0 / 3.0; cout \u0026lt;\u0026lt; f \u0026lt;\u0026lt; endl; return 0; } 左值和右值 左值：指向内存位置的表达式被称为左值(lvalue)表达式。左值可以出现在赋值号的左边或右边。\n右值：指存储在内存某些地址的数值。右值是不能对其进行赋值的表达式。右值只能出现在赋值号的右边\n变量作用域 一般有三个地方可以声明变量\n函数或一个代码块中，称为局部变量 在函数参数的定义中声明的变量，称为形式参数 在所有函数外部声明的变量，成为全局变量 #include \u0026lt;iostream\u0026gt; using namespace std; // 全局变量声明 int g; int gg = 100; int main(){ // 局部变量声明 int a, b; int c; // 实际初始化 a = 10; b = 20; c = a + b; cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; // 全局变量初始 g = 100; cout \u0026lt;\u0026lt; g \u0026lt;\u0026lt; endl; // 同名变量，局部覆盖全局变量 int gg = 300; cout \u0026lt;\u0026lt; gg \u0026lt;\u0026lt; endl; return 0; } 当局部变量被定义时，系统不会对其初始化，必须自行对其初始化。定义全局变量时，系统会自动初始化为下列值\n数据类型 初始化默认值 int 0 char \u0026lsquo;\\0\u0026rsquo; float 0 double 0 pointer NULL 正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果\n常量 常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量\n常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值\n常量的值在定义后不能更改\n整数常量 整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。\n整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意\n浮点常量 浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。\n当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的\n.14159 // 合法的 314159E-5L // 合法的 510E // 非法的：不完整的指数210f 布尔常量 true false 不要把 true 的值看成 1，把 false 的值看成 0\n字符常量 字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L\u0026rsquo;x\u0026rsquo;），此时它必须存储在 wchar_t 类型的变量中。否则，它就是一个窄字符常量（例如 \u0026lsquo;x\u0026rsquo;），此时它可以存储在 char 类型的简单变量中。\n字符常量可以是一个普通的字符（例如 \u0026lsquo;x\u0026rsquo;）、一个转义序列（例如 \u0026lsquo;\\t\u0026rsquo;），或一个通用的字符（例如 \u0026lsquo;\\u02C0\u0026rsquo;）\n有反斜杠时，它们就具有特殊的含义\n转义序列码\n转义序列 含义 \\ \\ 字符 ' \u0026rsquo; 字符 \u0026quot; \u0026quot; 字符 ? ? 字符 \\a 警报铃声 \\b 退格键 \\f 换页符 \\n 换行符 \\r 回车 \\t 水平制表符 \\v 垂直制表符 \\ooo 一到三位的八进制数 \\xhh . . . 一个或多个数字的十六进制数 字符串常量 符串字面值或常量是括在双引号 \u0026quot;\u0026quot; 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。\n定义常量 #define 预处理器 #include \u0026lt;iostream\u0026gt; using namespace std; #define WIDTH 5 #define LENGTH 10 #define NEWLINE \u0026#39;\\n\u0026#39; int main(){ cout \u0026lt;\u0026lt; WIDTH \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; LENGTH \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; NEWLINE \u0026lt;\u0026lt; endl; return 0; } const 关键字 #include \u0026lt;iostream\u0026gt; using namespace std; int main(){ const int WIDTH = 5; const int LENGTH = 10; const char NEWLINE = \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; WIDTH \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; LENGTH \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; NEWLINE \u0026lt;\u0026lt; endl; return 0; } 修饰符类型 C++ 允许在 char、int 和 double 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。\n下面列出了数据类型修饰符：\nsigned unsigned long short 修饰符 signed、unsigned、long 和 short 可应用于整型，signed 和 unsigned 可应用于字符型，long 可应用于双精度型。\n修饰符 signed 和 unsigned 也可以作为 long 或 short 修饰符的前缀。例如：unsigned long int。\nC++ 允许使用速记符号来声明无符号短整数或无符号长整数。您可以不写 int，只写单词 unsigned、short 或 unsigned、long，int 是隐含的。例如，下面的两个语句都声明了无符号整型变量。\nunsigned x; unsigned int y;\t类型限定符 给变量设置额外信息\n限定符 含义 const const 类型的对象在程序执行期间不能被修改改变。 volatile 修饰符 volatile 告诉编译器，变量的值可能以程序未明确指定的方式被改变。 restrict 由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。 存储类 作用：定义c++程序中变量/函数的范围（可见性）和声明周期。放置在修饰的类型之前\nauto register static extern mutable thread_local (C++11) 从 C++ 11 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用\nauto存储类 自 C++ 11 以来，auto 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。\nC++98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在C++11中已删除这一用法\nregister 存储类 用于定义存储在寄存器而不是RAM中的局部变量\n最大尺寸等于寄存器的大小，且不能应用一元运算符\u0026amp;， 因为它没有内存位置 寄存器只用于需要快速访问的变量，比如计数器。 不是一味的意味着变量存储到寄存器中，可能意味着存储到寄存器当中，取决于硬件和实现的限制 static存储类 作用：指示编译器在程序的声明周期内保持局部变量的存在，而不需要每次进入和离开作用域时候进行创建和销毁\n利用static变量修饰局部变量可以在函数调用中保持局部变量的值 修饰全局变量，使变量的作用域限定在声明的文件内 作用在类数据成员上，会导致仅有一个该成员的副本被类的所有对象共享 #include \u0026lt;iostream\u0026gt; // 函数声明 void func(void); // 全局静态变量 static int count = 10; int main(){ while (count--) { func(); } return 0; } void func(void) { // 局部静态变量 static int i = 5; i++; std::cout \u0026lt;\u0026lt; \u0026#34;变量i为 \u0026#34; \u0026lt;\u0026lt; i; std::cout \u0026lt;\u0026lt; \u0026#34;变量count为 \u0026#34; \u0026lt;\u0026lt; count \u0026lt;\u0026lt; std::endl; } extern存储类 提供一个全局变量的引用，全局变量对所有程序的文件都是可见的。当使用 \u0026rsquo;extern\u0026rsquo; 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。\n用来在另一个文件中声明一个全局变量或函数\nextern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候\n// t1.cpp #include \u0026lt;iostream\u0026gt; extern int count; void write_externx(void) { // Count is 5 std::cout \u0026lt;\u0026lt; \u0026#34;Count is \u0026#34; \u0026lt;\u0026lt; count \u0026lt;\u0026lt; std::endl; } // main.cpp #include \u0026lt;iostream\u0026gt; int count; extern void write_externx(); int main() { count = 5; write_externx(); return 0; } mutable存储类 只适用于类的对象，允许对象的成员替代常量。mutable 成员可以通过 const 成员函数修改\nthread_local 存储类 声明的变量仅可在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。\nthread_local 说明符可以与 static 或 extern 合并。\n可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。\nthread_local int x; // 命名空间下的全局变量 class X{ static thread_local std::string s; // 类的static成员变量 }; static thread_local std::string X::s; // X::s 是需要定义的 void foo(){ thread_local std::vector\u0026lt;int\u0026gt; v; // 本地变量 } ","permalink":"https://AlfredNing.github.io/note/program/game/c++/c++%E5%9F%BA%E7%A1%801/","summary":"简介 C++一种静态类型、编译式、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。\nc++是一门中级语言，综合高级语言和低级语言的特点。\nC++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。\n静态类型的编程语言都是在编译时候执行类型检查，而不是在运行时候执行类型检查\n面向对象四大特点 封装 继承 抽象 多态 开发工具，window使用Visual Studio\n对象 - 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。 类 - 类可以定义为描述对象行为/状态的模板/蓝图。 方法 - 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。 即时变量 - 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。 程序结构 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello, world!\u0026#34; \u0026lt;\u0026lt; endl; return 0; } g++ hello.cpp$ ./a.outHello Wo 头文件：包含程序必须的或有用的信息 命名空间 main 函数程序开始 分号是语句结束符，每个语句必须以分号结束。c++不以行末作为结束符，一行可以放置多个语句 块是一组使用大括号括起来的按逻辑连接的语句 标识符 以字母A-Z或a-z或下划线_开始，后跟多个字母数字下划线\n关键字 asm else new this auto enum operator throw bool explicit private true break export protected try case extern public typedef catch false register typeid char float reinterpret_cast typename class for return union const friend short unsigned const_cast goto signed using continue if sizeof virtual default inline static void delete int static_cast volatile do long struct wchar_t double mutable switch while dynamic_cast namespace template 三字符组 用于表示另一个字符的三个字符系列，又称为三字符系列","title":"C++初始"},{"content":"jvm内存结构图\n哪些内存结构与线程意义对应，其实问的是线程共有和私有 共有： 堆和方法区 私有： 本地方法栈、虚拟机栈、程序计数器\n程序计数器 保证程序在程序系统中能够执行下去，CPU必须具有某些手段来确定下一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器 一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器。 在程序开始执行前，必须将它的起始地址，即程序的一条指令所在的内存单元地址送入PC，因此程序计数器（PC）的内容即是从内存提取的第一条指令的地址。当执行指令时，CPU将自动修改PC的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数，以便使其保持的总是将要执行的下一条指令的地址 由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单的对PC加1 当程序转移时，转移指令执行的最终结果就是要改变PC的值，此PC值就是转去的地址，以此实现转移。有些机器中也称PC为指令指针IP（Instruction Pointer） 特征 JVM中的程序计数寄存器（Program Counter Register）中， Register 的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。 CPU只有把数据装载到寄存器才能够运行。\nJVM中的PC寄存器是对物理PC寄存器的一种抽象模拟\n很小的内存结构，忽略不计，也是运行最快的存储区域，不会随着程序的运行需要更大的空间 在JVM规范中，每个线程都有自己的程序计数器，是线程私有的，生命周期与线程生命周期保持一致 它是唯一一个在JVM虚拟机规范中没有规定任何OutOtMemoryError 情况的区域 问题 为什么使用PC寄存器来记录当前线程的执行地址 因为CPU需要不停的切换各个线程，准确知道执行的位置。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令 PC寄存器为什么被设置为线程私有 多线程在一个特定的时间段内之会执行某一个线程的方法，CPU需要不停的做任务切换**。为了准确记录各个线程正在执行的当前字节码指令，最好的办法就是为每一个线程分配PC寄存器**，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况 虚拟机栈 栈管运行，堆管内存\n栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿\nJava虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。 是线程私有的 生命周期: 生命周期和线程一致。\n特点: 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。\n栈是否有GC？ 不存在GC, 但有OOM\n抛出的异常：\nStackOverFlowError OutOfMemoryError Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个 StackOverflowError 异常 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出—个 OutOfMemoryError 异常 设置栈大小 -Xsssize (即：-XX:ThreadStackSize)\n一般为：512k-1M 栈的大小直接决定了函数调用的最大深度 设置的栈空间值过大，会导致系统可以用于创建线程的数量减少 一般一个进程中通常有3000-5000个线程\njdk5.0之前，默认为256k jdk5.0之后，默认为1024k\n栈帧 栈的基本单位是栈帧，每个线程都有自己的栈，栈中的数据都是以栈帧存在的。\n方法与栈帧的关系 在这个线程执行的方法都有一个栈帧 栈帧是一个内存区块，是一个数据集，维护着方法执行过程中的各种数据信息 栈的内部结构 局部变量表 操作数栈或表达式栈 动态链接或指向运行时常量池的方法引用 方法返回地址（或方法正常退出或者异常退出的定义） 一些附加信息 局部变量表 - Local Varibales 局部变量表被称为局部变量数组或者本地变量表 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，数据类别包括：基本数据类型，对象引用、以returnAddress类型 局部变量表的大小是在编译器确定，保存在方法的code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的 方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减 **局部变量表的变量只在当前方法调用中有效。**在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。 静态变量与局部变量区别 类变量表有两次初始化的机会，第一次准备阶段，执行系统初始化，赋零值，另一次是在初始化阶段，赋予代码中指定的初始值 和类变量初始化不同，局部变量表不存在系统初始化的过程，一旦定义了局部变量则必须人为的初始化，否则无法使用 与GC ROOTS的关系 局部变量表的变量也是重要的垃圾回收节点，只要被局部变量中直接或者间接引用的对象都不会被回收\n操作数栈 Operand Stack 操作数栈（Operand Stack）\n我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。\n每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出（Last-In-First-Out）的操作数栈，也可以称之为表达式栈（Expression Stack）。\n操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。\n每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值。\n栈中的任何一个元素都是可以任意的Java数据类型。\n32bit的类型占用一个栈单位深度\n64bit的类型占用两个栈单位深度\n操作数栈，在方法执行过程中，根据字节码指令，并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈（push）和出栈（pop）操作，往栈中写入数据或提取数据来完成一次数据访问。\n某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。比如：执行复制、交换、求和等操作\n如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。\n栈顶缓存 由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（ToS，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。\n动态链接（或指向运行时常量池的方法引用） 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic指令 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。 常量池的作用 常量池的作用，就是为了提供一些符号和常量，便于指令的识别。\n方法返回地址 存放调用该方法的pc寄存器的值。\n一个方法的结束，有两种方式：\n正常执行完成\n出现未处理的异常，非正常退出\n无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。\n本地方法与本地方法栈 本地方法 简单地讲，一个Native Method就是一个Java调用非Java代码的接口。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern \u0026ldquo;C\u0026quot;告知C++编译器去调用一个C的函数。\n\u0026ldquo;A native method is a Java method whose implementation is provided by non-java code.\u0026rdquo;\n在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。\n本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合 C/C++程序。\n本地方法栈 Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。 本地方法栈，也是线程私有的。 允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的） 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个 StackOverflowError 异常。 如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个 OutOfMemoryError 异常。 本地方法是使用C语言实现的。 它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。 堆 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。\nJava 堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。\n堆内存的大小是可以调节的。\n《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。\n堆，是GC ( Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。\n在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。\n对象都分配在堆上？\n《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated ) 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置 “几乎”所有的对象实例都在这里分配内存。——从实际使用角度看的。TLAB的存在 TLAB Thread Local Allocation Buffer\n堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。 所以，多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。\n堆的内部结构\n现代垃圾收集器大部分都基于分代收集理论设计。\nJava 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区 Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区 Tenure generation space 养老区 Old/Tenure Permanent Space 永久区 Perm Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间 Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区 Tenure generation space 养老区 Old/Tenure Meta Space 元空间 Meta 年轻代与老年代 存储在JVM中的Java对象可以被划分为两类： 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。 Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（OldGen） 其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）。 几乎所有的Java对象都是在Eden区被new出来的。 绝大部分的Java对象的销毁都在新生代进行了。 IBM 公司的专门研究表明，新生代中 80% 的对象都是“朝生夕死”的。 设置堆内存 设置新生代与老年代的比例 配置新生代与老年代在堆结构的占比。 默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3 可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5 可以使用选项”-Xmn”设置新生代最大内存大小 这个参数一般使用默认值就可以了。\n设置Eden 与Suvivor比例 在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1 可以通过选项“-XX:SurvivorRatio”调整这个空间比例。比如**-XX:SurvivorRatio=8** 参数设置 堆空间大小的设置 -Xms:初始内存 （默认为物理内存的1/64） -Xmx:最大内存（默认为物理内存的1/4） 新生代大小设置 -Xmn\n设置新生代的大小。(初始值及最大值) 通常默认即可。\n设置新生代垃圾的最大年龄。超过此值，仍未被回收的话，则进入老年代 默认值为15 -XX:MaxTenuringThreshold=0：表示年轻代对象不经过Survivor区，直接进入老年代。对于老年代比较多的应用，可以提高效率。 如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代的存活时间，增加在年轻代即被回收的概率 输出详细的GC处理日志 -XX:+PrintGCDetails\n在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间 -XX:HandlePromotionFailure\n如果大于，则此次Minor GC是安全的 如果小于，则虚拟机会查看-XX:HandlePromotionFailure设置值是否允许担保失败。 如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于或者HandlePromotionFailure=false，则改为进行一次Full GC。 查看所有的参数的最终值 -XX:+PrintFlagsFinal\n具体查看某个参数的指令： jps：查看当前运行中的进程 jinfo -flag SurvivorRatio 进程id -Xms60m -Xmx60m -XX:NewRatio=2 -XX:SurvivorRatio=8 -XX:+PrintGCDetails 对象分配过程 1.new的对象先放伊甸园区。此区有大小限制。\n2.当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC/YGC)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区\n3.然后将伊甸园中的剩余对象移动到幸存者0区。\n4.如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。\n5.如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。\n6.啥时候能去养老区呢？可以设置次数。默认是15次。\n可以设置参数：-XX:MaxTenuringThreshold= 设置对象晋升老年代的年龄阈值。 7.在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理。\n8.若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生OOM异常 java.lang.OutOfMemoryError: Java heap space\n分配策略 内存分配策略（或对象提升(promotion)规则):\n如果对象在Eden 出生并经过第一次MinorGC 后仍然存活，并且能被Survivor 容纳的话，将被移动到Survivor 空间中，并将对象年龄设为1 。对象在Survivor 区中每熬过一次MinorGC ， 年龄就增加1岁，当它的年龄增加到一定程度（默认为15 岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代中。\n内存分配原则 针对不同年龄段的对象分配原则如下所示：\n优先分配到Eden 大对象直接分配到老年代 尽量避免程序中出现过多的大对象 长期存活的对象分配到老年代 动态对象年龄判断 如果Survivor 区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。 空间分配担保 -XX:HandlePromotionFailure GC详情 Minor GC / Major GC /FULL GC\n按照GC回收区域划分 部分收集 Partial GC 整堆收集 Full GC MinorGC 触发机制 年轻代空间不足，这里的年轻代指的是Eden满，Survivor满不会引发GC 因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快 Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行 MajorGC 触发机制 发生在老年代的GC 出现了MajorGC 常常伴随着至少一次的MinorGC,但不一定是绝对的。Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程 在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC。 Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。 如果Major GC 后，内存还不足，就报OOM了。 FullGC 触发机制 调用System.gc(), 建议系统执行，取决于系统 老年代空间不足 方法区空间不足 通过MinorGc进入老年代的平均大小大于老年代的可用内存 由Eden区、Surviror From区向Survivor To区复制,，对象大于Survivor To可用内存。则把该对象转存到老年代，且老年代的可用内存小于该对象大小 full gc是开发或调优中尽量要避免的。这样暂时时间会短一些。\nOOM如何解决 首先通过内存映像分析工具对dump出来的堆转储快照进行分析，重点确认堆内存的对象是否是必要的。是出现了内存泄露还是内存溢出 如果是内存泄露，进一步通过工具查看泄露对象到GC roots的引用链。就能找到泄漏对象是通过怎样的路径与GC Roots 相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots 引用链的信息，就可以比较准确地定位出泄漏代码的位置。 如果不存在内存泄露。内存中的对象都还必须存活。检查虚拟机参数。与物理机内存比对是否可以调大。从代码上检查是否存在某些对象生命周期过长，持有时间过长的情况，尝试减少程序运行期的内存消耗 堆空间分代思想 经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。\n新生代：有Eden、两块大小相同的Survivor(又称为from/to，s0/s1)构成，to总为空。 老年代：存放新生代中经历多次GC仍然存活的对象。 JDK7:\nJDK8：\n为什么要分代 不分代也可以，分代的唯一理由是优化GC性能。如果没有分代的话，所有的对象都在一块。GC要找到哪些对象没有用的话，就需要对堆所有的区域进行扫描。而很多东西都是朝生夕死。如果分代的话，把新建的对象放在某一个地方，需要gc的时候，先将这块区域进行回收，腾出很大的空间。\nTLAB Thread Local Allocation Buffer\n从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。 所有OpenJDK衍生出来的JVM都提供了TLAB的设计。 为什么有TLAB？\n堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。 所以，多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。\nTLAB 参数设置 尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。 在程序中，开发人员可以通过选项“-XX:+/-UseTLAB”设置是否开启TLAB空间。 默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项“-XX:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。 一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存 方法区 堆、栈、方法区的关系 方法区的位置 \u0026lt;Java虚拟机规范\u0026gt;中说明所有的方法区在逻辑上是属于堆的一部分。对于HotSpotJVM而言，方法区有一个别名叫做no heap,目的是和堆分开\n将方法区看做是独立于Java堆得内存空间\n方法区的理解 共享：方法区与堆都是各个线程共享的内存区域 方法区在JVM启动的时候创建，实际的物理内存空间和Java堆一样可以是不连续的 方法区的大小，可以选择固定大小或者动态扩展 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutOfMemoryError: PermGen space 或者 java.lang.OutOfMemoryError: Metaspace 加载大量的第三方的jar包；Tomcat部署的工程过多（30-50个）；大量动态的生成反射类 关闭JVM就会释放这个区域的内存。 HotSpot方法区的演进 jdk7及以前，成为永久代。jdk8开始，使用元空间替换永久代\n本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEA JRockit/ IBM J9中不存在永久代的概念。\n元空间本质和永久代类似，都是JVM规范中方法区的实现。区别在于：元空间不在虚拟机设置的内存，而是使用本地内存。\n永久代、元空间二者并不只是名字变了，内部结构也调整了。\n根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常\n方法区常用参数 jdk1.7之前 通过-XX: PermSize来设置永久代初始分配空间。默认值是20.75M -XX:MaxPermSize来设置永久代最大可分配空间。32位机制默认是64M, 64位机制默认是82M 当JVM加载的类信息容量超过了这个值，会报异常OutOfMemoryError:PermGen space jdk1.8之后 元数据区大小可以使用参数**-XX:MetaspaceSize和-XX:MaxMetaspaceSize**指定,替代上述原有的两个参数 默认值依赖于平台。windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize 的值是-1，即没有限制。 默认情况下，如果不指定大小，会耗尽所有的可用系统内存。如果元空间区域发生溢出，虚拟机也会抛出常OutOfMemoryError: Metaspace -XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-XX:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。 如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC ，建议将-XX:MetaspaceSize设置为一个相对较高的值 方法区的信息 类信息 对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：\n① 这个类型的完整有效名称（全名=包名.类名）\n② 这个类型直接父类的完整有效名(对于interface或是java.lang.Object，都没有父类)\n③ 这个类型的修饰符(public,abstract, final的某个子集)\n④ 这个类型直接接口的一个有序列表\n域Field信息 JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。\n域的相关信息包括： 域名称、域类型、域修饰符(public, private, protected, static, final, volatile, transient的某个子集)\n方法信息 JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序 ：\n方法名称 方法的返回类型(或 void) 方法参数的数量和类型(按顺序) 方法的修饰符(public, private, protected, static, final, synchronized, native, abstract的一个子集) 方法的字节码(bytecodes)、操作数栈、局部变量表及大小 （abstract和native方法除外） 异常表（abstract和native方法除外） 每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引 not- final的类变量 静态变量和类关联在一起，随着类的加载而加载,它们成为类数据在逻辑上的一部分。 类变量被类的所有实例共享，即使没有类实例时你也可以访问它。 全局常量：static final。被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。 运行时常量池 运行时常量池（Runtime Constant Pool）是方法区的一部分。 常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。 JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。 运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。 运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。 String.intern() 运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些。 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutOfMemoryError异常。 永久代与元空间 只有HotSpot才有永久代\nHotSpot中永久代的变化\njdk1.6及之前：有永久代(permanent generation)\njdk1.7：有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中\njdk1.8及之后： 无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池仍在堆\n永久代被替换的原因 永久代设置空间大小很难确定。在某些场景下，如果动态加载类过多，容易产生Perm 区的OOM 。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。 而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。 对永久代很难调优 StringTable为什么需要调整 jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而full gc是老年代的空间不足、永久代不足时才会触发。\n这就导致StringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。\n静态变量存放 JDK 7及其以后版本的HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射Class对象存放在一起\n方法区是否存在GC 有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK 11时期的ZGC收集器就不支持类卸载）。\n一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。\n方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。\n先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：\n1、类和接口的全限定名\n2、字段的名称和描述符\n3、方法的名称和描述符\nHotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。\n回收废弃常量与回收Java堆中的对象非常类似。\n判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：\n该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。\n加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。\n该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\nJava虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class以及-XX:+TraceClassLoading -XX:+TraceClassUnloading查看类加载和卸载信息\n在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。\n","permalink":"https://AlfredNing.github.io/note/program/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98/","summary":"jvm内存结构图\n哪些内存结构与线程意义对应，其实问的是线程共有和私有 共有： 堆和方法区 私有： 本地方法栈、虚拟机栈、程序计数器\n程序计数器 保证程序在程序系统中能够执行下去，CPU必须具有某些手段来确定下一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器 一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器。 在程序开始执行前，必须将它的起始地址，即程序的一条指令所在的内存单元地址送入PC，因此程序计数器（PC）的内容即是从内存提取的第一条指令的地址。当执行指令时，CPU将自动修改PC的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数，以便使其保持的总是将要执行的下一条指令的地址 由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单的对PC加1 当程序转移时，转移指令执行的最终结果就是要改变PC的值，此PC值就是转去的地址，以此实现转移。有些机器中也称PC为指令指针IP（Instruction Pointer） 特征 JVM中的程序计数寄存器（Program Counter Register）中， Register 的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。 CPU只有把数据装载到寄存器才能够运行。\nJVM中的PC寄存器是对物理PC寄存器的一种抽象模拟\n很小的内存结构，忽略不计，也是运行最快的存储区域，不会随着程序的运行需要更大的空间 在JVM规范中，每个线程都有自己的程序计数器，是线程私有的，生命周期与线程生命周期保持一致 它是唯一一个在JVM虚拟机规范中没有规定任何OutOtMemoryError 情况的区域 问题 为什么使用PC寄存器来记录当前线程的执行地址 因为CPU需要不停的切换各个线程，准确知道执行的位置。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令 PC寄存器为什么被设置为线程私有 多线程在一个特定的时间段内之会执行某一个线程的方法，CPU需要不停的做任务切换**。为了准确记录各个线程正在执行的当前字节码指令，最好的办法就是为每一个线程分配PC寄存器**，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况 虚拟机栈 栈管运行，堆管内存\n栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿\nJava虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。 是线程私有的 生命周期: 生命周期和线程一致。\n特点: 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。\n栈是否有GC？ 不存在GC, 但有OOM\n抛出的异常：\nStackOverFlowError OutOfMemoryError Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个 StackOverflowError 异常 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出—个 OutOfMemoryError 异常 设置栈大小 -Xsssize (即：-XX:ThreadStackSize)\n一般为：512k-1M 栈的大小直接决定了函数调用的最大深度 设置的栈空间值过大，会导致系统可以用于创建线程的数量减少 一般一个进程中通常有3000-5000个线程\njdk5.0之前，默认为256k jdk5.0之后，默认为1024k\n栈帧 栈的基本单位是栈帧，每个线程都有自己的栈，栈中的数据都是以栈帧存在的。\n方法与栈帧的关系 在这个线程执行的方法都有一个栈帧 栈帧是一个内存区块，是一个数据集，维护着方法执行过程中的各种数据信息 栈的内部结构 局部变量表 操作数栈或表达式栈 动态链接或指向运行时常量池的方法引用 方法返回地址（或方法正常退出或者异常退出的定义） 一些附加信息 局部变量表 - Local Varibales 局部变量表被称为局部变量数组或者本地变量表 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，数据类别包括：基本数据类型，对象引用、以returnAddress类型 局部变量表的大小是在编译器确定，保存在方法的code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的 方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减 **局部变量表的变量只在当前方法调用中有效。**在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。 静态变量与局部变量区别 类变量表有两次初始化的机会，第一次准备阶段，执行系统初始化，赋零值，另一次是在初始化阶段，赋予代码中指定的初始值 和类变量初始化不同，局部变量表不存在系统初始化的过程，一旦定义了局部变量则必须人为的初始化，否则无法使用 与GC ROOTS的关系 局部变量表的变量也是重要的垃圾回收节点，只要被局部变量中直接或者间接引用的对象都不会被回收","title":"运行时内存"},{"content":"类的加载过程 Java数据类型分为数据基本数据类型和引用数据类型\n基本类型由虚拟机预先定义，引用类型需要进行类的加载\n类的加载大过程分为三步, 总过程七步\n装载 将java的class文件加载到机器内存，并在内存中构建出Java类的原型-类模板对象\n查找类的二进制文件，生成class实例\n加载类，需要完成以下三件事情：\n通过类的全名，获取类的二进制数据流 解析类的二进制数据流转换为方法区的数据结构(Java类模型) 创建java.lang.class类的实例，表示该类型 类模板对象 Java类在内存中的一个快照，JVM从字节码文件解析出来的常量池、类字段、类方法等类信息存储到类模板中。在运行期通过类模板获取Java类的任意信息，能够对Java类的成员变量进行遍历，进行方法调用。反射机制也是基于此，如果没有存储Java类的声明信息，JVM在运行期也无法进行反射\n获取二进制数据流 class字节码文件符号JVM规范\n通过读取class后缀的文件 读入jar、zip等归档数据包，提取类文件(热部署jar包原理基础) 事先存放在数据库的二进制数据 使用类型Http之类的协议通过网络进行加载 在运行时生成一段class的二进制信息等 class实例位置 类将.class文件加载至元空间后，会在堆中创建一个Java.lang.Class对象，用来封装类位于方法区内的数据结构，该Class对象是在加载类的过程中创建的，每个类都对应有一个Class类型的对象 数组类的加载 数组类本身不是由类加载器负责创建，而是由JVM在运行时根据需要去创建。加载器只负责加载数据元素的数据类型(基本数据类型和引用数据类型)，申请内存分配长度\n链接 验证阶段 保证加载的字节码是合法、合理并符合jvm规范\n格式验证回合装载阶段一起执行。验证通过之后，类加载器才会把验证成功的二级制数据信息加载到方法区中 格式验证之外的验证操作都在方法区中进行 准备阶段 为类的静态变量分配内存，并将其初始化为默认值。\nJava并不支持boolean类型，对于boolean类型，内部实现是int,由于int的默认值是0,故对应的，boolean的默认值就是false\n解析阶段 将类、接口、自动和方法的符号引用转换为直接引用\n符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。比较容易理解的就是在Class类文件中，通过常量池进行了大量的符号引用。通过解析操作，符号引用就可以转化为目标方法在类中方法表的位置，从而使得方法被成功调用。\n解析就是将符号引用转换为直接引用。换言之，直接引用存在，一定存在符号引用，反之不然\nJava虚拟机规范并没有要求解析操作一定要按照顺序执行\n在HotSpot VM中，加载、验证、准备和初始化会按照顺序有条不紊地执行，但链接阶段中的解析操作往往会伴随着JVM在执行完初始化之后再执行\n初始化 为静态变量赋予正确的初始值\n开始执行java字节码，执行类的初始化方法\nclinit方法：该方法只能由JVM编译器生成，程序开发者无法自定义一个同名的方法，无法在java程序中调用该方法，该方法由java字节码组成 init方法：由类的静态成员变量赋值及其static语句块产生 clinit方法的生成 以下几种情况，不会生产clinit方法\n一个类中没有声明任何类变量，也没静态代码块 一个类中声明类变量，但没有明确使用类的初始化语句以及静态代码块进行初始化操作 一个类中包含static final 修饰的基本类型字段，这些类字段使用编译时常量表达式 clinit是由虚拟机保证在多线程环境下正确的加锁同步，是线程安全的。如果有很长的耗时操作，是会造成死锁的。\n类的加载 加载 = 装载 + 链接 + 初始化\nJava程序的主动使用\n主动使用的说明 Class只有在必须要首次使用的时候才会被装载，Java虚拟机不会无条件地装载Class类型。Java虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用。\n主动使用只有下列几种情况：（即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成。）\n当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化。\n当调用类的静态方法时，即当使用了字节码invokestatic指令。\n当使用类、接口的静态字段时(final修饰特殊考虑)，比如，使用getstatic或者putstatic指令。\n当使用java.lang.reflect包中的方法反射类的方法时。比如：Class.forName(\u0026ldquo;com.atguigu.java.Test\u0026rdquo;)\n当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。\n如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。\n当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。\n当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。（涉及解析REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄对应的类）\n被动使用的情况 除了以上的情况属于主动使用，其他的情况均属于被动使用。被动使用不会引起类的初始化。\n也就是说：并不是在代码中出现的类，就一定会被加载或者初始化。如果不符合主动使用的条件，类就不会初始化。\n当访问一个静态字段时，只有真正声明这个字段的类才会被初始化。 当通过子类引用父类的静态变量，不会导致子类初始化 通过数组定义类引用，不会触发此类的初始化\n引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了。\n调用ClassLoader类的loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化。\n被动的使用，意味着不需要执行初始化环节，意味着没有clinit方法的调用\n如果针对代码，设置参数-XX:+TraceClassLoading，可以追踪类的加载信息并打印出来\nClass.forName 与loadClass Clas.forName加载后执行到初始化阶段\nClass.getClassLoader#loadClass只会执行到装载阶段\n使用 在程序中访问和调用它的静态类成员信息\n卸载 类、类加载器和类的实例之间的引用关系 在类的加载器内部实现中，用一个集合来存放所加载类的引用。另一方面，一个class对象总是会引用它的类加载器，调用class对象的getClassLoader方法，就能够获取它的类加载器。由此可见，代表某个类的Class实例与其类的加载器之间为双向关联关系。 一个类的实例总是引用代表这个类的Class对象。在Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有的Java类都有一个静态属性class，它引用代表这个类的Class对象\n类卸载的时机 一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期\n当Sample类被加载、链接和初始化后，它的生命周期就开始了。当代表Sample类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，Sample类在方法区内的数据也会被卸载，从而结束Sample类的生命周期。\n例如：\nloader1变量和obj变量间接引用代表Sample类的Class对象，而objClass变量则直接引用它。\n如果程序运行过程中，将上图左侧三个引用变量都置为null，此时Sample对象结束生命周期，MyClassLoader对象结束生命周期，代表Sample类的Class对象也结束生命周期，Sample类在方法区内的二进制数据被卸载。\n当再次有需要时，会检查Sample类的Class对象是否存在，如果存在会直接使用，不再重新加载；如果不存在Sample类会被重新加载，在Java虚拟机的堆区会生成一个新的代表Sample类的Class实例(可以通过哈希码查看是否是同一个实例)\n类卸载在实际生产的情况 启动类加载器加载的类型在整个运行期间是不可能被卸载的(jvm和jls规范)\n被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到unreachable的可能性极小。\n被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景中(比如：很多时候用户在开发自定义类加载器实例的时候采用缓存的策略以提高系统性能)，被加载的类型在运行期间也是几乎不太可能被卸载的(至少卸载的时间是不确定的)。\n综合以上三点，一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的。同时我们可以看的出来，开发者在开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下，来实现系统中的特定功能。\n方法区的垃圾回收 回收内容：常量池中废弃常量和不在使用的类\nHotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收\n确定不在使用的类必须同时满足下面三个条件\n该类所有的实例都已经被回收。也就是Java堆中不存在该类及其任何派生子类的实例 加载该类的类加载器已经被回收。这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法 Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收\n类的加载器 作用 类加载器是JVM执行类加载机制的前提。\nClassLoader是Java的核心组件，所有的类都是通过ClassLoader来进行加载的，通过各种方式将class二进制信息数据流读入JVM内部，转换为一个与目标类对应的java.lang.class对象实例，然后交给Java虚拟机进行链接、初始化操作。 ClassLoader在整个装载阶段，只能影响到类的加载，而无法通过其改变类的链接、初始化过程。是否可以加载是由Execution Engine决定的\n显式加载与隐式加载 显式加载 指的是在代码中通过ClassLoader加载class\nClass.forName(name) this.getClass().getClassLoader().loadClass() 隐式加载 通过虚拟机自动加载到内存中，例如：加载一个class文件的时候，class文件中引用到了另一个class，则会进行隐式加载\n类加载机制的必要性 一般情况下，Java开发人员并不需要在程序中显式地使用类加载器，但是了解类加载器的加载机制却显得至关重要。从以下几个方面说：\n避免在开发中遇到 java.lang.ClassNotFoundException异常或java.lang.NoClassDefFoundError异常时，手足无措。只有了解类加载器的加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解决问题\n需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作时，就需要与类加载器打交道了。\n开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑。\n加载的类是否唯一 类的唯一性 对于任意一个类，都是由其类加载器和这个类本身一同确认是否在Java虚拟机的唯一性。每一个加载器都有独立类名称空间，比较两个类是否相等，只有在两个类是由同一个类加载器加载的前提下才有意义，否则，类加载器不相同的时候，这个两个类必不相等\n命名空间 每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成 在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类 在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类 在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本\n类加载机制的基本特征 双亲委派模型：不是所有的类都遵守这个模型，有的时候，引导类加载器需要去加载用户代码，比如JDK内部的ServiceProvider/ServiceLoader机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。例如，Java 中JNDI、JDBC、文件系统、Cipher等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器 可见性： 子类加载器可以访问父加载器加载的类型。但是，反过来不允许，如果允许的话，不能通过利用类的加载器机制实现容器的逻辑 唯一性：由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见。 类加载器的分类 其实分为两类：\n引导类加载器（Bootstrap ClassLoader): c/c++编写\n自定义类加载器（Use-Defined ClassLoader) ： java编写\n自定义类加载器的定义：从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。\n子父类加载器的关系 除了顶层的启动类加载器，其余的类加载器都有其自己的父类加载器 不同类加载器看似是继承关系，实际是包含关系，每个子类加载器包含父类加载器的引用 引导类加载器 - Bootstrap ClassLoader 这个类加载使用C/C++语言实现的，嵌套在JVM内部。 它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar或sun.boot.class.path路径下的内容）。用于提供JVM自身需要类。 并不继承自java.lang.ClassLoader，没有父加载器。 出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类 加载扩展类和应用程序类加载器，并指定为他们的父类加载器。 扩展类加载器-Extension ClassLoader Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。 继承于ClassLoader类 父类加载器为启动类加载器 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。 使用-XX:+TraceClassLoading参数得到\n应用程序类加载器【系统类加载器】-AppClassLoader java语言编写，由sun.misc.Launcher$AppClassLoader实现 继承于ClassLoader类 父类加载器为扩展类加载器 它负责加载环境变量classpath或系统属性 java.class.path 指定路径下的类库 应用程序中的类加载器默认是系统类加载器。 它是用户自定义类加载器的默认父加载器 通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器 用户自定义类加载器 在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式。 体现Java语言强大生命力和巨大魅力的关键因素之一便是,Java开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的JAR包，也可以是网络上的远程资源。 通过类加载器可以实现非常绝妙的插件机制，这方面的实际应用案例举不胜举。例如，著名的OSGI组件框架，再如Eclipse的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。 同时，自定义加载器能够实现应用隔离，例如 Tomcat，Spring等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C/C++程序要好太多，想不修改C/C++程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。 所有用户自定义类加载器通常需要继承于抽象类java.lang.ClassLoader。 说明：\n站在程序的角度看，引导类加载器与另外两种类加载器（系统类加载器和扩展类加载器）并不是同一个层次意义上的加载器，引导类加载器是使用C++语言编写而成的，而另外两种类加载器则是使用Java语言编写而成的。由于引导类加载器压根儿就不是一个Java类，因此在Java程序中只能打印出空值\n获取类加载器的方式 /** * @author Alfred.Ning * @since 2023年02月27日 16:55:00 */ public class Test01 { public static void main(String[] args) { // 获取系统类加载器 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); System.out.println(systemClassLoader); // 获取扩展类加载器 ClassLoader extClassLoader = systemClassLoader.getParent(); System.out.println(extClassLoader); // 试图获取类的引导器加载器 失败 ClassLoader bootStrapClassLoader = extClassLoader.getParent(); System.out.println(bootStrapClassLoader); try { ClassLoader classLoader = Class.forName(\u0026#34;java.lang.String\u0026#34;).getClassLoader(); System.out.println(classLoader); ClassLoader classLoader1 = Class.forName(\u0026#34;Test01\u0026#34;).getClassLoader(); System.out.println(classLoader1); // 关于数组的类型加载器与数组元素的类加载相同 String[] arrStr = new String[10]; System.out.println(arrStr.getClass().getClassLoader()); // null: 引导类加载器 Test01[] arrUserDefined = new Test01[10]; System.out.println(arrUserDefined.getClass().getClassLoader());// 系统加载器 int[] arrInt = new int[10]; System.out.println(arrInt.getClass().getClassLoader());// 引导类加载器 // 获取上下文类的加载器 System.out.println(Thread.currentThread().getContextClassLoader()); } catch (ClassNotFoundException e) { e.printStackTrace(); } } } 自定义类加载器 应用场景 常见的应用场景\n实现类似进程内隔离，类加载器实际上用作不同的命名空间，以提供类似容器、模块化的效果。例如，两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰。这个方面的集大成者是Java EE和OSGI、JPMS等框架。\n应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统。或者是需要自己操纵字节码，动态修改或者生成类型。\n注意： 在一般情况下，使用不同的类加载器去加载不同的功能模块，会提高应用程序的安全性。但是，如果涉及Java类型转换，则加载器反而容易产生不美好的事情。在做Java类型转换时，只有两个类型都是由同一个加载器所加载，才能进行类型转换，否则转换时会发生异常。\n代码实现 覆写findClass方式 import java.io.BufferedInputStream; import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.IOException; /** * @author Alfred.Ning * @since 2023年02月27日 17:39:00 */ public class MyClassLoader extends ClassLoader { private String rootPath; public MyClassLoader(String rootPath) { this.rootPath = rootPath; } @Override protected Class\u0026lt;?\u0026gt; findClass(String name) throws ClassNotFoundException { String filePath = classToFilePath(name); byte[] data = getBytesFromPath(filePath); // 自定义classLoader 内部调用defineClass return defineClass(name, data, 0, data.length); } private byte[] getBytesFromPath(String filePath) { try (FileInputStream fis = new FileInputStream(filePath); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ) { byte[] buffer = new byte[1024]; int len; while ((len = fis.read(buffer)) != -1) { baos.write(buffer, 0, len); } return baos.toByteArray(); } catch (IOException e) { e.printStackTrace(); } return null; } private String classToFilePath(String name) { return rootPath + \u0026#34;\\\\\u0026#34; + name.replace(\u0026#34;.\u0026#34;, \u0026#34;\\\\\u0026#34;) + \u0026#34;.class\u0026#34;; } public static void main(String[] args) throws ClassNotFoundException { MyClassLoader myClassLoader = new MyClassLoader( \u0026#34;D:\\\\java_arch\\\\java_project\\\\test\\\\target\\\\classes\u0026#34;); Class\u0026lt;?\u0026gt; aClass = myClassLoader.findClass(\u0026#34;Test01\u0026#34;); System.out.println(aClass); MyClassLoader myClassLoader2 = new MyClassLoader( \u0026#34;D:\\\\java_arch\\\\java_project\\\\test\\\\target\\\\classes\u0026#34;); Class\u0026lt;?\u0026gt; bClass = myClassLoader2.findClass(\u0026#34;Test01\u0026#34;); System.out.println(bClass); System.out.println(aClass == bClass); //实现类隔离 System.out.println(aClass.getClassLoader()); System.out.println(aClass.getClassLoader().getParent()); } } 覆写loadClass方法 loadClass()也会调用findClass()，但是从逻辑上讲我们最好不要直接修改loadClass()的内部逻辑。建议的做法是只在findClass()里重写自定义类的加载方法，根据参数指定类的名字，返回对应的Class对象的引用\n双亲委派机制 定义 如果一个类加载器在收到加载类的请求时候，首先不会尝试自己去加载这个类，而是将这个请求任务委托给自己的父类加载器去完成，依次递归。如果父类加载器完成不了，才自己去加载\n本质 规定了类的加载顺序：引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会有系统类加载器或自定义的类加载器进行加载\n证明 源码分析 双亲委派机制在java.lang.ClassLoader.loadClass(String,boolean)接口中体现。该接口的逻辑如下： 先在当前加载器的缓存中查找有无目标类，如果有，直接返回 判断当前加载器的父加载器是否为空，如果不为空，则调用parent.loadClass(name, false)接口进行加载。 反之，如果当前加载器的父类加载器为空，则调用findBootstrapClassOrNull(name)接口，让引导类加载器进行加载。 如果通过以上3条路径都没能成功加载，则调用findClass(name)接口进行加载。该接口最终会调用java.lang.ClassLoader接口的defineClass系列的native接口加载目标Java类。 双亲委派的模型就隐藏在这第2和第3步中。\n2.举例\n假设当前加载的是java.lang.Object这个类，很显然，该类属于JDK中核心得不能再核心的一个类，因此一定只能由引导类加载器进行加载。当JVM准备加载javaJang.Object时，JVM默认会使用系统类加载器去加载，按照上面4步加载的逻辑，在第1步从系统类的缓存中肯定查找不到该类，于是进入第2步。由于从系统类加载器的父加载器是扩展类加载器，于是扩展类加载器继续从第1步开始重复。由于扩展类加载器的缓存中也一定査找不到该类，因此进入第2步。扩展类的父加载器是null,因此系统调用findClass(String), 最终通过引导类加载器进行加载。\n打破双亲委派机制 双亲委派机制坏坏1 双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。\n在Java的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况。\n第一次破坏双亲委派机制：\n双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK 1.2面世以前的“远古”时代。\n由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对已经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协，为了兼容这些已有代码，无法再以技术手段避免loadClass()被子类覆盖的可能性，只能在JDK1.2之后的java.lang.ClassLoader中添加一个新的protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码。上节我们已经分析过loadClass()方法，双亲委派的具体逻辑就实现在这里面，按照loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。\n双亲委派机制坏坏2: 线程上下文类加载器 双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（越基础的类由越上层的加载器进行加载），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，如果有基础类型又要调用回用户的代码，那该怎么办呢？\n这并非是不可能出现的事情，一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar的），肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码，现在问题来了，启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？（SPI:在Java平台中，通常把核心类rt.jar中提供外部服务、可由应用层自行实现的接口称为SPI）\n为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。\n有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，但也是无可奈何的事情。Java中涉及SPI的加载基本上都采用这种方式来完成，例如JNDI、JDBC、JCE、JAXB和JBI等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK 6时，JDK提供了java.util.ServiceLoader类，以META-INF/services中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案。\n默认上下文加载器就是应用类加载器，这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类。\n双亲委派机制坏坏3 第三次破坏双亲委派机制：\n双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。如：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等\nIBM公司主导的JSR-291（即OSGi R4.2）实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。\n当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：\n*1）将以java.开头的类，委派给父类加载器加载。\n2）否则，将委派列表名单内的类，委派给父类加载器加载。\n3）否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。\n4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。\n5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。\n6）否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。\n7）否则，类查找失败。\n说明：只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的\n热替换的实现 热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为**。热替换的关键需求在于服务不能中断，修改必须立即表现正在运行的系统之中**。基本上大部分脚本语言都是天生支持热替换的，比如：PHP，只要替换了PHP源文件，这种改动就会立即生效，而无需重启Web服务器。\n但对Java来说，热替换并非天生就支持，如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加载并重定义这个类。因此，在Java中实现这一功能的一个可行的方法就是灵活运用ClassLoader。\n注意：由不同ClassLoader加载的同名类属于不同的类型，不能相互转换和兼容。即两个不同的ClassLoader加载同一个类，在虚拟机内部，会认为这2个类是完全不同的 TOMCAT类加载机制 Tomcat8 和 Tomcat6比较大的区别是 ：Tomcat8可以通过配置 表示遵循双亲委派机制。\n当应用需要某个类时候，会按照下面的顺序进行加载\n使用bootstrap引导类加载器加载 使用system类加载器加载 使用应用类加载器在WEB-INF/classes中加载 使用应用类加载器在WEB-INF/lib中加载 使用common类加载器CATALINA_HOME/lib中加载 五个问题 1、既然 Tomcat 不遵循双亲委派机制，那么如果我自己定义一个恶意的HashMap，会不会有风险呢？(阿里面试问题)\n答： 显然不会有风险，如果有，Tomcat都运行这么多年了，那能不改进吗？\ntomcat不遵循双亲委派机制，只是自定义的classLoader顺序不同，但顶层还是相同的，还是要去顶层请求classloader。\n2、我们思考一下：Tomcat是个web容器， 那么它要解决什么问题？\n一个web容器可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。\n部署在同一个web容器中相同的类库相同的版本可以共享。否则，如果服务器有10个应用程序，那么要有10份相同的类库加载进虚拟机，这是扯淡的。\nweb容器也有自己依赖的类库，不能于应用程序的类库混淆。基于安全考虑，应该让容器的类库和程序的类库隔离开来。\n4、web容器要支持jsp的修改，我们知道，jsp 文件最终也是要编译成class文件才能在虚拟机中运行，但程序运行后修改jsp已经是司空见惯的事情，否则要你何用？ 所以，web容器需要支持 jsp 修改后不用重启。\n3、Tomcat 如果使用默认的类加载机制行不行？\n答案是不行的。为什么？我们看:\n第一个问题，如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的累加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。\n第二个问题，默认的类加载器是能够实现的，因为他的职责就是保证唯一性。\n第三个问题和第一个问题一样。\n我们再看第四个问题，我们想我们要怎么实现jsp文件的热替换，jsp 文件其实也就是class文件，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的，修改后的jsp是不会重新加载的。那么怎么办呢？我们可以直接卸载掉这jsp文件的类加载器，所以你应该想到了，每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载器。重新创建类加载器，重新加载jsp文件。\n4、如果tomcat 的 Common ClassLoader 想加载 WebApp ClassLoader 中的类，该怎么办？\n看了前面的关于破坏双亲委派模型的内容，我们心里有数了，我们可以使用线程上下文类加载器实现，使用线程上下文加载器，可以让父类加载器请求子类加载器去完成类加载的动作。\n5、为什么java文件放在Eclipse/IDEA中的src文件夹下会优先jar包中的class?\ntomcat类加载机制的理解，就不难明白。因为Eclipse/IDEA中的src文件夹中的文件java以及webContent中的JSP都会在tomcat启动时，被编译成class文件放在 WEB-INF/class 中。\n而Eclipse/IDEA外部引用的jar包，则相当于放在 WEB-INF/lib 中。\n因此肯定是 java文件或者JSP文件编译出的class优先加载。\n沙箱安全机制 保护程序安全 保护原生的JDK代码 Java安全模型的核心就是Java沙箱（sandbox）。什么是沙箱？沙箱是一个限制程序运行的环境。\n沙箱机制就是将Java代码限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源访问。通过这样的措施来保证对代码的有限隔离，防止对本地系统造成破坏。\n沙箱主要限制系统资源访问，例如：CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。\n所有的Java程序运行都可以指定沙箱，可以定制安全策略。\njdk9中类加载结构的新变化 为了保证兼容性，JDK 9没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。\n扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器（platform class loader）。可以通过ClassLoader的新方法getPlatformClassLoader()来获取。 JDK 9 时基于模块化进行构建（原来的 rt.jar 和 tools.jar 被拆分成数十个 JMOD 文件），其中的 Java 类库就已天然地满足了可扩展的需求，那自然无须再保留 \\lib\\ext 目录，此前使用这个目录或者 java.ext.dirs 系统变量来扩展 JDK 功能的机制已经没有继续存在的价值了。\n平台类加载器和应用程序类加载器都不再继承自 java.net.URLClassLoader。 现在启动类加载器、平台类加载器、应用程序类加载器全都继承于 jdk.internal.loader.BuiltinClassLoader。\n如果有程序直接依赖了这种继承关系，或者依赖了 URLClassLoader 类的特定方法，那代码很可能会在 JDK 9 及更高版本的 JDK 中崩溃。\n在Java 9中，类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器的名称在调试与类加载器相关的问题时会非常有用。\n启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器（以前是 C++实现），但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例。\n类加载的委派关系也发生了变动。\n当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。\n","permalink":"https://AlfredNing.github.io/note/program/jvm/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/","summary":"类的加载过程 Java数据类型分为数据基本数据类型和引用数据类型\n基本类型由虚拟机预先定义，引用类型需要进行类的加载\n类的加载大过程分为三步, 总过程七步\n装载 将java的class文件加载到机器内存，并在内存中构建出Java类的原型-类模板对象\n查找类的二进制文件，生成class实例\n加载类，需要完成以下三件事情：\n通过类的全名，获取类的二进制数据流 解析类的二进制数据流转换为方法区的数据结构(Java类模型) 创建java.lang.class类的实例，表示该类型 类模板对象 Java类在内存中的一个快照，JVM从字节码文件解析出来的常量池、类字段、类方法等类信息存储到类模板中。在运行期通过类模板获取Java类的任意信息，能够对Java类的成员变量进行遍历，进行方法调用。反射机制也是基于此，如果没有存储Java类的声明信息，JVM在运行期也无法进行反射\n获取二进制数据流 class字节码文件符号JVM规范\n通过读取class后缀的文件 读入jar、zip等归档数据包，提取类文件(热部署jar包原理基础) 事先存放在数据库的二进制数据 使用类型Http之类的协议通过网络进行加载 在运行时生成一段class的二进制信息等 class实例位置 类将.class文件加载至元空间后，会在堆中创建一个Java.lang.Class对象，用来封装类位于方法区内的数据结构，该Class对象是在加载类的过程中创建的，每个类都对应有一个Class类型的对象 数组类的加载 数组类本身不是由类加载器负责创建，而是由JVM在运行时根据需要去创建。加载器只负责加载数据元素的数据类型(基本数据类型和引用数据类型)，申请内存分配长度\n链接 验证阶段 保证加载的字节码是合法、合理并符合jvm规范\n格式验证回合装载阶段一起执行。验证通过之后，类加载器才会把验证成功的二级制数据信息加载到方法区中 格式验证之外的验证操作都在方法区中进行 准备阶段 为类的静态变量分配内存，并将其初始化为默认值。\nJava并不支持boolean类型，对于boolean类型，内部实现是int,由于int的默认值是0,故对应的，boolean的默认值就是false\n解析阶段 将类、接口、自动和方法的符号引用转换为直接引用\n符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。比较容易理解的就是在Class类文件中，通过常量池进行了大量的符号引用。通过解析操作，符号引用就可以转化为目标方法在类中方法表的位置，从而使得方法被成功调用。\n解析就是将符号引用转换为直接引用。换言之，直接引用存在，一定存在符号引用，反之不然\nJava虚拟机规范并没有要求解析操作一定要按照顺序执行\n在HotSpot VM中，加载、验证、准备和初始化会按照顺序有条不紊地执行，但链接阶段中的解析操作往往会伴随着JVM在执行完初始化之后再执行\n初始化 为静态变量赋予正确的初始值\n开始执行java字节码，执行类的初始化方法\nclinit方法：该方法只能由JVM编译器生成，程序开发者无法自定义一个同名的方法，无法在java程序中调用该方法，该方法由java字节码组成 init方法：由类的静态成员变量赋值及其static语句块产生 clinit方法的生成 以下几种情况，不会生产clinit方法\n一个类中没有声明任何类变量，也没静态代码块 一个类中声明类变量，但没有明确使用类的初始化语句以及静态代码块进行初始化操作 一个类中包含static final 修饰的基本类型字段，这些类字段使用编译时常量表达式 clinit是由虚拟机保证在多线程环境下正确的加锁同步，是线程安全的。如果有很长的耗时操作，是会造成死锁的。\n类的加载 加载 = 装载 + 链接 + 初始化\nJava程序的主动使用\n主动使用的说明 Class只有在必须要首次使用的时候才会被装载，Java虚拟机不会无条件地装载Class类型。Java虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用。\n主动使用只有下列几种情况：（即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成。）\n当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化。\n当调用类的静态方法时，即当使用了字节码invokestatic指令。\n当使用类、接口的静态字段时(final修饰特殊考虑)，比如，使用getstatic或者putstatic指令。\n当使用java.lang.reflect包中的方法反射类的方法时。比如：Class.forName(\u0026ldquo;com.atguigu.java.Test\u0026rdquo;)\n当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。","title":"类的加载"},{"content":"新特性 lambda表达式 方法引用 函数接口 流式处理 新日期时间API Optional类 新工具、JavaScript执行引擎 javaFx 函数编程 lambda表达式 想要在代码块以后某个时间点执行 可以转换为函数式接口 闭包作用域中有效访问final变量 任何一个lambda表达式都可以转换为所使用API中对应的函数式接口，注意：lambda表达式转换为函数式接口时候，注意检查期异常 不允许声明一个与局部变量同名的参数或者局部变量 lambda使用this,创建该lambda表达式方法的参数 组成 可选的类型声明 可选的参数小括号 可选的大括号 可选的返回值【只有一句表达式可以省略】 功能 内联功能的实现\n注意 变量引用不可变，实际内容可变\n函数接口 只包含一个抽象方法的接口，可以通过lambda表达式创建该接口的对象\n方法引用 方法引用用其名称指向方法\n引用符号:: 指向方法\n对象::实例方法 类:: 静态方法 类::实例方法（第一个参数会成为执行方法的对象) 构造器引用 类::new\njava中无法构造一个泛型类型T的数组，但可以通过数组引用解决。\n例如：stream.toArray(Class::new)\n默认方法 类优先原则\n接口中有一个默认方法，一个类也有同名的方法。另一个类继承了父类，实现了该接口。这种情况下，只有父类的方法会起作用。 出于兼容性，这样在接口中添加方法，不会对以前的编写的代码产生影响。不能对Object的方法定义默认方法\n静态方法 为接口添加静态方法\nStream API 原则：做什么，而不是怎么做\nStream不会自己存储元素。元素可能被存储在底层的集合当中，或者根据需要产生出来 Stream操作符不会改变源对象的。相反，他们会返回一个持有结果的新Stream Stream操作符可能是延迟执行的。意味着他们等到需要结果的时候才执行 Stream使用三阶段 创建Stream 中间操作 终止操作产生结果 创建Stream Stream.of() Arrays.Stream 可选长度参数\n空Stream: Stream.Empty()\nStream.generate(Supplier func);\nStream.iterate(seed, operator)\nPattern类的splitAsStream\nFiles.lines(path) : 记得使用try-with-resources语句\n中间操作 注意null对象\nfilter map flatMap filter 过滤操作，满足true的保留\n参数：Predicate对象\nT =\u0026gt; Boolean函数\nmap 对流中的每一个元素进行应用一个函数，将返回的值收集到一个新流当中\nflatMap 多流展开流\nflatMap属于计算机科学中的一个基本概念。假设有一个G(例如Stream)和两个函数，从T到G(U)的f函数和从U到G(U)的g方法。通过flatMap,先应用f函数，再应用g函数。\n提取子流和组合流 limit 裁剪指定长度的流\nskip 丢弃前面的n个元素\nStream.concat 将两个流连接起来\npeek 产生与另一个原始具有相同元素的流，每次提取元素的时候，都会调用一个函数\n有状态的转换 distinct 必须记住之前已经读取的元素\nsorted 遍历整个流，进行排序\nCollection.sort方法对原有的集合进行排序，而Stream.sorted方法会返回一个新的已排序的流\n终止操作 聚合方法 count max min findFirst findAny:找到第一个出现的元素就结束 anyMatch:是否有匹配的元素 allMatch: 所有元素匹配，并行执行提高速度 noneMatch: 所有元素不进行匹配，并行执行提高速度 reduce forEach: 保证传入函数并发执行\nforEachOrdered： 按照流的顺序执行访问\n注意返回值Optional\nOptional类型 使用一个或者接受正确值，或者返回另一个替代值的方法\nifPresent 接受一个函数，存在可选值，将值传递给函数。不会返回任何值，如果希望操作，调用map方法\norElse 不存在值产生一个替代值\norElseGet 计算默认值\norElseThrow 没有值的时候抛出异常\n创建可选值 Optional.of\nOptional.empty\nOptiona.ofNullable 对象不为空，返回Optional.of,否则返回Optional.empty()\n使用flatmap组合可选值函数 一个方法f返回Optional， 目标类型有一个返回Optional的方法g, 调用s.f().g()不能操作，如果s.f()存在执行g()。多次调用flatMap实现\n收集结果 收集到集合 iterator\ntoArray\ncollect 使用Collectiors类\n一个能创建目标类型的实例方法 一个元素添加到目标中的方法 一个将两个对象整合到一起的方法 public static void main(String[] args) { Stream\u0026lt;Integer\u0026gt; stream = Stream.iterate(10, v -\u0026gt; v + 1).limit(20); stream.forEach(System.out::println); // toList List\u0026lt;Integer\u0026gt; list = stream.collect(Collectors.toList()); Set\u0026lt;Integer\u0026gt; set1 = stream.collect(Collectors.toSet()); // 排序的set TreeSet\u0026lt;Integer\u0026gt; treeSet = stream.collect(Collectors.toCollection(TreeSet::new)); // 字符串拼接 String str = stream.map(Object::toString).collect(Collectors.joining(\u0026#34;; \u0026#34;)); // 总和 平均值 最大值 最小值summarizing类型 DoubleSummaryStatistics summaryStatistics = stream.collect( Collectors.summarizingDouble(Integer::intValue)); summaryStatistics.getAverage(); summaryStatistics.getCount(); summaryStatistics.getSum(); // ....... } 收集到map Collectors.toMap(键函数，值函数，键冲突函数)\nFunction.identity(). 实际的元素\n如果多个元素拥有相同的键，抛出IllegalStateException异常。传入键冲突函数。返回已有值，新值、两者都返回\n如果希望返回TreeMap，传入第四个函数。\n对于toMap的方法都有对应toConcurentMap方法\n分组和切片 groupingBy partitioningBy partitioningBy 效率大于groupingBy\n传入第二个参数设置downStream\ncounting summingXXX maxBy minBy 原始类型流 IntStream =\u0026gt; short char byte boolean int\nDoubleStream =\u0026gt; float double\n并行流 默认情况下，流操作是创建一个串行流。Collection.parallelStream()方法除外。\nparallel方法可以将任意的串行流转换为一个并行流\n确保传递给并行流的函数都是线程安全的\n日期时间 瞬时时间-Instant 时间间隔-Duration toNacos toMillis toSeconds toMinuters toHours toDays 本地日期 本地日期/时间\nLocalDate 年月日日期\n时段：Period\n日期矫正器：TemporalAdjusters\n本地时间：LocalTime\n本地日期和时间：LocalDateTime\n带时区的时间\n获取所有时区：ZoneId.getAvailableZoneIds() 返回时区：Zone.id(id) 日期转带有时区的：local.atZone(); 带有偏移量的时间：OffsetDateTime 格式化和解析 预定义的标准格式 String format = DateTimeFormatter.ISO_DATE.format(LocalDateTime.now()); System.out.println(format); 语言相关的格式化风格 String format1 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG) .format(ZonedDateTime.now()); System.out.println(format1); // 更改语言环境使用withLocale方法 自定义格式 DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\u0026#34;yyy-MM-dd HH:mm:ss\u0026#34;); System.out.println(formatter.format(LocalDateTime.now())); 与之前日期时间的交互 Instant类似java.util.Date类\njava.util.Date增加了两个方法：toInstant 和format方法\n其他增强内容 字符串 多个字符串组合起来，String.join\n数字类 Short/Integer/Long/Float/Double提供了静态方法sum/max/min,用来流操作中作为聚合函数使用\nBoolean提供logicalAnd / logicalAndor / logicalXor\nInterger支持无符号运算\nByte Short新增toUnsignedInt方法\nByte Short Integer 新增了toUnsignedLong 方法\nFloat Double 新增isFinite\nBigInteger新增实例方法（long|int|short|byte)ValueExtract，返回基本类型，不在目标范围时返回ArithmeticException\n新的数学函数 算术计算：(add | subtract | multiply | increment | decrement | negate)Extract\n将long值转换为等价的Int值： toIntExtract\n整数余数问题：floorMod floorDiv\n集合 Collection接口加入removeIf\nList接口 加入replaceAll ， sort方法\nIterator接口forEachRemaining：将剩余元素传递给一个函数\n比较器\ncomparing/thenComparing\n键函数返回null, 使用nullFirst或者nullLast\nCollections\ncheckQueue emptySorted() 文件 读取文件行的流\nFiles.lines : 默认UTF-8 , 配合使用try-with-resources\n遍历目录项 Files.list : 不会进入子目录\nFiles.walk: 会进入子目录，可以限制深度\nBase64编码 null检查 Objects.isNull 和nonNull 配合流使用\n正则表达式 引用命名捕获组\n语言环境 Locale.getAvailableLocales()\njdbc java.sql包下的Date/Time/TimeStamp提供方法和本地日期时间进行转化\nStatement类新增executeLargeUpdate方法\njava7的一些特性 try-with-resources： 前提实现AutoCloseable接口 忽略异常：ex.addSuppressed(exception) 捕获多个异常 反射异常：ReflectiveOperationException 使用文件 使用Path类 使用Files类 使用Objects equals方法 hash方法 URLClassLoader BitSet构造增强、java8可以通过BitSet返回IntStream 未补充\nJavaFX java8的并发增强 ","permalink":"https://AlfredNing.github.io/note/program/java8/java8/","summary":"新特性 lambda表达式 方法引用 函数接口 流式处理 新日期时间API Optional类 新工具、JavaScript执行引擎 javaFx 函数编程 lambda表达式 想要在代码块以后某个时间点执行 可以转换为函数式接口 闭包作用域中有效访问final变量 任何一个lambda表达式都可以转换为所使用API中对应的函数式接口，注意：lambda表达式转换为函数式接口时候，注意检查期异常 不允许声明一个与局部变量同名的参数或者局部变量 lambda使用this,创建该lambda表达式方法的参数 组成 可选的类型声明 可选的参数小括号 可选的大括号 可选的返回值【只有一句表达式可以省略】 功能 内联功能的实现\n注意 变量引用不可变，实际内容可变\n函数接口 只包含一个抽象方法的接口，可以通过lambda表达式创建该接口的对象\n方法引用 方法引用用其名称指向方法\n引用符号:: 指向方法\n对象::实例方法 类:: 静态方法 类::实例方法（第一个参数会成为执行方法的对象) 构造器引用 类::new\njava中无法构造一个泛型类型T的数组，但可以通过数组引用解决。\n例如：stream.toArray(Class::new)\n默认方法 类优先原则\n接口中有一个默认方法，一个类也有同名的方法。另一个类继承了父类，实现了该接口。这种情况下，只有父类的方法会起作用。 出于兼容性，这样在接口中添加方法，不会对以前的编写的代码产生影响。不能对Object的方法定义默认方法\n静态方法 为接口添加静态方法\nStream API 原则：做什么，而不是怎么做\nStream不会自己存储元素。元素可能被存储在底层的集合当中，或者根据需要产生出来 Stream操作符不会改变源对象的。相反，他们会返回一个持有结果的新Stream Stream操作符可能是延迟执行的。意味着他们等到需要结果的时候才执行 Stream使用三阶段 创建Stream 中间操作 终止操作产生结果 创建Stream Stream.of() Arrays.Stream 可选长度参数\n空Stream: Stream.Empty()\nStream.generate(Supplier func);\nStream.iterate(seed, operator)\nPattern类的splitAsStream\nFiles.lines(path) : 记得使用try-with-resources语句","title":"Java8"},{"content":"字节码文件 字节码文件 字节码文件跨平台 JVM实现遵守JVM虚拟机规范，所有JVM的环境都是一样的，所以字节码文件可以在各种虚拟机上执行\n通过Class文件，更多的计算机语言支持Java虚拟机平台。Class文件不仅仅是Java虚拟机的执行入口，更是Java生态圈的核心\n字节码文件内容 源代码经过编译器生成一个字节码文件，字节码文件是一种二进制的文件，内容是JVM的指令，而C/C++由编译器直接生成机器码。随着Java平台的不断发展，在将来，Class文件的内容也一定会做进一步的扩充，但是其基本的格式和结构不会做重大调整\n字节码文件编译器 作用范围 编译器种类 前端编译器\njavac (全量编译器)/Eclipse中的ECJ\tEclipse Compiler for Java （增量编译器） 主要任务：将java源代码转化为符合jvm规范的字节码文件 劣势：前端编译器并不会直接涉及编译优化等方面的技术，而是将这些具体优化细节移交给HotSpot的JIT编译器负责 后端编译器\nAOT(静态提前编译器，Ahead Of Time Compiler)\njdk9引入了AOT编译器(静态提前编译器，Ahead Of Time Compiler)\nJava 9 引入了实验性 AOT 编译工具jaotc。它借助了 Graal 编译器，将所输入的 Java 类文件转换为机器码，并存放至生成的动态共享库之中。\n所谓 AOT 编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而 AOT 编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。\n.java -\u0026gt; .class -\u0026gt; .so\n最大好处：Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢”的不良体验。\n缺点：\n破坏了java“一次编译，到处运行”，必须为每个不同硬件、OS编译对应的发行包。 降低了Java链接过程的动态性，加载的代码在编译期就必须全部已知。 还需要继续优化中，最初只支持Linux x64 java base\n类的class对象 外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类 接口 数组 枚举 注解 基本数据类型 void 字节码指令 Java虚拟机的指令是由一个字节长度、代表着某种特定操作含义的操作码[opcode]以及跟随其后的零至多个代表此操作所需操作数的操作数[operand]组成。虚拟机中许多指令并不包含操作数，只有一个操作码\n字节码相关面试\nidea插件：jclasslib\nimport org.testng.annotations.Test; /** * @author Alfred.Ning * @since 2023年02月20日 20:10:00 */ public class ByteCodeTest { @Test public void test1() { int i = 10; i++; ++i; System.out.println(i); // 10 } @Test public void test2() { int i = 10; i = i++; System.out.println(i); // 10 这里实际10 -\u0026gt; 11 -\u0026gt; 操作数栈覆盖局部变量表 } @Test public void test3() { int i = 10; i = i + (i++) + (++i); // 10 + 10( i =\u0026gt; 11) + 12 System.out.println(i); // 32 } // 包装类对象的缓存 @Test public void test4() { Integer i1 = 10; Integer i2 = 10; System.out.println(i1 == i2); //true 常量池存在 IntegerCache Integer i3 = 128; Integer i4 = 128; System.out.println(i3 == i4); // false Boolean b1 = true; Boolean b2 = true; System.out.println(b1 == b2); // true } /** * String声明的字面量数据都在字符串常量池 jdk 6中字符串常量池在方法区 jdk7之后常量池存放在堆空间 */ @Test public void test5() { String str = new String(\u0026#34;hello\u0026#34;) + new String(\u0026#34;world\u0026#34;); // str.intern(); //结果为true 如果是jdk1.6这里不生效 如果堆空间有的话，常量池直接引用堆空间的 String str1 = \u0026#34;helloworld\u0026#34;; // str.intern(); //改在这里 也是为false intern在常量池的引用改为堆空间的引用 System.out.println(str == str1); // false 堆空间和常量池 } @Test public void test06() { Father father = new Son(); /** * Son.x = 0 * Son.x = 30 * 20 * * * * 初始化父类构造器 指的是Son对象 print被重写 * son构造还没有被调用 所以为0 * son.print 被赋值是30 * x被赋值40 * 打印自己为20 */ System.out.println(father.x); } class Father { int x = 10; public Father() { this.print(); x = 20; } public void print() { System.out.println(\u0026#34;Father.x = \u0026#34; + x); } } class Son extends Father { int x = 30; public Son() { this.print(); x = 40; } public void print() { System.out.println(\u0026#34;Son.x = \u0026#34; + x); } } } class文件解读 解读工具 文本工具，转换成16进制 javap，java自带工具 IDEA插件，jclasslib ByteCode viewer class文件结构 魔数 Class文件版本 常量池 访问标识 类索引、父类索引、接口索引集合 字段表集合 方法表集合 属性表集合 魔数 class文件的标志\n每个 Class 文件开头的4个字节的无符号整数称为魔数（Magic Number） 它的唯一作用是确定这个文件是否为一个能被虚拟机接受的有效合法的Class文件。即：魔数是Class文件的标识符, 魔数值固定为0xCAFEBABE。不会改变。 如果一个Class文件不以0xCAFEBABE开头，虚拟机在进行文件校验的时候就会直接抛出以下错误： Error: A JNI error has occurred, please check your installation and try again Exception in thread \u0026ldquo;main\u0026rdquo; java.lang.ClassFormatError: Incompatible magic value 1885430635 in class file StringTest 使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。 jvm版本向下兼容 不同版本的Java编译器编译的Class文件对应的版本是不一样的。目前，高版本的Java虚拟机可以执行由低版本编译器生成的Class文件,但是低版本的Java虚拟机不能执行由高版本编译器生成的Class文件。否则JVM会抛出java.lang.UnsupportedClassVersionError异常 在实际应用中，由于开发环境和生产环境的不同，可能会导致该问题的发生。因此，需要我们在开发时，特别注意开发编译的JDK版本和生产环境中的JDK版本是否一致 文件版本号 紧接着魔数的 4 个字节存储的是 Class 文件的版本号。同样也是4个字节。第5个和第6个字节所代表的含义就是编译的副版本号minor_version，而第7个和第8个字节就是编译的主版本号major_version。 它们共同构成了class文件的格式版本号。譬如某个 Class 文件的主版本号为 M，副版本号为 m，那么这个Class 文件的格式版本号就确定为 M.m。 Java 的版本号是从45开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1。 虚拟机JDK版本为1.k （k \u0026gt;= 2）时，对应的class文件格式版本号的范围为45.0 - 44+k.0 （含两端）。 常量池 存放所有常量\nClass文件的资源仓库，它是clas文件结构中与其他项目关联最多的数据类型，也是占用class文件空间最大的数据项之一 常量池表项中，用于存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池存放 在版本号之后，紧跟着的是常量池的数量，以及若干个常量池表项。 常量池计数器 由于常量池的数量不固定，时长时短，所以需要放置两个字节来表示常量池容量计数值。 常量池容量计数值（u2类型）：从1开始，表示常量池中有多少项常量。即constant_pool_count=1表示常量池中有0个常量项。 下面demo的值： 其值为0x0016,掐指一算，也就是22。 需要注意的是，这实际上只有21项常量。索引为范围是1-21。为什么呢？ 通常我们写代码时都是从0开始的，但是这里的常量池却是从1开始，因为它把第0项常量空出来了。这是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况可用索引值0来表示。 int[] arr = new int[10]; arr[0]; arr[1]; ar[10 - 1]; 常量池表 constant_pool是一种表结构，以 1 ~ constant_pool_count - 1为索引。表明了后面有多少个常量项。 常量池主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References） 它包含了class文件结构及其子结构中引用的所有字符串常量、类或接口名、字段名和其他常量。常量池中的每一项都具备相同的特征。第1个字节作为类型标记，用于确定该项的格式，这个字节称为tag byte （标记字节、标签字节） 字面量和符号引用 全限定名：类的全限定，包的.替换成/\n简单名称:没有类型和参数修饰的方法或者字段名称\n描述符: 用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示。用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如：\n方法java.lang.String toString()的描述符为() Ljava/lang/String;，\n方法int abc(int[] x, int y)的描述符为([II) I。\n符号引用是用一组符号来描述引用的目标地址，可以是任意形式的字面量。符号引用和虚拟机实现的内存布局无关，引用的目标不一定加载到了内存中。 直接引用：可以是直接执行目标的指针，相对偏移量或者一个能间接定位到目标的句柄。直接引用与虚拟机实现的内存布局相关。 同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了 常量类型和结构 常量池中每一项常量都是一个表，JDK1.7之后共有14种不同的表结构数据。如下表格所示：\n==================================\n总结：\n这14种表（或者常量项结构）的共同点是：表开始的第一位是一个u1类型的标志位（tag），代表当前这个常量项使用的是哪种表结构，即哪种常量类型。\n在常量池列表中，CONSTANT_Utf8_info常量项是一种使用改进过的UTF-8编码格式来存储诸如文字字符串、类或者接口的全限定名、字段或者方法的简单名称以及描述符等常量字符串信息。\n这14种常量项结构还有一个特点是，其中13个常量项占用的字节固定，只有CONSTANT_Utf8_info占用字节不固定，其大小由length决定。为什么呢？因为从常量池存放的内容可知，其存放的是字面量和符号引用，最终这些内容都会是一个字符串，这些字符串的大小是在编写程序时才确定，比如你定义一个类，类名可以取长取短，所以在没编译前，大小不固定，编译后，通过utf-8编码，就可以知道其长度。\n访问标识(access_flag、访问标志、访问标记) 在常量池后，紧跟着访问标记。该标记使用两个字节表示，用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口；是否定义为 public 类型；是否定义为 abstract 类型；如果是类的话，是否被声明为 final 等。各种访问标记如下所示： 类的访问权限通常为 ACC_ 开头的常量。 每一种类型的表示都是通过设置访问标记的32位中的特定位来实现的。比如，若是public final的类，则该标记为ACC_PUBLIC | ACC_FINAL。 使用ACC_SUPER可以让类更准确地定位到父类的方法super.method(),现代编译器都会设置并且使用这个标记。 类索引、父类索引、接口索引 在访问标记后，会指定该类的类别、父类类别以及实现的接口，格式如下： 这三项数据来确定这个类的继承关系。\n类索引用于确定这个类的全限定名\n父类索引用于确定这个类的父类的全限定名。由于 Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object 之外，所有的Java类都有父类，因此除了java.lang.Object 外，所有Java类的父类索引都不为 0。\n接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按 implements 语句（如果这个类本身是一个接口，则应当是 extends 语句）后的接口顺序从左到右排列在接口索引集合中。\n1.this_class（类索引）\n2字节无符号整数，指向常量池的索引。它提供了类的全限定名。this_class的值必须是对常量池表中某项的一个有效索引值。常量池在这个索引处的成员必须为CONSTANT_Class_info类型结构体，该结构体表示这个class文件所定义的类或接口。\n2.super_class （父类索引）\n2字节无符号整数，指向常量池的索引。它提供了当前类的父类的全限定名。如果我们没有继承任何类，其默认继承的是java/lang/Object类。同时，由于Java不支持多继承，所以其父类只有一个。\nsuperclass指向的父类不能是final。\ninterfaces 指向常量池索引集合，它提供了一个符号引用到所有已实现的接口\n由于一个类可以实现多个接口，因此需要以数组形式保存多个接口的索引，表示接口的每个索引也是一个指向常量池的CONSTANT_Class (当然这里就必须是接口，而不是类)。\n3.1 interfaces_count (接口计数器)\ninterfaces_count项的值表示当前类或接口的直接超接口数量。\n3.2 interfaces [] (接口索引集合)\ninterfaces []中每个成员的值必须是对常量池表中某项的有效索引值，它的长度为 interfaces_count。 每个成员 interfaces[i]必须为 CONSTANT_Class_info结构，其中 0 interfaces[0]对应的是源代码中最左边的接口。\n字段表集合 字段计数器 fields_count （字段计数器）\nfields_count的值表示当前class文件fields表的成员个数。使用两个字节来表示。\nfields表中每个成员都是一个field_info结构，用于表示该类或接口所声明的所有类字段或者实例字段，不包括方法内部声明的变量，也不包括从父类或父接口继承的那些字段。\n字段表 fields []（字段表） fields表中的每个成员都必须是一个fields_info结构的数据项，用于表示当前类或接口中某个字段的完整描述。\n一个字段的信息包括如下这些信息。这些信息中，各个修饰符都是布尔值，要么有，要么没有。\n\u0026gt;作用域（public、private、protected修饰符）\n\u0026gt;是实例变量还是类变量（static修饰符）\n\u0026gt;可变性（final）\n\u0026gt;并发可见性（volatile修饰符，是否强制从主内存读写）\n\u0026gt;可否序列化（transient修饰符）\n\u0026gt;字段数据类型（基本数据类型、对象、数组）\n\u0026gt;字段名称\n字段表结构 字段表作为一个表，同样有他自己的结构：\n方法表集合 methods：指向常量池索引集合，它完整描述了每个方法的签名。\n在字节码文件中，每一个method_info项都对应着一个类或者接口中的方法信息。比如方法的访问修饰符(public、private或protected),方法的返回值类型以及方法的参数信息等。\n如果这个方法不是抽象的或者不是native的，那么字节码中会体现出来。\n一方面，methods表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法。另一方面，methods表有可能会出现由编译器自动添加的方法，最典型的便是编译器产生的方法信息(比如：类(接口)初始化方法()和实例初始化方法())。\n使用注意事项：\n在Java语言中，要重载(Overload)一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名之中，因此Java语言里无法仅仅依靠返回值的不同来对一个已有方法进行重载。但在Class文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个class文件中。\n也就是说，尽管Java语法规范并不允许在一个类或者接口中声明多个方法签名相同的方法，但是和Java语法规范相反，字节码文件中却恰恰允许存放多个方法签名相同的方法，唯一的条件就是这些方法之间的返回值不能相同。\n方法计数器 methods_count methods_count的值表示当前class文件methods表的成员个数。使用两个字节来表示。\nmethods 表中每个成员都是一个method_info结构。\n方法表 methods []（方法表） methods表中的每个成员都必须是一个method_info结构，用于表示当前类或接口中某个方法的完整描述。如果某个method_info结构的access_flags项既没有设置 ACC_NATIVE 标志也没有设置ACC_ABSTRACT标志，那么该结构中也应包含实现这个方法所用的Java虚拟机指令。\nmethod_info结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法和类或接口初始化方法\n方法表的结构实际跟字段表是一样的，方法表结构如下：\n属性表集合 方法表集合之后的属性表集合，指的是class文件所携带的辅助信息，比如该 class 文件的源文件的名称。以及任何带有RetentionPolicy.CLASS 或者RetentionPolicy.RUNTIME的注解。这类信息通常被用于Java虚拟机的验证和运行，以及Java程序的调试，一般无须深入了解。\n此外，字段表、方法表都可以有自己的属性表。用于描述某些场景专有的信息。\n属性表集合的限制没有那么严格，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，但Java虚拟机运行时会忽略掉它不认识的属性。\n属性计数器 attributes_count attributes_count的值表示当前class文件属性表的成员个数。属性表中每一项都是一个attribute_info结构。\n属性表 ConstantValue 属性 ConstantValue 属性表示一个常量字段的值。位于 field_info结构的属性表中。 ConstantValue_attribute { u2 attribute_name_index; u4 attribute_length; u2 constantvalue_index;//字段值在常量池中的索引，常量池在该索引处的项给出该属性表示的常量值。（例如，值是long型的，在常量池中便是CONSTANT_Long） } Deprecated 属性 Deprecated 属性是在 JDK 1.1 为了支持注释中的关键词@deprecated 而引入的。 Deprecated_attribute { u2 attribute_name_index; u4 attribute_length; } Code属性 Code属性就是存放方法体里面的代码。但是，并非所有方法表都有Code属性。像接口或者抽象方法，他们没有具体的方法体，因此也就不会有Code属性了。\nInnerClasses 属性 为了方便说明特别定义一个表示类或接口的 Class 格式为 C。如果 C 的常量池中包含某个CONSTANT_Class_info 成员，且这个成员所表示的类或接口不属于任何一个包，那么 C 的ClassFile 结构的属性表中就必须含有对应的 InnerClasses 属性。InnerClasses 属性是在 JDK 1.1 中为了支持内部类和内部接口而引入的,位于 ClassFile结构的属性表。\nLineNumberTable 属性 LineNumberTable 属性是可选变长属性，位于 Code结构的属性表。\nLineNumberTable属性是用来描述Java源码行号与字节码行号之间的对应关系。这个属性可以用来在调试的时候定位代码执行的行数。\nstart_pc,即字节码行号;line_number，即Java源代码行号。 在 Code 属性的属性表中,LineNumberTable 属性可以按照任意顺序出现，此外，多个 LineNumberTable属性可以共同表示一个行号在源文件中表示的内容，即 LineNumberTable 属性不需要与源文件的行一一对应。\nLocalVariableTable 属性 LocalVariableTable 是可选变长属性，位于 Code属性的属性表中。它被调试器用于确定方法在执行过程中局部变量的信息。在 Code 属性的属性表中，LocalVariableTable 属性可以按照任意顺序出现。 Code 属性中的每个局部变量最多只能有一个 LocalVariableTable 属性。\nstart pc + length表示这个变量在字节码中的生命周期起始和结束的偏移位置（this生命周期从头0到结尾）\nindex就是这个变量在局部变量表中的槽位（槽位可复用）\nname就是变量名称\nDescriptor表示局部变量类型描述\nSignature 属性 Signature 属性是可选的定长属性，位于 ClassFile， field_info或 method_info结构的属性表中。在 Java 语言中，任何类、 接口、 初始化方法或成员的泛型签名如果包含了类型变量（ Type Variables） 或参数化类型（ Parameterized Types），则 Signature 属性会为它记录泛型签名信息。\nSourceFile属性 其他属性 Java虚拟机中预定义的属性有20多个\n字节码指令集 操作码 操作数\n在Java虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。例如，iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。\n对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：\ni代表对int类型的数据操作\nl代表long类型的数据操作\ns代表short类型的数据操作\nb代表byte类型的数据操作\nc代表char类型的数据操作\nf代表float类型的数据操作\nd代表double类型的数据操作\n也有一些指令的助记符中没有明确地指明操作类型的字母，如arraylength指令，它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象。\n还有另外一些指令，如无条件跳转指令goto则是与数据类型无关的。\n大部分的指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。编译器会在编译期或运行期将byte和short类型的数据带符号扩展（Sign-Extend）为相应的int类型数据，将boolean和char类型数据零位扩展（Zero-Extend）为相应的int类型数据。与之类似，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。因此，大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的int类型作为运算类型。\nbyte b1 = 12;\nshort s1 = 10;\nint i = b1 + s1;\n指令分类 加载与存储指令 算术指令 类型转换指令 对象的创建与访问指令 方法调用与返回指令 方法嗲用指令 invokevirtual指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），支持多态。这也是Java语言中最常见的方法分派方式。 invokeinterface指令用于调用接口方法，它会在运行时搜索由特定对象所实现的这个接口方法，并找出适合的方法进行调用。 invokespecial指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法（构造器）、私有方法和父类方法。这些方法都是静态类型绑定的，不会在调用时进行动态派发。 invokestatic指令用于调用命名类中的类方法（static方法）。这是静态绑定的。 invokedynamic：调用动态绑定的方法，这个是JDK 1.7后新加入的指令。用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。前面4条调用指令的分派逻辑都固化在 java 虚拟机内部，而 invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。 操作数栈管理指令 控制转移指令 异常处理指令 同步控制指令 一个指令，可以从局部变量表、常量池、堆中对象、方法调用、系统调用中等取得数据，这些数据（可能是值，可能是对象的引用）被压入操作数栈 一个指令，也可以从操作数栈中取出一到多个值（pop多次），完成赋值、加减乘除、方法传参、系统调用等等操作 Java虚拟机中，数据类型可以分为哪几类 基本类型 数值类型 浮点数类型 float double 整数类型 byte short int long boolean returnAddress 引用类型 类类型 接口类型 数组类型 java所有基本类型与Java虚拟机基本类型保持一致，但是boolean有区别，java虚拟机认为boolean是基本类型，当编译成为字节码，用int或者byte表示boolean。java虚拟机中，false是由整数0来表示，所有非0整数表示true, boolean使用int替代操作，boolean数组使用byte数组进行访问\nJava虚拟机还有一个只在内部使用的基本类型：returnAddress，Java程序员不能使用这个类型，这个基本类型被用来实现Java程序中的finally子句。该类型是jsr, ret以及jsr_w指令需要使用到的，它的值是JVM指令的操作码的指针。returnAddress类型不是简单意义上的数值，不属于任何一种基本类型，并且它的值是不能被运行中的程序所修改的\n引用类型的值都是对动态创建对象的引用。 类类型值是引用类实例的引用 接口类型对实现了某个接口的实例的引用 数组类型的值是对数组对象的引用 特殊的引用值是null,表示该引用对象没有引用任何值\n基本类型为什么不放在堆中 首先堆、栈特点不一样。堆比栈要大，但是栈比堆得运行速度要快 复杂数据类型放在堆中，是为了不影响栈的效率。而是通过引用的方式去查找。（八大基本类似大小，创建的时候已经确立大小了。三大引用类型无法确定大小） ","permalink":"https://AlfredNing.github.io/note/program/jvm/%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6/","summary":"字节码文件 字节码文件 字节码文件跨平台 JVM实现遵守JVM虚拟机规范，所有JVM的环境都是一样的，所以字节码文件可以在各种虚拟机上执行\n通过Class文件，更多的计算机语言支持Java虚拟机平台。Class文件不仅仅是Java虚拟机的执行入口，更是Java生态圈的核心\n字节码文件内容 源代码经过编译器生成一个字节码文件，字节码文件是一种二进制的文件，内容是JVM的指令，而C/C++由编译器直接生成机器码。随着Java平台的不断发展，在将来，Class文件的内容也一定会做进一步的扩充，但是其基本的格式和结构不会做重大调整\n字节码文件编译器 作用范围 编译器种类 前端编译器\njavac (全量编译器)/Eclipse中的ECJ\tEclipse Compiler for Java （增量编译器） 主要任务：将java源代码转化为符合jvm规范的字节码文件 劣势：前端编译器并不会直接涉及编译优化等方面的技术，而是将这些具体优化细节移交给HotSpot的JIT编译器负责 后端编译器\nAOT(静态提前编译器，Ahead Of Time Compiler)\njdk9引入了AOT编译器(静态提前编译器，Ahead Of Time Compiler)\nJava 9 引入了实验性 AOT 编译工具jaotc。它借助了 Graal 编译器，将所输入的 Java 类文件转换为机器码，并存放至生成的动态共享库之中。\n所谓 AOT 编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而 AOT 编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。\n.java -\u0026gt; .class -\u0026gt; .so\n最大好处：Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢”的不良体验。\n缺点：\n破坏了java“一次编译，到处运行”，必须为每个不同硬件、OS编译对应的发行包。 降低了Java链接过程的动态性，加载的代码在编译期就必须全部已知。 还需要继续优化中，最初只支持Linux x64 java base\n类的class对象 外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类 接口 数组 枚举 注解 基本数据类型 void 字节码指令 Java虚拟机的指令是由一个字节长度、代表着某种特定操作含义的操作码[opcode]以及跟随其后的零至多个代表此操作所需操作数的操作数[operand]组成。虚拟机中许多指令并不包含操作数，只有一个操作码\n字节码相关面试\nidea插件：jclasslib\nimport org.testng.annotations.Test; /** * @author Alfred.","title":"字节码文件"},{"content":"JDK关系 Oracle JDK 与 Open JDK 关系\nOracle JDK是由oracle 公司开发的，Open JDK 是由IBM，Apple，SAP AG，Redhat等顶级公司合作开发 Oracle JDK大多数的功能是开源的，一些功能是开源。Open JDK完全开源 Oracle JDK以前的1.0版以前的版本是由Sun开发的，后来被Oracle收购并为其他版本维护，而OpenJDK最初只基于Java SDK或JDK版本7 Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本 Oracle JDK将从其10.0.X版本将收费，用户必须付费或必须依赖OpenJDK才能使用其免费版本 Oracle JDK在运行JDK时不会产生任何问题，而OpenJDK在为某些用户运行JDK时会产生一些问题 在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能 Oracle JDK具有良好的GC选项和更好的渲染器，而OpenJDK具有更少的GC选项，并且由于其包含自己的渲染器的分布，因此具有较慢的图形渲染器选项 Oracle JDK的构建过程基于OpenJDK，因此OpenJDK与Oracle JDK之间没有技术差异 Oracle JDK将更多地关注稳定性，它重视更多的企业级用户，而OpenJDK经常发布以支持其他性能，这可能会导致不稳定 JDK与JVM的关系 JDK: Java Development ToolKit(java开发工具包)。JDK是整个java的核心，包括了运行环境，java工具和java的基础类库。\njvm:Java Virtual Machine(java虚拟机)。通过在实际的计算机上模拟仿真各种计算机功能来实现。\n使用JDK（调用JAVA API）开发JAVA程序后，通过JDK中的编译程序（javac）将Java程序编译为Java字节码，在JRE上运行这些字节码，JVM会解析并映射到真实操作系统的CPU指令集和OS的系统调用\n如何理解java是跨平台的语言 当java的源代码经过编译程序编译成字节码，需要运行在不同的平台上面时，无需编译。\n如何理解JVM是跨语言的平台 jvm面对的是字节码文件，只关心字节码文件，不关心何种编程语言，只要实现jvm规范即可。Java不是最强大的语言，但是JVM是最强大的虚拟机。\nJVM的类型 Sun Classic VM \u0026ndash;\u0026gt;解释型\nExact VM \u0026ndash;\u0026gt; Solaris\nSUN公司的 HotSpot VM\nBEA 的 JRockit \u0026ndash;\u0026gt; 不包含解释器，服务器端，JMC\nIBM 的 J9\nKVM和CDC/CLDC Hotspot\nAzul VM\nLiquid VM\nApache Harmony\nMicrosoft JVM\nTaobaoJVM\nGraal VM \u0026ndash;\u0026gt; 2018年,“Run Programs Faster Anywhere”\nDalvik VM : 安卓系统底层\n其他JVM：\nJava Card VM、Squawk VM、JavaInJava、Maxine VM、Jikes RVM、IKVM.NET、Jam VM、Cacao VM、Sable VM、Kaffe、Jelatine JVM、Nano VM、MRP、Moxie JVM\nJVM的生命周期 启动 java虚拟机的启动是由引导类加载器(bootstrap class loader)创建一个初始类(initial class)来完成的，这个类是由虚拟机指定\n退出 某线程调用Runtime类或System类的exit方法， 或Runtime类的halt方法【仅仅是拥有退出的机会】，并且在JAVA安全管理器允许这次exit或者halt方法操作会进行退出 程序正常执行结束 程序在执行过程中遇到了异常或错误进而终止 由于操作系统错误而导致java虚拟机进程终止 关于HotSpot 目前是java主流的虚拟机。\nsun的JDK版本从1.3.1开始运用HotSpot虚拟机，2006年底开源，主要实现是c++, JNI接口部分用C实现 HotSpot是比较新的虚拟机，使用JIT(Just In Time)编译器，可以大大提高java运行性能 Java原先是把源代码编译成字节码虚拟机执行，速度较慢。HosSpot将常用的部分编译分为本地（原生，native)代码，显著提高性能 HotSpot JVM参数分为规则参数和非规则参数。 规则参数相对稳定，在JDK未来的版本不太会有太大的改动 非规则参数则有升级JDK而改动的可能 JVM的架构（组成） 详细\n最上层：javac编译器将编译好的字节码class文件，通过java类装载器执行机制，把对象的class文件存放在jvm划分区域 中间层：称为Runtime Data Area 主要是Java代码运行时用于存放数据 最下层：解释器，JIT(just in time)编译器和GC(Garbage Collection 垃圾回收器) ","permalink":"https://AlfredNing.github.io/note/program/jvm/jvm%E5%88%9D%E8%AF%86/","summary":"JDK关系 Oracle JDK 与 Open JDK 关系\nOracle JDK是由oracle 公司开发的，Open JDK 是由IBM，Apple，SAP AG，Redhat等顶级公司合作开发 Oracle JDK大多数的功能是开源的，一些功能是开源。Open JDK完全开源 Oracle JDK以前的1.0版以前的版本是由Sun开发的，后来被Oracle收购并为其他版本维护，而OpenJDK最初只基于Java SDK或JDK版本7 Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本 Oracle JDK将从其10.0.X版本将收费，用户必须付费或必须依赖OpenJDK才能使用其免费版本 Oracle JDK在运行JDK时不会产生任何问题，而OpenJDK在为某些用户运行JDK时会产生一些问题 在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能 Oracle JDK具有良好的GC选项和更好的渲染器，而OpenJDK具有更少的GC选项，并且由于其包含自己的渲染器的分布，因此具有较慢的图形渲染器选项 Oracle JDK的构建过程基于OpenJDK，因此OpenJDK与Oracle JDK之间没有技术差异 Oracle JDK将更多地关注稳定性，它重视更多的企业级用户，而OpenJDK经常发布以支持其他性能，这可能会导致不稳定 JDK与JVM的关系 JDK: Java Development ToolKit(java开发工具包)。JDK是整个java的核心，包括了运行环境，java工具和java的基础类库。\njvm:Java Virtual Machine(java虚拟机)。通过在实际的计算机上模拟仿真各种计算机功能来实现。\n使用JDK（调用JAVA API）开发JAVA程序后，通过JDK中的编译程序（javac）将Java程序编译为Java字节码，在JRE上运行这些字节码，JVM会解析并映射到真实操作系统的CPU指令集和OS的系统调用\n如何理解java是跨平台的语言 当java的源代码经过编译程序编译成字节码，需要运行在不同的平台上面时，无需编译。\n如何理解JVM是跨语言的平台 jvm面对的是字节码文件，只关心字节码文件，不关心何种编程语言，只要实现jvm规范即可。Java不是最强大的语言，但是JVM是最强大的虚拟机。\nJVM的类型 Sun Classic VM \u0026ndash;\u0026gt;解释型\nExact VM \u0026ndash;\u0026gt; Solaris\nSUN公司的 HotSpot VM\nBEA 的 JRockit \u0026ndash;\u0026gt; 不包含解释器，服务器端，JMC\nIBM 的 J9\nKVM和CDC/CLDC Hotspot","title":"Jvm初识"},{"content":"指导思想 可维护性：修改功能少，需要改动的地方越少，可维护性越好 可复用性：代码被以后重复使用，写出自己总结的类库 可扩展性：添加功能无需修改原来的代码 灵活性：代码接口可以灵活调用 原则 单一职责原则 SRP 一个类别太大，别太累。负责单一的职责 高内聚，低耦合 开闭原则 OCP 对扩展开放，对修改关闭：尽量不修改原来的代码进行扩展 抽象化，多态是开闭原则的关键 里氏替换原则 LSP 所有使用父类的方法，必须能够透明的使用子类对象 依赖倒置原则 DIP 依赖抽象，而不是依赖具体 面向抽象/接口编程 接口隔离原则 ISP 每一个接口应该承担独立的角色，不干自己不该干的事情 避免子类不需要实现的方法 需要对客户提供接口的时候，只需要暴露最小的接口 迪米特法则 LOD 尽量不要和陌生人说话 在迪米特法则中，对于一个对象，非陌生人包含以下几类 当前对象本身this 以参数形式传入到当前对象方法中的对象 当前对象的成员对象 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友 当前对象所创建的对象 和其它类的耦合度变低 工具类例外 ","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/","summary":"指导思想 可维护性：修改功能少，需要改动的地方越少，可维护性越好 可复用性：代码被以后重复使用，写出自己总结的类库 可扩展性：添加功能无需修改原来的代码 灵活性：代码接口可以灵活调用 原则 单一职责原则 SRP 一个类别太大，别太累。负责单一的职责 高内聚，低耦合 开闭原则 OCP 对扩展开放，对修改关闭：尽量不修改原来的代码进行扩展 抽象化，多态是开闭原则的关键 里氏替换原则 LSP 所有使用父类的方法，必须能够透明的使用子类对象 依赖倒置原则 DIP 依赖抽象，而不是依赖具体 面向抽象/接口编程 接口隔离原则 ISP 每一个接口应该承担独立的角色，不干自己不该干的事情 避免子类不需要实现的方法 需要对客户提供接口的时候，只需要暴露最小的接口 迪米特法则 LOD 尽量不要和陌生人说话 在迪米特法则中，对于一个对象，非陌生人包含以下几类 当前对象本身this 以参数形式传入到当前对象方法中的对象 当前对象的成员对象 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友 当前对象所创建的对象 和其它类的耦合度变低 工具类例外 ","title":"设计原则"},{"content":" 解释器模式是类的行为模式。给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子\n角色 抽象表达式(Expression)角色：声明一个所有的具体表达式角色都需要实现的抽象接口。这个接口主要是一个interpret()方法，称做解释操作 终结符表达式(Terminal Expression)角色：实现了抽象表达式角色所要求的接口 非终结符表达式(Nonterminal Expression)角色：文法中的每一条规则都需要一个具体的非终结符表达式 环境(Context)角色：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值 示例代码\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/","summary":"解释器模式是类的行为模式。给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子\n角色 抽象表达式(Expression)角色：声明一个所有的具体表达式角色都需要实现的抽象接口。这个接口主要是一个interpret()方法，称做解释操作 终结符表达式(Terminal Expression)角色：实现了抽象表达式角色所要求的接口 非终结符表达式(Nonterminal Expression)角色：文法中的每一条规则都需要一个具体的非终结符表达式 环境(Context)角色：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值 示例代码","title":"解释器模式"},{"content":" 状态模式，状态对象行为模式。允许对一个对象在其内部状态改变的时候改变其行为。这个对象看上去就像是改变了它的类一样\n状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变\n角色 环境角色:定义客户端所感兴趣的接口，并且保留一个具体状态类的实例。这个具体状态类的实例给出此环境对象的现有状态 抽象状态(State)角色：定义一个接口，用以封装环境（Context）对象的一个特定的状态所对应的行为 具体状态(ConcreteState)角色：每一个具体状态类都实现了环境（Context）的一个状态所对应的行为 认识状态模式 状态和行为\n所谓对象的状态，通常指的就是对象实例的属性的值；而行为指的就是对象的功能，再具体点说，行为大多可以对应到方法上。\n状态模式的功能就是分离状态的行为，通过维护状态的变化，来调用不同状态对应的不同功能。也就是说，状态和行为是相关联的，它们的关系可以描述为：状态决定行为。\n由于状态是在运行期被改变的，因此行为也会在运行期根据状态的改变而改变。\n行为的平行性\n注意平行线而不是平等性。所谓平行性指的是各个状态的行为所处的层次是一样的，相互独立的、没有关联的，是根据不同的状态来决定到底走平行线的哪一条。行为是不同的，当然对应的实现也是不同的，相互之间是不可替换的。\n策略模式的比较\n状态模式的结构和策略模式的结构完全一样，但是，它们的目的、实现、本质却是完全不一样的。还有行为之间的特性也是状态模式和策略模式一个很重要的区别，状态模式的行为是平行性的，不可相互替换的；而策略模式的行为是平等性的，是可以相互替换的。\n环境和状态处理对象\n在状态模式中，环境(Context)是持有状态的对象，但是环境(Context)自身并不处理跟状态相关的行为，而是把处理状态的功能委托给了状态对应的状态处理类来处理。\n在具体的状态处理类中经常需要获取环境(Context)自身的数据，甚至在必要的时候会回调环境(Context)的方法，因此，通常将环境(Context)自身当作一个参数传递给具体的状态处理类。\n客户端一般只和环境(Context)交互。客户端可以用状态对象来配置一个环境(Context)，一旦配置完毕，就不再需要和状态对象打交道了。客户端通常不负责运行期间状态的维护，也不负责决定后续到底使用哪一个具体的状态处理对象\n示例代码\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/","summary":"状态模式，状态对象行为模式。允许对一个对象在其内部状态改变的时候改变其行为。这个对象看上去就像是改变了它的类一样\n状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变\n角色 环境角色:定义客户端所感兴趣的接口，并且保留一个具体状态类的实例。这个具体状态类的实例给出此环境对象的现有状态 抽象状态(State)角色：定义一个接口，用以封装环境（Context）对象的一个特定的状态所对应的行为 具体状态(ConcreteState)角色：每一个具体状态类都实现了环境（Context）的一个状态所对应的行为 认识状态模式 状态和行为\n所谓对象的状态，通常指的就是对象实例的属性的值；而行为指的就是对象的功能，再具体点说，行为大多可以对应到方法上。\n状态模式的功能就是分离状态的行为，通过维护状态的变化，来调用不同状态对应的不同功能。也就是说，状态和行为是相关联的，它们的关系可以描述为：状态决定行为。\n由于状态是在运行期被改变的，因此行为也会在运行期根据状态的改变而改变。\n行为的平行性\n注意平行线而不是平等性。所谓平行性指的是各个状态的行为所处的层次是一样的，相互独立的、没有关联的，是根据不同的状态来决定到底走平行线的哪一条。行为是不同的，当然对应的实现也是不同的，相互之间是不可替换的。\n策略模式的比较\n状态模式的结构和策略模式的结构完全一样，但是，它们的目的、实现、本质却是完全不一样的。还有行为之间的特性也是状态模式和策略模式一个很重要的区别，状态模式的行为是平行性的，不可相互替换的；而策略模式的行为是平等性的，是可以相互替换的。\n环境和状态处理对象\n在状态模式中，环境(Context)是持有状态的对象，但是环境(Context)自身并不处理跟状态相关的行为，而是把处理状态的功能委托给了状态对应的状态处理类来处理。\n在具体的状态处理类中经常需要获取环境(Context)自身的数据，甚至在必要的时候会回调环境(Context)的方法，因此，通常将环境(Context)自身当作一个参数传递给具体的状态处理类。\n客户端一般只和环境(Context)交互。客户端可以用状态对象来配置一个环境(Context)，一旦配置完毕，就不再需要和状态对象打交道了。客户端通常不负责运行期间状态的维护，也不负责决定后续到底使用哪一个具体的状态处理对象\n示例代码","title":"状态模式"},{"content":" 类的行为模式。使用示例：Servlet的应用\n抽象类：将部分逻辑以具体的方法以及具体的构造函数的形式实现。然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的实现方式实现这些抽象方法，从而对剩余逻辑有不同的实现。\n模板方法所代表的行为称为顶级行为，其逻辑称为顶级逻辑\n角色 抽象模板：顶层逻辑骨架 具体模板：具体实现顶层逻辑 子类可以置换掉父类的可变部分，但是子类却不可以改变模板方法所代表的顶级逻辑\n方法 模板方法：一个抽象类可以有任意多个模板方法，而不限于一个。每一个模板方法都可以调用任意多个具体方法 基本方法： 抽象方法：一个抽象方法由抽象类声明，由具体子类实现 具体方法：一个具体方法由抽象类声明并实现，而子类并不实现或置换 钩子方法：一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个空实现，作为方法的默认实现 示例代码\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","summary":"类的行为模式。使用示例：Servlet的应用\n抽象类：将部分逻辑以具体的方法以及具体的构造函数的形式实现。然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的实现方式实现这些抽象方法，从而对剩余逻辑有不同的实现。\n模板方法所代表的行为称为顶级行为，其逻辑称为顶级逻辑\n角色 抽象模板：顶层逻辑骨架 具体模板：具体实现顶层逻辑 子类可以置换掉父类的可变部分，但是子类却不可以改变模板方法所代表的顶级逻辑\n方法 模板方法：一个抽象类可以有任意多个模板方法，而不限于一个。每一个模板方法都可以调用任意多个具体方法 基本方法： 抽象方法：一个抽象方法由抽象类声明，由具体子类实现 具体方法：一个具体方法由抽象类声明并实现，而子类并不实现或置换 钩子方法：一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个空实现，作为方法的默认实现 示例代码","title":"模板方法模式"},{"content":" 对象的行为模式。又称为快照模式，对象的行为模式。一个用来存储另外一个对象内部状态的快照对象。\n指在不破坏封装的条件下，将一个对象的状态捕捉住，并且外部化，进行存储，从而可以在将来合适的时候把这个对象还原存储起来的状态。备忘录模式常常与命令模式和迭代子模式一同使用\n角色 备忘录角色 备忘录角色又如下责任：\n（1）将发起人（Originator）对象的内战状态存储起来。备忘录可以根据发起人对象的判断来决定存储多少发起人（Originator）对象的内部状态。\n（2）备忘录可以保护其内容不被发起人（Originator）对象之外的任何对象所读取。\n备忘录有两个等效的接口：\n●　**窄接口：**负责人（Caretaker）对象（和其他除发起人对象之外的任何对象）看到的是备忘录的窄接口(narrow interface)，这个窄接口只允许它把备忘录对象传给其他的对象。\n●　**宽接口：**与负责人对象看到的窄接口相反的是，发起人对象可以看到一个宽接口(wide interface)，这个宽接口允许它读取所有的数据，以便根据这些数据恢复这个发起人对象的内部状态。\n发起人角色 发起人角色有如下责任：\n（1）创建一个含有当前的内部状态的备忘录对象。\n（2）使用备忘录对象存储其内部状态。\n负责人角色 负责人角色有如下责任：\n（1）负责保存备忘录对象。\n（2）不检查备忘录对象的内容。\n示例代码\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/","summary":"对象的行为模式。又称为快照模式，对象的行为模式。一个用来存储另外一个对象内部状态的快照对象。\n指在不破坏封装的条件下，将一个对象的状态捕捉住，并且外部化，进行存储，从而可以在将来合适的时候把这个对象还原存储起来的状态。备忘录模式常常与命令模式和迭代子模式一同使用\n角色 备忘录角色 备忘录角色又如下责任：\n（1）将发起人（Originator）对象的内战状态存储起来。备忘录可以根据发起人对象的判断来决定存储多少发起人（Originator）对象的内部状态。\n（2）备忘录可以保护其内容不被发起人（Originator）对象之外的任何对象所读取。\n备忘录有两个等效的接口：\n●　**窄接口：**负责人（Caretaker）对象（和其他除发起人对象之外的任何对象）看到的是备忘录的窄接口(narrow interface)，这个窄接口只允许它把备忘录对象传给其他的对象。\n●　**宽接口：**与负责人对象看到的窄接口相反的是，发起人对象可以看到一个宽接口(wide interface)，这个宽接口允许它读取所有的数据，以便根据这些数据恢复这个发起人对象的内部状态。\n发起人角色 发起人角色有如下责任：\n（1）创建一个含有当前的内部状态的备忘录对象。\n（2）使用备忘录对象存储其内部状态。\n负责人角色 负责人角色有如下责任：\n（1）负责保存备忘录对象。\n（2）不检查备忘录对象的内容。\n示例代码","title":"备忘录模式"},{"content":" 对象的创建模式。通过一个原型对象来指明所有创建的对象的类型，然后复用这个原型对象的方法来创建出更多同类型的对象。\n实现一个自身可以克隆的接口\n分类 简单形式 角色：\n客户角色 抽象原型角色 具体原型角色 登记形式 角色：\n客户角色 抽象原型角色 具体原型角色 原型管理角色 两种形式的比较 简单形式和登记形式的原型模式各有其长处和短处。\n如果需要创建的原型对象数目较少而且比较固定的话，可以采取第一种形式。在这种情况下，原型对象的引用可以由客户端自己保存。\n如果要创建的原型对象数目不固定的话，可以采取第二种形式。在这种情况下，客户端不保存对原型对象的引用，这个任务被交给管理员对象。在复制一个原型对象之前，客户端可以查看管理员对象是否已经有一个满足要求的原型对象。如果有，可以直接从管理员类取得这个对象引用；如果没有，客户端就需要自行复制此原型对象。\nJava中的克隆方法 Java的所有类都是从java.lang.Object类继承而来的，而Object类提供protected Object clone()方法对对象进行复制，子类当然也可以把这个方法置换掉，提供满足自己需要的复制方法。对象的复制有一个基本问题，就是对象通常都有对其他的对象的引用。当使用Object类的clone()方法来复制一个对象时，此对象对其他对象的引用也同时会被复制一份\nJava语言提供的Cloneable接口只起一个作用，就是在运行时期通知Java虚拟机可以安全地在这个类上使用clone()方法。通过调用这个clone()方法可以得到一个对象的复制。由于Object类本身并不实现Cloneable接口，因此如果所考虑的类没有实现Cloneable接口时，调用clone()方法会抛出CloneNotSupportedException异常。\n原型模式的优点 原型模式允许在运行时动态改变具体的实现类型。原型模式可以在运行期间，由客户来注册符合原型接口的实现类型，也可以动态地改变具体的实现类型，看起来接口没有任何变化，但其实运行的已经是另外一个类实例了。因为克隆一个原型就类似于实例化一个类。\n原型模式的缺点 原型模式最主要的缺点是每一个类都必须配备一个克隆方法。配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类来说不是很难，而对于已经有的类不一定很容易，特别是当一个类引用不支持序列化的间接对象，或者引用含有循环结构的时候。\n示例代码\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","summary":"对象的创建模式。通过一个原型对象来指明所有创建的对象的类型，然后复用这个原型对象的方法来创建出更多同类型的对象。\n实现一个自身可以克隆的接口\n分类 简单形式 角色：\n客户角色 抽象原型角色 具体原型角色 登记形式 角色：\n客户角色 抽象原型角色 具体原型角色 原型管理角色 两种形式的比较 简单形式和登记形式的原型模式各有其长处和短处。\n如果需要创建的原型对象数目较少而且比较固定的话，可以采取第一种形式。在这种情况下，原型对象的引用可以由客户端自己保存。\n如果要创建的原型对象数目不固定的话，可以采取第二种形式。在这种情况下，客户端不保存对原型对象的引用，这个任务被交给管理员对象。在复制一个原型对象之前，客户端可以查看管理员对象是否已经有一个满足要求的原型对象。如果有，可以直接从管理员类取得这个对象引用；如果没有，客户端就需要自行复制此原型对象。\nJava中的克隆方法 Java的所有类都是从java.lang.Object类继承而来的，而Object类提供protected Object clone()方法对对象进行复制，子类当然也可以把这个方法置换掉，提供满足自己需要的复制方法。对象的复制有一个基本问题，就是对象通常都有对其他的对象的引用。当使用Object类的clone()方法来复制一个对象时，此对象对其他对象的引用也同时会被复制一份\nJava语言提供的Cloneable接口只起一个作用，就是在运行时期通知Java虚拟机可以安全地在这个类上使用clone()方法。通过调用这个clone()方法可以得到一个对象的复制。由于Object类本身并不实现Cloneable接口，因此如果所考虑的类没有实现Cloneable接口时，调用clone()方法会抛出CloneNotSupportedException异常。\n原型模式的优点 原型模式允许在运行时动态改变具体的实现类型。原型模式可以在运行期间，由客户来注册符合原型接口的实现类型，也可以动态地改变具体的实现类型，看起来接口没有任何变化，但其实运行的已经是另外一个类实例了。因为克隆一个原型就类似于实例化一个类。\n原型模式的缺点 原型模式最主要的缺点是每一个类都必须配备一个克隆方法。配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类来说不是很难，而对于已经有的类不一定很容易，特别是当一个类引用不支持序列化的间接对象，或者引用含有循环结构的时候。\n示例代码","title":"原型模式"},{"content":" 命令模式属于对象的行为模式，又成交易模式或行动模式。　命令模式把一个请求或者操作封装到一个对象中。命令模式允许系统使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能\n角色 命令角色 具体命令角色 请求者角色 接收者角色 客户端角色 优点 更松散的耦合 更动态的控制 很自然的复合命令 更好的扩展性 代码示例\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/","summary":"命令模式属于对象的行为模式，又成交易模式或行动模式。　命令模式把一个请求或者操作封装到一个对象中。命令模式允许系统使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能\n角色 命令角色 具体命令角色 请求者角色 接收者角色 客户端角色 优点 更松散的耦合 更动态的控制 很自然的复合命令 更好的扩展性 代码示例","title":"命令模式"},{"content":" 将抽象部分与实现部分相分离，使他们都可以独立的变化。结构式模式\n角色 实现接口 抽象接口 具体实现 具体抽象实现 应用 具体到实际应用上，需要将抽象与实现分离开来，对客户端无感知的一种行为。\n示例代码\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/","summary":"将抽象部分与实现部分相分离，使他们都可以独立的变化。结构式模式\n角色 实现接口 抽象接口 具体实现 具体抽象实现 应用 具体到实际应用上，需要将抽象与实现分离开来，对客户端无感知的一种行为。\n示例代码","title":"桥接模式"},{"content":" 把一个类的接口变成客户端所期待的另一种接口，从而使原本因接口不匹配而无法完成一起工作的两个类可以一起工作\n结构 类的适配器模式 对象的适配器模式 类的适配器模式 把适配类的API转换成目标API\n角色：\n●　目标(Target)角色：这就是所期待得到的接口。注意：由于这里讨论的是类适配器模式，因此目标不可以是类。\n●　源(Adapee)角色：现在需要适配的接口。\n●　适配器(Adaper)角色：适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。\n对象的适配器模式 类的适配器模式一样，对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类\n类适配器和对象适配器的权衡 ●　类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。\n●　对于类适配器，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静态的关系，当适配器继承了Adaptee后，就不可能再去处理 Adaptee的子类了。\n对于对象适配器，一个适配器可以把多种不同的源适配到同一个目标。换言之，同一个适配器可以把源类和它的子类都适配到目标接口。因为对象适配器采用的是对象组合的关系，只要对象类型正确，是不是子类都无所谓。\n●　对于类适配器，适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。\n对于对象适配器，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。\n●　对于类适配器，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。\n对于对象适配器，需要额外的引用来间接得到Adaptee。\n建议尽量使用对象适配器的实现方式，多用合成/聚合、少用继承。当然，具体问题具体分析，根据需要来选用实现方式，最适合的才是最好的\n优点 复用性 扩展性 缺点 过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构\n代码示例\n缺省适配器模式 抽象类中实现顶层接口的默认实现\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","summary":"把一个类的接口变成客户端所期待的另一种接口，从而使原本因接口不匹配而无法完成一起工作的两个类可以一起工作\n结构 类的适配器模式 对象的适配器模式 类的适配器模式 把适配类的API转换成目标API\n角色：\n●　目标(Target)角色：这就是所期待得到的接口。注意：由于这里讨论的是类适配器模式，因此目标不可以是类。\n●　源(Adapee)角色：现在需要适配的接口。\n●　适配器(Adaper)角色：适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。\n对象的适配器模式 类的适配器模式一样，对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类\n类适配器和对象适配器的权衡 ●　类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。\n●　对于类适配器，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静态的关系，当适配器继承了Adaptee后，就不可能再去处理 Adaptee的子类了。\n对于对象适配器，一个适配器可以把多种不同的源适配到同一个目标。换言之，同一个适配器可以把源类和它的子类都适配到目标接口。因为对象适配器采用的是对象组合的关系，只要对象类型正确，是不是子类都无所谓。\n●　对于类适配器，适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。\n对于对象适配器，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。\n●　对于类适配器，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。\n对于对象适配器，需要额外的引用来间接得到Adaptee。\n建议尽量使用对象适配器的实现方式，多用合成/聚合、少用继承。当然，具体问题具体分析，根据需要来选用实现方式，最适合的才是最好的\n优点 复用性 扩展性 缺点 过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构\n代码示例\n缺省适配器模式 抽象类中实现顶层接口的默认实现","title":"适配器模式"},{"content":" 分离对象的的属性与创建过程，用户创建重的对象。\n写法分类：\n在Builder里面直接new对象的方式，MyBatis的SqlSessionFactoryBuilder就是这种写法，适用于属性之间关联不多且大量属性都有默认值的场景。 间接new的方式：例如Guava的Cache都是这种写法，适用于属性之间有一定关联性的场景。 建造者模式的优点及适用场景\n建造者模式这种设计模式，优缺点比较明显。从优点来说：\n客户端不比知道产品内部细节，将产品本身与产品创建过程解耦，使得相同的创建过程可以创建不同的产品对象 可以更加精细地控制产品的创建过程，将复杂对象分门别类抽出不同的类别来，使得开发者可以更加方便地得到想要的产品 想了想，说缺点，建造者模式说不上缺点，只能说这种设计模式的使用比较受限：\n产品属性之间差异很大且属性没有默认值可以指定，这种情况是没法使用建造者模式的，我们可以试想，一个对象20个属性，彼此之间毫无关联且每个都需要手动指定，那么很显然，即使使用了建造者模式也是毫无作用 代码示例\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E6%9E%84%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/","summary":"分离对象的的属性与创建过程，用户创建重的对象。\n写法分类：\n在Builder里面直接new对象的方式，MyBatis的SqlSessionFactoryBuilder就是这种写法，适用于属性之间关联不多且大量属性都有默认值的场景。 间接new的方式：例如Guava的Cache都是这种写法，适用于属性之间有一定关联性的场景。 建造者模式的优点及适用场景\n建造者模式这种设计模式，优缺点比较明显。从优点来说：\n客户端不比知道产品内部细节，将产品本身与产品创建过程解耦，使得相同的创建过程可以创建不同的产品对象 可以更加精细地控制产品的创建过程，将复杂对象分门别类抽出不同的类别来，使得开发者可以更加方便地得到想要的产品 想了想，说缺点，建造者模式说不上缺点，只能说这种设计模式的使用比较受限：\n产品属性之间差异很大且属性没有默认值可以指定，这种情况是没法使用建造者模式的，我们可以试想，一个对象20个属性，彼此之间毫无关联且每个都需要手动指定，那么很显然，即使使用了建造者模式也是毫无作用 代码示例","title":"构建者模式"},{"content":" 对象的行为模式。在不修改已有程序的前提下，通过添加额外的访问者来完成对已有代码功能的提升。\n将数据结构与操作分离\n角色：\n抽象访问者: 声明了一个或者多个方法操作，形成所有的具体访问者角色必须实现的接口 具体访问者: 实现抽象访问者所声明的接口，也就是抽象访问者所声明的各个访问操作 抽象节点: 声明一个接受操作，接受一个访问者对象作为一个参数 具体节点: 实现了抽象节点所规定的接受操作 结构对象: 遍历结构的元素 访问者模式优点：\n扩展性好，可以在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能； 符合单一职责原则，通过访问者将无关的行为分离，使职责单一；\n访问者模式缺点：\n违反了迪米特原则，因为具体元素对访问者公布细节； 违反了依赖倒置原则，依赖了具体类，没有依赖抽象； 对象结构变化困难，若对象结构发生了改变，访问者的接口和访问者的实现也都要发生相应的改变；\n使用场景：\n对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作； 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作\u0026quot;污染\u0026quot;这些对象的类，也不希望在增加新操作时修改这些类。\n访问者模式示例\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/","summary":"对象的行为模式。在不修改已有程序的前提下，通过添加额外的访问者来完成对已有代码功能的提升。\n将数据结构与操作分离\n角色：\n抽象访问者: 声明了一个或者多个方法操作，形成所有的具体访问者角色必须实现的接口 具体访问者: 实现抽象访问者所声明的接口，也就是抽象访问者所声明的各个访问操作 抽象节点: 声明一个接受操作，接受一个访问者对象作为一个参数 具体节点: 实现了抽象节点所规定的接受操作 结构对象: 遍历结构的元素 访问者模式优点：\n扩展性好，可以在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能； 符合单一职责原则，通过访问者将无关的行为分离，使职责单一；\n访问者模式缺点：\n违反了迪米特原则，因为具体元素对访问者公布细节； 违反了依赖倒置原则，依赖了具体类，没有依赖抽象； 对象结构变化困难，若对象结构发生了改变，访问者的接口和访问者的实现也都要发生相应的改变；\n使用场景：\n对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作； 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作\u0026quot;污染\u0026quot;这些对象的类，也不希望在增加新操作时修改这些类。\n访问者模式示例","title":"访问者模式"},{"content":" 迭代器模式又叫做游标模式，作用：提供一种方法访问一个容器元素中的各个对象，而又不暴露该对象的内部细节\n角色：\n迭代器角色 具体迭代器角色 容器角色 具体容器角色 ","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/","summary":" 迭代器模式又叫做游标模式，作用：提供一种方法访问一个容器元素中的各个对象，而又不暴露该对象的内部细节\n角色：\n迭代器角色 具体迭代器角色 容器角色 具体容器角色 ","title":"迭代器模式"},{"content":" 代理模式是一种使用代理对象来执行目标对象的方法并在代理对象中增强目标对象方法的一种设计模式\n静态代理 动态代理 静态代理的特点如下：\n使用静态代理时，通常客户类不需要感知RealSubject。 静态代理的缺点：代理对象需要与目标对象实现一样的接口，因此接口较多时需要定义和维护大量的代理类代码。 与适配器的差异：适配器通常考虑改变接口形态，而代理则不会也不能改变接口形态。 与装饰器的差异：被代理对象由代理对象创建，客户端甚至不需要知道被代理类的存在；被装饰对象则由客户端创建并传给装饰对象，可以层层嵌套，层层装饰。代理模式常用于控制被代理对象的访问，而装饰模式是增加被装饰者的功能。\nJDK动态代理的特点如下：\n通过实现InvocationHandler接口完成代理逻辑。 通过反射代理方法，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。 代理类必须实现接口。 代理模式\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","summary":"代理模式是一种使用代理对象来执行目标对象的方法并在代理对象中增强目标对象方法的一种设计模式\n静态代理 动态代理 静态代理的特点如下：\n使用静态代理时，通常客户类不需要感知RealSubject。 静态代理的缺点：代理对象需要与目标对象实现一样的接口，因此接口较多时需要定义和维护大量的代理类代码。 与适配器的差异：适配器通常考虑改变接口形态，而代理则不会也不能改变接口形态。 与装饰器的差异：被代理对象由代理对象创建，客户端甚至不需要知道被代理类的存在；被装饰对象则由客户端创建并传给装饰对象，可以层层嵌套，层层装饰。代理模式常用于控制被代理对象的访问，而装饰模式是增加被装饰者的功能。\nJDK动态代理的特点如下：\n通过实现InvocationHandler接口完成代理逻辑。 通过反射代理方法，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。 代理类必须实现接口。 代理模式","title":"代理模式"},{"content":" 对象的结构模式，以共享的方式高效的支持大量的细粒度对象\njava中String类型就是享元模式 享元模式采用一个共享来避免大量拥有相同内容对象的开销\n分类 单纯享元模式 所有的享元对象都是可以共享的\n角色：\n抽象享元(Flyweight)角色：抽象接口 具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口 享元工厂(FlyweightFactory)角色：本角色负责创建和管理享元角色 复合享元模式 抽象享元(Flyweight)角色：抽象接口 具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口 复合享元角色：复合享元角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解成为多个本身是单纯享元对象的组合。复合享元角色又称作不可共享的享元对象 享元工厂(FlyweightFactory)角色：本角色负责创建和管理享元角色 ","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/","summary":" 对象的结构模式，以共享的方式高效的支持大量的细粒度对象\njava中String类型就是享元模式 享元模式采用一个共享来避免大量拥有相同内容对象的开销\n分类 单纯享元模式 所有的享元对象都是可以共享的\n角色：\n抽象享元(Flyweight)角色：抽象接口 具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口 享元工厂(FlyweightFactory)角色：本角色负责创建和管理享元角色 复合享元模式 抽象享元(Flyweight)角色：抽象接口 具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口 复合享元角色：复合享元角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解成为多个本身是单纯享元对象的组合。复合享元角色又称作不可共享的享元对象 享元工厂(FlyweightFactory)角色：本角色负责创建和管理享元角色 ","title":"享元模式"},{"content":" 描述部分与整体的关系，组装树形结构\n角色 抽象构件角色 树叶构件角色 树枝构件角色 分类 透明式：在该方式中，由于抽象构件声明了所有子类中的全部方法，所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的 安全式：在该方式中，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题，但由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性 组合模式代码\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/","summary":"描述部分与整体的关系，组装树形结构\n角色 抽象构件角色 树叶构件角色 树枝构件角色 分类 透明式：在该方式中，由于抽象构件声明了所有子类中的全部方法，所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的 安全式：在该方式中，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题，但由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性 组合模式代码","title":"组合模式"},{"content":" 观察者模式-对象行为模式。发布/订阅模式，模型-视图模式、源-监听器模式，从属者模式。\n定义一对多的依赖关系，让多个观察者同时监听某一个主题对象。这个对象在状态上发生变化时，会通知所有观察者对象，是它们能够主动更新自己的状态。\n角色：\n抽象主题角色：提供一个接口，可以增加和减少观察者对象，抽象主题角色又叫做抽象被观察者角色。 具体主题角色：将有关状态存入具体观察者对象 抽象观察者角色：为所有的观察者提供一个接口，在得到主题的通知时更新自己。 具体观察者角色：存储与主题状态自恰的状态。 模式分类：\n推模式\n主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。\n拉模式 主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。\njava对观察者模式的支持\nObserver接口： 观察者 Observable类： 被观察者 示例代码\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","summary":"观察者模式-对象行为模式。发布/订阅模式，模型-视图模式、源-监听器模式，从属者模式。\n定义一对多的依赖关系，让多个观察者同时监听某一个主题对象。这个对象在状态上发生变化时，会通知所有观察者对象，是它们能够主动更新自己的状态。\n角色：\n抽象主题角色：提供一个接口，可以增加和减少观察者对象，抽象主题角色又叫做抽象被观察者角色。 具体主题角色：将有关状态存入具体观察者对象 抽象观察者角色：为所有的观察者提供一个接口，在得到主题的通知时更新自己。 具体观察者角色：存储与主题状态自恰的状态。 模式分类：\n推模式\n主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。\n拉模式 主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。\njava对观察者模式的支持\nObserver接口： 观察者 Observable类： 被观察者 示例代码","title":"观察者模式"},{"content":" 对象的行为模式，允许你将请求沿着处理链进行发送。收到请求后，每个处理者可对请求进行处理，或将其传递给链上的下个处理者\n角色：\n抽象处理者：定义处理请求的接口。 具体处理者：具体处理者接到请求，可以将请求处理，或者将请求传给下家。 示例代码\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/","summary":"对象的行为模式，允许你将请求沿着处理链进行发送。收到请求后，每个处理者可对请求进行处理，或将其传递给链上的下个处理者\n角色：\n抽象处理者：定义处理请求的接口。 具体处理者：具体处理者接到请求，可以将请求处理，或者将请求传给下家。 示例代码","title":"责任链模式"},{"content":" 动态的将责任添加到对象上，动态添加功能。\n分类：\n父组件，供子组件使用 装饰者：组合其他组件，一部分功能是自己的，调用被装饰者，等同于保留被装饰者的功能 具体组件：实现具体方法 饮料添加各种配料，返回最终的价格。\n代码示例\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/","summary":"动态的将责任添加到对象上，动态添加功能。\n分类：\n父组件，供子组件使用 装饰者：组合其他组件，一部分功能是自己的，调用被装饰者，等同于保留被装饰者的功能 具体组件：实现具体方法 饮料添加各种配料，返回最终的价格。\n代码示例","title":"装饰者模式"},{"content":" 门面模式对外，调停者模式对内\n对象的行为模式，调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显引用。从而使它们可以较松散地耦合。当这些对象中的某些对象之间的相互作用发生改变时，不会立即影响到其他的一些对象之间的相互作用。从而保证这些相互作用可以彼此独立地变化\n角色：\n抽象调停者角色 具体调停者角色 抽象同事类角色 具体公式类角色 示例代码\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E8%B0%83%E5%81%9C%E8%80%85%E6%A8%A1%E5%BC%8F/","summary":"门面模式对外，调停者模式对内\n对象的行为模式，调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显引用。从而使它们可以较松散地耦合。当这些对象中的某些对象之间的相互作用发生改变时，不会立即影响到其他的一些对象之间的相互作用。从而保证这些相互作用可以彼此独立地变化\n角色：\n抽象调停者角色 具体调停者角色 抽象同事类角色 具体公式类角色 示例代码","title":"调停者模式"},{"content":" 提供高层次的接口，统一门面对象进行，使得子系统易于使用。\n选择性的暴露方法\n角色分类：\n门面角色: 客户端可以调用这个角色的方法 子系统角色：可以同时有一个或者多个子系统 门面模式示例代码\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/","summary":"提供高层次的接口，统一门面对象进行，使得子系统易于使用。\n选择性的暴露方法\n角色分类：\n门面角色: 客户端可以调用这个角色的方法 子系统角色：可以同时有一个或者多个子系统 门面模式示例代码","title":"门面模式"},{"content":" 任何可以产生对象的方法和类，都可以被称为工厂。\n创建型设计模式，父类提供创建对象的方法，允许子类决定实例化对象的类型\n分类 根据产品是具体产品还是具体工厂：\n简单工厂模式 工厂方法模式 根据工厂的抽象程度\n工厂方法模式 抽象工厂模式 简单工厂模式 只对不同类对象的创建进行了一层薄薄的封装，通过向工厂传递类型来指定要创建的对象。\n工厂方法模式 工厂方法模式将生产具体产品的任务分发给具体的产品工厂\n抽象工厂模式 针对不同产品的创建。在工厂方法模式下，在抽象工厂里面增加创建产品的接口，并在具体子工厂中实现产品的创建\n工厂模式代码示例合\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","summary":"任何可以产生对象的方法和类，都可以被称为工厂。\n创建型设计模式，父类提供创建对象的方法，允许子类决定实例化对象的类型\n分类 根据产品是具体产品还是具体工厂：\n简单工厂模式 工厂方法模式 根据工厂的抽象程度\n工厂方法模式 抽象工厂模式 简单工厂模式 只对不同类对象的创建进行了一层薄薄的封装，通过向工厂传递类型来指定要创建的对象。\n工厂方法模式 工厂方法模式将生产具体产品的任务分发给具体的产品工厂\n抽象工厂模式 针对不同产品的创建。在工厂方法模式下，在抽象工厂里面增加创建产品的接口，并在具体子工厂中实现产品的创建\n工厂模式代码示例合","title":"工厂模式"},{"content":" 对于做同一件事有多种方法，Comparator接口。\nContext：环境类 Strategy: 抽象策略类 ConcreteStrategy: 具体策略类 使用场景 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。\n策略模式示例代码\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","summary":"对于做同一件事有多种方法，Comparator接口。\nContext：环境类 Strategy: 抽象策略类 ConcreteStrategy: 具体策略类 使用场景 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。\n策略模式示例代码","title":"策略模式"},{"content":" 保持内存中只有一个对象\n分类：\n是否加载实例\n饿汉式 饱汉式 是否线程安全\n安全 不安全 特殊实现方式：\n静态内部类 枚举 单例模式代码\n","permalink":"https://AlfredNing.github.io/note/program/design_pattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","summary":"保持内存中只有一个对象\n分类：\n是否加载实例\n饿汉式 饱汉式 是否线程安全\n安全 不安全 特殊实现方式：\n静态内部类 枚举 单例模式代码","title":"单例模式"},{"content":"使用场景 多用于子串匹配问题\n流程 在暴力解的过程当中有加速\n定义： 在该位置之前的前缀与后缀的长度，但不能取到字符串的整体长度，定义为指标信息\n解释：\n对匹配串建立上述指标信息 匹配过程 求解证明 x-r 与 y-r\u0026rsquo;是相同，从i位置匹配match串等同于从match的q位置进行匹配\ni位置到r位置一定不能匹配match\n验证：假设i位置到r位置，有个k位置能够匹配match串，那就说明从k位置到x位置是相同的，也就是match串y位置之前字符串的一个后缀，此时，与next的数组定义违反，出现了一个更长的。假设不成立。\nnext数组生成 match长度为M,时间复杂度为O(M)\nnext[0] = -1;\nnext[1] = 0;\nnext[2] = 0位置和1位置决定;\n求i位置的next[i]时候，前面所有位置都已经准备好\nnext证明 来到i位置next[i]最大为next[i+1]+1\n假设next[i]\u0026gt;next[i-1] + 1,\n那么说明next[i-1]求解错误，矛盾，不成立\n代码实现 public class Kmp { public static int getIndexOf(String s, String match) { if (s == null || match == null || match.length() \u0026lt; 1 || s.length() \u0026lt; match.length()) { return -1; } char[] strs = s.toCharArray(); char[] matchs = match.toCharArray(); int x = 0;// strs中当前匹配位置 int y = 0; // match中当前匹配位置、 int[] next = getNextArray(matchs); while (x \u0026lt; strs.length \u0026amp;\u0026amp; y \u0026lt; matchs.length) { if (strs[x] == matchs[y]) { x++; y++; } else if (next[y] == -1) { // y已经来到开头 或者写成y==0 x++; } else { y = next[y]; } } return y == matchs.length ? x - y : -1; } public static int[] getNextArray(char[] matchs) { if (matchs.length == 1) { return new int[]{-1}; } int[] next = new int[matchs.length]; next[0] = -1; // 人为规定 next[1] = 0; // 人为规定 int i = 2; // 从2开始 int cn = 0; // 和i-1位置比较的字符 while (i \u0026lt; matchs.length) { if (matchs[i - 1] == matchs[cn]) { next[i++] = ++cn; } else if (cn \u0026gt; 0) { // 往前跳 cn = next[cn]; } else { // 匹配不到 next[i++] = 0; } } return next; } } 时间复杂度-O(N) 对于上述代码的while循环处理\nx[最大到N] x-y[最大到N] 第一个分支 变大 不变 第二个分支 变大 变大 第三个分支 不变 变大 最大为2N,复杂度为O(N)\n","permalink":"https://AlfredNing.github.io/note/program/algorithm/kmp/","summary":"使用场景 多用于子串匹配问题\n流程 在暴力解的过程当中有加速\n定义： 在该位置之前的前缀与后缀的长度，但不能取到字符串的整体长度，定义为指标信息\n解释：\n对匹配串建立上述指标信息 匹配过程 求解证明 x-r 与 y-r\u0026rsquo;是相同，从i位置匹配match串等同于从match的q位置进行匹配\ni位置到r位置一定不能匹配match\n验证：假设i位置到r位置，有个k位置能够匹配match串，那就说明从k位置到x位置是相同的，也就是match串y位置之前字符串的一个后缀，此时，与next的数组定义违反，出现了一个更长的。假设不成立。\nnext数组生成 match长度为M,时间复杂度为O(M)\nnext[0] = -1;\nnext[1] = 0;\nnext[2] = 0位置和1位置决定;\n求i位置的next[i]时候，前面所有位置都已经准备好\nnext证明 来到i位置next[i]最大为next[i+1]+1\n假设next[i]\u0026gt;next[i-1] + 1,\n那么说明next[i-1]求解错误，矛盾，不成立\n代码实现 public class Kmp { public static int getIndexOf(String s, String match) { if (s == null || match == null || match.length() \u0026lt; 1 || s.length() \u0026lt; match.length()) { return -1; } char[] strs = s.toCharArray(); char[] matchs = match.","title":"Kmp"},{"content":"title: \u0026ldquo;面试经历\u0026rdquo; date: 2023-06-12T19:33:59+08:00 lastmod: 2023-06-12T19:33:59+08:00 author: [\u0026ldquo;AlfredNing\u0026rdquo;] keywords:\ncategories: # 没有分类界面可以不填写 tags: # 标签\n随记 description: \u0026quot;\u0026quot; weight: slug: \u0026quot;\u0026quot; draft: false # 是否为草稿 comments: true # 本页面是否显示评论 reward: true # 打赏 mermaid: true #是否开启mermaid showToc: true # 显示目录 TocOpen: true # 自动展开目录 hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等 disableShare: true # 底部不显示分享栏 showbreadcrumbs: true #顶部显示路径 cover: image: \u0026quot;\u0026quot; #图片路径例如：posts/tech/123/123.png caption: \u0026quot;\u0026quot; #图片底部描述 alt: \u0026quot;\u0026quot; relative: false 2023年6月12日 :slightly_smiling_face: 百度面 别想太多，不是正式员工面，外包面试。面试官人非常不错，面试过程中有个小插曲，就是到了时间点，外面有两个女同事，推开了门，面试官这边说等三分钟，对面好像有点不耐烦，关键的点是你推开了门，里面还在开会不应该把门给关上吗。是不是对外包的人看不起还是怎么回事。其实我没想那么多，面试他们，我就是为了工资而已，我需要现金流，但我看不惯有的人把自己摆在很高的位置上面。其实今天的面试官非常不错，我之前面试其它公司的时候，有的面试官恨不得把自己挂在天上。有什么好优越的，就因为你是在这家公司，你来面试其他人你就变得优越了。人都是会受外界而改变的, 人人平等的社会终究还是理想的。\n下午回来吃了饺子，好久都没有吃下午饭了，今天算是破例了。为什么老想着给别人打工-因为我要形成我初期的资金积累。\n底层人民没有生活。我讨厌高高在上的人\n","permalink":"https://AlfredNing.github.io/thinking/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/","summary":"title: \u0026ldquo;面试经历\u0026rdquo; date: 2023-06-12T19:33:59+08:00 lastmod: 2023-06-12T19:33:59+08:00 author: [\u0026ldquo;AlfredNing\u0026rdquo;] keywords:\ncategories: # 没有分类界面可以不填写 tags: # 标签\n随记 description: \u0026quot;\u0026quot; weight: slug: \u0026quot;\u0026quot; draft: false # 是否为草稿 comments: true # 本页面是否显示评论 reward: true # 打赏 mermaid: true #是否开启mermaid showToc: true # 显示目录 TocOpen: true # 自动展开目录 hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等 disableShare: true # 底部不显示分享栏 showbreadcrumbs: true #顶部显示路径 cover: image: \u0026quot;\u0026quot; #图片路径例如：posts/tech/123/123.png caption: \u0026quot;\u0026quot; #图片底部描述 alt: \u0026quot;\u0026quot; relative: false 2023年6月12日 :slightly_smiling_face: 百度面 别想太多，不是正式员工面，外包面试。面试官人非常不错，面试过程中有个小插曲，就是到了时间点，外面有两个女同事，推开了门，面试官这边说等三分钟，对面好像有点不耐烦，关键的点是你推开了门，里面还在开会不应该把门给关上吗。是不是对外包的人看不起还是怎么回事。其实我没想那么多，面试他们，我就是为了工资而已，我需要现金流，但我看不惯有的人把自己摆在很高的位置上面。其实今天的面试官非常不错，我之前面试其它公司的时候，有的面试官恨不得把自己挂在天上。有什么好优越的，就因为你是在这家公司，你来面试其他人你就变得优越了。人都是会受外界而改变的, 人人平等的社会终究还是理想的。","title":""}]