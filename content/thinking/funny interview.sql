1 http 与https
http设计的初衷是用来接收和处理http页面，轻量无状态。默认端口80
https http over SSL/TLS 识别网站，加密传输。默认端口443。
非对称加密+对称加密。原因是存在秘钥交换问题。
服务器给客户端公钥。客户端生成会话秘钥。用公钥加密。返回给服务端，服务端进行解密。之后采用对称加密.
2. TCP 与 UDP
属于传输层协议。

3. 继承与接口区别
继承：解决代码的复用性和可维护性，满足的是is-a关系,对类的抽象。可以有实现和抽象方法，也可以定义成员变量。单继承
接口：设计各种规范，让其他类实现这些方法，满足的是like-a关系，对行为的抽象。多实现。如果是接口继承接口的话，可用extends.在接口中只能定义全局常量,和抽象方法

===========================================网络===========================================
4. TCP 和UDP
TCP UDP 工作在传输层，负责传输数据。稳定可靠，文件，浏览网页
TCP基于连接，在乎可靠性，及时反馈 全双工。
    - 三次握手
        1. clien > SYN包 > Server端
        2. Server端 > SYN + ACK 包 > client端
        3. 客户端 > ACK 包 > Server端
    为什么需要三次握手，而不是两次握手？
        服务端回复SYN + ACK包 建立连接。防止因为已失效的请求报文突然又传到服务器引起错误。
        实际分析：
                客户端向服务端发送SYN包请求建立连接，因为某些未知的原因，并没有到达服务器。在中间某个网络节点产生滞留。为了建立连接，客户端重新发送SYN包，这次的数据包成功达到
                服务端返回SYN+ACK包，但是第一包阻塞的SYN包网络节点突然恢复，又送达到服务器端，在两次握手的基础上，服务端认为是客户端的建立新连接。在两次握手之后，进入等待数据状态。
                客户端认为是一个连接，服务端认为是两个连接，造成状态不一致。在三次握手的基础上，服务端收不到最后的ACK包，不会认为建立连接成功。
        三次握手解决网络信道不可靠的问题，能在不可靠的信道上建立可靠的连接
    - 传输确认
    TCP 如何处理丢包问题 乱序问题 
        tcp为每一个连接建立发送缓冲区，从建立连接的第一个字节的序列号为0，后面每个字节的序列号增加1，发送数据时，从发送缓冲区取一部分数据组成数据内容。在tcp协议头会附带序列号和长度。
        回复确认： 接收段收到数据后，需要回复确认ack=序列号+长度 = 下一包起始序列号。
        切割发送： 发送端可以发送多包数据，接收端只需要回复一次即可。发送端可以把待发送的数据分割成一系列碎片，发送到对端。对端根据序列号和长度重构出来完整的数据
        丢失重传： 假设丢失，接收端发送ack=100,发送端重传序列号100到接收端。接收端进行补齐。
    - 四次挥手
    处于连接的客户端和服务器都可以发送关闭请求。
        假设客户端主动发送连接关闭请求
        1。 客户端向服务器发送FIN关闭连接请求，自己进入终止等待1状态。
        2. 服务端收到FIN包，发送ACK包，表示自己进入关闭等待状态。客户端进入终止等待2状态。服务端此时还可以发送未发送的数据，客户端还可以接收数据。
        3. 服务端发送数据完成之后，发送FIN包，服务端进入最后确认状态。
        4. 客户端收到回复ACK包，自己进入超时等待状态，经过超时时间后关闭连接。服务端收到ACK包，立即关闭连接
    为什么客户需要超时等待？
        为了保证对方已收到ACK包，因为假设客户端发送ACK包就立即释放，一旦ACK包在网络丢失。服务端一直停留在最后确认状态。如果客户端等待一段时间，服务端没有收到ACK包，会重发FIN包，客户端会响应ACK，刷新等待时间
        不可靠的网络连接过程中，进行可靠的连接。
UCP基于非连接，面向报文。速度快，适合实时性要求较高，对少量丢包没有太大要求的场景。域名查询，视频查询，隧道网络：vpn
    发送数据，就是把数据封装组成数据包，经过网卡发送出去。没有状态上的联系。

===========================================操作系统===========================================
5. CPU状态相关
    CPU 分为内核态与用户态，也分别称为管态和目态。
    CPU指令：特权指令和非特权指令。特权指令是只有内核态的CPU可以运行，非特权指令就是CPU的内核态和用户态都可以运行。
6. 进程状态
    创建 -> 就绪 -> 运行 -> 阻塞 -> 终止
7. 进程和线程
    进程是对正在运行中的程序的一个抽象，是系统进行资源分配和调度的基本单位。线程是操作系统能够运算调度的最小单位，是进程当中的一个执行单元。
    一个程序在内存运行，每个进程都有其自己独立的一块内存空间。一个进程有多个线程。多个线程共享进程的堆和方法区资源。每个线程有自己的程序计数器、虚拟机栈和本地方法栈。
8. 进程和线程内如何通信
    为什么是内？实际上只需要进程间的通信，因为同一进程的线程共享地址空间，没有通信的必要，但需要做好同步/互斥。
    进程间通信方式：
        1. 管道
        2. 有名管道
        3. 信号量
        4. 消息队列
        5. 信号
        6. 共享内存
        7. 套接字
    线程间通信方式：
        1. 锁机制：互斥锁、条件变量，读写锁
        2. 信号量机制
        3. 信号量机制
    线程间通信的目的在于线程同步，所有线程没有像进程中用于数据交换的通信进程

===========================================java 基础===========================================    
9. == 和 equals区别
    基本类型：比较的是值是否相同；
    引用类型：比较的是引用是否相同

10. map 和flatmap区别
    共同点：map 和flatmap都是接受一个映射函数，将该函数应用每个元素中，并返回一个Stream。map为输入元素每个生成一个值，而flatmap用该流的内容替换每个生成流的效果，简而概括：
    flatmap将生成的所有单独的流都扁平化为一个流
