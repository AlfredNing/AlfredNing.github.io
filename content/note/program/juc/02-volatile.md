---
title: "02-Volatile"
date: 2023-07-11T08:04:59+08:00
lastmod: 2023-07-11T08:04:59+08:00
author: ["AlfredNing"]
keywords: 
- 
categories: # 没有分类界面可以不填写
- 
tags: # 标签
- juc
description: ""
weight:
slug: ""
draft: false # 是否为草稿
comments: true # 本页面是否显示评论
reward: true # 打赏
mermaid: true #是否开启mermaid
showToc: true # 显示目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示路径
cover:
    image: "" #图片路径例如：posts/tech/123/123.png
    caption: "" #图片底部描述
    alt: ""
    relative: false
---

# JMM

现代计算机组成体系之上，CPU与内存之间的运行速度差距较大，为了缓存速度上的差异，引入了多级缓存。

Java Memory Model 本身是一种**抽象**的概念并不真实存在它仅仅描述的是一组约定或规范，通过这组规范定义了

- 程序中各个变量的读写访问方式
- 决定另一个线程对共享变量的写入以及如何变成对另一个线程可见

关键技术点围绕多线程的**原子性、可见性、原子性**

1. 通过JMM来实现线程和主内存的抽象关系
2. **屏蔽各个硬件平台和操作系统的内存访问差异**以实现让Java程序在各种平台下都能达到一致的内存访问效果

## 特性

### 可见性

是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道该变更 ，JMM规定了所有的变量都存储在*主内存*中。

**Java中普通的共享变量不保证可见性**，因为数据修改被写入内存的时机是不确定的，多线程并发下很可能出现"**脏读**"，所以每个线程都有自己的*工作内存*，线程自己的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取，赋值等 ）都必需在线程自己的工作内存中进行，而不能够直接读写主内存中的变量。**不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成**

### 原子性

指一个操作是不可中断的，即多线程环境下，操作不能被其他线程干扰

### 有序性

对于一个线程的执行代码而言，我们总是习惯性认为代码的执行总是从上到下，有序执行。

但为了提供性能，编译器和处理器通常会对指令序列进行重新排序。

**指令重排可以保证串行语义一致，但没有义务保证多线程间的语义也一致，即可能产生"脏读"，**简单说，

两行以上不相干的代码在执行的时候有可能先执行的不是第一条，不见得是从上到下顺序执行，执行顺序会被优化。

单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。处理器在进行重排序时必须要考虑指令之间的*数据依赖性*，多线程环境中线程交替执行,由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的,结果无法预测

## 多线程度变量的读写过程

### 读写过程

JVM运行过程的实体是线程，而每个线程创建JVM时都会为其创建工作内存（栈空间）属于私有数据区，而java内存模型规定的所有变量都在主内存中。主内存是共享内存区域，所有线程都可以访问。

**线程对变量的操作必须在工作内存中进行，首先要将变量从主内存中拷贝到自己的工作内存空间，然后对变量进行操作，操作完成之后在写回主内存**

不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完

### 总结

- 我们定义的所有共享变量都储存在物理主内存中
- 每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本(主内存中该变量的一份拷贝)
- 线程对共享变量所有的操作都必须先在线程自己的工作内存中进行后写回主内存，不能直接从主内存中读写(不能越级)
- 不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行(同级不能相互访问)

## 多线程先行发生原则之happens-before

### 定义

在JMM中，如果一个操作执行的结果需要对另一个操作可见性或者 代码重排序，那么这两个操作之间必须存在happens-before关系。**包含可见性和有序性的约束**

### 说明

如果Java内存模型中所有的有序性都仅靠volatile和synchronized来完成，那么有很多操作都将会变得非常啰嗦，但是我们在编写Java并发代码的时候并没有察觉到这一点。

我们没有时时、处处、次次，添加volatile和synchronized来完成程序，这是因为Java语言中JMM原则下，有一个“先行发生”(Happens-Before)的原则限制和规矩

原则：

**它是判断数据是否存在竞争，线程是否安全的非常有用的手段。依赖这个原则，我们可以通过几条简单规则一揽子解决并发环境下两个操作之间是否可能存在冲突的所有问题，而不需要陷入Java内存模型苦涩难懂的底层编译原理之中**

### 总原则

1. 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
2. 两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。

### 8条规则

#### 次序规则

一个线程内，按照代码顺序，写在前面的操作先行发生于写在后面的操作

#### 锁定规则

一个unLock操作先行发生于后面((这里的“后面”是指时间上的先后))对同一个锁的lock操作

#### volatile变量规则

对一个volatile变量的写操作先行发生于后面对这个变量的读操作，前面的写对后面的读是可见的，这里的“后面”同样是指时间上的先后

#### 传递规则

如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C

#### 线程启动规则(Thread Start Rule)

Thread对象的start()方法先行发生于此线程的每一个动作

#### 线程中断规则(Thread Interruption Rule)

对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生

可以通过Thread.interrupted()检测到是否发生中断

#### 线程终止规则(Thread Termination Rule)

线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。

#### 对象终结规则(Finalizer Rule)

一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始

# volatile

## 特点

- 可见性
- 有序性

## 内存语义

- 当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值立即刷新回主内存中
- 当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，直接从主内存中读取共享变量

## 内存屏障

内存屏障（也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作），避免代码重排序。内存屏障其实就是**一种JVM指令**，Java内存模型的重排规则会要求**Java编译器在生成JVM指令时插入特定的内存屏障指令**，通过这些内存屏障指令，volatile实现了Java内存模型中的可见性和有序性，但volatile无法保证原子性。

内存屏障之前的所有写操作都要回写到主内存，

内存屏障之后的所有读操作都能获得内存屏障之前的所有写操作的最新结果(实现了可见性)。

因此重排序时，不允许把内存屏障之后的指令重排序到内存屏障之前。

**一句话：对一个 volatile 域的写, happens-before 于任意后续对这个 volatile 域的读，也叫写后读。**

### 四大内存屏障

![img](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/9AA3E2AB-B131-4094-B35C-AE5A6FDC1597.png)

### 写屏障

1. 在每个 volatile 写操作的**前⾯**插⼊⼀个 StoreStore 屏障
2. 在每个 volatile 写操作的**后⾯**插⼊⼀个 StoreLoad 屏障

### 读屏障

1. 在每个 volatile 读操作的**后⾯**插⼊⼀个 LoadLoad 屏障

2. 在每个 volatile 读操作的**后⾯**插⼊⼀个 LoadStore 屏障

## 保证可见性

Java内存模型中定义的8种工作内存与主内存之间的原子操作

**read(读取)→load(加载)→use(使用)→assign(赋值)→store(存储)→write(写入)→lock(锁定)→unlock(解锁)**

![img](C:/Users/15667/AppData/Local/Temp/mindmaster/d71b1ea190/bin/504BA6E9-0EEE-4BD7-AC83-13416F52C8DB.png)

read: 作用于主内存，将变量的值从主内存传输到工作内存，主内存到工作内存

load: 作用于工作内存，将read从主内存传输的变量值放入工作内存变量副本中，即数据加载

use: 作用于工作内存，将工作内存变量副本的值传递给执行引擎，每当JVM遇到需要该变量的字节码指令时会执行该操作

assign: 作用于工作内存，将从执行引擎接收到的值赋值给工作内存变量，每当JVM遇到一个给变量赋值字节码指令时会执行该操作

store: 作用于工作内存，将赋值完毕的工作变量的值写回给主内存

write: 作用于主内存，将store传输过来的变量值赋值给主内存中的变量

由于上述只能保证单条指令的原子性，针对多条指令的组合性原子保证，没有大面积加锁，所以，JVM提供了另外两个原子指令：

lock: 作用于主内存，将一个变量标记为一个线程独占的状态，只是写时候加锁，就只是锁了写变量的过程。

unlock: 作用于主内存，把一个处于锁定状态的变量释放，然后才能被其他线程占用

## 不保证原子性

**volatile变量的复合操作(如i++)不具有原子性**

![img](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/EC6BDB39-0DE6-44D9-B178-4424A90EEF85.png)

read-load-use 和 assign-store-write 成为了两个不可分割的原子操作，但是在use和assign之间依然有极小的一段真空期，有可能变量会被其他线程读取，导致写丢失一次

但是无论在哪一个时间点主内存的变量和任一工作内存的变量的值都是相等的。这个特性就导致了volatile变量不适合参与到依赖当前值的运算，如i = i + 1; i++

## 指令禁重排

重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段，有时候会改变程序语句的先后顺序

- 不存在数据依赖关系，可以重排序

- 存在数据依赖关系，禁止重排序

**但重排后的指令绝对不能改变原有的串行语义！这点在并发设计中必须要重点考虑！**

编译器优化的重排序： 编译器在不改变单线程串行语义的前提下，可以重新调整指令的执行顺序

指令级并行的重排序： 处理器使用指令级并行技术来讲多条指令重叠执行，若不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序

内存系统的重排序： 由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是乱序执行

**数据依赖性：若两个操作访问同一变量，且这两个操作中有一个为写操作，此时两操作间就存在数据依赖性。**

**存在数据依赖关系，禁止重排序===> 重排序发生，会导致程序运行结果不同。**

编译器和处理器在重排序时，会遵守数据依赖性，不会改变存在依赖关系的两个操作的执行,但不同处理器和不同线程之间的数据性不会被编译器和处理器考虑，其只会作用于单处理器和单线程环境。

通过内存屏障实现来实现指令重排

## 正确使用volatile

### 单一赋值使用，复合赋值不可以

```java
volatile int a = 10；
volatile boolean flag = false
```

### 状态标志，判断业务是否结束

### 开销较低的锁，写锁策略

```javascript
class UseVolatileDemo {

  /**
   * 使用：当读远多于写，结合使用内部锁和 volatile 变量来减少同步的开销 理由：利用volatile保证读取操作的可见性；利用synchronized保证复合操作的原子性
   */
  public class Counter {

    private volatile int value;

    public int getValue() {
      return value;   //利用volatile保证读取操作的可见性
    }

    public synchronized int increment() {
      return value++; //利用synchronized保证复合操作的原子性
    }
  }
}
```

### DCL双端锁的发布

DCL双端锁:  double check lock 双端锁检测机制

```java
class SafeDoubleCheckSingleton {

  //通过volatile声明，实现线程安全的延迟初始化。
  private volatile static SafeDoubleCheckSingleton singleton;

  //私有化构造方法
  private SafeDoubleCheckSingleton() {
  }

  //双重锁设计
  public static SafeDoubleCheckSingleton getInstance() {
    if (singleton == null) {
      //1.多线程并发创建对象时，会通过加锁保证只有一个线程能创建对象
      synchronized (SafeDoubleCheckSingleton.class) {
        if (singleton == null) {
          //隐患：多线程环境下，由于重排序，该对象可能还未完成初始化就被其他线程读取
          //原理:利用volatile，禁止 "初始化对象"(2) 和 "设置singleton指向内存空间"(3) 的重排序
          singleton = new SafeDoubleCheckSingleton();
        }
      }
    }
//2.对象创建完毕，执行getInstance()将不需要获取锁，直接返回创建对象
    return singleton;
  }
}


// 不使用volatile，静态内部类替代
class SingletonDemo {

  private SingletonDemo() {
  }

  private static class SingletonDemoHandler {

    private static SingletonDemo instance = new SingletonDemo();
  }

  public static SingletonDemo getInstance() {
    return SingletonDemoHandler.instance;
  }
}
```

? 为什么ava写了一个volatile关键字系统底层加入内存屏障？两者关系怎么勾搭上的?

1. 字节码层面： 加上volatile会自己码会加入标识：`ACC_VOLATILE`
2. JMM根据上述指令去相应位置插入内存屏障指令