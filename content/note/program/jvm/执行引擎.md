---
title: "执行引擎"
date: 2023-05-01T21:28:28+08:00
lastmod: 2023-05-01T21:28:28+08:00
author: ["AlfredNing"]
keywords: 
- 
categories: # 没有分类界面可以不填写
- 
tags: # 标签
- jvm
description: ""
weight:
slug: ""
draft: false # 是否为草稿
comments: true # 本页面是否显示评论
reward: true # 打赏
mermaid: true #是否开启mermaid
showToc: true # 显示目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示路径
cover:
    image: "" #图片路径例如：posts/tech/123/123.png
    caption: "" #图片底部描述
    alt: ""
    relative: false
---

# 执行引擎的定义

**将字节码指令解释/编译为对应平台上的本地机器指令。将高级语言翻译成低级语言**

# 执行引擎的工作流程

从外观上来看，所有的Java虚拟机的执行引擎输入、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果。

![img](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/4258A9CA-30EB-4AB4-BDAC-21EC00B3D061.png)

1.  执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。
2. 每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。
3. 当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。

# 代码执行和编译的过程

![img](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/0CB26048-6E48-42AA-A7F0-5A80EFDAC88E.png)

1. 过程1: javac.exe的执行
   Java代码编译是由Java源码编译器来完成，流程图如下所示

   ![img](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/EFCFA7B5-974D-4554-A81D-C5E8978FAE66.png)

2. java.exe的执行：
   Java字节码的执行是由JVM执行引擎来完成，流程图如下所示
   ![img](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/0B2BFBEA-28C5-4CBF-80BC-9B9E2A992566.png)

## 概念

### 前端编译器

.java文件转换为.class文件的过程

### 后端运行期编译器

JIT 编译器，Just In Time Compiler: 把字节码转变成机器码的过程。

### 静态提前编译器

AOT 编译器，Ahead Of Time Compiler: 直接把.java文件编译成本地机器代码的过程。

![img](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/1BCF0430-983B-4B3A-ACD4-93F535C6FD49.png)

>HotSpot VM是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器并存的架构。

## 解释器

当Java虚拟机启动时会根据预定义的规范对字节码**采用逐行解释的方式执行**，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。

### 工作机制

- 解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。从这个角度说，java是解释语言。
- 当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。

### 解释器的分类

在Java的发展历史里，一共有两套解释执行器，即古老的**字节码解释器**、现在普遍使用的**模板解释器**。

- 字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。
- 而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。
- 在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。
  - Interpreter模块：实现了解释器的核心功能
  - Code模块：用于管理HotSpot VM在运行时生成的本地机器指令

### 只用解释器的问题

- 由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C/C++程序员所调侃。
- 为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。
- 不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。

### 为什么说Java是半解释半编译的语言

1. JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。
2. 现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。

# JIT编译器

JIT（Just In Time Compiler)编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。

### 为什么还保留解释器的问题

> 有些开发人员会感觉到诧异，既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。
>
> 首先明确：
>
> 当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。
>
> 编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。
>
> 所以：
>
> 尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。在此模式下，当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。
>
> 同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。

### HotSpot执行方式

![image-20230502104029947](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230502104029947.png)

当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，**即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。**

> 案例：注意解释执行与编译执行在线上环境微妙的辩证关系。机器在热机状态可以承受的负载要大于冷机状态。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。
>
> 在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1/8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前l/2发布成功的服务器马上全部宕机，此故障说明了JIT 的存在。—— 阿里团队

## 如何选择

### 热点代码及探测方式

当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用执行的频率而定。关于那些需要被编译为本地代码的字节码，也被称之为“热点代码”，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出深度优化，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。

- 一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，或**简称为OSR（On Stack Replacement）编译。**

- 一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。

- **目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测。**

#### 方法调用计数器

- 这个计数器就用于统计方法被调用的次数，它的默认阈值在 Client 模式下是 1500 次，在 Server 模式下是 10000 次。超过这个阈值，就会触发JIT编译。
- 这个阈值可以通过虚拟机参数**-XX:CompileThreshold**来人为设定。
- 当一个方法被调用时，会先检查该方法是否存在被 JIT 编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加 1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。

###### 热度衰减

如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）。

#### 回变形计数器

它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为 “回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发 OSR 编译。（On-Stack Replacement)

# 编译器

## Graal编译器

## AOT编译器

- jdk9引入了AOT编译器(静态提前编译器，Ahead Of Time Compiler)

- Java 9 引入了实验性 AOT 编译工具jaotc。它借助了 Graal 编译器，**将所输入的 Java 类文件转换为机器码，并存放至生成的动态共享库之中。**

- 所谓 AOT 编译，是与即时编译相对立的一个概念。我们知道，**即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而 AOT 编译指的则是，在程序运行之前，便将字节码转换为机器码的过程**。
- .java -> .class -> .so

**最大好处**：Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢”的不良体验。

**缺点：**

- 破坏了java“一次编译，到处运行”，必须为每个不同硬件、OS编译对应的发行包。
- 降低了Java链接过程的动态性，加载的代码在编译期就必须全部已知。

还需要继续优化中，最初只支持Linux x64 java base

## 动态编译

动态编译(compile during run-time)，英文称Dynamic compilation；Just In Time也是这个意思

在程序运行过程之中进行编译。

### 监视器

HotSpot里运行着一个监视器（Profile Monitor），用来监视程序的运行状况。

Java字节码（class文件）是以解释的方式被加载到虚拟机中**(默认启动时解释执行**)。 程序运行过程中，那一部分运用频率大，那些**对程序的性能影响重要。对程序运行效率影响大的代码，称为热点（hotspot），HotSpot会把这些热点动态地编译成机器码（native code），同时对机器码进行优化**，从而提高运行效率。对那些较少运行的代码，HotSpot就不会把他们编译。

HotSpot对字节码有三层处理：

- 不编译(字节码加载到虚拟机中时的状态。也就是当虚拟机执行的时候再编译)；
- 编译(把字节码编译成本地代码。虚拟机执行的时候已经编译好了，不要再编译了)；
- 编译并优化（不但把字节码编译成本地代码，而且还进行了优化）。

**至于哪些程序那些不编译，那些编译，那些优化，则是由监视器（Profile Monitor）决定。**

## 为什么不静态编译

动态编译器在许多方面比静态编译器优越。**静态编译器通常很难准确预知程序运行过程中究竟什么部分最需要优化。**

函数调用都是很浪费系统时间的，因为有许多进栈出栈操作。因此有一种优化办法，**就是把原来的函数调用，通过编译器的编译，改成非函数调用，把函数代码直接嵌到调用出，变成顺序执行。**

面向对象的语言支持多态，**静态编译无效确定程序调用哪个方法，因为多态是在程序运行中确定调用哪个方法。**

# HotSpot VM执行方式【重点】

## 解释器与JIT并存的架构

缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。

- -Xint：完全采用解释器模式执行程序
- -Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行
- -Xmixed：采用解释器+即时编译器的混合模式共同执行程序

![image-20230502105355070](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230502105355070.png)

# c1 c2编译器

在HotSpot VM中内嵌有两个JIT编译器，分为**Client Complier**与**Server Complier**。通常情况下简称为C1编译器和C2编译器。开发人员可以显示指定使用那种模式。

- -client：指定Java虚拟机运行在Client模式下，并使用C1编译器
  - C1编译器会对字节码进行**简单和可靠的优化，耗时短**。以达到更快的编译速度。
  - client启动快，占用内存小，执行效率没有server快，默认情况下不进行动态编译，适用于桌面应用程序。
- -server：指定Java虚拟机运行在Server模式下，并使用C2编译器
  - C2进行耗时**较长的优化，以及激进优化**。但优化的代码执行效率更高
  - server启动慢，占用内存多，执行效率高，适用于服务器端应用；

## 两种编译器的优化策略

不同的编译器有不同的优化策略。

C1编译器主要有方法内联，去虚拟化、冗余消除

- 方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程。
- 虚拟化：对唯一的实现类进行内联。
- 冗余消除：在运行期间把一些不会执行的代码折叠掉。

C2的优化主要是在全局层面，**逃逸分析是优化的基础**。基于逃逸分析在C2上有如下几种优化：

- 标量替换: 用标量值代替聚合对象的属性值
- 栈上分配：对于未逃逸的对象分配对象在栈而不是堆
- 同步消除：清除同步操作，通常指synchronized

总结:

- 一般来讲，JIT编译出来的机器码性能比解释器高
- C2编译器启动时长比C1编译器满，系统稳定执行以后，C2编译器执行速度远远快于C1编译器。

