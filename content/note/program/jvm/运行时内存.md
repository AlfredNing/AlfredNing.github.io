---
title: "运行时内存"
date: 2023-02-27T21:33:26+08:00
lastmod: 2023-02-27T21:33:26+08:00
author: ["AlfredNing"]
keywords: 
- 
categories: # 没有分类界面可以不填写
- 
tags: # 标签
- jvm
description: ""
weight:
slug: ""
draft: false # 是否为草稿
comments: true # 本页面是否显示评论
reward: true # 打赏
mermaid: true #是否开启mermaid
showToc: true # 显示目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示路径
cover:
    image: "" #图片路径例如：posts/tech/123/123.png
    caption: "" #图片底部描述
    alt: ""
    relative: false
---

jvm内存结构图

![image-20230227213433004](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230227213433004.png)

哪些内存结构与线程意义对应，其实问的是线程共有和私有
共有： 堆和方法区
私有： 本地方法栈、虚拟机栈、程序计数器

# 程序计数器

1. 保证程序在程序系统中能够执行下去，CPU必须具有某些手段来确定下一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器
2. 一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器。
   在程序开始执行前，必须将它的起始地址，即程序的一条指令所在的内存单元地址送入PC，因此程序计数器（PC）的内容即是从内存提取的第一条指令的地址。当执行指令时，CPU将自动修改PC的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数，以便使其保持的总是将要执行的下一条指令的地址
3. 由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单的对PC加1
4. 当程序转移时，转移指令执行的最终结果就是要改变PC的值，此PC值就是转去的地址，以此实现转移。有些机器中也称PC为指令指针IP（Instruction Pointer）

## 特征

> JVM中的程序计数寄存器（Program Counter Register）中， Register 的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。 CPU只有把数据装载到寄存器才能够运行。

**JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟**

- 很小的内存结构，忽略不计，也是运行最快的存储区域，不会随着程序的运行需要更大的空间
- 在JVM规范中，每个线程都有自己的程序计数器，是线程私有的，生命周期与线程生命周期保持一致
- **它是唯一一个在JVM虚拟机规范中没有规定任何OutOtMemoryError 情况的区域**

## 问题

1. 为什么使用PC寄存器来记录当前线程的执行地址
   因为CPU需要不停的切换各个线程，准确知道执行的位置。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令
2. PC寄存器为什么被设置为线程私有
   多线程在一个特定的时间段内之会执行某一个线程的方法，CPU需要不停的做任务切换**。为了准确记录各个线程正在执行的当前字节码指令，最好的办法就是为每一个线程分配PC寄存器**，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况

# 虚拟机栈

> 栈管运行，堆管内存
>
> 栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿
>
> - Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。
> - 是线程私有的
>
> 生命周期: 生命周期和线程一致。
>
> 特点: 栈是一种快速有效的分配存储方式，**访问速度仅次于程序计数器**。

栈是否有GC？ 不存在GC, 但有OOM

抛出的异常：

- StackOverFlowError
- OutOfMemoryError

1. Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的
2. 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个 StackOverflowError 异常
3. 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出—个 OutOfMemoryError 异常

## 设置栈大小

 -Xsssize (即：-XX:ThreadStackSize)

- 一般为：512k-1M
- 栈的大小直接决定了函数调用的最大深度
- 设置的栈空间值过大，会导致系统可以用于创建线程的数量减少

一般一个进程中通常有3000-5000个线程

jdk5.0之前，默认为256k
jdk5.0之后，默认为1024k

## 栈帧

栈的基本单位是栈帧，每个线程都有自己的栈，栈中的数据都是以栈帧存在的。

### 方法与栈帧的关系

- 在这个线程执行的方法都有一个栈帧
- 栈帧是一个内存区块，是一个数据集，维护着方法执行过程中的各种数据信息

### 栈的内部结构

- 局部变量表
- 操作数栈或表达式栈
- 动态链接或指向运行时常量池的方法引用
- 方法返回地址（或方法正常退出或者异常退出的定义）
- 一些附加信息

![img](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/53BA4F99-EA72-4192-B3B8-44BDE74899EF.png)



#### 局部变量表 - Local Varibales

- 局部变量表被称为局部变量数组或者本地变量表
- **定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量**，数据类别包括：基本数据类型，对象引用、以returnAddress类型
- **局部变量表的大小是在编译器确定**，保存在方法的code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的
- **方法嵌套调用的次数由栈的大小决定**。一般来说，**栈越大，方法嵌套调用次数越多**。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减
- **局部变量表的变量只在当前方法调用中有效。**在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。**当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。**

##### 静态变量与局部变量区别

- 类变量表有两次初始化的机会，第一次准备阶段，执行系统初始化，赋零值，另一次是在初始化阶段，赋予代码中指定的初始值
- 和类变量初始化不同，局部变量表不存在系统初始化的过程，**一旦定义了局部变量则必须人为的初始化，否则无法使用**

##### 与GC ROOTS的关系

**局部变量表的变量也是重要的垃圾回收节点，只要被局部变量中直接或者间接引用的对象都不会被回收**

#### 操作数栈 Operand Stack





