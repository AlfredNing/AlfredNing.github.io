---
title: "运行时内存"
date: 2023-02-27T21:33:26+08:00
lastmod: 2023-02-27T21:33:26+08:00
author: ["AlfredNing"]
keywords: 
- 
categories: # 没有分类界面可以不填写
- 
tags: # 标签
- jvm
description: ""
weight:
slug: ""
draft: false # 是否为草稿
comments: true # 本页面是否显示评论
reward: true # 打赏
mermaid: true #是否开启mermaid
showToc: true # 显示目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示路径
cover:
    image: "" #图片路径例如：posts/tech/123/123.png
    caption: "" #图片底部描述
    alt: ""
    relative: false
---

jvm内存结构图

![image-20230227213433004](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230227213433004.png)

哪些内存结构与线程意义对应，其实问的是线程共有和私有
共有： 堆和方法区
私有： 本地方法栈、虚拟机栈、程序计数器

# 程序计数器

1. 保证程序在程序系统中能够执行下去，CPU必须具有某些手段来确定下一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器
2. 一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器。
   在程序开始执行前，必须将它的起始地址，即程序的一条指令所在的内存单元地址送入PC，因此程序计数器（PC）的内容即是从内存提取的第一条指令的地址。当执行指令时，CPU将自动修改PC的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数，以便使其保持的总是将要执行的下一条指令的地址
3. 由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单的对PC加1
4. 当程序转移时，转移指令执行的最终结果就是要改变PC的值，此PC值就是转去的地址，以此实现转移。有些机器中也称PC为指令指针IP（Instruction Pointer）

## 特征

> JVM中的程序计数寄存器（Program Counter Register）中， Register 的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。 CPU只有把数据装载到寄存器才能够运行。

**JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟**

- 很小的内存结构，忽略不计，也是运行最快的存储区域，不会随着程序的运行需要更大的空间
- 在JVM规范中，每个线程都有自己的程序计数器，是线程私有的，生命周期与线程生命周期保持一致
- **它是唯一一个在JVM虚拟机规范中没有规定任何OutOtMemoryError 情况的区域**

## 问题

1. 为什么使用PC寄存器来记录当前线程的执行地址
   因为CPU需要不停的切换各个线程，准确知道执行的位置。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令
2. PC寄存器为什么被设置为线程私有
   多线程在一个特定的时间段内之会执行某一个线程的方法，CPU需要不停的做任务切换**。为了准确记录各个线程正在执行的当前字节码指令，最好的办法就是为每一个线程分配PC寄存器**，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况

# 虚拟机栈

> 栈管运行，堆管内存
>
> 栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿
>
> - Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。
> - 是线程私有的
>
> 生命周期: 生命周期和线程一致。
>
> 特点: 栈是一种快速有效的分配存储方式，**访问速度仅次于程序计数器**。

栈是否有GC？ 不存在GC, 但有OOM

抛出的异常：

- StackOverFlowError
- OutOfMemoryError

1. Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的
2. 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个 StackOverflowError 异常
3. 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出—个 OutOfMemoryError 异常

## 设置栈大小

 -Xsssize (即：-XX:ThreadStackSize)

- 一般为：512k-1M
- 栈的大小直接决定了函数调用的最大深度
- 设置的栈空间值过大，会导致系统可以用于创建线程的数量减少

一般一个进程中通常有3000-5000个线程

jdk5.0之前，默认为256k
jdk5.0之后，默认为1024k

## 栈帧

栈的基本单位是栈帧，每个线程都有自己的栈，栈中的数据都是以栈帧存在的。

### 方法与栈帧的关系

- 在这个线程执行的方法都有一个栈帧
- 栈帧是一个内存区块，是一个数据集，维护着方法执行过程中的各种数据信息

### 栈的内部结构

- 局部变量表
- 操作数栈或表达式栈
- 动态链接或指向运行时常量池的方法引用
- 方法返回地址（或方法正常退出或者异常退出的定义）
- 一些附加信息

![img](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/53BA4F99-EA72-4192-B3B8-44BDE74899EF.png)



#### 局部变量表 - Local Varibales

- 局部变量表被称为局部变量数组或者本地变量表
- **定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量**，数据类别包括：基本数据类型，对象引用、以returnAddress类型
- **局部变量表的大小是在编译器确定**，保存在方法的code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的
- **方法嵌套调用的次数由栈的大小决定**。一般来说，**栈越大，方法嵌套调用次数越多**。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减
- **局部变量表的变量只在当前方法调用中有效。**在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。**当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。**

##### 静态变量与局部变量区别

- 类变量表有两次初始化的机会，第一次准备阶段，执行系统初始化，赋零值，另一次是在初始化阶段，赋予代码中指定的初始值
- 和类变量初始化不同，局部变量表不存在系统初始化的过程，**一旦定义了局部变量则必须人为的初始化，否则无法使用**

##### 与GC ROOTS的关系

**局部变量表的变量也是重要的垃圾回收节点，只要被局部变量中直接或者间接引用的对象都不会被回收**

#### 操作数栈 Operand Stack

操作数栈（Operand Stack）

- 我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。
- 每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出（Last-In-First-Out）的操作数栈，也可以称之为表达式栈（Expression Stack）。

- 操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。

- 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值。

- 栈中的任何一个元素都是可以任意的Java数据类型。

- 32bit的类型占用一个栈单位深度
- 64bit的类型占用两个栈单位深度

- 操作数栈，在方法执行过程中，根据字节码指令，并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈（push）和出栈（pop）操作，往栈中写入数据或提取数据来完成一次数据访问。

- 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。比如：执行复制、交换、求和等操作

- 如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。

##### 栈顶缓存

由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（ToS，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。

##### 动态链接（或指向运行时常量池的方法引用）

- 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic指令
- 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。

##### 常量池的作用

常量池的作用，就是为了提供一些符号和常量，便于指令的识别。

##### 方法返回地址

- 存放调用该方法的pc寄存器的值。

- 一个方法的结束，有两种方式：
- 正常执行完成
- 出现未处理的异常，非正常退出

- 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。

# 本地方法与本地方法栈

## 本地方法

简单地讲，一个Native Method就是一个Java调用非Java代码的接口。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern "C"告知C++编译器去调用一个C的函数。

 "A native method is a Java method whose implementation is provided by non-java code."

在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。

本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合 C/C++程序。

## 本地方法栈

- Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。
- 本地方法栈，也是线程私有的。
- 允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）
- 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个 StackOverflowError 异常。
- 如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个 OutOfMemoryError 异常。
- 本地方法是使用C语言实现的。
- 它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。

# 堆

- 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。

- Java 堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。

- 堆内存的大小是可以调节的。

- 《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。

- 堆，是GC ( Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。
- 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。

> 对象都分配在堆上？
>
> - 《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated ) 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置
> - “几乎”所有的对象实例都在这里分配内存。——从实际使用角度看的。TLAB的存在

## TLAB

**Thread Local Allocation Buffer**

- 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据
- 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的
- 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。

**所以，多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。**

堆的内部结构

现代垃圾收集器大部分都基于分代收集理论设计。

1. Java 7及之前堆内存逻辑上分为三部分：**新生区+养老区+永久区**
   Young Generation Space   新生区      Young/New 又被划分为Eden区和Survivor区
   Tenure generation space  养老区      Old/Tenure
   Permanent Space          永久区      Perm
2. Java 8及之后堆内存逻辑上分为三部分：**新生区+养老区+元空间**
   Young Generation Space    新生区      Young/New 又被划分为Eden区和Survivor区
   Tenure generation space   养老区      Old/Tenure
   Meta Space                元空间      Meta
   ![img](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/428161D7-41DB-4FFE-8D47-74F45FDAC0CE.png)

### 年轻代与老年代

- 存储在JVM中的Java对象可以被划分为两类：
- 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速
- 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。
- Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（OldGen）
- 其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）。

![img](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/34DC8A34-8FC1-4410-AAD6-421A3CE7010B.png)

- 几乎所有的Java对象都是在Eden区被new出来的。
- 绝大部分的Java对象的销毁都在新生代进行了。
- IBM 公司的专门研究表明，新生代中 80% 的对象都是“朝生夕死”的。

## 设置堆内存

### 设置新生代与老年代的比例

![img](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/3361B78F-4E9C-47DF-AA94-C10367777ECE.png)

- 配置新生代与老年代在堆结构的占比。
- 默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3
- 可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5
- 可以使用选项”-Xmn”设置新生代最大内存大小

**这个参数一般使用默认值就可以了。**

### 设置Eden 与Suvivor比例

- 在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1
- 可以通过选项“-XX:SurvivorRatio”调整这个空间比例。比如**-XX:SurvivorRatio=8**

## 参数设置

### 堆空间大小的设置

- -Xms:初始内存 （默认为物理内存的1/64）
- -Xmx:最大内存（默认为物理内存的1/4）

### 新生代大小设置

**-Xmn**

设置新生代的大小。(初始值及最大值) **通常默认即可。**

### 设置新生代垃圾的最大年龄。超过此值，仍未被回收的话，则进入老年代

- 默认值为15
- -**XX:MaxTenuringThreshold**=0：表示年轻代对象不经过Survivor区，直接进入老年代。对于老年代比较多的应用，可以提高效率。
- 如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代的存活时间，增加在年轻代即被回收的概率

### 输出详细的GC处理日志

**-XX:+PrintGCDetails**

### 在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间

**-XX:HandlePromotionFailure**

- 如果大于，则此次Minor GC是安全的
-  如果小于，则虚拟机会查看-XX:HandlePromotionFailure设置值是否允许担保失败。
- 如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于或者HandlePromotionFailure=false，则改为进行一次Full GC。

### 查看所有的参数的最终值

**-XX:+PrintFlagsFinal**

```java
具体查看某个参数的指令： jps：查看当前运行中的进程
 jinfo -flag SurvivorRatio 进程id
    
-Xms60m -Xmx60m -XX:NewRatio=2 -XX:SurvivorRatio=8 -XX:+PrintGCDetails    
```

## 对象分配过程

1.new的对象先放伊甸园区。此区有大小限制。

2.当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC/YGC)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区

3.然后将伊甸园中的剩余对象移动到幸存者0区。

4.如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。

5.如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。

6.啥时候能去养老区呢？可以设置次数。默认是15次。

- 可以设置参数：-XX:MaxTenuringThreshold= 设置对象晋升老年代的年龄阈值。

7.在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理。

8.若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生OOM异常 java.lang.OutOfMemoryError: Java heap space

### 分配策略

内存分配策略（或对象提升(promotion)规则):

如果对象在Eden 出生并经过第一次MinorGC 后仍然存活，并且能被Survivor 容纳的话，将被移动到Survivor 空间中，并将对象年龄设为1 。对象在Survivor 区中每熬过一次MinorGC ， 年龄就增加1岁，当它的年龄增加到一定程度（默认为15 岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代中。

### 内存分配原则

针对不同年龄段的对象分配原则如下所示：

- 优先分配到Eden
- 大对象直接分配到老年代 
- 尽量避免程序中出现过多的大对象
- 长期存活的对象分配到老年代
- 动态对象年龄判断
- 如果Survivor 区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。
- 空间分配担保
- -XX:HandlePromotionFailure

# GC详情

Minor GC / Major GC /FULL GC

## 按照GC回收区域划分

- 部分收集 Partial GC
- 整堆收集 Full GC

### MinorGC  触发机制

- 年轻代空间不足，这里的年轻代指的是Eden满，Survivor满不会引发GC
- 因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快
- Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行

### MajorGC 触发机制

- 发生在老年代的GC
- 出现了MajorGC 常常伴随着至少一次的MinorGC,但不一定是绝对的。Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程
- 在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC。
- Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。
- 如果Major GC 后，内存还不足，就报OOM了。

### FullGC 触发机制

- 调用System.gc(), 建议系统执行，取决于系统
- 老年代空间不足
- 方法区空间不足
- 通过MinorGc进入老年代的平均大小大于老年代的可用内存
- 由Eden区、Surviror From区向Survivor To区复制,，对象大于Survivor To可用内存。则把该对象转存到老年代，且老年代的可用内存小于该对象大小

**full gc是开发或调优中尽量要避免的。这样暂时时间会短一些。**

# OOM如何解决

1. 首先通过内存映像分析工具对dump出来的堆转储快照进行分析，重点确认堆内存的对象是否是必要的。是出现了内存泄露还是内存溢出
2. 如果是内存泄露，进一步通过工具查看泄露对象到GC roots的引用链。就能找到泄漏对象是通过怎样的路径与GC Roots 相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots 引用链的信息，就可以比较准确地定位出泄漏代码的位置。
3. 如果不存在内存泄露。内存中的对象都还必须存活。检查虚拟机参数。与物理机内存比对是否可以调大。从代码上检查是否存在某些对象生命周期过长，持有时间过长的情况，尝试减少程序运行期的内存消耗

## 堆空间分代思想

经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。

- 新生代：有Eden、两块大小相同的Survivor(又称为from/to，s0/s1)构成，to总为空。
- 老年代：存放新生代中经历多次GC仍然存活的对象。

JDK7:

![img](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/9DAA470E-243A-4877-9257-4332F3F709AA.png)

JDK8：

![img](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/4CC6274D-B8D6-43E9-8263-6427BB2088C0.png)

## 为什么要分代

不分代也可以，分代的唯一理由是优化GC性能。如果没有分代的话，所有的对象都在一块。GC要找到哪些对象没有用的话，就需要对堆所有的区域进行扫描。而很多东西都是朝生夕死。如果分代的话，把新建的对象放在某一个地方，需要gc的时候，先将这块区域进行回收，腾出很大的空间。

# TLAB

Thread Local Allocation Buffer

- 从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。
- 所有OpenJDK衍生出来的JVM都提供了TLAB的设计。
  ![img](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/E2171052-57C3-41E2-8DB5-B07E605A2705.png)

为什么有TLAB？

- 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据
- 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的
- 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。

所以，多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。

## TLAB 参数设置

- 尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。
- 在程序中，开发人员可以通过选项“-XX:+/-UseTLAB”设置是否开启TLAB空间。
- 默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项“-XX:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。
- 一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存

![img](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/EB0EC2A0-F8D1-43CA-80DE-7AF3EFB81EFA.png)

# 方法区

## 堆、栈、方法区的关系

![img](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/BC6B1D30-0A01-4A07-966A-990E8466D257.png)

![img](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/DF5BC3E0-0799-4F00-A366-1FA4C39D5D1C.png)

![img](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/07F5D72D-D061-4131-91D5-0DE70D79DC11.png)

## 方法区的位置

<Java虚拟机规范>中说明所有的方法区在逻辑上是属于堆的一部分。对于HotSpotJVM而言，方法区有一个别名叫做`no heap`,目的是和堆分开

**将方法区看做是独立于Java堆得内存空间**

![img](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/1AE5EA48-E43B-44EB-BC3D-7EF3A6E52916.png)

## 方法区的理解

- 共享：方法区与堆都是各个线程共享的内存区域
- 方法区在JVM启动的时候创建，实际的物理内存空间和Java堆一样可以是不连续的
- 方法区的大小，可以选择固定大小或者动态扩展
- 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutOfMemoryError: PermGen space 或者 java.lang.OutOfMemoryError: Metaspace
- 加载大量的第三方的jar包；Tomcat部署的工程过多（30-50个）；大量动态的生成反射类
- 关闭JVM就会释放这个区域的内存。

## HotSpot方法区的演进

1. jdk7及以前，成为**永久代**。jdk8开始，使用元空间替换永久代

   本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEA JRockit/ IBM J9中不存在永久代的概念。

2. 元空间本质和永久代类似，都是JVM规范中方法区的实现。区别在于：**元空间不在虚拟机设置的内存，而是使用本地内存。**

3. 永久代、元空间二者并不只是名字变了，内部结构也调整了。

4. 根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常

## 方法区常用参数

### jdk1.7之前

- 通过-XX: PermSize来设置永久代初始分配空间。默认值是20.75M
- -XX:MaxPermSize来设置永久代最大可分配空间。32位机制默认是64M, 64位机制默认是82M
- 当JVM加载的类信息容量超过了这个值，会报异常OutOfMemoryError:PermGen space

### jdk1.8之后

- 元数据区大小可以使用参数**-XX:MetaspaceSize和-XX:MaxMetaspaceSize**指定,替代上述原有的两个参数
- 默认值依赖于平台。windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize 的值是-1，即没有限制。
- 默认情况下，如果不指定大小，会耗尽所有的可用系统内存。如果元空间区域发生溢出，虚拟机也会抛出常OutOfMemoryError: Metaspace
- -XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-XX:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。
- 如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为**了避免频繁地GC ，建议将-XX:MetaspaceSize设置为一个相对较高的值**

## 方法区的信息

### 类信息

对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息： 

① 这个类型的完整有效名称（全名=包名.类名）

② 这个类型直接父类的完整有效名(对于interface或是java.lang.Object，都没有父类) 

③ 这个类型的修饰符(public,abstract, final的某个子集) 

④ 这个类型直接接口的一个有序列表 

### 域Field信息

- JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。

- 域的相关信息包括： 域名称、域类型、域修饰符(public, private, protected, static, final, volatile, transient的某个子集)

### 方法信息

JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序 ：

- 方法名称 
- 方法的返回类型(或 void)
- 方法参数的数量和类型(按顺序)
- 方法的修饰符(public, private, protected, static, final, synchronized, native, abstract的一个子集)
- 方法的字节码(bytecodes)、操作数栈、局部变量表及大小 （abstract和native方法除外）
- 异常表（abstract和native方法除外）
- 每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引

### not- final的类变量

- 静态变量和类关联在一起，随着类的加载而加载,它们成为类数据在逻辑上的一部分。
- 类变量被类的所有实例共享，即使没有类实例时你也可以访问它。
- 全局常量：static final。被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。

### 运行时常量池

- 运行时常量池（Runtime Constant Pool）是方法区的一部分。
- 常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。
- 运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。
- JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。
- 运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。
- 运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。
- String.intern()
- 运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些。
  当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutOfMemoryError异常。

## 永久代与元空间

1. 只有HotSpot才有永久代

2. HotSpot中永久代的变化

jdk1.6及之前：有永久代(permanent generation)

jdk1.7：有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中

jdk1.8及之后： 无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池仍在堆

![img](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/1BDFC218-0594-47AB-A5B4-538863E7A69C.png)

![img](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/6A6650AB-A24A-4A20-B2B5-23BFFF885F11.png)

![img](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/14E9585E-D497-4AFF-9232-D41C725416DA.png)

### 永久代被替换的原因

1. 永久代设置空间大小很难确定。在某些场景下，如果动态加载类过多，容易产生Perm 区的OOM 。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。
   **而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。**
2. 对永久代很难调优

### StringTable为什么需要调整

jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而full gc是老年代的空间不足、永久代不足时才会触发。

这就导致StringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。

### 静态变量存放

JDK 7及其以后版本的HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射Class对象存放在一起

## 方法区是否存在GC

> 有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK 11时期的ZGC收集器就不支持类卸载）。
>
> 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。
>
> 方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。
>
> - 先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：
> - 1、类和接口的全限定名
> - 2、字段的名称和描述符
> - 3、方法的名称和描述符 
>
> - HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。
>
> - 回收废弃常量与回收Java堆中的对象非常类似。
>
> - 判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件： 
> - 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 
> - 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。 
> - 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
>
> - Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class以及-XX:+TraceClassLoading -XX:+TraceClassUnloading查看类加载和卸载信息
>
> - 在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。
