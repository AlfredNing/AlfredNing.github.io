---
title: "运行时内存"
date: 2023-02-27T21:33:26+08:00
lastmod: 2023-02-27T21:33:26+08:00
author: ["AlfredNing"]
keywords: 
- 
categories: # 没有分类界面可以不填写
- 
tags: # 标签
- jvm
description: ""
weight:
slug: ""
draft: false # 是否为草稿
comments: true # 本页面是否显示评论
reward: true # 打赏
mermaid: true #是否开启mermaid
showToc: true # 显示目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示路径
cover:
    image: "" #图片路径例如：posts/tech/123/123.png
    caption: "" #图片底部描述
    alt: ""
    relative: false
---

jvm内存结构图

![image-20230227213433004](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230227213433004.png)

哪些内存结构与线程意义对应，其实问的是线程共有和私有
共有： 堆和方法区
私有： 本地方法栈、虚拟机栈、程序计数器

# 程序计数器

1. 保证程序在程序系统中能够执行下去，CPU必须具有某些手段来确定下一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器
2. 一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器。
   在程序开始执行前，必须将它的起始地址，即程序的一条指令所在的内存单元地址送入PC，因此程序计数器（PC）的内容即是从内存提取的第一条指令的地址。当执行指令时，CPU将自动修改PC的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数，以便使其保持的总是将要执行的下一条指令的地址
3. 由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单的对PC加1
4. 当程序转移时，转移指令执行的最终结果就是要改变PC的值，此PC值就是转去的地址，以此实现转移。有些机器中也称PC为指令指针IP（Instruction Pointer）

## 特征

> JVM中的程序计数寄存器（Program Counter Register）中， Register 的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。 CPU只有把数据装载到寄存器才能够运行。

**JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟**

- 很小的内存结构，忽略不计，也是运行最快的存储区域，不会随着程序的运行需要更大的空间
- 在JVM规范中，每个线程都有自己的程序计数器，是线程私有的，生命周期与线程生命周期保持一致
- **它是唯一一个在JVM虚拟机规范中没有规定任何OutOtMemoryError 情况的区域**

## 问题

1. 为什么使用PC寄存器来记录当前线程的执行地址
   因为CPU需要不停的切换各个线程，准确知道执行的位置。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令
2. PC寄存器为什么被设置为线程私有
   多线程在一个特定的时间段内之会执行某一个线程的方法，CPU需要不停的做任务切换**。为了准确记录各个线程正在执行的当前字节码指令，最好的办法就是为每一个线程分配PC寄存器**，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况

# 虚拟机栈

> 栈管运行，堆管内存
>
> 栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿
>
> - Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。
> - 是线程私有的
>
> 生命周期: 生命周期和线程一致。
>
> 特点: 栈是一种快速有效的分配存储方式，**访问速度仅次于程序计数器**。

栈是否有GC？ 不存在GC, 但有OOM

抛出的异常：

- StackOverFlowError
- OutOfMemoryError

1. Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的
2. 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个 StackOverflowError 异常
3. 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出—个 OutOfMemoryError 异常

## 设置栈大小

 -Xsssize (即：-XX:ThreadStackSize)

- 一般为：512k-1M
- 栈的大小直接决定了函数调用的最大深度
- 设置的栈空间值过大，会导致系统可以用于创建线程的数量减少

一般一个进程中通常有3000-5000个线程

jdk5.0之前，默认为256k
jdk5.0之后，默认为1024k

## 栈帧

栈的基本单位是栈帧，每个线程都有自己的栈，栈中的数据都是以栈帧存在的。

### 方法与栈帧的关系

- 在这个线程执行的方法都有一个栈帧
- 栈帧是一个内存区块，是一个数据集，维护着方法执行过程中的各种数据信息

### 栈的内部结构

- 局部变量表
- 操作数栈或表达式栈
- 动态链接或指向运行时常量池的方法引用
- 方法返回地址（或方法正常退出或者异常退出的定义）
- 一些附加信息

![img](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/53BA4F99-EA72-4192-B3B8-44BDE74899EF.png)



#### 局部变量表 - Local Varibales

- 局部变量表被称为局部变量数组或者本地变量表
- **定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量**，数据类别包括：基本数据类型，对象引用、以returnAddress类型
- **局部变量表的大小是在编译器确定**，保存在方法的code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的
- **方法嵌套调用的次数由栈的大小决定**。一般来说，**栈越大，方法嵌套调用次数越多**。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减
- **局部变量表的变量只在当前方法调用中有效。**在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。**当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。**

##### 静态变量与局部变量区别

- 类变量表有两次初始化的机会，第一次准备阶段，执行系统初始化，赋零值，另一次是在初始化阶段，赋予代码中指定的初始值
- 和类变量初始化不同，局部变量表不存在系统初始化的过程，**一旦定义了局部变量则必须人为的初始化，否则无法使用**

##### 与GC ROOTS的关系

**局部变量表的变量也是重要的垃圾回收节点，只要被局部变量中直接或者间接引用的对象都不会被回收**

#### 操作数栈 Operand Stack

操作数栈（Operand Stack）

- 我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。
- 每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出（Last-In-First-Out）的操作数栈，也可以称之为表达式栈（Expression Stack）。

- 操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。

- 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值。

- 栈中的任何一个元素都是可以任意的Java数据类型。

- 32bit的类型占用一个栈单位深度
- 64bit的类型占用两个栈单位深度

- 操作数栈，在方法执行过程中，根据字节码指令，并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈（push）和出栈（pop）操作，往栈中写入数据或提取数据来完成一次数据访问。

- 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。比如：执行复制、交换、求和等操作

- 如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。

##### 栈顶缓存

由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（ToS，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。

##### 动态链接（或指向运行时常量池的方法引用）

- 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic指令
- 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。

##### 常量池的作用

常量池的作用，就是为了提供一些符号和常量，便于指令的识别。

##### 方法返回地址

- 存放调用该方法的pc寄存器的值。

- 一个方法的结束，有两种方式：
- 正常执行完成
- 出现未处理的异常，非正常退出

- 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。

# 本地方法与本地方法栈

## 本地方法

简单地讲，一个Native Method就是一个Java调用非Java代码的接口。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern "C"告知C++编译器去调用一个C的函数。

 "A native method is a Java method whose implementation is provided by non-java code."

在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。

本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合 C/C++程序。

## 本地方法栈

- Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。
- 本地方法栈，也是线程私有的。
- 允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）
- 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个 StackOverflowError 异常。
- 如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个 OutOfMemoryError 异常。
- 本地方法是使用C语言实现的。
- 它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。

# 堆

- 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。

- Java 堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。

- 堆内存的大小是可以调节的。

- 《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。

- 堆，是GC ( Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。
- 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。

> 对象都分配在堆上？
>
> - 《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated ) 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置
> - “几乎”所有的对象实例都在这里分配内存。——从实际使用角度看的。TLAB的存在

## TLAB

**Thread Local Allocation Buffer**

- 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据
- 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的
- 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。

**所以，多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。**

堆的内部结构

现代垃圾收集器大部分都基于分代收集理论设计。

1. Java 7及之前堆内存逻辑上分为三部分：**新生区+养老区+永久区**
   Young Generation Space   新生区      Young/New 又被划分为Eden区和Survivor区
   Tenure generation space  养老区      Old/Tenure
   Permanent Space          永久区      Perm
2. Java 8及之后堆内存逻辑上分为三部分：**新生区+养老区+元空间**
   Young Generation Space    新生区      Young/New 又被划分为Eden区和Survivor区
   Tenure generation space   养老区      Old/Tenure
   Meta Space                元空间      Meta
   ![img](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/428161D7-41DB-4FFE-8D47-74F45FDAC0CE.png)

### 年轻代与老年代

- 存储在JVM中的Java对象可以被划分为两类：
- 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速
- 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。
- Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（OldGen）
- 其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）。

![img](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/34DC8A34-8FC1-4410-AAD6-421A3CE7010B.png)

- 几乎所有的Java对象都是在Eden区被new出来的。
- 绝大部分的Java对象的销毁都在新生代进行了。
- IBM 公司的专门研究表明，新生代中 80% 的对象都是“朝生夕死”的。

## 设置堆内存

### 设置新生代与老年代的比例

![img](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/3361B78F-4E9C-47DF-AA94-C10367777ECE.png)

- 配置新生代与老年代在堆结构的占比。
- 默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3
- 可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5
- 可以使用选项”-Xmn”设置新生代最大内存大小

**这个参数一般使用默认值就可以了。**

### 设置Eden 与Suvivor比例

- 在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1
- 可以通过选项“-XX:SurvivorRatio”调整这个空间比例。比如**-XX:SurvivorRatio=8**

## 参数设置

### 堆空间大小的设置

- -Xms:初始内存 （默认为物理内存的1/64）
- -Xmx:最大内存（默认为物理内存的1/4）

### 新生代大小设置

**-Xmn**

设置新生代的大小。(初始值及最大值) **通常默认即可。**

### 设置新生代垃圾的最大年龄。超过此值，仍未被回收的话，则进入老年代

- 默认值为15
- -**XX:MaxTenuringThreshold**=0：表示年轻代对象不经过Survivor区，直接进入老年代。对于老年代比较多的应用，可以提高效率。
- 如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代的存活时间，增加在年轻代即被回收的概率

### 输出详细的GC处理日志

**-XX:+PrintGCDetails**

### 在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间

**-XX:HandlePromotionFailure**

- 如果大于，则此次Minor GC是安全的
-  如果小于，则虚拟机会查看-XX:HandlePromotionFailure设置值是否允许担保失败。
- 如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于或者HandlePromotionFailure=false，则改为进行一次Full GC。

### 查看所有的参数的最终值

**-XX:+PrintFlagsFinal**

```java
具体查看某个参数的指令： jps：查看当前运行中的进程
 jinfo -flag SurvivorRatio 进程id
    
-Xms60m -Xmx60m -XX:NewRatio=2 -XX:SurvivorRatio=8 -XX:+PrintGCDetails    
```

## 对象分配过程

1.new的对象先放伊甸园区。此区有大小限制。

2.当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC/YGC)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区

3.然后将伊甸园中的剩余对象移动到幸存者0区。

4.如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。

5.如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。

6.啥时候能去养老区呢？可以设置次数。默认是15次。

- 可以设置参数：-XX:MaxTenuringThreshold= 设置对象晋升老年代的年龄阈值。

7.在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理。

8.若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生OOM异常 java.lang.OutOfMemoryError: Java heap space

### 分配策略

内存分配策略（或对象提升(promotion)规则):

如果对象在Eden 出生并经过第一次MinorGC 后仍然存活，并且能被Survivor 容纳的话，将被移动到Survivor 空间中，并将对象年龄设为1 。对象在Survivor 区中每熬过一次MinorGC ， 年龄就增加1岁，当它的年龄增加到一定程度（默认为15 岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代中。

### 内存分配原则

针对不同年龄段的对象分配原则如下所示：

- 优先分配到Eden
- 大对象直接分配到老年代 
- 尽量避免程序中出现过多的大对象
- 长期存活的对象分配到老年代
- 动态对象年龄判断
- 如果Survivor 区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。
- 空间分配担保
- -XX:HandlePromotionFailure
