---
title: "类的加载"
date: 2023-02-23T20:16:54+08:00
lastmod: 2023-02-23T20:16:54+08:00
author: ["AlfredNing"]
keywords: 
- 
categories: # 没有分类界面可以不填写
- 
tags: # 标签
- jvm
description: ""
weight:
slug: ""
draft: false # 是否为草稿
comments: true # 本页面是否显示评论
reward: true # 打赏
mermaid: true #是否开启mermaid
showToc: true # 显示目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示路径
cover:
    image: "" #图片路径例如：posts/tech/123/123.png
    caption: "" #图片底部描述
    alt: ""
    relative: false
---

## 类的加载过程

> Java数据类型分为数据基本数据类型和引用数据类型
>
> 基本类型由虚拟机预先定义，引用类型需要进行类的加载

类的加载大过程分为三步, 总过程七步

![image-20230223202441994](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230223202441994.png)

## 装载

**将java的class文件加载到机器内存，并在内存中构建出Java类的原型-类模板对象**

查找类的二进制文件，生成class实例

加载类，需要完成以下三件事情：

- 通过类的全名，获取类的二进制数据流
- 解析类的二进制数据流转换为方法区的数据结构(**Java类模型**)
- 创建java.lang.class类的实例，表示该类型

### 类模板对象

Java类在内存中的一个快照，JVM从字节码文件解析出来的常量池、类字段、类方法等类信息存储到类模板中。在运行期通过类模板获取Java类的任意信息，能够对Java类的成员变量进行遍历，进行方法调用。**反射机制也是基于此，如果没有存储Java类的声明信息，JVM在运行期也无法进行反射**

### 获取二进制数据流

class字节码文件符号JVM规范

- 通过读取class后缀的文件
- 读入jar、zip等归档数据包，提取类文件(热部署jar包原理基础)
- 事先存放在数据库的二进制数据
- 使用类型Http之类的协议通过网络进行加载
- 在运行时生成一段class的二进制信息等

### class实例位置

类将.class文件加载至元空间后，会在堆中创建一个Java.lang.Class对象，用来封装类位于方法区内的数据结构，该Class对象是在加载类的过程中创建的，每个类都对应有一个Class类型的对象![image-20230223203835960](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230223203835960.png)

### 数组类的加载

数组类本身不是由类加载器负责创建，而是由JVM在运行时根据需要去创建。加载器只负责加载数据元素的数据类型(基本数据类型和引用数据类型)，申请内存分配长度

## 链接

### 验证阶段

保证加载的字节码是合法、合理并符合jvm规范

![img](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/383F532C-0FB2-466F-9F82-6756791E6268.png)

- **格式验证回合装载阶段一起执行。验证通过之后，类加载器才会把验证成功的二级制数据信息加载到方法区中**
- **格式验证之外的验证操作都在方法区中进行**

### 准备阶段

为类的静态变量分配内存，并将其初始化为默认值。

**Java并不支持boolean类型，对于boolean类型，内部实现是int,由于int的默认值是0,故对应的，boolean的默认值就是false**

### 解析阶段

将类、接口、自动和方法的符号引用转换为直接应用

符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。比较容易理解的就是在Class类文件中，通过常量池进行了大量的符号引用。通过解析操作，符号引用就可以转化为目标方法在类中方法表的位置，从而使得方法被成功调用。

**解析就是将符号引用转换为直接引用。换言之，直接引用存在，一定存在符号引用，反之不然**

> Java虚拟机规范并没有要求解析操作一定要按照顺序执行
>
> 在HotSpot VM中，加载、验证、准备和初始化会按照顺序有条不紊地执行，但链接阶段中的解析操作往往会伴随着JVM在执行完初始化之后再执行

## 初始化

为静态变量赋予正确的初始值

开始执行java字节码，执行类的初始化方法

- clinit方法：该方法只能由JVM编译器生成，程序开发者无法自定义一个同名的方法，无法在java程序中调用该方法，该方法由java字节码组成
- init方法：由类的静态成员变量赋值及其static语句块产生

### clinit方法的生成

以下几种情况，不会生产clinit方法

1. 一个类中没有声明任何**类变量**，也没静态代码块
2. 一个类中声明类变量，但没有明确使用类的初始化语句以及静态代码块进行初始化操作
3. 一个类中包含static final 修饰的基本类型字段，这些类字段使用编译时常量表达式

clinit是由虚拟机保证在多线程环境下正确的加锁同步，是线程安全的。如果有很长的耗时操作，是会造成死锁的。

### 类的加载

加载 = 装载 + 链接 + 初始化

Java程序的主动使用

#### 主动使用的说明

Class只有在必须要首次使用的时候才会被装载，Java虚拟机不会无条件地装载Class类型。Java虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用。

主动使用只有下列几种情况：（即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成。）

1. 当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化。

2. 当调用类的静态方法时，即当使用了字节码invokestatic指令。

3. 当使用类、接口的静态字段时(final修饰特殊考虑)，比如，使用getstatic或者putstatic指令。

4. 当使用java.lang.reflect包中的方法反射类的方法时。比如：Class.forName("com.atguigu.java.Test")

5. 当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。

6. 如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。

7. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。

8. 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。（涉及解析REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄对应的类）

#### 被动使用的情况

除了以上的情况属于主动使用，其他的情况均属于被动使用。被动使用不会引起类的初始化。

也就是说：**并不是在代码中出现的类，就一定会被加载或者初始化。如果不符合主动使用的条件，类就不会初始化**。

1. 当访问一个静态字段时，只有真正声明这个字段的类才会被初始化。

- 当通过子类引用父类的静态变量，不会导致子类初始化

2. 通过数组定义类引用，不会触发此类的初始化

3. 引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了。

4. 调用ClassLoader类的loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化。

**被动的使用，意味着不需要执行初始化环节，意味着没有clinit方法的调用**

> 如果针对代码，设置参数-XX:+TraceClassLoading，可以追踪类的加载信息并打印出来

### Class.forName 与loadClass

Clas.forName加载后执行到初始化阶段

Class.getClassLoader#loadClass只会执行到装载阶段

## 使用

在程序中访问和调用它的静态类成员信息

## 卸载

### 类、类加载器和类的实例之间的引用关系

在类的加载器内部实现中，用一个集合来存放所加载类的引用。另一方面，一个class对象总是会引用它的类加载器，调用class对象的getClassLoader方法，就能够获取它的类加载器。由此可见，代表某个类的Class实例与其类的加载器之间为双向关联关系。
一个类的实例总是引用代表这个类的Class对象。在Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有的Java类都有一个静态属性class，它引用代表这个类的Class对象

### 类卸载的时机

**一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期**

![image-20230227153343489](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230227153343489.png)

当Sample类被加载、链接和初始化后，它的生命周期就开始了。当代表Sample类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，Sample类在方法区内的数据也会被卸载，从而结束Sample类的生命周期。

> 例如：
>
> loader1变量和obj变量间接引用代表Sample类的Class对象，而objClass变量则直接引用它。
>
> 如果程序运行过程中，将上图左侧三个引用变量都置为null，此时Sample对象结束生命周期，MyClassLoader对象结束生命周期，代表Sample类的Class对象也结束生命周期，Sample类在方法区内的二进制数据被卸载。
>
> 当再次有需要时，会检查Sample类的Class对象是否存在，如果存在会直接使用，不再重新加载；如果不存在Sample类会被重新加载，在Java虚拟机的堆区会生成一个新的代表Sample类的Class实例(可以通过哈希码查看是否是同一个实例)

### 类卸载在实际生产的情况

1. 启动类加载器加载的类型在整个运行期间是不可能被卸载的(jvm和jls规范)

2. 被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到unreachable的可能性极小。

3. 被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景中(比如：很多时候用户在开发自定义类加载器实例的时候采用缓存的策略以提高系统性能)，被加载的类型在运行期间也是几乎不太可能被卸载的(至少卸载的时间是不确定的)。

**综合以上三点，一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的。同时我们可以看的出来，开发者在开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下，来实现系统中的特定功能。**

### 方法区的垃圾回收

回收内容：常量池中废弃常量和不在使用的类

HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收

确定不在使用的类必须同时满足下面三个条件

1. 该类所有的实例都已经被回收。也就是Java堆中不存在该类及其任何派生子类的实例
2. 加载该类的类加载器已经被回收。这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的
3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“**被允许**”，而并不是和对象一样，没有引用了就必然会回收