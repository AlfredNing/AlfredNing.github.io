---
title: "C++基础5"
date: 2023-03-28T22:10:36+08:00
lastmod: 2023-03-28T22:10:36+08:00
author: ["AlfredNing"]
keywords: 
- 
categories: # 没有分类界面可以不填写
- 
tags: # 标签
- c++
description: ""
weight:
slug: ""
draft: false # 是否为草稿
comments: true # 本页面是否显示评论
reward: true # 打赏
mermaid: true #是否开启mermaid
showToc: true # 显示目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示路径
cover:
    image: "" #图片路径例如：posts/tech/123/123.png
    caption: "" #图片底部描述
    alt: ""
    relative: false
---

# 信号处理

号是由操作系统传给进程的中断，会提早终止一个程序。在 UNIX、LINUX、Mac OS X 或 Windows 系统上，可以通过按 Ctrl+C 产生中断

可以在程序捕获的信号

| 信号    | 描述                                         |
| ------- | -------------------------------------------- |
| SIGABRT | 程序的异常终止，如调用 **abort**。           |
| SIGFPE  | 错误的算术运算，比如除以零或导致溢出的操作。 |
| SIGILL  | 检测非法指令。                               |
| SIGINT  | 接收到交互注意信号。                         |
| SIGSEGV | 非法访问内存。                               |
| SIGTERM | 发送到程序的终止请求。                       |

- signal函数： 捕获突发事件
- raise函数：生成信号

# c++多线程

基于进程 ： 程序的并发执行

基于线程：同一程序的片段并发执行

多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径

> 使用 POSIX 编写多线程 C++ 程序。POSIX Threads 或 Pthreads 提供的 API 可在多种类 Unix POSIX 系统上可用，比如 FreeBSD、NetBSD、GNU/Linux、Mac OS X 和 Solaris

## 创建线程

```c++
#include <pthread.h>pthread_create (thread, attr, start_routine, arg)
```

在这里，**pthread_create** 创建一个新的线程，并让它可执行。下面是关于参数的说明：

| 参数          | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| thread        | 指向线程标识符指针。                                         |
| attr          | 一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。 |
| start_routine | 线程运行函数起始地址，一旦线程被创建就会执行。               |
| arg           | 运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。 |

创建线程成功时，函数返回 0，若返回值不为 0 则说明创建线程失败

## 终止线程

用下面的程序，我们可以用它来终止一个 POSIX 线程：

```c++
#include <pthread.h>pthread_exit (status)
```

在这里，**pthread_exit** 用于显式地退出一个线程。通常情况下，pthread_exit() 函数是在线程完成工作后无需继续存在时被调用。

如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止

## 向线程传递参数

```c++
#include <iostream>
#include <cstdlib>
#include <pthread.h>
using namespace std;
#define NUM_THREADS 5
struct thread_data{   
	int  thread_id;   
	char *message;
};
void *PrintHello(void *threadarg){   
	struct thread_data *my_data;
	my_data = (struct thread_data *) threadarg;   
	cout << "Thread ID : " << my_data->thread_id ;   
	cout << " Message : " << my_data->message << endl;   
	pthread_exit(NULL);
}
int main (){ 
	pthread_t threads[NUM_THREADS];  
	struct thread_data td[NUM_THREADS];  
	int rc;   int i;   
	for( i=0; i < NUM_THREADS; i++ ){    
		cout <<"main() : creating thread, " << i << endl;
		td[i].thread_id = i; 
		td[i].message = "This is message"; 
		rc = pthread_create(&threads[i], NULL, PrintHello, (void *)&td[i]);   
		if (rc){      
			cout << "Error:unable to create thread," << rc << endl;  
			exit(-1);  
		} 
	} 
	pthread_exit(NULL);
    return 0;
}
```

## 连接和分离线程

```
pthread_join (threadid, status) pthread_detach (threadid)
```

pthread_join() 子程序阻碍调用程序，直到指定的 threadid 线程终止为止。

当创建一个线程时，它的某个属性会定义它是否是可连接的（joinable）或可分离的（detached）。

只有创建时定义为可连接的线程才可以被连接。如果线程创建时被定义为可分离的，则它永远也不能被连接。

# STL

C++ 标准模板库的核心包括以下三个组件：

| 组件                | 描述                                                         |
| ------------------- | ------------------------------------------------------------ |
| 容器（Containers）  | 容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。 |
| 算法（Algorithms）  | 算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。 |
| 迭代器（iterators） | 迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。 |

三个组件都带有丰富的预定义函数，通过简单的方式处理复杂的任务

```c++
#include <iostream>
#include <iostream>
#include <vector>
using namespace std;

int main() {
	// 向量存储
	vector<int> vec;
	int i;
	cout << "vector size: " << vec.size() << endl;

	for (int i = 0; i < 5; i++) {
		vec.push_back(i);
	}
	cout << "vector size: " << vec.size() << endl;
	for (i = 0; i < 5; i++) {
		cout << "value of vec [" << i << "] = " << vec[i] << endl;
	}
	vector<int>::iterator  v = vec.begin();
	while (v != vec.end()) {
		cout << "value of v = " << *v << endl;
		v++;
	}

	return 0;
}
```

## c++标准库

C++ 标准库可以分为两部分：

- **标准函数库：** 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。
- **面向对象类库：** 这个库是类及其相关函数的集合。

C++ 标准库包含了所有的 C 标准库，为了支持类型安全，做了一定的添加和修改。

### 标准函数库

- 输入/输出 I/O
- 字符串和字符处理
- 数学
- 时间、日期和本地化
- 动态分配
- 其他
- 宽字符函数

### 面向对象类库

标准的 C++ 面向对象类库定义了大量支持一些常见操作的类，比如输入/输出 I/O、字符串处理、数值处理。面向对象类库包含以下内容：

- 标准的 C++ I/O 类
- String 类
- 数值类
- STL 容器类
- STL 算法
- STL 函数对象
- STL 迭代器
- STL 分配器
- 本地化库
- 异常处理类
- 杂项支持库