---
title: "C++基础4"
date: 2023-03-27T20:10:47+08:00
lastmod: 2023-03-27T20:10:47+08:00
author: ["AlfredNing"]
keywords: 
- 
categories: # 没有分类界面可以不填写
- 
tags: # 标签
- 
description: ""
weight:
slug: ""
draft: false # 是否为草稿
comments: true # 本页面是否显示评论
reward: true # 打赏
mermaid: true #是否开启mermaid
showToc: true # 显示目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示路径
cover:
    image: "" #图片路径例如：posts/tech/123/123.png
    caption: "" #图片底部描述
    alt: ""
    relative: false
---

# 数据封装

面向对象编程中把数据和操作数据的函数绑定在一起的一个概念。同等概念既数据隐藏

默认情况下，在类中定义的所有项目都是私有的。

把一个类定义为另一个类的友元类，会暴露实现细节，从而降低了封装性。理想的做法是尽可能地对外隐藏每个类的实现细节

## 设计策略

通常情况下，我们都会设置类成员状态为私有（private），除非我们真的需要将其暴露，这样才能保证良好的**封装性**。

这通常应用于数据成员，但它同样适用于所有成员，包括虚函数

# 接口（抽象类）

接口描述类的行为和功能，而不需要完成特定类的实现。

c++中的接口是用抽象类来实现，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与数据分离开的概念

**抽象类: 类中至少有一个函数被声明为纯虚函数**，纯虚函数是通过在声明中使用 "= 0" 来指定的

设计**抽象类**（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为**接口**使用。如果试图实例化一个抽象类的对象，会导致编译错误。

因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重载纯虚函数，就尝试实例化该类的对象，会导致编译错误。

可用于实例化对象的类被称为**具体类**。

```c++
#include <iostream>
using namespace std;
// 基类
class Shape {public:
  // 提供接口框架的纯虚函数
virtual int getArea() = 0;
void setWidth(int w)
{
    width = w;
}
void setHeight(int h)
{
    height = h;
}protected:
    int width;
    int height;};
    // 派生类
class Rectangle: public Shape{public:
    int getArea()
    {
        return (width * height);
    }};
class Triangle : public Shape {
    public:
        int getArea()
        {
            return (width * height) / 2;
        }
};
int main(void) {
    Rectangle Rect;
    Triangle  Tri;

    Rect.setWidth(5);
    Rect.setHeight(7);
    // 输出对象的面积
    cout << "Total Rectangle area: " << Rect.getArea() << endl;

    Tri.setWidth(5);
    Tri.setHeight(7);
    // 输出对象的面积
    cout << "Total Triangle area: " << Tri.getArea() << endl;

    return 0;
}
```

## 设计策略

面向对象的系统可能会使用一个抽象基类为所有的外部应用程序提供一个适当的、通用的、标准化的接口。然后，派生类通过继承抽象基类，就把所有类似的操作都继承下来。

外部应用程序提供的功能（即公有函数）在抽象基类中是以纯虚函数的形式存在的。这些纯虚函数在相应的派生类中被实现。

这个架构也使得新的应用程序可以很容易地被添加到系统中，即使是在系统被定义之后依然可以如此

# 文件和流

标准库 **fstream**：从文件读取流和向文件写入流

| 据类型   | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| ofstream | 该数据类型表示输出文件流，用于创建文件并向文件写入信息。     |
| ifstream | 该数据类型表示输入文件流，用于从文件读取信息。               |
| fstream  | 该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。 |

### 打开文件

在从文件读取信息或者向文件写入信息之前，必须先打开文件。**ofstream** 和 **fstream** 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 **ifstream** 对象

```c++
void open(const char *filename, ios::openmode mode);
ofstream outfile;
// 写入文件模式 截断文件
outfile.open("file.dat", ios::out | ios::trunc );
// 打开文件，读写
fstream  afile;
afile.open("file.dat", ios::out | ios::in );
```

| 模式标志   | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| ios::app   | 追加模式。所有写入都追加到文件末尾。                         |
| ios::ate   | 文件打开后定位到文件末尾。                                   |
| ios::in    | 打开文件用于读取。                                           |
| ios::out   | 打开文件用于写入。                                           |
| ios::trunc | 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。 |

### 关闭文件

在 C++ 编程中，使用流插入运算符（ << ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里使用的是 **ofstream** 或 **fstream** 对象，而不是 **cout** 对象

### 读取文件

使用流提取运算符（ >> ）从文件读取信息，对象是ofstream或fstream

```c++
#include <iostream>
#include <fstream>
using namespace std;
int main() {
	char data[100];
	// 写模式打开文件
	ofstream outfile;
	outfile.open("afile.dat");
	
	cout << "Write to the file " << endl;
	cout << "Enter your name " << endl;
	cin.getline(data, 100);
	// 写文件写入
	outfile << data << endl;

	// 读模式打开文件
	ifstream infile;
	infile.open("afile.dat");
	cout << "Reading from the file " << endl;
	infile >> data;
	cout << data << endl;
	infile >> data;
	cout << data << endl;

	infile.close();

	return 0;
}
```

文件位置指针

**istream** 和 **ostream** 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 **seekg**（"seek get"）和关于 ostream 的 **seekp**（"seek put"）。

seekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 **ios::beg**（默认的，从流的开头开始定位），也可以是 **ios::cur**（从流的当前位置开始定位），也可以是 **ios::end**（从流的末尾开始定位）。

文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。

# 异常处理

- throw： 当问题出现， 程序会抛出一个异常
- catch:  捕获异常处理
- try:  **try** 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块

可以使用 **throw** 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。

```c++
#include <iostream>
using namespace std;
double division(int a, int b) {
	if (b == 0) {
		throw "Diviision By Zero";
	}
	return a / b;
}
int main() {
	try {
		double z = division(50, 0);
		cout << z << endl;
	}
	catch (const char* msg) {
		cerr << msg << endl;
	}
	return 0;
}
```

## 标准异常

![image-20230327203905933](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230327203905933.png)

## 定义新的异常

通过继承和重载 **exception** 类来定义新的异常

```c++
#include <iostream>
using namespace std;
struct MyException : public exception {
	const char* what() const throw()
	{
		return "C++ exception";
	}
};
int main() {
	try {
		throw MyException();
	}
	catch (MyException& e) {
		cout << "e: " << e.what() << endl;
	}
	catch (exception& e) {
		// 其他错误
	}
	return 0;
}
```

# 动态内存

- 栈：在函数内部声明的所有变量都将占用栈内存
- 堆: 程序未使用的内存，在程序运行时候可用于动态内存分配

new运算符: 给定类型的变量在运行时分配堆内的内存，返回分配的内存地址

如果不需要动态分配内存，使用delete运算符，删除之前由 new 运算符分配的内存

包括数组在内的任意内置的数据类型，也可以是包括类或结构在内的用户自定义的任何数据类型。

**malloc() 函数在 C 语言中就出现了，在 C++ 中仍然存在，但建议尽量不要使用 malloc() 函数。new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象**

```c++
#include <iostream>
using namespace std;

int main() {
	double* pvalue = NULL; // 初始化为null的指针
	pvalue = new double; // 申请内存
	*pvalue = 29494.99; // 在申请的内存存储值
	cout << "Value of pavlue: " << *pvalue << endl;
	delete pvalue; // 释放内存
	return 0;
}
```

## 数组的动态内存分配

```c++
char* pvalue  = NULL;   // 初始化为 null 的指针
pvalue  = new char[20]; // 为变量请求内存
delete []pvalue;        // 删除 pvalue 所指向的数组

// new  多维数组分配内存
int ROW = 2;int COL = 3;
double **pvalue  = new double* [ROW]; // 为行分配内存
// 为列分配内存
for(int i = 0; i < COL; i++) {
	pvalue[i] = new double[COL];
}
// 释放多维数组内存：
for(int i = 0; i < COL; i++) {
    delete[] pvalue[i];
}
delete [] pvalue;
```

### 对象的动态内存分配

```c++
#include <iostream>
using namespace std;
class Box {
public:
	Box() {
		cout << "调用构造函数！" << endl;
	}
	~Box() {
		cout << "调用析构函数！" << endl;
	}
};int main() {
	Box* myBoxArray = new Box[4];

	delete[] myBoxArray; // Delete array

	return 0;
}
如果要为一个包含四个 Box 对象的数组分配内存，构造函数将被调用 4 次，同样地，当删除这些对象时，析构函数也将被调用相同的次数（4次）。
```

# 命名空间

作为附加信息来区分不同库中相同名称的函数、类、变量等，使用了命名空间既定义了上下文。**本质上，命名空间定义了一个范围**

## 定义命名空间

关键字 **namespace**后跟命名空间的名称

为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称：**name::code;  // code 可以是变量或函数**

```c++
#include <iostream>
using namespace std;
namespace first_space {
	void func() {
		cout << "Inside first_space " << endl;
	}
}
namespace second_space {
	void func() {
		cout << "Inside second_space " << endl;
	}
}
int main() {
	first_space::func();
	second_space::func();
	return 0;
}
```

## using指令

使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称
using 指令也可以用来指定命名空间中的特定项目

**using** 指令引入的名称遵循正常的范围规则。名称从使用 **using** 指令开始是可见的，直到该范围结束。此时，在范围以外定义的同名实体是隐藏的。

```c++
#include <iostream>
using namespace std;
namespace first_space {
	void func() {
		cout << "Inside first_space " << endl;
	}
}
namespace second_space {
	void func() {
		cout << "Inside second_space " << endl;
	}
}
using namespace first_space;
using std::cout;
int main() {
	func();
	second_space::func();
	return 0;
}
```

## 不连续的命名空间

命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。一个命名空间的各个组成部分可以分散在多个文件中

所以，如果命名空间中的某个组成部分需要请求定义在另一个文件中的名称，则仍然需要声明该名称。下面的命名空间定义可以是定义一个新的命名空间，也可以是为已有的命名空间增加新的元素

## 嵌套的命名空间

```c++
namespace namespace_name1 {
   // 代码声明
   namespace namespace_name2 {
      // 代码声明
   }
}
// 通过使用 :: 运算符来访问嵌套的命名空间中的成员
// 访问 namespace_name2 中的成员
using namespace namespace_name1::namespace_name2;
// 访问 namespace:name1 中的成员
using namespace namespace_name1;
```

# 模板

模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。

模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念

可以使用模板来定义函数和类

## 函数模板

```c++
#include <iostream>
using namespace std;
template <typename T> inline T const& Max(T const& a, T const& b) {
	return a < b ? b : a;
}
int main() {
	int i = 39;
	int j = 20;
	cout << "Max(i,j): " << Max(i, j) << endl;
	cout << "Max(i, j): " << Max(i, j) << endl;
	double f1 = 13.5;
	double f2 = 20.7;
	cout << "Max(f1, f2): " << Max(f1, f2) << endl;

	string s1 = "Hello";
	string s2 = "World";
	cout << "Max(s1, s2): " << Max(s1, s2) << endl;
	return 0;
}
```

## 类模板

```c++
#include <iostream>
#include <vector>
#include <cstdlib>
#include <string>
#include <stdexcept>
using namespace std;

template <class T> class Stack {
private:
	vector<T> elems;
public:
	void push(T const&);
	void pop();
	T top() const;
	bool empty() const {
		return elems.empty();
	}
};

template <class T> void Stack<T>::push(T const& elem) {
	elems.push_back(elem);
}

template <class T> void Stack<T>::pop() {
	if (elems.empty()) {
		throw out_of_range("Stack<>::pop(): empty stack");
	}
	elems.pop_back();
}

template <class T> T Stack<T>::top() const {
	if (elems.empty()) {
		throw out_of_range("Stack<>::pop(): empty stack");
	}
	return elems.back();
}
int main() {

	try
	{
		Stack<int> intStack;
		Stack<string> strStack;
		intStack.push(8);
		cout << intStack.top() << endl;

		strStack.push("hello");
		cout << strStack.top() << endl;
		strStack.pop();
		strStack.pop();

	}
	catch (exception const& ex) {
		cerr << "Exception: " << ex.what() << endl;
		return -1;
	}
	return 0;
}
```

# 预处理器

指令用在指示编译器在实际编译器之前完成所需完成的预处理

- 所有的预处理器以#开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾
- #include #define、#if、#else、#line 等

## #define 预处理

\#define 预处理指令用于创建符号常量。该符号常量通常称为**宏**

### 函数宏

\#define 来定义一个带有参数的宏

```c++
#include <iostream>
using namespace std;
#define MIN(a,b) (a<b ? a : b)
int main (){
   int i, j;
   i = 100;
   j = 30;
   cout <<"较小的值为：" << MIN(i, j) << endl;
    return 0;
}
```

### 条件编译

有几个指令可以用来有选择地对部分程序源代码进行编译。这个过程被称为条件编译。

```c++
#ifndef NULL   
#define NULL 0
#endif

// 调试
#ifdef DEBUG   
cerr <<"Variable x = " << x << endl;
#endif

#if 0   不进行编译的代码#endif
```

```c++
#include <iostream>
using namespace std;
#define DEBUG 
#define MIN(a, b)( (b < a) ? b : a)
int main() {
	int i, j;
	i = 100;
	j = 30;
#ifdef  DEBUG
	cerr << "Trace: Inside main function" << endl;
#endif //  DEBUG
#if 0
	/*注释部分*/
	cout << MKSTR(hello c++) << endl;
#endif
	cout << "The minimum is " << MIN(i, j) << endl;
#ifdef DEBUG
	cerr << "Trace: Coming out of main function" << endl;
#endif // DEBUG
	return 0;
}
```

### # 和 ## 运算符

\# 和 ## 预处理运算符在 C++ 和 ANSI/ISO C 中都是可用的。# 运算符会把 replacement-text 令牌转换为用引号引起来的字符串

\## 运算符用于连接两个令牌

## 预定义宏

| 宏       | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| **LINE** | 这会在程序编译时包含当前行号。                               |
| **FILE** | 这会在程序编译时包含当前文件名。                             |
| **DATE** | 这会包含一个形式为 month/day/year 的字符串，它表示把源文件转换为目标代码的日期。 |
| **TIME** | 这会包含一个形式为 hour:minute:second 的字符串，它表示程序被编译的时间。 |

```c++
#include <iostream>
using namespace std;
int main() {
	cout << "Value of __LINE__ : " << __LINE__ << endl;
	cout << "Value of __FILE__ : " << __FILE__ << endl;
	cout << "Value of __DATE__ : " << __DATE__ << endl;
	cout << "Value of __TIME__ : " << __TIME__ << endl;
	return 0;
}
```

