---
title: "C++基础3"
date: 2023-03-26T19:04:24+08:00
lastmod: 2023-03-26T19:04:24+08:00
author: ["AlfredNing"]
keywords: 
- 
categories: # 没有分类界面可以不填写
- 
tags: # 标签
- c++
description: ""
weight:
slug: ""
draft: false # 是否为草稿
comments: true # 本页面是否显示评论
reward: true # 打赏
mermaid: true #是否开启mermaid
showToc: true # 显示目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示路径
cover:
    image: "" #图片路径例如：posts/tech/123/123.png
    caption: "" #图片底部描述
    alt: ""
    relative: false
---

# 指针

表示内存的地址。**指针是一个变量**，值为另一个变量的内存地址。内存位置的直接地址

- 必须先声明，后使用
- 所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表存地址的长的十六进制数
- 不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同

| 概念               | 描述                                                         |
| ------------------ | ------------------------------------------------------------ |
| C++ Null 指针      | C++ 支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。 |
| C++ 指针的算术运算 | 可以对指针进行四种算术运算：++、--、+、-                     |
| C++ 指针 vs 数组   | 指针和数组之间有着密切的关系。                               |
| C++ 指针数组       | 可以定义用来存储指针的数组。                                 |
| C++ 指向指针的指针 | C++ 允许指向指针的指针。                                     |
| C++ 传递指针给函数 | 通过引用或地址传递参数，使传递的参数在调用函数中被改变。     |
| C++ 从函数返回指针 | C++ 允许函数返回指针到局部变量、静态变量和动态内存分配。     |

```c++
#include <iostream>
using namespace std;
int main() {
	int var = 20;
	// 指针变量声明
	int* ip;
	double* dp;
	ip = &var;
	// 使用: 变量存储的地址
	cout << "ip: " << ip << endl;
	// 访问地址
	cout << *ip << endl;
	return 0;
}
```

# 引用

引用变量是一个别名，他是一件存在的变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。

## 与指针比较

- 不存在空引用。引用必须连接到一块合法的内存。
- **一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象**。
- 引用必须在创建时被初始化。指针可以在任何时间被初始化。

| 概念             | 描述                                                     |
| ---------------- | -------------------------------------------------------- |
| 把引用作为参数   | C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。 |
| 把引用作为返回值 | 可以从 C++ 函数中返回引用，就像返回其他数据类型一样。    |

```c++
#include <iostream>
using namespace std;
int main() {
	// 简单变量
	int i;
	double d;

	// 引用
	int& r = i;
	double & s = d;

	i = 5;
	cout << "Value of i: " << i << endl;
	cout << "Value of i reference: " << r << endl;

	d = 11.8;
	cout << "Value of d: " << d << endl;
	cout << "Value of d reference: " << s << endl;
	return 0;
}
```

# 时期和时间

c++标准库没有提供，继承c语言用于日期和时间操作结构和函数。使用时需要引入头部文件

相关类型

- clock_t
- time_t
- size_t
- tm

类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数

结构类型 **tm** 把日期和时间以 C 结构的形式保存

| 序号 | 函数 & 描述                                                  |
| ---- | ------------------------------------------------------------ |
| 1    | **time_t time(time_t \*time);** 该函数返回系统的当前日历时间，自 1970 年 1 月 1 日以来经过的秒数。如果系统没有时间，则返回 .1。 |
| 2    | **char \*ctime(const time_t \*time);** 该返回一个表示当地时间的字符串指针，字符串形式 *day month year hours:minutes:seconds year\n\0*。 |
| 3    | **struct tm \*localtime(const time_t \*time);** 该函数返回一个指向表示本地时间的 **tm** 结构的指针。 |
| 4    | **clock_t clock(void);** 该函数返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。如果时间不可用，则返回 .1。 |
| 5    | **char \* asctime ( const struct tm \* time );** 该函数返回一个指向字符串的指针，字符串包含了 time 所指向结构中存储的信息，返回形式为：day month date hours:minutes:seconds year\n\0。 |
| 6    | **struct tm \*gmtime(const time_t \*time);** 该函数返回一个指向 time 的指针，time 为 tm 结构，用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。 |
| 7    | **time_t mktime(struct tm \*time);** 该函数返回日历时间，相当于 time 所指向结构中存储的时间。 |
| 8    | **double difftime ( time_t time2, time_t time1 );** 该函数返回 time1 和 time2 之间相差的秒数。 |
| 9    | **size_t strftime();** 该函数可用于格式化日期和时间为指定的格式。 |

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <ctime>
using namespace std;
int main() {
	// 基于当前系统的当前日期/时间
	time_t now = time(0);

	// 把 now 转换为字符串形式
	char* dt = ctime(&now);

	cout << "本地日期和时间：" << dt << endl;

	// 把 now 转换为 tm 结构
	tm* gmtm = gmtime(&now);
	dt = asctime(gmtm);
	cout << "UTC 日期和时间：" << dt << endl;
	tm* ltm = localtime(&now);
	cout << "Year: " << 1900 + ltm->tm_year << endl;
	cout << "Month: " << 1 + ltm->tm_mon << endl;
	cout << "Day: " << ltm->tm_mday << endl;
	cout << "Time: " << 1 + ltm->tm_hour << ":";
	cout << 1 + ltm->tm_min << ":";
	cout << 1 + ltm->tm_sec << endl;
	return 0;
}
```

# 输入和输出

输入操作：外围设备流向内存

输出操作：内存流向外围设备

## IO 库头文件

| 头文件 | 函数和描述                                                   |
| ------ | ------------------------------------------------------------ |
|        | 该文件定义了 **cin、cout、cerr** 和 **clog** 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。 |
|        | 该文件通过所谓的参数化的流操纵器（比如 **setw** 和 **setprecision**），来声明对执行标准化 I/O 有用的服务。 |
|        | 该文件为用户控制的文件处理声明服务                           |

## 标准输出流 - cout

预定义的对象 **cout** 是 **ostream** 类的一个实例。cout 对象"连接"到标准输出设备，通常是显示屏。**cout** 是与流插入运算符 << 结合使用的,**endl** 用于在行末添加一个换行符

## 标准输入流 -cin

预定义的对象 **cin** 是 **istream** 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。**cin** 是与流提取运算符 >> 结合使用的。

C++ 编译器根据要输入值的数据类型，选择合适的流提取运算符来提取值，并把它存储在给定的变量中。

流提取运算符 >> 在一个语句中可以多次使用

## 标准错误流 - cerr

预定义的对象 **cerr** 是 **ostream** 类的一个实例。cerr 对象附属到标准错误设备，通常也是显示屏，但是 **cerr** 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。**cerr** 也是与流插入运算符 << 结合使用的

## 标准日志流 - clog

预定义的对象 **clog** 是 **ostream** 类的一个实例。clog 对象附属到标准错误设备，通常也是显示屏，但是 **clog** 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲在，直到缓冲填满或者缓冲区刷新时才会输出。

**clog** 也是与流插入运算符 << 结合使用的

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>

using namespace std;
int main() {
	char name[50];
	cout << "请输入名称：";
	cin >> name;
	cout << "name: " << name << endl;

	char str[] = "unable to read";
	clog << "message info: " << str << endl;
	cerr << "mesage error: " << str << endl;
	return 0;
}
```

# 结构体

用户自定义可用的数据类型，表示存储不同类型的数据项。

- 定义结构
- 访问成员运算符.: 成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号

```C++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
using namespace std;
// 定义一个结构体
struct Books {
	char title[50];
	char author[50];
	char subject[100];
	int book_id;
};
int main() {
	// 定义结构体类型
	Books Book1;
	Books Book2;

	strcpy(Book1.title, "浪潮之巅");
	strcpy(Book1.author, "吴军");
	strcpy(Book1.subject, "科技产业");
	Book1.book_id, 1001;

	cout << "book1.title: " << Book1.title;
	cout << "book1.author: " << Book1.author;
	cout << "book1.subject: " << Book1.subject;
	cout << "book1.book_id: " << Book1.book_id;
	return 0;
}
```

## 结构作为函数参数

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
using namespace std;
void printBook(struct Books book);
// 定义一个结构体
struct Books {
	char title[50];
	char author[50];
	char subject[100];
	int book_id;
};
int main() {
	// 定义结构体类型
	Books Book1;
	Books Book2;

	strcpy(Book1.title, "浪潮之巅");
	strcpy(Book1.author, "吴军");
	strcpy(Book1.subject, "科技产业");
	Book1.book_id = 1001;
	printBook(Book1);
	return 0;
}

void printBook(struct Books book) {
	cout << "Book.title: " << book.title;
	cout << "Book.author: " << book.author;
	cout << "Book.subject: " << book.subject;
	cout << "Book.book_id: " << book.book_id;
}
```

## 指向结构的指针

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
using namespace std;
void printBook(struct Books* book);
/*
	结构体指针定义：struct Books *struct_pointer;
	为了查找结构变量的地址& 运算符放在结构名称的前面
	使用指向该结构的指针访问结构的成员： 必须使用-> 运算符
*/
// 定义一个结构体
struct Books {
	char title[50];
	char author[50];
	char subject[100];
	int book_id;
};
int main() {
	// 定义结构体类型
	Books Book1;
	Books Book2;

	strcpy(Book1.title, "浪潮之巅");
	strcpy(Book1.author, "吴军");
	strcpy(Book1.subject, "科技产业");
	Book1.book_id = 1001;
	printBook(&Book1);
	return 0;
}

void printBook(struct Books* book) {
	cout << "Book.title: " << book->title;
	cout << "Book.author: " << book->author;
	cout << "Book.subject: " << book->subject;
	cout << "Book.book_id: " << book->book_id;
}
```

## typedof

更加简单的定义结构体方式

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
using namespace std;
// 定义一个结构体
typedef  struct {
	char title[50];
	char author[50];
	char subject[100];
	int book_id;
} Books;
void printBook(Books* book);
/*
	结构体指针定义：struct Books *struct_pointer;
	为了查找结构变量的地址& 运算符放在结构名称的前面
	使用指向该结构的指针访问结构的成员： 必须使用-> 运算符
*/
int main() {
	// 定义结构体类型
	Books Book1;
	Books Book2;

	strcpy(Book1.title, "浪潮之巅");
	strcpy(Book1.author, "吴军");
	strcpy(Book1.subject, "科技产业");
	Book1.book_id = 1001;
	printBook(&Book1);

	// typedef 关键字来定义非结构类型
	typedef long int* pint32;
	pint32 x, y, z; // x, y 和 z 都是指向长整型 long int 的指针。
	return 0;
}
// 直接使用 Books 来定义 Books 类型的变量，而不需要使用 struct 关键字
void printBook(Books* book) {
	cout << "Book.title: " << book->title;
	cout << "Book.author: " << book->author;
	cout << "Book.subject: " << book->subject;
	cout << "Book.book_id: " << book->book_id;
}
```

# 类和对象

用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类被称为类的成员。

## 类

定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作

类定义是以关键字 **class** 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表

## 对象

类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样

```c++
#include <iostream>
using namespace std;
class Box {
public:
	double length;
	double width;
	double height;
	double breadth;
};

int main() {
	// 对象声明
	Box Box1;
	double volume = 0.0;
	Box1.height = 5.0;
	Box1.width = 5.0;
	Box1.length = 5.0;

	volume = Box1.height * Box1.length * Box1.width;
	cout << "Box1 的体积：" << volume << endl;
	return 0;
}
```



| 概念                | 描述                                                         |
| ------------------- | ------------------------------------------------------------ |
| 类成员函数          | 类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。 |
| 类访问修饰符        | 类成员可以被定义为 public、private 或 protected。默认情况下是定义为 private。 |
| 构造函数 & 析构函数 | 类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。 |
| C++ 拷贝构造函数    | 拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。 |
| C++ 友元函数        | **友元函数**可以访问类的 private 和 protected 成员。         |
| C++ 内联函数        | 通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。 |
| C++ 中的 this 指针  | 每个对象都有一个特殊的指针 **this**，它指向对象本身。        |
| C++ 中指向类的指针  | 指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。 |
| C++ 类的静态成员    | 类的数据成员和函数成员都可以被声明为静态的                   |

## 继承

继承代表了 **is a** 关系

## 基类 & 派生类

一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名。

```c++
class derived-class: access-specifier base-class
```

其中，访问修饰符 access-specifier 是 **public、protected** 或 **private** 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private

```c++
#include <iostream>
using namespace std;
class Shape {
public:
	void setWidth(int w) {
		width = w;
	}
	void setHeight(int h) {
		height = h;
	}
protected:
	int width;
	int height;
};
// 派生类
class Rectangle : public Shape {
public:
	int getArea() {
		return width * height;
	}
};
int main() {
	Rectangle Rect;
	Rect.setWidth(4);
	Rect.setHeight(5);
	cout << "Area is: " << Rect.getArea() << endl;
	return 0;
}
```

## 访问控制

派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private

| 访问     | public | protected | private |
| -------- | ------ | --------- | ------- |
| 同一个类 | yes    | yes       | yes     |
| 派生类   | yes    | yes       | no      |
| 外部的类 | yes    | no        | no      |

一个派生类继承了所有的基类方法，但下列情况除外：

- 基类的构造函数、析构函数和拷贝构造函数。
- 基类的重载运算符。
- 基类的友元函数。

## 继承类型

当一个类派生自基类，该基类可以被继承为 **public、protected** 或 **private** 几种类型。

**几乎不使用 protected 或 private 继承，通常使用 public 继承**

- **公有继承（public）：\**当一个类派生自\**公有**基类时，基类的**公有**成员也是派生类的**公有**成员，基类的**保护**成员也是派生类的**保护**成员，基类的**私有**成员不能直接被派生类访问，但是可以通过调用基类的**公有**和**保护**成员来访问。
- **保护继承（protected）：** 当一个类派生自**保护**基类时，基类的**公有**和**保护**成员将成为派生类的**保护**成员。
- **私有继承（private）：\**当一个类派生自\**私有**基类时，基类的**公有**和**保护**成员将成为派生类的**私有**成员。

## 多继承

多继承即一个子类可以有多个父类，它继承了多个父类的特性

访问修饰符继承方式是 **public、protected** 或 **private** 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔

```c++
#include <iostream>
using namespace std;
class Shape {
public:
	void setWidth(int w) {
		width = w;
	}
	void setHeight(int h) {
		height = h;
	}
protected:
	int width;
	int height;
};
class PointCost {
public:
	int getCost(int area) {
		return area * 70;
	}
};
// 派生类
class Rectangle : public Shape, public PointCost{
public:
	int getArea() {
		return width * height;
	}
};
int main() {
	int area;
	Rectangle Rect;
	Rect.setWidth(4);
	Rect.setHeight(5);
	area = Rect.getArea();
	cout << "Area is: " << area << endl;
	cout << "Cost is: " << Rect.getCost(area) << endl;
	return 0;
}
```

# 重载运算符和重载函数

同一作用域中的某个**函数**和**运算符**指定多个定义，分别称为**函数重载**和**运算符重载**

- 同一个作用域
- 函数名或具有相同名称的声明
- 形参列表和定义不同

编译器根据传入参数选择合适的重载函数或者重载运算符，该过程称为重载决策。

## 函数重载

```c++
#include <iostream>
using namespace std;
class printData {
public:
	void print(int t) {
		cout << "int: " << t << endl;
	}
	void print(char* c) {
		cout << "char: " << c << endl;
	}
	void print(double f) {
		cout << "double: " << f << endl;
	}
};
int main() {
	printData pd;
	// Call print to print integer
	pd.print(5);
	// Call print to print float
	pd.print(500.263);
	// Call print to print character
	char s[] = "hello";
	pd.print(s);
	return 0;
}
```

## 运算符重载

重定义或重载大部分 C++ 内置的运算符，自定义运算符

重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。

```c++
#include <iostream>
using namespace std;
class Box {
public:
	double getVolume(void) {
		return length * breadth * height;
	}
	void setLength(double len)
	{
		length = len;
	}

	void setBreadth(double bre)
	{
		breadth = bre;
	}

	void setHeight(double hei)
	{
		height = hei;
	}

	Box operator+(const Box& b) {
		Box box;
		box.length = this->length + b.length;
		box.breadth = this->breadth + b.breadth;
		box.height = this->height + b.height;
		return box;
	}
private:
	double length;
	double breadth;
	double height;
};
int main() {
	Box Box1;                // 声明 Box1，类型为 Box
	Box Box2;                // 声明 Box2，类型为 Box
	Box Box3;                // 声明 Box3，类型为 Box
	double volume = 0.0;     // 把体积存储在该变量中

	// Box1 详述
	Box1.setLength(6.0);
	Box1.setBreadth(7.0);
	Box1.setHeight(5.0);

	// Box2 详述
	Box2.setLength(12.0);
	Box2.setBreadth(13.0);
	Box2.setHeight(10.0);

	// Box1 的体积
	volume = Box1.getVolume();
	cout << "Volume of Box1 : " << volume << endl;

	// Box2 的体积
	volume = Box2.getVolume();
	cout << "Volume of Box2 : " << volume << endl;

	// 把两个对象相加，得到 Box3
	Box3 = Box1 + Box2;

	// Box3 的体积
	volume = Box3.getVolume();
	cout << "Volume of Box3 : " << volume << endl;
	return 0;
}
```

### 可重载运算符

| +    | -    | *    | /      | %      | ^         |
| ---- | ---- | ---- | ------ | ------ | --------- |
| &    | \|   | ~    | !      | ,      | =         |
| <    | >    | <=   | >=     | ++     | --        |
| <<   | >>   | ==   | !=     | &&     | \|\|      |
| +=   | -=   | /=   | %=     | ^=     | &=        |
| \|=  | *=   | <<=  | >>=    | []     | ()        |
| ->   | ->*  | new  | new [] | delete | delete [] |

### 不可重载运算符

| ::   | .*   | .    | ?:   |
| ---- | ---- | ---- | ---- |
|      |      |      |      |

# 多态

调用成员函数，会根据调用函数的对象的类型执行不同的函数

```java
#include <iostream> 
using namespace std;
class Shape {
protected:
	int width, height;
public:
	Shape(int a = 0, int b = 0)
	{
		width = a;
		height = b;
	}
	virtual int area()
	{
		cout << "Parent class area :" << endl;
		return 0;
	}
};class Rectangle : public Shape {
public:
	Rectangle(int a = 0, int b = 0) :Shape(a, b) { }
	int area()
	{
		cout << "Rectangle class area :" << (width * height) << endl;
		return (width * height);
	}
};class Triangle : public Shape {
public:
	Triangle(int a = 0, int b = 0) :Shape(a, b) { }
	int area()
	{
		cout << "Triangle class area :" << (width * height / 2) << endl;
		return (width * height / 2);
	}
};// 程序的主函数
int main() {
	Shape* shape;
	Rectangle rec(10, 7);
	Triangle  tri(10, 5);

	// 存储矩形的地址
	shape = &rec;
	// 调用矩形的求面积函数 area
	shape->area();

	// 存储三角形的地址
	shape = &tri;
	// 调用三角形的求面积函数 area
	shape->area();

	// 输出错误： Parent class area Parent class area
	/*
	原因：调用函数 area() 被编译器设置为基类中的版本，这就是所谓的静态多态，或静态链接 - 
	函数调用在程序执行前就准备好了。有时候这也被称为早绑定，因为 area() 函数在程序编译期间就已经设置好了
	添加关键字virtual
	*/
	return 0;
}
```

## 虚函数

在基类中用关键字virtual声明的函数，在派生类中重新定义基类中定义的虚函数，会告诉编译器不要静态链接到该函数

在程序中任意根据所调用的对象类型来选择调用的函数，这种操作被称为**动态链接**，或者**后期绑定**

## 纯虚函数

在基类中不给出默认的实现

```c++
class Shape {
   protected:
      int width, height;
   public:
      Shape( int a=0, int b=0)
      {
         width = a;
         height = b;
      }
      // pure virtual function
      virtual int area() = 0;
    // = 0 告诉编译器，函数没有主体，上面的虚函数是纯虚函数。
};
```

# 数据抽象

定义：只向外界提供信息，并隐藏后台实现细节，既只表现必要的信息而不呈现细节

数据抽象是一种依赖于接口和实现分离的编程技术。

## 访问标签强制抽象

在 C++ 中，我们使用访问标签来定义类的抽象接口。一个类可以包含零个或多个访问标签：

- 使用公共标签定义的成员都可以访问该程序的所有部分。一个类型的数据抽象视图是由它的公共成员来定义的。
- 使用私有标签定义的成员无法访问到使用类的代码。私有部分对使用类型的代码隐藏了实现细节。

访问标签出现的频率没有限制。每个访问标签指定了紧随其后的成员定义的访问级别。指定的访问级别会一直有效，直到遇到下一个访问标签或者遇到类主体的关闭右括号为止。

### 好处

- 类的内部收到保护，不会因为用户的低级错误导致对象状态受损
- 类实现可能随着时间推移发生变化，以便应对不断变化的需求，或者应对那些要求不改变用户级代码的错误报告

如果只在类的私有部分定义数据成员，编写该类的作者就可以随意更改数据。如果实现发生改变，则只需要检查类的代码，看看这个改变会导致哪些影响。如果数据是公有的，则任何直接访问旧表示形式的数据成员的函数都可能受到影响

```c++
#include <iostream> 
using namespace std;
class Adder {
public:
	Adder(int i = 0) {
		total = i;
	}
	// 对外接口
	void addNum(int number) {
		total += number;
	}
	int getTotal() {
		return total;
	}
private:
	// 对外界隐藏
	int total; 
};
int main() {
	Adder a;
	a.addNum(10);
	a.addNum(20);
	cout << "total: " << a.getTotal() << endl;
	return 0;
}
```

## 设计策略

接口独立于实现，具体实现依赖于抽象。

如果改变底层实现，接口也将保持不变

在这种情况下，不管任何程序使用接口，接口都不会受到影响，只需要将最新的实现重新编译即可

