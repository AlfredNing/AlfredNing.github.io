---
title: "行为模式"
date: 2023-08-03T10:19:40+08:00
lastmod: 2023-08-03T10:19:40+08:00
author: ["AlfredNing"]
keywords: 
- 
categories: # 没有分类界面可以不填写
- 
tags: # 标签
- 设计模式
description: ""
weight:
slug: ""
draft: false # 是否为草稿
comments: true # 本页面是否显示评论
reward: true # 打赏
mermaid: true #是否开启mermaid
showToc: true # 显示目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示路径
cover:
    image: "" #图片路径例如：posts/tech/123/123.png
    caption: "" #图片底部描述
    alt: ""
    relative: false
---

# 定义

- 关注点在于“怎样运行对象和类”
- 用户描述程序在运行时复杂的流程控制
- 类行为模式：采用继承机制，对象行为模式：采用组合或聚合在对象之间分配行为

# 模板方法模式

定义算法框架，算法具体涉及的相关步骤延迟到子类中实现。模板方法模式允许在不改变算法结构的情况下，通过子类来重新定义算法的特定步骤。

## 角色

- 模板类
- 具体子类

## 适用场景

- 当有一个算法的框架需要稳定不变，但其中的某些步骤需要根据不同情况进行定制时，可以使用模板方法模式。
- 当希望通过子类来扩展算法的特定步骤，而不是整个算法时，模板方法模式非常有用。
- Spring的BeanFactory, Java的Servlet

## 实现

```java
package design_patterns;

/**
 * 模板方法模式
 *
 * @author Alfred.Ning
 * @since 2023年08月03日 10:32:00
 */
public class TemplateMethodMain {

  public static void main(String[] args) {
    Chess chess = new Chess();
    chess.play();

    new Monopoly().play();
  }

}

// 模板类
abstract class Game {

  abstract void initialize();

  abstract void startGame();

  abstract void endGame();

  public final void play() {
    initialize();
    startGame();
    endGame();
  }

}

// 具体游戏类 - 国际象棋
class Chess extends Game {

  @Override
  void initialize() {
    System.out.println("初始化国际象棋游戏");
  }

  @Override
  void startGame() {
    System.out.println("开始国际象棋游戏");
  }

  @Override
  void endGame() {
    System.out.println("结束国际象棋游戏");
  }
}

// 具体游戏类 - 大富翁
class Monopoly extends Game {

  @Override
  void initialize() {
    System.out.println("初始化大富翁游戏");
  }

  @Override
  void startGame() {
    System.out.println("开始大富翁游戏");
  }

  @Override
  void endGame() {
    System.out.println("结束大富翁游戏");
  }
}
```

# 策略模式

- 客户端和算法之间相互解耦
- 客户端运行时选择不同的算法，无需修改代码

## 角色

- 策略接口
- 具体策略类
- 上下文类

## 使用场景

- 当一个类有多种算法或行为，需要在运行时动态地选择其中一种时，可以使用策略模式。
- 当一个类的算法涉及复杂的条件语句，可以通过策略模式将不同的算法抽象出来，使代码更加清晰和可维护。
- 线程池的拒绝策略

## 实现

```java
/**
 * 策略模式
 *
 * @author Alfred.Ning
 * @since 2023年08月03日 11:51:00
 */
public class StrategyMain {

  public static void main(String[] args) {
    ShopCart shoppingCart = new ShopCart();
    double originalPrice = 100.0;

    // 设置普通会员策略
    shoppingCart.setDiscountStrategy(new RegularCustomerDiscount());
    double totalPriceForRegularCustomer = shoppingCart.calculateTotalPrice(originalPrice);
    System.out.println("Total price for regular customer: " + totalPriceForRegularCustomer);

    // 设置高级会员策略
    shoppingCart.setDiscountStrategy(new PremiumCustomerDiscount());
    double totalPriceForPremiumCustomer = shoppingCart.calculateTotalPrice(originalPrice);
    System.out.println("Total price for premium customer: " + totalPriceForPremiumCustomer);

    // 设置超级会员策略
    shoppingCart.setDiscountStrategy(new SuperCustomerDiscount());
    double totalPriceForSuperCustomer = shoppingCart.calculateTotalPrice(originalPrice);
    System.out.println("Total price for super customer: " + totalPriceForSuperCustomer);

  }

}

// 上下文
class ShopCart {

  private DiscountStrategy discountStrategy;

  public void setDiscountStrategy(DiscountStrategy discountStrategy) {
    this.discountStrategy = discountStrategy;
  }

  public double calculateTotalPrice(double originPrice) {
    return discountStrategy.applyDiscount(originPrice);
  }
}

// 策略接口
interface DiscountStrategy {

  double applyDiscount(double originPrice);
}

// 普通会员实现
class RegularCustomerDiscount implements DiscountStrategy {

  @Override
  public double applyDiscount(double originPrice) {
    return originPrice;
  }
}

// 高级会员折扣策略
class PremiumCustomerDiscount implements DiscountStrategy {

  @Override
  public double applyDiscount(double originalPrice) {
    // 高级会员享受9折优惠
    return originalPrice * 0.9;
  }
}

// 超级会员
class SuperCustomerDiscount implements DiscountStrategy {

  @Override
  public double applyDiscount(double originPrice) {
    return originPrice * 0.8;
  }
}
```

# 状态模式

它允许一个对象在其内部状态发生改变时改变其行为，使得对象看起来好像修改了其类。状态模式将对象的行为包装在不同的状态对象中，使得对象的行为可以根据内部状态的改变而改变，而无需修改对象本身的代码。

**与策略模式最大的不同在于内部存在状态的改变**

## 角色 

- 环境类
- 状态接口
- 具体状态类

## 使用场景

- 当一个对象的行为取决于它的状态，并且对象的状态可能在运行时发生变化时，可以使用状态模式。
- 当对象有很多状态，并且每个状态下有不同的行为时，可以使用状态模式来封装状态的行为，使得代码更加清晰和易于扩展。

## 实现

```java
/**
 * 状态模式
 *
 * @author Alfred.Ning
 * @since 2023年08月03日 12:08:00
 */
public class StateMain {

  public static void main(String[] args) {
    Elevator elevator = new Elevator();

    elevator.goUp();
    elevator.pause();

    elevator.setCurrentState(new RunningState());
    elevator.goUp();
    elevator.goDown();

    elevator.setCurrentState(new StopState());
    elevator.pause();
  }
}

// 环境类
class Elevator {

  private ElevatorState currentState;

  public Elevator() {
    currentState = new StopState();
  }

  public void setCurrentState(ElevatorState currentState) {
    this.currentState = currentState;
  }

  public void goUp() {
    this.currentState.goUp();
  }

  public void goDown() {
    this.currentState.goDown();
  }

  public void pause() {
    currentState.pause();
  }
}

// 状态接口 - 电梯
interface ElevatorState {

  void goUp();

  void goDown();

  void pause();
}

// 停止状态
class StopState implements ElevatorState {

  @Override
  public void goUp() {
    System.out.println("Elevator is going up.");
  }

  @Override
  public void goDown() {
    System.out.println("Elevator is going down.");
  }

  @Override
  public void pause() {
    System.out.println("Elevator is paused.");
  }
}

// 运行状态
class RunningState implements ElevatorState {

  @Override
  public void goUp() {
    System.out.println("Elevator is already going up.");
  }

  @Override
  public void goDown() {
    System.out.println("Elevator is already going down.");
  }

  @Override
  public void pause() {
    System.out.println("Elevator cannot pause while running.");
  }
}

// 暂停状态
class PauseState implements ElevatorState {

  @Override
  public void goUp() {
    System.out.println("Elevator is going up from pause state.");
  }

  @Override
  public void goDown() {
    System.out.println("Elevator is going down from pause state.");
  }

  @Override
  public void pause() {
    System.out.println("Elevator is already paused.");
  }
}
```

# 中介者模式

通过封装一系列对象之间的交互，将对象之间的耦合解耦，从而使得对象之间的通信更加简单和灵活。

中介者模式的核心思想是将对象之间的通信封装在一个中介者中，使得对象之间不再直接交互，而是通过中介者来进行通信。这样可以降低对象之间的耦合度，使得系统更加灵活和可维护。

## 角色

- 中介者
- 具体中介者
- 抽象同事类
- 具体同事类

## 使用场景

- 当一个对象和其他对象之间存在复杂的交互关系，导致耦合度较高时，可以使用中介者模式来简化对象之间的通信。
- 当一个对象需要和多个其他对象进行通信，而且每个对象都有不同的行为，可以使用中介者模式来封装对象之间的交互逻辑。

## 实现

```java
import java.util.ArrayList;
import java.util.List;

/**
 * @author Alfred.Ning
 * @since 2023年08月03日 12:45:00
 */
public class MediatorMain {

  public static void main(String[] args) {
    ChatRoom chatRoom = new ChatRoom();
    ChatUser u1 = new ChatUser(chatRoom, "user01");
    chatRoom.addUser(u1);
    chatRoom.addUser(new ChatUser(chatRoom, "user02"));
    chatRoom.addUser(new ChatUser(chatRoom, "user03"));

    u1.sendMessage("Hello everyOne");


  }

}

// 中介者接口
interface ChatMediator {

  void sendMessage(String message, User user);
}

// 抽象同事类
abstract class User {

  protected ChatMediator mediator;
  protected String name;


  public User(ChatMediator mediator, String name) {
    this.mediator = mediator;
    this.name = name;
  }

  public abstract void sendMessage(String message);

  public abstract void receiveMessage(String message);
}

// 具体中介者
class ChatRoom implements ChatMediator {

  private List<User> users;

  public ChatRoom() {
    users = new ArrayList<>();
  }

  @Override
  public void sendMessage(String message, User user) {
    for (User u : users) {
      if (u != user) {
        u.receiveMessage(message);
      }
    }
  }

  public void addUser(User user) {
    users.add(user);
  }
}

// 具体同事类
class ChatUser extends User {

  public ChatUser(ChatMediator chatMediator, String name) {
    super(chatMediator, name);
  }

  @Override
  public void sendMessage(String message) {
    System.out.println(name + " 发送消息: " + message);
    mediator.sendMessage(message, this);
  }

  @Override
  public void receiveMessage(String message) {
    System.out.println(name + " 接收消息: " + message);
  }
}
```

# 观察者模式

定义对象的一对多依赖关系，使得每当一个对象状态发生改变，其相关依赖对象得到通知并被自动更新。发布-订阅，模型-视图

## 角色

- 主题
- 具体主题
- 观察者
- 具体观察者

## 使用场景

- 当一个对象的改变需要同时改变其他对象的时候，可以使用观察者模式。
- 当一个对象必须通知其他对象，但又希望尽量避免与被通知对象之间的耦合时，可以使用观察者模式。
- 当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，可以使用观察者模式将这两者解耦。
- Spring事件机制、Vue的双向绑定、响应式编程

## 实现

```java
import java.util.ArrayList;
import java.util.List;

/**
 * 观察者模式
 *
 * @author Alfred.Ning
 * @since 2023年08月03日 13:22:00
 */
public class ObserverMain {

  public static void main(String[] args) {
    WeatherStation weatherStation = new WeatherStation();
    DisplayBoard displayBoard = new DisplayBoard();
    Logger logger = new Logger();
    weatherStation.addObserver(logger);
    weatherStation.addObserver(displayBoard);

    weatherStation.setTemperature(25.6f);
  }
}

// 观察者
interface Observer {

  void update(float temperature);
}

// 具体观察者 - 显示板
class DisplayBoard implements Observer {

  @Override
  public void update(float temperature) {
    System.out.println("DisplayBoard Temperature updated to " + temperature);
  }
}

// 具体观察者 - 日志
class Logger implements Observer {

  @Override
  public void update(float temperature) {
    System.out.println("Logger: Temperature updated to " + temperature);
  }
}

// 主题
interface Subject {

  void addObserver(Observer observer);

  void removeObserver(Observer observer);

  void notifyObserver();
}

// 具体主题
class WeatherStation implements Subject {

  private List<Observer> observers;
  private float temperature;

  public WeatherStation() {
    observers = new ArrayList<>();
  }

  public void setTemperature(float temperature) {
    this.temperature = temperature;
    notifyObserver();
  }

  @Override
  public void addObserver(Observer observer) {
    observers.add(observer);
  }

  @Override
  public void removeObserver(Observer observer) {
    observers.remove(observer);
  }

  @Override
  public void notifyObserver() {
    for (Observer observer : observers) {
      observer.update(this.temperature);
    }
  }
}
```



