---
title: "DDD"
date: 2023-05-27T23:18:05+08:00
lastmod: 2023-05-27T23:18:05+08:00
author: ["AlfredNing"]
keywords: 
- 
categories: # 没有分类界面可以不填写
- 
tags: # 标签
- DDD
description: ""
weight:
slug: ""
draft: false # 是否为草稿
comments: true # 本页面是否显示评论
reward: false # 打赏
mermaid: true #是否开启mermaid
showToc: true # 显示目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示路径
cover:
    image: "" #图片路径例如：posts/tech/123/123.png
    caption: "" #图片底部描述
    alt: ""
    relative: false
---

> DDD是软件核心复杂性的应对之道
>
> 调整程序的结构，该解耦的解耦，该拆分的拆分，在实现新的功能，才能保证设计质量
>
> 运用DDD，当系统业务变得复杂，将对业务的理解绘制出领域模型正确知道软件开发
>
> 微服务： 小而专

# 软件开发方式

- DL驱动开发
- 数据驱动设计
- DDD驱动设计

## DL驱动开发

DeadLine驱动开发，给定截至日期。我挂你他喵的写成什么样，完成就好。

## 数据驱动设计

**良好的设计数据库表，**通过数据流串联对应的业务流程。适合小型系统，基本可以应付大多数的应用场景。

- 确定对应的数据实体
- 完成库表设计

## DDD领域驱动设计

应对软件架构复杂设计方法论

# 整洁架构

![image-20230527232501471](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230527232501471.png)

# 软件退化

- 软件的本质是对真实世界的模拟
- 软件中业务逻辑正确与否的唯一标准就是是否与真实世界一致
- 软件要做成什么样，不由我们决定，也不用用户决定，而是由真实世界决定
- 产品为什么提出变更需求，因为他们对真实世界的理解也不是完全正确，跳过需要，建立在对真实世界理解的基础上进行开发。但认识真实世界是一件非常难的事情，最初只能认识真实世界中那些简单、清晰、易于理解的业务逻辑，完成该部分的软件

## 根源

第一版软件是完美的，但随后随着业务需求变动，软件的业务逻辑越来越接近真实世界，使得我们的软件越来越专业，同时业务逻辑也越来越复杂，软件规模也越来越大。**简单软件有简单软件的设计，复杂软件有复杂软件的设计**

每次软件变更，**逐步调整软件的程序结构，由简单程序转变为复杂程序结构**，而不是一味的塞代码，赛代码才是最终根源。

## 杜绝软件退化的两顶帽子

软件的发展规律是逐步从简单软件转换为复杂软件

**发生在每次新需求变更的时候，采用一下设计方法**

1. 在不添加新功能的前提下，重构代码，调整原有程序结构，以适应新功能实现新的功能
2. 实现新功能

## 过渡设计

每一种初始所谓的“灵活设计”只能应对一种需求变更，不能真正解决未来变更的问题，被称为“过度设计”

- 活在今天的格子里，做今天的事。为当前的需求进行设计，使其刚刚满足当前的需求

解决思路：

每次需求变更额设计，只有保证每次需求变更时候做出正确的设计，才能使得软件以良性循环维护下午

## 两顶帽子的实现思路

**困难的是第一步，如何调整程序设计以适应新功能**

多次变更，难以理清思路，设计开始迷失方向

## 最终解决

领域驱动的思想： 将真实世界与软件世界进行对应。每次需求变更，将变更还原到真实世界，看看真实世界，在根据真实世界进行变更设计，保持领域驱动。

### 领域驱动核心要求：领域模型

![image-20230528000015839](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528000015839.png)



每次变更，先回到领域模型，基于业务进行领域模型的变更，然后在根据领域模型的变更指导程序变更

# 电商功能演练DDD

## 首要需求

![image-20230528201107373](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528201107373.png)

## 采用领域分析

**先进行需求分析，设计领域模型**

![image-20230528201156497](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528201156497.png)

领域模型图

![image-20230528201215018](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528201215018.png)

## 1. 需求变更

![image-20230528201243420](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528201243420.png)

**分析付款与折扣的关系？**

**单一职责原则**：软件系统中的每个元素都只负责自己职责范围内的事情，而将其他的事情交给别人去做，我只是去调用。

### 职责如何定义？

错误理解：做某件事，和这件事相关的一切所有的事都是它的职责

正确理解：**一个职责就是软件变化的原因**

**什么是高质量的代码？**

用户提出需求变更，为了实现这个变更而修改软件的成本越低，软件的设计质量就越高。

这就要求每次需求变更的时候只修改一个模块的代码来实现新需求。

需要平时不断的整理代码，将因同一个原因而变更的代码放在一起，将因不同原因的代码而放在不同的模块中、不同类中。

单一职责原则要求在维护软件的过程中需要不断的进行整理，将软件变化的同一个原因的代码放在一起，将软件变化的不同原因分开放。

如何分析不同原因？

![image-20230528201853289](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528201853289.png)

答案是否定，说明是不同原因。

![image-20230528201945086](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528201945086.png)

## 2. 需求变更

![image-20230528202003638](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528202003638.png)

![image-20230528202013937](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528202013937.png)



![image-20230528202044981](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528202044981.png)

答案是否定的

![image-20230528202058730](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528202058730.png)

## 3. 需求变更

支付方式变更

![image-20230528202126042](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528202126042.png)

# DDD落地到数据库设计

## 早期系统设计

![image-20230528202230863](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528202230863.png)

**缺陷：**

先进行数据库设计，但数据库设计只能描述数据结构，而不能描述系统对这些数据结构的处理

## 面向对象的软件设计系统设计

![image-20230528202422892](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528202422892.png)

### 领域模型对象持久化

- 插入记录就是新增一个领域对象
- 修改就是根据key值去修改对应的领域对象
- 删除就是催毁这个领域对象

 **领域模型对象持久化存储的思想：将暂时不用的领域对象持久化存储到磁盘，再次使用这个领域对象，从数据库恢复成领域对象。**

数据库设计发生剧烈的变化，但唯一不变的是**领域对象**。数据操作底层发生变更，上层业务代码不修改

### DDD数据库设计的核心

以领域模型为核心，如何将领域模型转换成数据库的设计的过程。**将类转换为表的过程**

![image-20230528203110168](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528203110168.png)

### 关系转换

- 一对一
- 一对多
- 多对一
- 多对多
- 继承关系（上面四种属于传统关系）

#### 一对一

![image-20230528203347815](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528203347815.png)

#### 多对一

![image-20230528203517927](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528203517927.png)

#### 一对多

![image-20230528203622952](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528203622952.png)

#### 多对多关系

![image-20230528203720680](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528203720680.png)

- 领域模型总，无论功能还是属性，在命名都是采用中文
- 数据库设计，细化为英文命名，或者汉语拼音首字母，同时要确定字段类型是否为空等其他属性

#### 继承关系

##### 第一种方案

冗余设计

![image-20230528203946679](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528203946679.png)

**表稀疏： 大量字段为空**，浪费存储空间，影响查询速度

##### 第二种方案

采用主键生成器，公用同一个主键

![image-20230528204126537](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528204126537.png)

![image-20230528204134316](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528204134316.png)

优缺点：

单独查询一张表比较快，如果查询所有表就比较慢。

##### 第三种方案

![image-20230528204246014](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528204246014.png)

## NoSQL数据库的设计

需要join的查询，直接写到单表中进行分布式存储，这张表成为“宽表”

# DDD落地到程序设计

**领域模型的最终落地是三种类型的对象：服务、实体、值对象**

**设计思路：贫血模型与充血模式**

## 服务

标识在领域对象之外的操作行为，接收用户的请求和执行某些操作。

当用户在界面发送请求，服务接收处理，最终将以实体或者值对象的数据持久化到数据库中

## 实体

通过一个唯一标识字段来区分真实世界中每一个个体的领域对象。**属性随着时间不断变化。**

## 值对象

代表的是真实世界中那些一成不变的、本质性的事物，这样的领域对象叫做“值对象”。如：行业、地理位置、币种、职位

## 实体和值对象的区分

**可变性是实体的特点，不变性是值对象的本质**

注意实体和值对象在不同业务设计下是不同的，例如菜单可以设计成实体，认为每个菜单都是不一样的。设计成值对象，认为所有的菜单都是一样的，进行应用

## 将业务领域模型转换为程序设计

### 贫血模型

在软件设计中，有很多的pojo对象除了有一堆的get/set方法，几乎没有任何业务逻辑。

变更成本提高

![image-20230528205902866](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528205902866.png)

### 充血模型

![image-20230528205933848](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528205933848.png)

**直接执行会员的打折方法**，维护成本降低

保持了领域模型的原貌，直接映射了程序的变更，保持了对象的封装性。

### 两种模型对比

1. 贫血模型比充血模型简单易行
2. ![image-20230528210307088](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528210307088.png)

3. ![image-20230528210317117](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528210317117.png)

4. 充血模型需要更强的OOA/D能力，分析业务、业务建模与设计能力
5. 充血模型需要有交强的团队协作能力
6. 贫血模型更容易应对复杂的业务处理场景，**划分独立步骤，分给多个service串联进行执行**

## 工程实践选择

没有唯一的标准，适合才是最好的。

1. **将需要封装的业务逻辑放到领域对象，进行充血模型设计**
2. **除此之外的其他业务逻辑放到service中，按照贫血模型设计**

需要封装的业务逻辑进行充血模型设计：

1. 领域模型中出现继承，多态的情况
2. 在软件设计过程中，出现类型或者编码转换
3. 表现领域对象之间的关系
4. “聚合”，在真实世界中那些代表整体与部分的事物

**不必过多纠结于是实体还是值对象，更多的精力放在业务理解上，结合充血模型与贫血模式双重设计**

# 核心概念

## 聚合

表达的是整体与部分的关系。整体封装了部分的实例。

识别整体与部分，当整体不存在，部分就变得没有意义。例如：订单包含订单明细。

**如何判断聚合关系：整体不存在，部分是是否存在。如果不存在就是聚合，反之，非聚合。**

对部分的操作必须是整体访问

### 聚合根

外部系统访问内部的唯一标准。**领域驱动设计适合增删改业务操作系统，不适合分析统计系统。**

## 仓库

之前设计，通过订单DAO与订单明细DAO完成数据库的保存，由订单service去添加事务保证。设计缺乏集合、缺乏封装性，不利于日后的维护。

实现仓库对完成对数据库的访问

### 仓库与订单访问DAO的区别

- 当数据添加或者查询数据库，都是查询访问单表
- 在领域建模设定对象之间的关系，将其设定为聚合

## 工厂

调用仓库，进行补填。

通过仓库与工厂，对所有DAO进行了一层封装，加入聚合、装配将操作步骤封装起来，对上层的客户程序屏蔽

1. 聚合实现整体与部分的关系

2. 对缓存、对数据库的操作都封装在仓库与工厂中

3. 数据的查询通过工厂进行补填与装配，而不是通过之前的sql join

# 限界上下文

将整个系统划分成"问题域"。如果某个子域复杂，可以划分成更多的子域。以子域模型为构建，称为限界上下文。

单一职责原则：每个限界上下文中实现的都是软件变化同一个原因的业务。

限界上下文的高内聚：每个限界上下文实现的功能都是软件变换的同一个原因的代码。

# DDD实现思路

业务分析 -> 战略设计 -> 战术设计：不同阶段的输出都是下一阶段的输入

业务分析：在这个阶段需要集齐项目团队的成员主要包括领域专家、设计人员、开发人员等一起对业务问题域以及业务期望进行全面的梳理，厘请业务中的统一语言，在业务领域中发现领域事件、领域对象及其对应的领域行为，搞清楚他们各自的关联关系。

战略设计：通过DDD的理论，对业务进行领域划分构建领域模型，梳理出相应的限界上下文，通过统一的领域语言从战略层面进行领域划分以及构建领域模型。在构建领域模型的过程中需要梳理出对应的聚合、实体、以及值对象。

战术设计：以领域模型为战术设计的输入，以限界上下文作为微服务划分的边界进行微服务拆分，在每个微服务中进行领域分层，实现领域模型对于代码的映射，从而实现DDD的真正落地实施。

## 相关概念

1. 值对象：不需要唯一表示
2. 实体： 具有唯一标识。 对应业务对象的业务属性和行为

值对象以及实体都是领域模型中的领域对象，是组成领域模型的基础元素，一起实现领域内的最基本的核心领域逻辑。

1. 聚合：有业务关联关系的的实体以及值对象的集合，通过实体、值对象以及各自之间的业务逻辑聚合在一起完成某个业务节点。根据业务的单一职责以及高内聚的设计原则来划分
2. 聚合根: 是一类特殊实体，具备唯一标识，具有独立的声明周期。用来协调实体以及值对象完成业务逻辑的功能。保证聚合内的数据修改复核聚合中的业务规则。**一个聚合只有一个聚合根，聚合根在聚合之内采用引用依赖的方式对实体和值对象进行组织和协调，聚合根和聚合根之间通过唯一id进行聚合之间的协同。**

# 微服务拆分

微服务解决单点系统的可用性问题

## 单体应用的问题

- 维护难
- 更新难
- 稳定难

## 拆分手段

### 业务能力

所谓业务能力就是平台的具体实现的业务功能是什么，这就好比在电商业务中物流域我们按照业务可以划分为仓储、运输、配送、计费等业务领域。大的领域划分出来之后，我们可以用真实的业务流程来串联这些业务领域。

### 通用能力

对于微服务本身来说，通用能力就是将各个微服务都涉及到的通用能力进行抽象形成单独的微服务。但是对于整个业务平台来说，通用能力实际就是业务中台

1. 通用服务: 所谓通用服务就是在各个微服务之间都会碰到的问题，比如说接口的鉴权、日志的监控和管理、服务状态的监控和管理以及服务幂等等分布式系统问题
2. 业务中台: 电商的业务形态有很多种，就阿里巴巴来说，有淘宝、天猫、主打生鲜的盒马、天猫超市等等。不管上层的业务形态有怎样的变化，实际上他们都是有比较核心的业务域是通用的，比如用户、支付、仓储、物流等等。那么实际上这些通用的业务对于整个电商平台来说实际就是通用能力，因此我们需要将这些通用的公共的能力进行下沉，形成业务中台，实现企业级的通用业务能力复用

## 拆分原则

1. 拆分合理： 防止微服务爆炸，增加平台出现bug，增加业务成本
2. 拆分过程逐步迭代。软件平台架构的演进过程必定会经历现有平台以及新架构平台先共存，后替代的过程。因此我们可以先从平台的非核心功能开始再到核心功能这样逐步拆分的方式进行迭代拆分，避免一上来就要大刀阔斧的进行微服务拆分以及架构调整，否则就会陷入旧平台不稳定而新平台又不完善的尴尬处境
3. 确保微服务高内聚低耦合: 在进行微服务拆分之前，应该对平台进行完整的领域划分，建立合适的领域模型，确定好边界上下文，并以此作为微服务拆分的指导。将领域模型的稳定与不断变化的外部需求进行隔离，保证核心领域模型的稳定，避免领域模型之间的强依赖。从而达到实现微服务高内聚低耦合的目的。

# 工程化落地

基础设施层反向依赖领域层？

业务领域是核心域：核心域对外部的依赖越少越好，实现技术复杂度与业务复杂度相分离

**领域层就是核心层因此它的对外依赖越少越好，也就是说应该是非核心依赖核心而不是核心依赖非核心**

技术实现细节依赖于接口抽象，例如：将repo层的定义放在domain层，具体实现由基础设施层完成

## 各层数据流转

![image-20230603204543989](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230603204543989.png)

### 结构设计

采用4层结构。有的还有五层、六层结构

#### Interfaces 接口层

负责向用户显示信息和解释用户命令，请求应用层以获取用户所需要展现的数据(比如获取首页的商品数据)

前端应用通过这一层的接口，向应用服务获取展现所需的数据。这一层主要用来处理用户发送的 Restful 请求，解析用户输入的配置文件，并将数据传递给 Application 层。数据的组装、数据传输格式以及 Facade 接口等代码都会放在这一层目录里。

**Assembler：** 实现 DTO 与领域对象之间的相互转换和数据交换。一般来说 Assembler 与 DTO 总是一同出现。

**Dto：** 它是数据传输的载体，内部不存在任何业务逻辑，我们可以通过 DTO 把内部的领域对象与外界隔离

**Facade：** 提供较粗粒度的调用接口，将用户请求委派给一个或多个应用服务进行处理。

#### **Application**: 应用层 

相对于领域层,应用层是很薄的一层,应用层定义了软件要完成的任务,要尽量简单。

应用服务向下基于微服务内的领域服务或外部微服务的应用服务完成服务的编排和组合，向上为用户接口层提供各种应用数据展现支持服务。应用服务和事件等代码会放在这一层目录里。

Application 的代码目录结构有：event 和 service

- **Event（事件）：**这层目录主要存放事件相关的代码。

  它包括两个子目录：publish 和 subscribe。前者主要存放事件发布相关代码，后者主要存放事件订阅相关代码（事件处理相关的核心业务逻辑在领域层实现）。

  这里提示一下：虽然应用层和领域层都可以进行事件的发布和处理，但为了实现事件的统一管理，我建议你将微服务内所有事件的发布和订阅的处理都统一放到应用层，事件相关的核心业务逻辑实现放在领域层。通过应用层调用领域层服务，来实现完整的事件发布和订阅处理流程。

- **Service（应用服务）：**这层的服务是应用服务。

  应用服务会对多个领域服务或外部应用服务进行封装、编排和组合，对外提供粗粒度的服务。应用服务主要实现服务组合和编排，是一段独立的业务逻辑。你可以将所有应用服务放在一个应用服务类里，也可以把一个应用服务设计为一个应用服务类，以防应用服务类代码量过大。

#### Domain：领域层

它主要存放领域层核心业务逻辑相关的代码。

领域层可以包含多个聚合代码包，它们共同实现领域模型的核心业务逻辑。聚合以及聚合内的实体、方法、领域服务和事件等代码会放在这一层目录里。

- entity: :具有唯一标识的对象
-  值对象(Value Objects): 无需唯一标识的对象
- 领域服务(Domain Services): 一些行为无法归类到实体对象或值对象上,本质是一些操作,而非事物(与本例中domain/service包下的含义不同)
- 聚合/聚合根(Aggregates,Aggregate Roots):
- 聚合是指一组具有内聚关系的相关对象的集合,每个聚合都有一个root和boundary
- 工厂(Factories): 创建复杂对象,隐藏创建细节
- 仓储(Repository): 提供查找和持久化对象的方法

#### Infrastructure（基础层）

 它主要存放基础资源服务相关的代码

 * 为应用层 传递消息(比如通知)
 * 为领域层 提供持久化机制(最底层的实现)
 * 为用户界面层 提供组件配置
 * 基础设施层还能够通过架构框架来支持四个层次间的交互模式。

[代码结构示例](https://github.com/AlfredNing/Coding/tree/main/ddd-demo)
