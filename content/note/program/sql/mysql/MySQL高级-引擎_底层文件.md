---
title: "MySQL高级-引擎_底层文件"
date: 2023-05-23T19:40:55+08:00
lastmod: 2023-05-23T19:40:55+08:00
author: ["AlfredNing"]
keywords: 
- 
categories: # 没有分类界面可以不填写
- 
tags: # 标签
- MySQL
description: ""
weight:
slug: ""
draft: false # 是否为草稿
comments: true # 本页面是否显示评论
reward: true # 打赏
mermaid: true #是否开启mermaid
showToc: true # 显示目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示路径
cover:
    image: "" #图片路径例如：posts/tech/123/123.png
    caption: "" #图片底部描述
    alt: ""
    relative: false
---

# 系统配置

## 字符集的设置

```sql
show variables like 'character%';
```

- character_set_server：服务器级别的字符集
- character_set_database：当前数据库的字符集
- character_set_client：服务器解码请求时使用的字符集
- character_set_connection：服务器处理请求时会把请求字符串从character_set_client转为character_set_connection 
- character_set_results：服务器向客户端返回数据时使用的字符集

**小结**

- 如果`创建或修改列`时没有显式的指定字符集和比较规则，则该列`默认用表的`字符集和比较规则
- 如果`创建表时`没有显式的指定字符集和比较规则，则该表`默认用数据库的`字符集和比较规则
- 如果`创建数据库时`没有显式的指定字符集和比较规则，则该数据库`默认用服务器的`字符集和比较规则

##  **请求到响应过程中字符集的变化**

```mermaid
graph TB
A(客户端) --> |"使用操作系统的字符集编码请求字符串"| B(从character_set_client转换为character_set_connection)
B --> C(从character_set_connection转换为具体的列使用的字符集)
C --> D(将查询结果从具体的列上使用的字符集转换为character_set_results)
D --> |"使用操作系统的字符集解码响应的字符串"| A

```





## SQL大小写的设置

```sql
show variables like '%lower_case_table_names%' 
该参数只适用于5.7版本
默认为0 大小写敏感
设置为1，大小写不敏感，创建的表都是以小写方式存放在磁盘上，对于sql语句都是转换为小写对表和数据库查找
设置为2，创建的表和数据库依据语句上存放，凡是查找都是转换为小写进行
```

## SQL编写建议

1. 关键字和函数名称全部大写
2. 数据库名、表名、表别名、字段名、字段别名等全部小写
3. SQL语句必须以分号结尾

## SQL_MODE的设置

- 宽松模式
- 严格模式

**MySQL的sql_mode合理设置**

  sql_mode是个很容易被忽视的变量,默认值是空值,在这种设置下是可以允许一些非法操作的,比如允许一些非法数据的插入。在生产环境必须将这个值设置为严格模式,所以开发、测试环境的数据库也必须要设置,这样在开发测试阶段就可以发现问题.

**sql model 常用来解决下面几类问题**

1. 通过设置sql mode, 可以完成不同严格程度的数据校验，有效地保障数据准备性。

2. 通过设置sql model 为宽松模式，来保证大多数sql符合标准的sql语法，这样应用在不同数据库之间进行迁移时，则不需要对业务sql 进行较大的修改。

　3. 在不同数据库之间进行数据迁移之前，通过设置SQL Mode 可以使MySQL 上的数据更方便地迁移到目标数据库中。

```sql
# 临时设置
set global sql_mode = ''; -- 全局生效
set session sql_mode = ''; -- 会话生效
# my.cnf可以修改，永久设置，设置完毕重启 	

生成环境： 临时设置 + 全局设置。重启也会永久生效
```

## 数据目录

```sql
show variables like '%datadir%';
```

## 数据库与文件系统的关系

存储引擎把表存储在文件系统上

四个默认数据库

- mysql: 用户、权限等
- information_schema: 维护所有其他数据库的信息
- performance_schema: mysql运行状态信息
- sys: 通过视图的形式把information_schema与performance_schema结合起来，帮助开发人员和系统管理人员监控MYSQL的技术性能

## 表在文件系统的表示

## InnoDB

- db.opt: 针对该数据库的信息
- *.frm: 存储表结构
- *.ibd: 存储表数据，**也可以放在ibdata1**: 系统表空间

1. 系统表空间（system tablespace）
   默认情况下，InnoDB会在数据目录下创建一个名为`ibdata1`、大小为`12M`的`自拓展`文件，这个文件就是对应的`系统表空间`在文件系统上的表示。
2. 独立表空间(file-per-table tablespace)
   在MySQL5.6.6以及之后的版本中，InnoDB并不会默认的把各个表的数据存储到系统表空间中，而是为`每一个表建立一个独立表空间`，也就是说我们创建了多少个表，就有多少个独立表空间。使用`独立表空间`来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同。

> MySQL8.0中不再单独提供`表名.frm`，而是**合并**在`表名.ibd`文件中，也没有db.opt文件
>
> 利用ibd2sdi 可以查看ibd文件

3. 系统表空间与独立表空间的设置
   可以自己指定使用`系统表空间`还是`独立表空间`来存储数据，这个功能由启动参数`innodb_file_per_table`控制

   ```sql
   [server] 
   innodb_file_per_table=0 # 0：代表使用系统表空间； 1：代表使用独立表空间
   ```

   

4. 其他类型的表空间
   随着MySQL的发展，除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间，比如通用表空间（general tablespace）、临时表空间（temporary tablespace）等。

###  MyISAM

在MyISAM中的索引全部都是`二级索引`，该存储引擎的`数据和索引是分开存放`的。所以在文件系统中也是使用不同的文件来存储数据文件和索引文件，同时表数据都存放在对应的数据库子目录下。

- 表结构： *.frm, MySQL8.0 改为了 b.xxx.sdi
- 表数据：*.myd
- 表索引：*.myi

# Mysql架构

C/S架构，既Client/Server架构，服务端使用`mysqld`

`Mysql5.7架构图`

![image-20230524193010225](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230524193010225.png)

## 连接层

- 三握手建立TCP连接
- 身份认证、权限认证

## 服务层

###  SQL Interface: SQL接口

- 接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT … FROM就是调用SQL Interface
- MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口

### **Parser:** **解析器**

- 在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。
- 在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建**语法树**，并根据数据字典丰富查询语法树，会`验证该客户端是否具有执行该查询的权限`。创建好语法树后，MySQL还会对SQL查询进行语法上的优化，进行查询重写。

### **Optimizer:** **查询优化器**

- SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个`执行计划`。
- 这个执行计划表明应该`使用哪些索引`进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。
- 它使用**“选取-投影-连接”**策略进行查询。例如：

```mysql
SELECT id,name FROM student WHERE gender = '女';
```

这个SELECT查询先根据WHERE语句进行`选取`，而不是将表全部查询出来以后再进行gender过滤。 这个SELECT查询先根据id和name进行属性`投影`，而不是将属性全部取出以后再进行过滤，将这两个查询条件`连接`起来生成最终查询结果。

### **Caches & Buffers： 查询缓存组件**

- MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。
- 这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。
- 这个查询缓存可以在`不同客户端之间共享`。
- 从MySQL 5.7.20开始，不推荐使用查询缓存，并在`MySQL 8.0中删除`

### **引擎层**

插件式存储引擎层（ Storage Engines），**真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作**，服务层通过API与存储引擎进行通信。开发人员也可以定制属于自己的引擎

# SQL执行

## MySQL执行流程

![image-20230524210721611](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230524210721611.png)

1. 查询缓存。缓存中发现这条语句，返回结果。但是由于命中率并不高。**MySQL8.0取消缓存设置**

   查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。这就意味着查询匹配的`鲁棒性大大降低`，只有`相同的查询操作才会命中查询缓存`。两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。因此 MySQL 的 查询缓存命中率不高 。

   同时，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql、 information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。

   此外，既然是缓存，那就有它`缓存失效的时候`。MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了`INSERT`、`UPDATE`、`DELETE`、`TRUNCATE TABLE`、`ALTER TABLE`、`DROP TABLE`或`DROP DATABASE`语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！对于`更新压力大的数据库`来说，查询缓存的命中率会非常低。

2. 解析器

   1. 词法分析：识别字符串
   2. 语法分析：识别语法规则

3. 优化器：确定SQL的执行路径，是全表扫描，还是索引检索

   1. 逻辑优化
   2. 物理查询

4. 执行器：在执行之前需要判断该用户是否`具备权限`。如果没有，就会返回权限错误。如果具备权限，就执行 SQL查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存

SQL 语句在 MySQL 中的流程是： SQL语句→查询缓存→解析器→优化器→执行器

```sql
show VARIABLES like '%query_cache_type%' # mysql8.0之后没有该参数
有三个值
0:关闭查询缓存
1:代表开启On
2: DEMAND, 按需开启，
指定为2时候，使用下面开启/关闭缓存
SELECT SQL_CACHE * FROM users; # 开启
SELECT SQL_NO_CACHE * FROM users; # 关闭
建议在静态表使用查询缓存，静态表：更新不频繁
# 查看缓存信息
show STATUS like '%Qcache%'; # mysql8.0之后没有该参数
```

```sql
# 开启sql记录执行
select @@profiling;
set profiling =  1; #开启 session级别

SELECT * from job_history;

select @@profiling;
show PROFILES;
-- 最近一次
show profile;
-- 查询指定
show profile for query 98;
# 查看cpu, io
show profile cpu,block io for query 137;
```



## 数据库缓冲池 Buff - Pool

`InnoDB`存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。而磁盘 I/O 需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请`占用内存来作为数据缓冲池`，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的`Buffer Pool`之后才可以访问。

这样做的好处是可以让磁盘活动最小化，从而`减少与磁盘直接进行 I/O 的时间`。要知道，这种策略对提升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。

### 缓冲池

![image-20230525203527796](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230525203527796.png)

#### 缓存原则

`位置 * 频次`这个原则，可以帮我们对 I/O 访问效率进行优化。

首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。

其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有 200G，但是内存只有 16G，缓冲池大小只有 1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会**优先对使用频次高的热数据进行加载**。

#### 缓冲池的预读特性

在读取部分数据同时，会预先读取部分数据的上下可能引用的数据。

#### 读取数据

缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。

```java

--  查看缓冲池大小
show variables like 'innodb_buffer_pool_size';
-- 修改缓冲池，也可以修改配置文件 全局修改
set global innodb_buffer_pool_size = 268435456;
-- 将单个buffer poll 拆分成小的buffer pool
show variables like 'innodb_buffer_pool_instances';
/**
配置文件修改 buffer_poll
[server]
innodb_buffer_pool_instances = 
*/
计算每个buffer poll占比： innodb_buffer_pool_size/innodb_buffer_pool_instances

```

#### 更新数据流程

更新某个数据，如果数据在Buffer Pool不存在，会先将数据从磁盘中国加载，修改完成之后，放入缓冲池当中，当达到一定的落盘时机，才会刷入磁盘中

**缓冲池无论是5.7还是8.0都存在，查询缓存在8.0中不存在**

# 存储引擎

1. MyISAM  
2. InnoDB
3. Memory
4. Blackhole
5. CSV
6. Performance_Schema
7. Archive
8. Federated
9. Mrg_Myisam

## InnoDB - 具有外键的支持事物引擎

- MySQL从3.23.34a开始就包含InnoDB存储引擎。`大于等于5.5之后，默认采用InnoDB引擎`。 
- InnoDB是MySQL的`默认事务型引擎`，它被设计用来处理大量的短期(short-lived)事务。可以确保事务的完整提交(Commit)和回滚(Rollback)。
- 除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。
- **除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。**
- 数据文件结构：
  - 表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中）
  - 表名.ibd 存储数据和索引
- InnoDB是`为处理巨大数据量的最大性能设计`。
  - 在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除了。比如：`.frm`，`.par`，`.trn`，`.isl`，`.db.opt`等都在MySQL8.0中不存在了。
- 对比MyISAM的存储引擎，**InnoDB写的处理效率差一些**，并且会占用更多的磁盘空间以保存数据和索引。
- MyISAM只缓存索引，不缓存真实数据；**InnoDB不仅缓存索引还要缓存真实数据，`对内存要求较高`**，而且内存大小对性能有决定性的影响。

## MyISAM - 主要的非事务处理存储引擎

- MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM`不支持事务、行级锁、外键`，有一个毫无疑问的缺陷就是`崩溃后无法安全恢复`。 
- `5.5之前默认的存储引擎`
- 优势是访问的`速度快`，对事务完整性没有要求或者以SELECT、INSERT为主的应用
- 针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高
- 数据文件结构：
  - 表名.frm 存储表结构
  - 表名.MYD 存储数据 (MYData)
  - 表名.MYI 存储索引 (MYIndex)
- 应用场景：只读应用或者以读为主的业务

## Archive：用于数据存档

## Blackhole 

丢弃写操作，读操作会返回空内容

## CSV

存储数据时，以逗号分隔各个数据项，作为数据交互

## Memory

置于内存的表

##  Federated

访问远程表，默认禁用

##  Merge引擎

管理多个MyISAM表构成的表集合

##  NDB引擎

MySQL集群专用存储引擎

## InnoDB 与 MyISAM对比

![image-20230526204055829](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230526204055829.png)

> 阿里巴巴 Percona为Mysql数据库做了改进，新建存储引擎Xtradb替代Innodb, 并且在性能和并发上做的更好，阿里巴巴大部分数据库基于percona的原型进行修改

# 索引

> 减少IO次数，降低查询时间
>
> 索引具体实现与其存储引擎相关

## 索引及其优缺点

### 索引概述

索引是帮助MySQL高效获取数据的**数据结构**

**索引的本质：**索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现`高级查找算法`。

### 优点

1. 提高检索数据的效率，**降低IO成本**
2. 可以创建唯一索引，保证数据库的每一行的唯一性
3. 加速表和表之间的连接
4. 在使用分组和排序字句时候，可以**减少分组和排序的时间**，降低CPU消耗

### 缺点

1. 创建索引和维护索引需要耗费时间，随着数据量的增加，时间也会增加
2. 索引需要占据磁盘空间
3. 索引提高查询速度，同时会降低表的更新速度。当对表中的数据进行增加、删除和修改的时候，索引也需要动态维护，降低了数据的维护成本

> TIP:
>
> 索引提高查询速度，影响插入记录的速度。这种情况下，先删除表得索引，在插入数据，插入数据完成之后，再去恢复索引3的

## InnoDB索引推演

### 索引之前的查找

```sql
SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;
```

1. 在一个页的查找

假设目前表中的记录比较少，所有的记录都可以被存放在一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：

- 以主键为搜索条件
  - 可以在页目录中使用`二分法`快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。
- 以其他列作为搜索条件
  - 因为在数据页中并没有对非主键建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从最小记录开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。

2. 在很多页中查找

大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤：

1. 定位到记录所在的页。
2. 从所在的页内查找相应的记录。

在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能`从第一个页`沿着`双向链表`一直往下找，在每一个页中根据我们上面的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是`超级耗时`的。

### 设计索引

```sql
mysql> CREATE TABLE index_demo(
    -> c1 INT,
    -> c2 INT,
    -> c3 CHAR(1),
    -> PRIMARY KEY(c1)
    -> ) ROW_FORMAT = Compact;
```

这个新建的`index_demo`表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键，这个表使用`Compact`行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图：

![image-20230527181855398](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230527181855398.png)



- `record_type`：记录头信息的一项属性，表示记录的类型，`0`表示普通记录、`1`表示目录项记录、`2`表示最小记录、`3`表示最大记录。
- `next_record`：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁。
- `各个列的值`：这里只记录在`index_demo`表中的三个列，分别是`c1`、`c2`和`c3`。 
- `其他信息`：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。

将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：

![image-20230527182053856](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230527182053856.png)

记录放到页中示意图

![image-20230527182127589](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230527182127589.png)

#### 简单的设计索引方案

在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们`想快速的定位到需要查找的记录在哪些数据页`中该咋办？我们可以为快速定位记录所在的数据页而`建立一个目录`，建这个目录必须完成下边这些事：

- **下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值**
- **给所有的页建立一个目录项**

![image-20230527182301724](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230527182301724.png)

以`页28`为例，它对应`目录项2`，这个目录项中包含着该页的页号`28`以及该页中用户记录的最小主键值`5`。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为`20`的记录，具体查找过程分两步：

1. 先从目录项中根据`二分法`快速确定出主键值为`20`的记录在`目录项3`中（因为 12 < 20 < 209 ），它对应的页是`页9`。
2. 再根据前边说的在页中查找记录的方式去`页9`中定位具体的记录。

**页分裂**：对页中的纪录进行增删改查，需要通过一些列诸如移动的操作，使得状态成立，下一个数据页记录的主键值大于上一个页中记录的主键值，这个过程被称为页分裂。

#### InnoDB的索引方案

##### 迭代1次：目录项记录的目录页

![](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230527184236140.png)

从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调`目录项记录`和普通的`用户记录`的**不同点**：

- `目录项记录`的`record_type`值是1，而`普通用户记录`的`record_type`值是0。
- 目录项记录只有`主键值和页的编号`两个列，而普通的用户记录的列是用户自己定义的，可能包含`很多列`，另外还有InnoDB自己添加的隐藏列。
- 了解：记录头信息里还有一个叫`min_rec_mask`的属性，只有在存储`目录项记录`的页中的主键值最小的`目录项记录`的`min_rec_mask`值为`1`，其他别的记录的`min_rec_mask`值都是`0`

现在以查找主键为`20`的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：

1. 先到存储`目录项记录`的页，也就是页30中通过`二分法`快速定位到对应目录项，因为 12 < 20 < 209 ，所以定位到对应的记录所在的页就是页9。
2. 再到存储用户记录的页9中根据`二分法`快速定位到主键值为`20`的用户记录。

##### 迭代2次：多个目录项记录的页

![image-20230527184329890](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230527184329890.png)

从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：

- 为存储该用户记录而新生成了`页31`。
- 因为原先存储目录项记录的`页30的容量已满`（我们前边假设只能存储4条目录项记录），所以不得不需要一个新的`页32`来存放`页31`对应的目录项。

现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为`20`的记录为例：

1. 确定`目录项记录页`我们现在的存储目录项记录的页有两个，即`页30`和`页32`，又因为页30表示的目录项的主键值的范围是 [1, 320) ，页32表示的目录项的主键值不小于 320 ，所以主键值为`20`的记录对应的目录项记录在`页30`中。
2. 通过目录项记录页`确定用户记录真实所在的页`。在一个存储`目录项记录`的页中通过主键值定位一条目录项记录的方式说过了。
3. 在真实存储用户记录的页中定位到具体的记录。

##### 迭代3次：目录项记录页的目录页

![image-20230527184418438](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230527184418438.png)

如图，我们生成了一个存储更高级目录项的`页33`，这个页中的两条记录分别代表页30和页32，如果用户记录的主键值在`[1, 320)`之间，则到页30中查找更详细的目录项记录，如果主键值`不小于320`的话，就到页32中查找更详细的目录项记录。

**这个数据结构，它的名称是`B+树`。** 

##### B+Tree

一个B+树的节点其实可以分成好多层**，规定最下边的那层，也就是存放我们用户记录的那层为第`0`层**，之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页`最多存放3条记录`，存放目录项记录的页`最多存放4条记录`。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放`100条用户记录`，所有存放目录项记录的内节点代表的数据页可以存放`1000条目录项记录`，那么：

- 如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放`100`条记录。
- 如果B+树有2层，最多能存放`1000×100=10,0000`条记录。
- 如果B+树有3层，最多能存放`1000×1000×100=1,0000,0000`条记录。
- 如果B+树有4层，最多能存放`1000×1000×1000×100=1000,0000,0000`条记录。相当多的记录！！！

所以一般情况下，我们`用到的B+树都不会超过4层`，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的`Page Directory`（页目录），**所以在页面内也可以通过`二分法`实现快速定位记录**。

#### 常见索引概念

##### 聚簇索引

索引既数据

###### 特点

1. 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：

   - `页内`的记录是按照主键的大小顺序排成一个`单向链表`。

   - 各个存放`用户记录的页`也是根据页中用户记录的主键大小顺序排成一个`双向链表`。
   - 存放`目录项记录的页`分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个`双向链表`。 

2. **B+树的`叶子节点`存储的是完整的用户记录。**

   所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。

###### 优点

- `数据访问更快`，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快
- 聚簇索引对于主键的`排序查找`和`范围查找`速度非常快
- 按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以`节省了大量的io操作`。

###### 缺点

- `插入速度严重依赖于插入顺序`，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个**自增ID列为主键**
- `更新主键的代价很高`，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义**主键为不可更新**
- `二级索引访问需要两次索引查找`，第一次找到主键值，第二次根据主键值找到行数据

###### 限制

- 对于MySQL数据库目前只有InnoDB支持聚簇索引，而MyISAM不支持
- 每个MySQL的表只能有一个聚簇索引
- 如果没有定义主键，选择非空唯一索引代替。如果没有这样的索引,InnoDB隐式定义一个主键作为聚簇索引
- **innodb的表主键尽量选择有序的顺序id，不建议使用无序id**

##### 二级索引【辅助索引，非聚簇索引】

![image-20230527190516777](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230527190516777.png)

**叶子节点存放主键值**

**概念：回表** 我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到`聚簇索引`中再查一遍，这个过程称为`回表`。也就是根据c2列的值查询一条完整的用户记录需要使用到`2`棵B+树！

##### 联合索引

也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照`c2和c3列`的大小进行排序，这个包含两层含义：

- 先把各个记录和页按照c2列进行排序。

- 在记录的c2列相同的情况下，采用c3列进行排序

注意一点，以c2和c3列的大小为排序规则建立的B+树称为`联合索引`，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：

- 建立`联合索引`只会建立如上图一样的1棵B+树。

- 为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。

> 1. 聚簇索引的叶子节点存储的是我们的数据记录，非聚簇索引存储的是数据位置。非聚簇索引不会影响数据表的物理存储顺序
> 2. 一个表只能由一个聚餐索引，因为只能有一种排序存储的方式，但可以有多个非聚餐索引，多个索引目录提供数据检索
> 3. 使用聚餐索引的时候，数据的查询效率高，但如果对数据进行插入、更新、删除等操作，效率会比非聚簇索引低

##### InnoDB的B+树注意事项

###### 1. 根页面位置万年不动

真实创建B+树过程：

- 每当为某个表创建一个B+树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个`根节点`页面。最开始表中没有数据的时候，每个B+树索引对应的`根节点`中既没有用户记录，也没有目录项记录。
- 随后向表中插入用户记录时，先把用户记录存储到这个`根节点`中。
- 当根节点中的可用`空间用完时`继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如`页a`中，然后对这个新页进行`页分裂`的操作，得到另一个新页，比如`页b`。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到`页a`或者`页b`中，而`根节点`便升级为存储目录项记录的页。

这个过程特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是`InnoDB`存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。

###### 2. 内节点中目录项记录的唯一性

道B+树索引的内节点中目录项记录的内容是`索引列+页号`的搭配，但是这个搭配对于二级索引来说有点不严谨。还拿`index_demo`表为例，假设这个表中的数据是这样的：

| c1   | c2   | c3   |
| ---- | ---- | ---- |
| 1    | 1    | 'u'  |
| 3    | 1    | 'd'  |
| 5    | 1    | 'y'  |
| 7    | 1    | 'a'  |

如果二级索引中目录项的内容只是`索引号+页号`的搭配的话，那么为`c2`列建立索引后的B+树应该长这样：![image-20230527194832595](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230527194832595.png)

如果我们想要新插入一行记录，其中`c1`、`c2`、`c3`的值分别是：`9`、`1`、`c`，那么在修改这个为c2列建立的二级索引对应的B+树时便碰到了个大问题：由于`页3`中存储的目录项记录是由`c2列+页号`的值构成的，`页3`中的两条目录项记录对应的c2列的值都是`1`，那么我们这条新插入的记录到底应该放在`页4`中，还是应该放在`页5`中啊？答案是：对不起，懵了。

为了让新插入记录能找到自己在哪个页里，我们需要**保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的。**所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：

- 索引列的值
- 主键值
- 页号

也就是我们把主键值也添加到二级索引内节点中的目录项记录了，这样就能保证B+树每一层节点中各条目录项记录除页号这个字段外是唯一的，所以我们为c2列建立二级索引后的示意图实际上应该是这样子的：

![image-20230527195001033](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230527195001033.png)

这样我们再插入记录`(9, 1, 'c')`时，由于`页3`中存储的目录项记录是由`c2列+主键+页号`的值构成的，可以先把新记录的`c2`列的值和`页3`中各目录项记录的`c2`列的值作比较，如果`c2`列的值相同的话，可以接着比较主键值，因为B+树同一层中不同目录项记录的`c2列+主键`的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新记录应该被插入到`页5`中。

3. ###### 一个页面最少存储2条记录

一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错！这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问的存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢？那就是目录层级非常非常非常多，而且最后的那个存放真实数据的目录中存放一条记录。费了半天劲只能存放一条真实的用户记录？所以`InnoDB的一个数据页至少可以存放两条记录`

## MyISAM的索引方案

**B树索引适用存储引擎如表所示：**

| 索引/存储引擎 | MyISAM | InnoDB | Memory |
| ------------- | ------ | ------ | ------ |
| B-Tree索引    | 支持   | 支持   | 支持   |

即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索引是Btree索引；**而Memory默认的索引是Hash索引。**

MyISAM引擎使用`B+Tree`作为索引结构，叶子节点的data域存放的是`数据记录的地址`。

### MyISAM的原理

![image-20230527195158208](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230527195158208.png)

###  MyISAM与 InnoDB对比

1. 在InnoDB存储引擎中，我们只需要根据主键值对`聚簇索引`进行一次查找就能找到对应的记录，而在`MyISAM`中却需要进行一次`回表`操作，意味着MyISAM中建立的索引相当于全部都是`二级索引`。 

2. InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是`分离的`，索引文件仅保存数据记录的地址。

3. InnoDB的非聚簇索引data域存储相应记录`主键的值`，而MyISAM索引记录的是`地址`。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。

4. MyISAM的回表操作是十分`快速`的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。

5.  InnoDB要求表`必须有主键`（`MyISAM可以没有`）。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。

### 索引代价

- **空间上的代价**

每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用`16KB`的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。

- **时间上的代价**

每次对表中的数据进行`增、删、改`操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每层节点都是按照索引列的值`从小到大的顺序排序`而组成了`双向链表`。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些`记录移位`，`页面分裂`、`页面回收`等操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。

## MySQL数据结构的合理性

### 全表扫描

### Hash索引

加速查找速度的数据结构，常见有两类：

- 树：平衡二叉树等
- 哈希：例如hashmap

1. hash索引对于范围查询不太友好
2. 多余对于组合索引查询，会把组合查询键当做一个key进行计算，对于单独键不太使用
3. 多余有大量重复key来说，会产生哈希冲突，从而查询时间退化

### 二叉搜索树

![image-20230528163242370](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528163242370.png)

为了提高查询效率，就需要`减少磁盘IO数`。为了减少磁盘IO的次数，就需要尽量`降低树的高度`，需要把原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好

### AVL树

二叉平衡树

![image-20230528163343921](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528163343921.png)

### B-Tree

![image-20230528163442107](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528163442107.png)

一个 M 阶的 B 树（M>2）有以下的特性：

1. 根节点的儿子数的范围是 [2,M]。 

2. 每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 = 关键字的数量 +1，k 的取值范围为[ceil(M/2), M]。 

3. 叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M/2), M]。 

4. 假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i] <Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …,P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k]指向关键字大于 Key[k-1] 的子树。

5. 所有叶子节点位于同一层。

上面那张图所表示的 B 树就是一棵 3 阶的 B 树。我们可以看下磁盘块 2，里面的关键字为（8，12），它有 3 个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8，(9，10) 在 8 和 12 之间，而 (13，15)大于 12，刚好符合刚才我们给出的特征。

然后我们来看下如何用 B 树进行查找。假设我们想要`查找的关键字是 9`，那么步骤可以分为以下几步：

1. 我们与根节点的关键字 (17，35）进行比较，9 小于 17 那么得到指针 P1； 

2. 按照指针 P1 找到磁盘块 2，关键字为（8，12），因为 9 在 8 和 12 之间，所以我们得到指针 P2； 

3. 按照指针 P2 找到磁盘块 6，关键字为（9，10），然后我们找到了关键字 9。

**叶子节点和非叶子节点都要存储数据**

![image-20230528163622477](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528163622477.png)

### B+ Tree

1. 有 k 个孩子的节点就有 k 个关键字。也**就是孩子数量 = 关键字数**，**而 B 树中，孩子数量 = 关键字数+1。**
2. 非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）。
3. 非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中， `非叶子节点既保存索引，也保存数据记录`。
4. 所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。

### R树

支持geometry数据类型，常用于地理位置计算

### 思考题

#### 为了减少IO，索引树会一次性加载吗

当然不会

1. 数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个G。
2. 当我们利用索引查询时候，是不可能将全部几个G的索引都加载进内存的，我们能做的只能是：逐一加载每一个磁盘页，因为磁盘页对应着索引树的节点。

#### **B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO**

> InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT(占用4个字节)或BIGINT(占用8个字节)，指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值，因为是估算，为了方便计算，这里的K取值为103。也就是说一个深度为3的B+Tree索引可以维护103 * 10^3 * 10^3 = 10亿条记录。（这里假定一个数据页也存储10^3条行记录数据了）
>
> 实际情况中每个节点可能不能填充满，因此在数据库中，`B+Tree的高度一般都在2~4层`。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作

#### 为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引

1. B+树的磁盘读写代价更低

B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对于B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。

2. B+树的查询效率更加稳定

由于非终结点并不是最终指向文件内容的节点，而只是叶子结点中关键字的索引。所有任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

#### Hash索引与B+树索引的区别

1. Hash索引`不能进行范围查询`，而B+树可以。这是因为Hash索引指向的数据是无序的，而B+树的叶子节点是个有序的链表。

2. Hash索引`不支持联合索引的最左侧原则`（即联合索引的部分索引无法使用），而B+树可以。对于联合索引来说，Hash索引在计算Hash值的时候是将索引键合并后再一起计算Hash值，所以不会针对每个索引单独计算Hash值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。

3. Hash索引`不支持 ORDER BY 排序`，因为Hash索引指向的数据是无序的，因此无法起到排序优化的作用，而B+树索引数据是有序的，可以起到对该字段ORDER BY 排序优化的作用。同理，我们也无法用Hash索引进行`模糊查询`，而B+树使用LIKE进行模糊查询的时候，LIKE后面后模糊查询（比如%结尾）的话就可以起到优化作用。

4. `InnoDB不支持哈希索引`

# Innodb的数据存储结构

## 数据库的存储结构：页

索引结构给我们提供了高效的索引方式，不过索引信息以及数据记录都保存在文件上的，确切说是存储在页结构中。另一方面，索引是在存储引擎中实现的，MySQL服务器上的`存储引擎`负责对表中数据的读取和写入工作。不同存储引擎中`存放的格式`一般不同的，甚至有的存储引擎比如Memory都不用磁盘来存储数据。

###  磁盘与内存交互基本单位：页

InnoDB将数据划分为若干个页，InnoDB中页的大小默认为`16KB`。

以`页`作为磁盘和内存之间交互的基本单位，也就是一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。也就是说，**在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页（Page），数据库I/O操作的最小单位是页。**一个页中可以存储多个行记录。

> 记录是按照行来存储的，但是数据库的读取并不以行为单位，否则一次读取（也就是一次I/O操作）只能处理一行数据，效率会非常低。

### 页结构概述

页a、页b、页c…页n这些页可以`不在物理结构上相连`，只要通过`双向链表`相关联即可。每个数据页中的记录会按照主键值从小到大的顺序组成一个`单向链表`，每个数据页都会为存储在它里边的记录生成一个`页目录`，在通过主键查找某条记录的时候可以在页目录中`使用二分法`快速定位到对应的槽，然后再遍历该槽对应的分组中的记录即可快速找到指定的记录

### 页的上层结构

![image-20230528173638999](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528173638999.png)

区（Extent）是比页大一级的存储结构，在InnoDB存储引擎中，一个区会分配`64个连续的页`。因为InnoDB中的页大小默认是16KB，所以一个区的大小是64*16KB=`1MB`。

段（Segment）由一个或多个区组成，区在文件系统是一个连续分配的空间（在InnoDB中是连续的64个页），不过在段中不要求区与区之间是相邻的。`段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。`当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。

表空间（Tablespace）是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为`系统表空间`、`用户表空间`、`撤销表空间`、`临时表空间`等。

## 页的内部结构

### 文件头部和文件尾部

#### 文件头部

38字节

描述各种页的通用信息。（比如页的编号、其上一页、下一页是谁等）

![image-20230528175152694](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528175152694.png)

- `FIL_PAGE_OFFSET（4字节）`：每一个页都有一个单独的页号，就跟你的身份证号码一样，InnoDB通过页号可以唯一定位一个页
- `FIL_PAGE_TYPE（2字节）`：这个代表当前页的类型。

![image-20230528175301892](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528175301892.png)

- `FIL_PAGE_PREV（4字节）和FIL_PAGE_NEXT（4字节）`：InnoDB都是以页为单位存放数据的，如果数据分散到多个不连续的页中存储的话需要把这些页关联起来，FIL_PAGE_PREV和FIL_PAGE_NEXT就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，保证这些页之间**不需要是物理上的连续，而是逻辑上的连续。**
- `FIL_PAGE_SPACE_OR_CHKSUM（4字节）`：代表当前页面的校验和（checksum）。文件头部和文件尾部都有属性：FIL_PAGE_SPACE_OR_CHKSUM
- `FIL_PAGE_LSN（8字节）`：页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）

##### 文件校验和的作用

InnoDB存储引擎以页为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么`在修改后的某个时间需要把数据同步到磁盘中。`但是在同步了一半的时候断电了，造成了该页传输的不完整。

为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况），这时可以通过文件尾的校验和（checksum 值）与文件头的校验和做比对，如果两个值不相等则证明页的传输有问题，需要重新进行传输，否则认为页的传输已经完成。

#### 文件尾部

8字节

- 前4个字节代表页的校验和：这个部分是和File Header中的校验和相对应的。
- 后4个字节代表页面被最后修改时对应的日志序列位置（LSN）：这个部分也是为了校验页的完整性的，如果首部和尾部的LSN值校验不成功的话，就说明同步过程出现了问题。

### 空闲空间、用户记录和最小最大记录

#### 空闲空间

存储的记录会按照指定的`行格式`存储到`User Records`部分。但是在一开始生成页的时候，其实并没有User Records这个部分，`每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分`，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去`申请新的页`了

#### 用户记录

User Records中的这些记录按照`指定的行格式`一条一条摆在User Records部分，相互之间形成`单链表`

####  Infimum + Supremum（最小最大记录）

**记录可以比较大小吗**？
是的，记录可以比大小，对于一条完整的记录来说，比较记录的大小就是`比较主键`的大小。比方说我们插入的4行记录的主键值分别是：1、2、3、4，这也就意味着这4条记录是从小到大依次递增。

InnoDB规定的最小记录与最大记录这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的

这两条记录`不是我们自己定义的记录`，所以它们并不存放在页的User Records部分，他们被单独放在一个称为Infimum + Supremum的部分

![image-20230528181430874](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528181430874.png)

### 页目录与页头

####  Page Directory 页目录

在页中，记录是以`单向链表`的形式进行存储的。单向链表的特点就是插入、删除非常方便，但是`检索效率不高`，最差的情况下需要遍历链表上的所有节点才能完成检索。因此在页结构中专门设计了页目录这个模块，`专门给记录做一个目录`，通过`二分查找法`的方式进行检索，提升效率。

**页目录，二分法查找**

1. 将所有的记录`分成几个组`，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录。
2. 第 1 组，也就是最小记录所在的分组只有 1 个记录；
   最后一组，就是最大记录所在的分组，会有 1-8 条记录；
   其余的组记录数量在 4-8 条之间。
   这样做的好处是，除了第 1 组（最小记录所在组）以外，其余组的记录数会`尽量平分`。
3. 在每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段。
4. `页目录用来存储每组最后一条记录的地址偏移量`，这些地址偏移量会按照`先后顺序存储`起来，每组的地址偏移量也被称之为`槽（slot）`，每个槽相当于指针指向了不同组的最后一个记录。

#### 页面头部

为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫Page Header的部分，这个部分占用固定的56个字节，专门存储各种状态信息。

![image-20230528183704255](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230528183704255.png)

## InnoDB行格式

### 语法规则

```sql
-- 查看默认行格式
select @@innodb_default_row_format;
-- 查看表的格式
show table status like 'employees';
-- 创建表指定格式
create table table_name (...) row_format=compact;
-- 修改表格式
alter table table_name row_format=compact;
```

### Compact格式

*MySQL5.1默认*

一条记录记录额外信息和记录的真实数据

![image-20230602230821191](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230602230821191.png)

#### 变长字段列表

MySQL支持一些变长的数据类型，比如VARCHAR(M)、VARBINARY(M)、TEXT类型，BLOB类型，这些数据类型修饰列称为`变长字段`。

边长字段存储多少字节的数据是不固定的。所以我们在存储数据把这些数据占用的字节数也存起来。

> 这里面存储的变长长度和字段顺序是反过来的。比如两个varchar字段在表结构的顺序是a(10)，b(15)。那么在变长字段长度列表中存储的长度顺序就是15，10，是反过来的。

#### Null值列表

Compact行格式会把Null值的类统一管理起来，存在一个标记为Null值列表中。如果表中没有NULL的列，则NULL值列表并不会存在

> 为什么需要NULL值列表
>
> 因为底层数据是需要对其的，如果每一标注null值，你想你去存储的时候给a/b值，他是放在那一列上合适呢。使用一个特殊的符号放到相应的数据位置表示，可以达到，但是会浪费空间。所以直接在行数据得头部开辟一块空间用来记录行数据哪些是非空数据、哪些是空数据
>
> 1. 二进制位的值为1时，代表该列的值为NULL。
> 2. 二进制位的值为0时，代表该列的值不为NULL。
> 3. 注意：同样顺序也是反过来存放的

#### 记录的头信息

五个字节

![image-20230602231450889](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230602231450889.png)

![image-20230602231506467](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230602231506467.png)

`delete_mask`：这个属性标记着当前记录是否被删除，占用1个二进制位

- 值为0：代表记录并没有被删除
- 值为1：代表记录被删除掉了

> 被删除的数据为什么还在页中存储？
>
> 性能考虑，如果每次剔除一条数据，记录重新排列，是会特别浪费空间的，就会JVM垃圾清理一个意思。所以这里只是打上一个删除标记。所有被删除的记录都会组成一个所谓的垃圾链表。在这个链表中的记录占用的空间称之为`可重用空间`，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。

- `min_rec_mask`：B+树的每层非叶子节点中的最小记录都会添加该标记，min_rec_mask值为1。我们自己插入的四条记录的min_rec_mask值都是0，意味着它们都不是B+树的非叶子节点中的最小记录。
- record_type：这个属性表示当前记录的类型，一共有4种类型的记录：
  0：表示普通记录
  1：表示B+树非叶节点记录
  2：表示最小记录
  3：表示最大记录
- `heap_no`：这个属性表示当前记录在本页中的位置。

> MySQL会自动给每个页里加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为`伪记录`或者`虚拟记录`。这两个伪记录一个代表`最小记录`，一个代表`最大记录`。最小记录和最大记录的heap_no值分别是0和1，也就是说它们的位置最靠前
>
> - `n_owned`：页目录中每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段
> - `next_record`：记录头信息里该属性非常重要，它表示从当前记录的真实数据到下一条记录的真实数据的`地址偏移量`

一个表没有定义主键，则会选取Unique作为主键，如果没有Unique字段，则会为表添加一个隐藏的row_id隐藏列作为字段。所以row_id是在没有自定义主键以及Unique键的情况下才会存在的。

### Dynamic 与Compressed格式

#### 行溢出

```sql
create table varchar_size_demo(

	c varchar(65535)
) CHARSET = ascii row_format = compact;
-- 创建失败

create table varchar_size_demo1(

	c varchar(65532)
) CHARSET = ascii row_format = compact;
-- 创建成功 65532 + 2个字节变长长度记录 + 1个字节null值标识


create table varchar_size_demo2(

	c varchar(65533) not null
) CHARSET = ascii row_format = compact;
-- 创建成功 65532 + 2个字节变长长度记录
```

最大字节是65535，页大学是16KB 16384字节，表面在存储数据时候，会发生当前行数据溢出。

在Compact和Reduntant行格式中，对于占用存储空间非常大的列，在**记录的真实数据处只会存储该列的一部分数据**，把剩余的数据分散存储在几个其他的页中进行`分页存储`，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页。这称为`页的扩展`。

在MySQL 8.0中，默认行格式就是Dynamic，Dynamic、Compressed行格式和Compact行格式挺像，只不过在处理行溢出数据时有分歧

- **Compressed和Dynamic两种记录格式对于存放在BLOB中的数据采用了完全的行溢出的方式。如图，在数据页中只存放20个字节的指针（溢出页的地址），实际的数据都存放在Off Page（溢出页）中。**
- **Compact和Redundant两种格式会在记录的真实数据处存储一部分数据（存放768个前缀字节）。**

## 区 段 碎片 表空间

#### 区是什么

B+树的每一个层的页都会形成双向链表数据结构，如果以页来分配单位，实际存储的物理位置可能理的非常远，造成物理读取时候`随机读取`，尽可能让链表相邻的页的物理位置相邻，进行范围查询的时候使用`顺序IO`

引入`区`的概念，一个区就是物理位置上连续的`64个页`。因为InnoDB中的页的大小默认是16KB，所以一个区的大小是64*16KB=`1MB`。在表中`数据量大`的时候，为某个索引分配空间的时候就不再按照页的单位分配了，而是按照`区为单位分配`，甚至在表中的数据特别多的时候，可以一次性分配多个连续的区。虽然可能造成`一点点空间的浪费`（数据不足以填充满整个区），但是从性能角度看，可以消除很多的随机I/O，`功大于过`！

#### 段是什么

范围查询，如果对B+树叶子节点得记录不进行区分，如果把所有代表节点得页面放到申请的区中，造成性能不太好。所有采用了区分对待

- 叶子节点段
- 非叶子节点段
- 回滚段
- 数据段
- 索引段

数据段即为B+树的叶子节点，索引段即为B+树的非叶子节点。

在InnoDB存储引擎中，对段的管理都是由引擎自身所完成，DBA不能也没有必要对其进行控制。这从一定程度上简化了DBA对于段的管理。

**段其实不对应表空间中的某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。**

#### 碎片区

默认情况下，一个使用InnoDB存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的，一个区默认占用1M（64*16KB=1024KB）存储空间，所以**默认情况下一个只存在几条记录的小表也需要2M的存储空间么？**以后每次添加一个索引都要多申请2M的存储空间么？这对于存储记录比较少的表简直是天大的浪费。这个问题的症结在于到现在为止我们介绍的区都是非常`纯粹`的，也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用。

为了考虑以完整的区为单位分配给某个段对于`数据量较小`的表太浪费存储空间的这种情况，InnoDB提出了一个`碎片（fragment）区`的概念。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页面用于段A，有些页面用于段B，有些页甚至哪个段都不属于。`碎片区直属于表空间`，并不属于任何一个段。

所以此后为某个段分配存储空间的策略是这样的：

- 在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。
- 当某个段已经占用了`32个碎片区`页面之后，就会申请以完整的区为单位来分配存储空间。

所以现在段不能仅定义为是某些区的集合，更精确的应该是`某些零散的页面`已经`一些完整的区`的集合。

#### 区分类

- `空闲的区(FREE)`：现在还没有用到这个区中的任何页面。
- `有剩余空间的碎片区(FREE_FRAG)`：表示碎片区中还有可用的页面。
- `没有剩余空间的碎片区(FULL_FRAG)`：表示碎片区中的所有页面都被使用，没有空闲页面。
- `附属于某个段的区(FSEG)`：每一索引都可以分为叶子节点段和非叶子节点段

处于`FREE`、`FREE_FRAG`以及`FULL_FRAG`这三种状态的区都是独立的，直属于表空间。而处于`FSEG`状态的区是附属于某个段的

#### 表空间

表空间是Innodb存储结构逻辑层的最高层，所有的数据放在表空间中。

**逻辑容器**，表空间存储对象是段，一个表空间可以有多个段，一个段只能属于一个表空间。表空间数据库由一个或多个表空间组成。

- 系统表空间
- 独立表空间
- 撤销表空间
- 临时表空间

空间可以回收，drop可以自动回收，也可以在删除大量数据，统计分析或者是日志表之后执行：`alter table tableName engine=innodb`