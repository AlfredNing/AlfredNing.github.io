<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MySql高级 | AlfredNing</title><meta name=keywords content><meta name=description content="系统配置 字符集的设置 show variables like 'character%'; character_set_server：服务器级别的字符集 character_set_database：当前数据库的字符集 character_set_client：服务器解码请求时使用的字符集 character_set_connection：服务器处理请求时会把请求字符串从character_set_client转为character_set_connection character_set_results：服务器向客户端返回数据时使用的字符集 小结
如果创建或修改列时没有显式的指定字符集和比较规则，则该列默认用表的字符集和比较规则 如果创建表时没有显式的指定字符集和比较规则，则该表默认用数据库的字符集和比较规则 如果创建数据库时没有显式的指定字符集和比较规则，则该数据库默认用服务器的字符集和比较规则 请求到响应过程中字符集的变化 graph TB A(客户端) --> |&#34;使用操作系统的字符集编码请求字符串&#34;| B(从character_set_client转换为character_set_connection) B --> C(从character_set_connection转换为具体的列使用的字符集) C --> D(将查询结果从具体的列上使用的字符集转换为character_set_results) D --> |&#34;使用操作系统的字符集解码响应的字符串&#34;| A SQL大小写的设置 show variables like '%lower_case_table_names%' 该参数只适用于5.7版本 默认为0 大小写敏感 设置为1，大小写不敏感，创建的表都是以小写方式存放在磁盘上，对于sql语句都是转换为小写对表和数据库查找 设置为2，创建的表和数据库依据语句上存放，凡是查找都是转换为小写进行 SQL编写建议 关键字和函数名称全部大写 数据库名、表名、表别名、字段名、字段别名等全部小写 SQL语句必须以分号结尾 SQL_MODE的设置 宽松模式 严格模式 MySQL的sql_mode合理设置
sql_mode是个很容易被忽视的变量,默认值是空值,在这种设置下是可以允许一些非法操作的,比如允许一些非法数据的插入。在生产环境必须将这个值设置为严格模式,所以开发、测试环境的数据库也必须要设置,这样在开发测试阶段就可以发现问题.
sql model 常用来解决下面几类问题
通过设置sql mode, 可以完成不同严格程度的数据校验，有效地保障数据准备性。
通过设置sql model 为宽松模式，来保证大多数sql符合标准的sql语法，这样应用在不同数据库之间进行迁移时，则不需要对业务sql 进行较大的修改。
3. 在不同数据库之间进行数据迁移之前，通过设置SQL Mode 可以使MySQL 上的数据更方便地迁移到目标数据库中。
# 临时设置 set global sql_mode = ''; -- 全局生效 set session sql_mode = ''; -- 会话生效 # my."><meta name=author content="AlfredNing"><link rel=canonical href=https://AlfredNing.github.io/note/program/sql/mysql/mysql%E9%AB%98%E7%BA%A7/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.e7eab50320211a47cfd1e9828bbc9dc3f4c658e54ec4002276df0fe43221e733.css integrity="sha256-5+q1AyAhGkfP0emCi7ydw/TGWOVOxAAidt8P5DIh5zM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://AlfredNing.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://AlfredNing.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://AlfredNing.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://AlfredNing.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://AlfredNing.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="MySql高级"><meta property="og:description" content="系统配置 字符集的设置 show variables like 'character%'; character_set_server：服务器级别的字符集 character_set_database：当前数据库的字符集 character_set_client：服务器解码请求时使用的字符集 character_set_connection：服务器处理请求时会把请求字符串从character_set_client转为character_set_connection character_set_results：服务器向客户端返回数据时使用的字符集 小结
如果创建或修改列时没有显式的指定字符集和比较规则，则该列默认用表的字符集和比较规则 如果创建表时没有显式的指定字符集和比较规则，则该表默认用数据库的字符集和比较规则 如果创建数据库时没有显式的指定字符集和比较规则，则该数据库默认用服务器的字符集和比较规则 请求到响应过程中字符集的变化 graph TB A(客户端) --> |&#34;使用操作系统的字符集编码请求字符串&#34;| B(从character_set_client转换为character_set_connection) B --> C(从character_set_connection转换为具体的列使用的字符集) C --> D(将查询结果从具体的列上使用的字符集转换为character_set_results) D --> |&#34;使用操作系统的字符集解码响应的字符串&#34;| A SQL大小写的设置 show variables like '%lower_case_table_names%' 该参数只适用于5.7版本 默认为0 大小写敏感 设置为1，大小写不敏感，创建的表都是以小写方式存放在磁盘上，对于sql语句都是转换为小写对表和数据库查找 设置为2，创建的表和数据库依据语句上存放，凡是查找都是转换为小写进行 SQL编写建议 关键字和函数名称全部大写 数据库名、表名、表别名、字段名、字段别名等全部小写 SQL语句必须以分号结尾 SQL_MODE的设置 宽松模式 严格模式 MySQL的sql_mode合理设置
sql_mode是个很容易被忽视的变量,默认值是空值,在这种设置下是可以允许一些非法操作的,比如允许一些非法数据的插入。在生产环境必须将这个值设置为严格模式,所以开发、测试环境的数据库也必须要设置,这样在开发测试阶段就可以发现问题.
sql model 常用来解决下面几类问题
通过设置sql mode, 可以完成不同严格程度的数据校验，有效地保障数据准备性。
通过设置sql model 为宽松模式，来保证大多数sql符合标准的sql语法，这样应用在不同数据库之间进行迁移时，则不需要对业务sql 进行较大的修改。
3. 在不同数据库之间进行数据迁移之前，通过设置SQL Mode 可以使MySQL 上的数据更方便地迁移到目标数据库中。
# 临时设置 set global sql_mode = ''; -- 全局生效 set session sql_mode = ''; -- 会话生效 # my."><meta property="og:type" content="article"><meta property="og:url" content="https://AlfredNing.github.io/note/program/sql/mysql/mysql%E9%AB%98%E7%BA%A7/"><meta property="article:section" content="note"><meta property="article:published_time" content="2023-05-23T19:40:55+08:00"><meta property="article:modified_time" content="2023-05-23T19:40:55+08:00"><meta property="og:site_name" content="Alfred.Ning"><meta name=twitter:card content="summary"><meta name=twitter:title content="MySql高级"><meta name=twitter:description content="系统配置 字符集的设置 show variables like 'character%'; character_set_server：服务器级别的字符集 character_set_database：当前数据库的字符集 character_set_client：服务器解码请求时使用的字符集 character_set_connection：服务器处理请求时会把请求字符串从character_set_client转为character_set_connection character_set_results：服务器向客户端返回数据时使用的字符集 小结
如果创建或修改列时没有显式的指定字符集和比较规则，则该列默认用表的字符集和比较规则 如果创建表时没有显式的指定字符集和比较规则，则该表默认用数据库的字符集和比较规则 如果创建数据库时没有显式的指定字符集和比较规则，则该数据库默认用服务器的字符集和比较规则 请求到响应过程中字符集的变化 graph TB A(客户端) --> |&#34;使用操作系统的字符集编码请求字符串&#34;| B(从character_set_client转换为character_set_connection) B --> C(从character_set_connection转换为具体的列使用的字符集) C --> D(将查询结果从具体的列上使用的字符集转换为character_set_results) D --> |&#34;使用操作系统的字符集解码响应的字符串&#34;| A SQL大小写的设置 show variables like '%lower_case_table_names%' 该参数只适用于5.7版本 默认为0 大小写敏感 设置为1，大小写不敏感，创建的表都是以小写方式存放在磁盘上，对于sql语句都是转换为小写对表和数据库查找 设置为2，创建的表和数据库依据语句上存放，凡是查找都是转换为小写进行 SQL编写建议 关键字和函数名称全部大写 数据库名、表名、表别名、字段名、字段别名等全部小写 SQL语句必须以分号结尾 SQL_MODE的设置 宽松模式 严格模式 MySQL的sql_mode合理设置
sql_mode是个很容易被忽视的变量,默认值是空值,在这种设置下是可以允许一些非法操作的,比如允许一些非法数据的插入。在生产环境必须将这个值设置为严格模式,所以开发、测试环境的数据库也必须要设置,这样在开发测试阶段就可以发现问题.
sql model 常用来解决下面几类问题
通过设置sql mode, 可以完成不同严格程度的数据校验，有效地保障数据准备性。
通过设置sql model 为宽松模式，来保证大多数sql符合标准的sql语法，这样应用在不同数据库之间进行迁移时，则不需要对业务sql 进行较大的修改。
3. 在不同数据库之间进行数据迁移之前，通过设置SQL Mode 可以使MySQL 上的数据更方便地迁移到目标数据库中。
# 临时设置 set global sql_mode = ''; -- 全局生效 set session sql_mode = ''; -- 会话生效 # my."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"笔记","item":"https://AlfredNing.github.io/note/"},{"@type":"ListItem","position":3,"name":"编程","item":"https://AlfredNing.github.io/note/program/"},{"@type":"ListItem","position":4,"name":"MySql高级","item":"https://AlfredNing.github.io/note/program/sql/mysql/mysql%E9%AB%98%E7%BA%A7/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MySql高级","name":"MySql高级","description":"系统配置 字符集的设置 show variables like \u0026#39;character%\u0026#39;; character_set_server：服务器级别的字符集 character_set_database：当前数据库的字符集 character_set_client：服务器解码请求时使用的字符集 character_set_connection：服务器处理请求时会把请求字符串从character_set_client转为character_set_connection character_set_results：服务器向客户端返回数据时使用的字符集 小结\n如果创建或修改列时没有显式的指定字符集和比较规则，则该列默认用表的字符集和比较规则 如果创建表时没有显式的指定字符集和比较规则，则该表默认用数据库的字符集和比较规则 如果创建数据库时没有显式的指定字符集和比较规则，则该数据库默认用服务器的字符集和比较规则 请求到响应过程中字符集的变化 graph TB A(客户端) --\u0026gt; |\u0026#34;使用操作系统的字符集编码请求字符串\u0026#34;| B(从character_set_client转换为character_set_connection) B --\u0026gt; C(从character_set_connection转换为具体的列使用的字符集) C --\u0026gt; D(将查询结果从具体的列上使用的字符集转换为character_set_results) D --\u0026gt; |\u0026#34;使用操作系统的字符集解码响应的字符串\u0026#34;| A SQL大小写的设置 show variables like \u0026#39;%lower_case_table_names%\u0026#39; 该参数只适用于5.7版本 默认为0 大小写敏感 设置为1，大小写不敏感，创建的表都是以小写方式存放在磁盘上，对于sql语句都是转换为小写对表和数据库查找 设置为2，创建的表和数据库依据语句上存放，凡是查找都是转换为小写进行 SQL编写建议 关键字和函数名称全部大写 数据库名、表名、表别名、字段名、字段别名等全部小写 SQL语句必须以分号结尾 SQL_MODE的设置 宽松模式 严格模式 MySQL的sql_mode合理设置\nsql_mode是个很容易被忽视的变量,默认值是空值,在这种设置下是可以允许一些非法操作的,比如允许一些非法数据的插入。在生产环境必须将这个值设置为严格模式,所以开发、测试环境的数据库也必须要设置,这样在开发测试阶段就可以发现问题.\nsql model 常用来解决下面几类问题\n通过设置sql mode, 可以完成不同严格程度的数据校验，有效地保障数据准备性。\n通过设置sql model 为宽松模式，来保证大多数sql符合标准的sql语法，这样应用在不同数据库之间进行迁移时，则不需要对业务sql 进行较大的修改。\n3. 在不同数据库之间进行数据迁移之前，通过设置SQL Mode 可以使MySQL 上的数据更方便地迁移到目标数据库中。\n# 临时设置 set global sql_mode = \u0026#39;\u0026#39;; -- 全局生效 set session sql_mode = \u0026#39;\u0026#39;; -- 会话生效 # my.","keywords":[""],"articleBody":"系统配置 字符集的设置 show variables like 'character%'; character_set_server：服务器级别的字符集 character_set_database：当前数据库的字符集 character_set_client：服务器解码请求时使用的字符集 character_set_connection：服务器处理请求时会把请求字符串从character_set_client转为character_set_connection character_set_results：服务器向客户端返回数据时使用的字符集 小结\n如果创建或修改列时没有显式的指定字符集和比较规则，则该列默认用表的字符集和比较规则 如果创建表时没有显式的指定字符集和比较规则，则该表默认用数据库的字符集和比较规则 如果创建数据库时没有显式的指定字符集和比较规则，则该数据库默认用服务器的字符集和比较规则 请求到响应过程中字符集的变化 graph TB A(客户端) --\u003e |\"使用操作系统的字符集编码请求字符串\"| B(从character_set_client转换为character_set_connection) B --\u003e C(从character_set_connection转换为具体的列使用的字符集) C --\u003e D(将查询结果从具体的列上使用的字符集转换为character_set_results) D --\u003e |\"使用操作系统的字符集解码响应的字符串\"| A SQL大小写的设置 show variables like '%lower_case_table_names%' 该参数只适用于5.7版本 默认为0 大小写敏感 设置为1，大小写不敏感，创建的表都是以小写方式存放在磁盘上，对于sql语句都是转换为小写对表和数据库查找 设置为2，创建的表和数据库依据语句上存放，凡是查找都是转换为小写进行 SQL编写建议 关键字和函数名称全部大写 数据库名、表名、表别名、字段名、字段别名等全部小写 SQL语句必须以分号结尾 SQL_MODE的设置 宽松模式 严格模式 MySQL的sql_mode合理设置\nsql_mode是个很容易被忽视的变量,默认值是空值,在这种设置下是可以允许一些非法操作的,比如允许一些非法数据的插入。在生产环境必须将这个值设置为严格模式,所以开发、测试环境的数据库也必须要设置,这样在开发测试阶段就可以发现问题.\nsql model 常用来解决下面几类问题\n通过设置sql mode, 可以完成不同严格程度的数据校验，有效地保障数据准备性。\n通过设置sql model 为宽松模式，来保证大多数sql符合标准的sql语法，这样应用在不同数据库之间进行迁移时，则不需要对业务sql 进行较大的修改。\n3. 在不同数据库之间进行数据迁移之前，通过设置SQL Mode 可以使MySQL 上的数据更方便地迁移到目标数据库中。\n# 临时设置 set global sql_mode = ''; -- 全局生效 set session sql_mode = ''; -- 会话生效 # my.cnf可以修改，永久设置，设置完毕重启 生成环境： 临时设置 + 全局设置。重启也会永久生效 数据目录 show variables like '%datadir%'; 数据库与文件系统的关系 存储引擎把表存储在文件系统上\n四个默认数据库\nmysql: 用户、权限等 information_schema: 维护所有其他数据库的信息 performance_schema: mysql运行状态信息 sys: 通过视图的形式把information_schema与performance_schema结合起来，帮助开发人员和系统管理人员监控MYSQL的技术性能 表在文件系统的表示 InnoDB db.opt: 针对该数据库的信息 *.frm: 存储表结构 *.ibd: 存储表数据，也可以放在ibdata1: 系统表空间 系统表空间（system tablespace） 默认情况下，InnoDB会在数据目录下创建一个名为ibdata1、大小为12M的自拓展文件，这个文件就是对应的系统表空间在文件系统上的表示。 独立表空间(file-per-table tablespace) 在MySQL5.6.6以及之后的版本中，InnoDB并不会默认的把各个表的数据存储到系统表空间中，而是为每一个表建立一个独立表空间，也就是说我们创建了多少个表，就有多少个独立表空间。使用独立表空间来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同。 MySQL8.0中不再单独提供表名.frm，而是合并在表名.ibd文件中，也没有db.opt文件\n利用ibd2sdi 可以查看ibd文件\n系统表空间与独立表空间的设置 可以自己指定使用系统表空间还是独立表空间来存储数据，这个功能由启动参数innodb_file_per_table控制\n[server] innodb_file_per_table=0 # 0：代表使用系统表空间； 1：代表使用独立表空间 其他类型的表空间 随着MySQL的发展，除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间，比如通用表空间（general tablespace）、临时表空间（temporary tablespace）等。\nMyISAM 在MyISAM中的索引全部都是二级索引，该存储引擎的数据和索引是分开存放的。所以在文件系统中也是使用不同的文件来存储数据文件和索引文件，同时表数据都存放在对应的数据库子目录下。\n表结构： *.frm, MySQL8.0 改为了 b.xxx.sdi 表数据：*.myd 表索引：*.myi Mysql架构 C/S架构，既Client/Server架构，服务端使用mysqld\nMysql5.7架构图\n连接层 三握手建立TCP连接 身份认证、权限认证 服务层 SQL Interface: SQL接口 接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT … FROM就是调用SQL Interface MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口 Parser: 解析器 在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。 在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建语法树，并根据数据字典丰富查询语法树，会验证该客户端是否具有执行该查询的权限。创建好语法树后，MySQL还会对SQL查询进行语法上的优化，进行查询重写。 Optimizer: 查询优化器 SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个执行计划。 这个执行计划表明应该使用哪些索引进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。 它使用**“选取-投影-连接”**策略进行查询。例如： SELECT id,name FROM student WHERE gender = '女'; 这个SELECT查询先根据WHERE语句进行选取，而不是将表全部查询出来以后再进行gender过滤。 这个SELECT查询先根据id和name进行属性投影，而不是将属性全部取出以后再进行过滤，将这两个查询条件连接起来生成最终查询结果。\nCaches \u0026 Buffers： 查询缓存组件 MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。 这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。 这个查询缓存可以在不同客户端之间共享。 从MySQL 5.7.20开始，不推荐使用查询缓存，并在MySQL 8.0中删除 引擎层 插件式存储引擎层（ Storage Engines），真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作，服务层通过API与存储引擎进行通信。开发人员也可以定制属于自己的引擎\nSQL执行 MySQL执行流程 查询缓存。缓存中发现这条语句，返回结果。但是由于命中率并不高。MySQL8.0取消缓存设置\n查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。这就意味着查询匹配的鲁棒性大大降低，只有相同的查询操作才会命中查询缓存。两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。因此 MySQL 的 查询缓存命中率不高 。\n同时，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql、 information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。\n此外，既然是缓存，那就有它缓存失效的时候。MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了INSERT、UPDATE、DELETE、TRUNCATE TABLE、ALTER TABLE、DROP TABLE或DROP DATABASE语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！对于更新压力大的数据库来说，查询缓存的命中率会非常低。\n解析器\n词法分析：识别字符串 语法分析：识别语法规则 优化器：确定SQL的执行路径，是全表扫描，还是索引检索\n逻辑优化 物理查询 执行器：在执行之前需要判断该用户是否具备权限。如果没有，就会返回权限错误。如果具备权限，就执行 SQL查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存\n**SQL 语句在 MySQL 中的流程是： SQL语句→查询缓存→解析器→优化器→执行器 **\nshow VARIABLES like '%query_cache_type%' # mysql8.0之后没有该参数 有三个值 0:关闭查询缓存 1:代表开启On 2: DEMAND, 按需开启， 指定为2时候，使用下面开启/关闭缓存 SELECT SQL_CACHE * FROM users; # 开启 SELECT SQL_NO_CACHE * FROM users; # 关闭 建议在静态表使用查询缓存，静态表：更新不频繁 # 查看缓存信息 show STATUS like '%Qcache%'; # mysql8.0之后没有该参数 # 开启sql记录执行 select @@profiling; set profiling = 1; #开启 session级别 SELECT * from job_history; select @@profiling; show PROFILES; -- 最近一次 show profile; -- 查询指定 show profile for query 98; # 查看cpu, io show profile cpu,block io for query 137; 数据库缓冲池 Buff - Pool InnoDB存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。而磁盘 I/O 需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请占用内存来作为数据缓冲池，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的Buffer Pool之后才可以访问。\n这样做的好处是可以让磁盘活动最小化，从而减少与磁盘直接进行 I/O 的时间。要知道，这种策略对提升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。\n缓冲池 缓存原则 位置 * 频次这个原则，可以帮我们对 I/O 访问效率进行优化。\n首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。\n其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有 200G，但是内存只有 16G，缓冲池大小只有 1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会优先对使用频次高的热数据进行加载。\n缓冲池的预读特性 在读取部分数据同时，会预先读取部分数据的上下可能引用的数据。\n读取数据 缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。\n-- 查看缓冲池大小 show variables like 'innodb_buffer_pool_size'; -- 修改缓冲池，也可以修改配置文件 全局修改 set global innodb_buffer_pool_size = 268435456; -- 将单个buffer poll 拆分成小的buffer pool show variables like 'innodb_buffer_pool_instances'; /** 配置文件修改 buffer_poll [server] innodb_buffer_pool_instances = */ 计算每个buffer poll占比： innodb_buffer_pool_size/innodb_buffer_pool_instances 更新数据流程 更新某个数据，如果数据在Buffer Pool不存在，会先将数据从磁盘中国加载，修改完成之后，放入缓冲池当中，当达到一定的落盘时机，才会刷入磁盘中\n缓冲池无论是5.7还是8.0都存在，查询缓存在8.0中不存在\n存储引擎 MyISAM InnoDB Memory Blackhole CSV Performance_Schema Archive Federated Mrg_Myisam InnoDB - 具有外键的支持事物引擎 MySQL从3.23.34a开始就包含InnoDB存储引擎。大于等于5.5之后，默认采用InnoDB引擎。 InnoDB是MySQL的默认事务型引擎，它被设计用来处理大量的短期(short-lived)事务。可以确保事务的完整提交(Commit)和回滚(Rollback)。 除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。 除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。 数据文件结构： 表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中） 表名.ibd 存储数据和索引 InnoDB是为处理巨大数据量的最大性能设计。 在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除了。比如：.frm，.par，.trn，.isl，.db.opt等都在MySQL8.0中不存在了。 对比MyISAM的存储引擎，InnoDB写的处理效率差一些，并且会占用更多的磁盘空间以保存数据和索引。 MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响。 MyISAM - 主要的非事务处理存储引擎 MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM不支持事务、行级锁、外键，有一个毫无疑问的缺陷就是崩溃后无法安全恢复。 5.5之前默认的存储引擎 优势是访问的速度快，对事务完整性没有要求或者以SELECT、INSERT为主的应用 针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高 数据文件结构： 表名.frm 存储表结构 表名.MYD 存储数据 (MYData) 表名.MYI 存储索引 (MYIndex) 应用场景：只读应用或者以读为主的业务 Archive：用于数据存档 Blackhole 丢弃写操作，读操作会返回空内容\nCSV 存储数据时，以逗号分隔各个数据项，作为数据交互\nMemory 置于内存的表\nFederated 访问远程表，默认禁用\nMerge引擎 管理多个MyISAM表构成的表集合\nNDB引擎 MySQL集群专用存储引擎\nInnoDB 与 MyISAM对比 阿里巴巴 Percona为Mysql数据库做了改进，新建存储引擎Xtradb替代Innodb, 并且在性能和并发上做的更好，阿里巴巴大部分数据库基于percona的原型进行修改\n索引 减少IO次数，降低查询时间\n索引具体实现与其存储引擎相关\n索引及其优缺点 索引概述 索引是帮助MySQL高效获取数据的数据结构\n**索引的本质：**索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现高级查找算法。\n优点 提高检索数据的效率，降低IO成本 可以创建唯一索引，保证数据库的每一行的唯一性 加速表和表之间的连接 在使用分组和排序字句时候，可以减少分组和排序的时间，降低CPU消耗 缺点 创建索引和维护索引需要耗费时间，随着数据量的增加，时间也会增加 索引需要占据磁盘空间 索引提高查询速度，同时会降低表的更新速度。当对表中的数据进行增加、删除和修改的时候，索引也需要动态维护，降低了数据的维护成本 TIP:\n索引提高查询速度，影响插入记录的速度。这种情况下，先删除表得索引，在插入数据，插入数据完成之后，再去恢复索引3的\nInnoDB索引推演 索引之前的查找 SELECT [列名列表] FROM 表名 WHERE 列名 = xxx; 在一个页的查找 假设目前表中的记录比较少，所有的记录都可以被存放在一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：\n以主键为搜索条件 可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。 以其他列作为搜索条件 因为在数据页中并没有对非主键建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从最小记录开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。 在很多页中查找 大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤：\n定位到记录所在的页。 从所在的页内查找相应的记录。 在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据我们上面的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是超级耗时的。\n设计索引 mysql\u003e CREATE TABLE index_demo( -\u003e c1 INT, -\u003e c2 INT, -\u003e c3 CHAR(1), -\u003e PRIMARY KEY(c1) -\u003e ) ROW_FORMAT = Compact; 这个新建的index_demo表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键，这个表使用Compact行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图：\nrecord_type：记录头信息的一项属性，表示记录的类型，0表示普通记录、1表示目录项记录、2表示最小记录、3表示最大记录。 next_record：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁。 各个列的值：这里只记录在index_demo表中的三个列，分别是c1、c2和c3。 其他信息：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。 将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：\n记录放到页中示意图\n简单的设计索引方案 在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们想快速的定位到需要查找的记录在哪些数据页中该咋办？我们可以为快速定位记录所在的数据页而建立一个目录，建这个目录必须完成下边这些事：\n下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值 给所有的页建立一个目录项 以页28为例，它对应目录项2，这个目录项中包含着该页的页号28以及该页中用户记录的最小主键值5。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为20的记录，具体查找过程分两步：\n先从目录项中根据二分法快速确定出主键值为20的记录在目录项3中（因为 12 \u003c 20 \u003c 209 ），它对应的页是页9。 再根据前边说的在页中查找记录的方式去页9中定位具体的记录。 页分裂：对页中的纪录进行增删改查，需要通过一些列诸如移动的操作，使得状态成立，下一个数据页记录的主键值大于上一个页中记录的主键值，这个过程被称为页分裂。\nInnoDB的索引方案 迭代1次：目录项记录的目录页 从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调目录项记录和普通的用户记录的不同点：\n目录项记录的record_type值是1，而普通用户记录的record_type值是0。 目录项记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有InnoDB自己添加的隐藏列。 了解：记录头信息里还有一个叫min_rec_mask的属性，只有在存储目录项记录的页中的主键值最小的目录项记录的min_rec_mask值为1，其他别的记录的min_rec_mask值都是0 现在以查找主键为20的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：\n先到存储目录项记录的页，也就是页30中通过二分法快速定位到对应目录项，因为 12 \u003c 20 \u003c 209 ，所以定位到对应的记录所在的页就是页9。 再到存储用户记录的页9中根据二分法快速定位到主键值为20的用户记录。 迭代2次：多个目录项记录的页 从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：\n为存储该用户记录而新生成了页31。 因为原先存储目录项记录的页30的容量已满（我们前边假设只能存储4条目录项记录），所以不得不需要一个新的页32来存放页31对应的目录项。 现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为20的记录为例：\n确定目录项记录页我们现在的存储目录项记录的页有两个，即页30和页32，又因为页30表示的目录项的主键值的范围是 [1, 320) ，页32表示的目录项的主键值不小于 320 ，所以主键值为20的记录对应的目录项记录在页30中。 通过目录项记录页确定用户记录真实所在的页。在一个存储目录项记录的页中通过主键值定位一条目录项记录的方式说过了。 在真实存储用户记录的页中定位到具体的记录。 迭代3次：目录项记录页的目录页 如图，我们生成了一个存储更高级目录项的页33，这个页中的两条记录分别代表页30和页32，如果用户记录的主键值在[1, 320)之间，则到页30中查找更详细的目录项记录，如果主键值不小于320的话，就到页32中查找更详细的目录项记录。\n这个数据结构，它的名称是B+树。\nB+Tree 一个B+树的节点其实可以分成好多层**，规定最下边的那层，也就是存放我们用户记录的那层为第0层**，之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页最多存放3条记录，存放目录项记录的页最多存放4条记录。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放100条用户记录，所有存放目录项记录的内节点代表的数据页可以存放1000条目录项记录，那么：\n如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放100条记录。 如果B+树有2层，最多能存放1000×100=10,0000条记录。 如果B+树有3层，最多能存放1000×1000×100=1,0000,0000条记录。 如果B+树有4层，最多能存放1000×1000×1000×100=1000,0000,0000条记录。相当多的记录！！！ 所以一般情况下，我们用到的B+树都不会超过4层，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的Page Directory（页目录），所以在页面内也可以通过二分法实现快速定位记录。\n常见索引概念 聚簇索引 索引既数据\n特点 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：\n页内的记录是按照主键的大小顺序排成一个单向链表。\n各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。\n存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。\nB+树的叶子节点存储的是完整的用户记录。\n所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。\n优点 数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快 聚簇索引对于主键的排序查找和范围查找速度非常快 按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以节省了大量的io操作。 缺点 插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增ID列为主键 更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新 二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据 限制 对于MySQL数据库目前只有InnoDB支持聚簇索引，而MyISAM不支持 每个MySQL的表只能有一个聚簇索引 如果没有定义主键，选择非空唯一索引代替。如果没有这样的索引,InnoDB隐式定义一个主键作为聚簇索引 innodb的表主键尽量选择有序的顺序id，不建议使用无序id 二级索引【辅助索引，非聚簇索引】 叶子节点存放主键值\n概念：回表 我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到聚簇索引中再查一遍，这个过程称为回表。也就是根据c2列的值查询一条完整的用户记录需要使用到2棵B+树！\n联合索引 也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照c2和c3列的大小进行排序，这个包含两层含义：\n先把各个记录和页按照c2列进行排序。\n在记录的c2列相同的情况下，采用c3列进行排序\n注意一点，以c2和c3列的大小为排序规则建立的B+树称为联合索引，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：\n建立联合索引只会建立如上图一样的1棵B+树。\n为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。\n聚簇索引的叶子节点存储的是我们的数据记录，非聚簇索引存储的是数据位置。非聚簇索引不会影响数据表的物理存储顺序 一个表只能由一个聚餐索引，因为只能有一种排序存储的方式，但可以有多个非聚餐索引，多个索引目录提供数据检索 使用聚餐索引的时候，数据的查询效率高，但如果对数据进行插入、更新、删除等操作，效率会比非聚簇索引低 InnoDB的B+树注意事项 1. 根页面位置万年不动 真实创建B+树过程：\n每当为某个表创建一个B+树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个根节点页面。最开始表中没有数据的时候，每个B+树索引对应的根节点中既没有用户记录，也没有目录项记录。 随后向表中插入用户记录时，先把用户记录存储到这个根节点中。 当根节点中的可用空间用完时继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如页a中，然后对这个新页进行页分裂的操作，得到另一个新页，比如页b。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到页a或者页b中，而根节点便升级为存储目录项记录的页。 这个过程特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是InnoDB存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。\n2. 内节点中目录项记录的唯一性 道B+树索引的内节点中目录项记录的内容是索引列+页号的搭配，但是这个搭配对于二级索引来说有点不严谨。还拿index_demo表为例，假设这个表中的数据是这样的：\nc1 c2 c3 1 1 ‘u’ 3 1 ’d' 5 1 ‘y’ 7 1 ‘a’ 如果二级索引中目录项的内容只是索引号+页号的搭配的话，那么为c2列建立索引后的B+树应该长这样： 如果我们想要新插入一行记录，其中c1、c2、c3的值分别是：9、1、c，那么在修改这个为c2列建立的二级索引对应的B+树时便碰到了个大问题：由于页3中存储的目录项记录是由c2列+页号的值构成的，页3中的两条目录项记录对应的c2列的值都是1，那么我们这条新插入的记录到底应该放在页4中，还是应该放在页5中啊？答案是：对不起，懵了。\n为了让新插入记录能找到自己在哪个页里，我们需要**保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的。**所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：\n索引列的值 主键值 页号 也就是我们把主键值也添加到二级索引内节点中的目录项记录了，这样就能保证B+树每一层节点中各条目录项记录除页号这个字段外是唯一的，所以我们为c2列建立二级索引后的示意图实际上应该是这样子的：\n这样我们再插入记录(9, 1, 'c')时，由于页3中存储的目录项记录是由c2列+主键+页号的值构成的，可以先把新记录的c2列的值和页3中各目录项记录的c2列的值作比较，如果c2列的值相同的话，可以接着比较主键值，因为B+树同一层中不同目录项记录的c2列+主键的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新记录应该被插入到页5中。\n一个页面最少存储2条记录 一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错！这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问的存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢？那就是目录层级非常非常非常多，而且最后的那个存放真实数据的目录中存放一条记录。费了半天劲只能存放一条真实的用户记录？所以InnoDB的一个数据页至少可以存放两条记录\nMyISAM的索引方案 B树索引适用存储引擎如表所示：\n索引/存储引擎 MyISAM InnoDB Memory B-Tree索引 支持 支持 支持 即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索引是Btree索引；而Memory默认的索引是Hash索引。\nMyISAM引擎使用B+Tree作为索引结构，叶子节点的data域存放的是数据记录的地址。\nMyISAM的原理 MyISAM** 与 InnoDB对比 在InnoDB存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录，而在MyISAM中却需要进行一次回表操作，意味着MyISAM中建立的索引相当于全部都是二级索引。\nInnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。\nInnoDB的非聚簇索引data域存储相应记录主键的值，而MyISAM索引记录的是地址。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。\nMyISAM的回表操作是十分快速的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。\nInnoDB要求表必须有主键（MyISAM可以没有）。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。\n索引代价 空间上的代价 每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用16KB的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。\n时间上的代价 每次对表中的数据进行增、删、改操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收等操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。\n","wordCount":"661","inLanguage":"zh","datePublished":"2023-05-23T19:40:55+08:00","dateModified":"2023-05-23T19:40:55+08:00","author":[{"@type":"Person","name":"AlfredNing"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://AlfredNing.github.io/note/program/sql/mysql/mysql%E9%AB%98%E7%BA%A7/"},"publisher":{"@type":"Organization","name":"AlfredNing","logo":{"@type":"ImageObject","url":"https://AlfredNing.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://AlfredNing.github.io accesskey=h title="AlfredNing (Alt + H)">AlfredNing</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://AlfredNing.github.io/note/ title=📓笔记><span>📓笔记</span></a></li><li><a href=https://AlfredNing.github.io/thinking/ title=🤔黑洞><span>🤔黑洞</span></a></li><li><a href=https://AlfredNing.github.io/search/ title="🔎搜索 (Alt + /)" accesskey=/><span>🔎搜索</span></a></li><li><a href=https://AlfredNing.github.io/tags/ title=🏷️标签><span>🏷️标签</span></a></li><li><a href=https://AlfredNing.github.io/archives title=🗄️归档><span>🗄️归档</span></a></li><li><a href=https://AlfredNing.github.io/about title=🤙关于><span>🤙关于</span></a></li></ul></nav></header><main class="main page"><article class=post-single><div id=single-content><header class=post-header><div class=breadcrumbs><a href=https://AlfredNing.github.io>主页</a>&nbsp;»&nbsp;<a href=https://AlfredNing.github.io/note/>笔记</a>&nbsp;»&nbsp;<a href=https://AlfredNing.github.io/note/program/>编程</a></div><h1 class=post-title>MySql高级</h1><div class=post-meta>创建:&nbsp;<span title='2023-05-23 19:40:55 +0800 +0800'>2023年-05月-23日</span>&nbsp;|&nbsp;更新:&nbsp;2023年-05月-23日&nbsp;|&nbsp;字数:&nbsp;661字&nbsp;|&nbsp;时长:&nbsp;4分钟&nbsp;|&nbsp;AlfredNing
&nbsp;|&nbsp;标签: &nbsp;<ul class=post-tags-meta><a href=https://AlfredNing.github.io/tags/mysql/>MySQL</a></ul><span id=busuanzi_container_page_pv>&nbsp;| 访问: <span id=busuanzi_value_page_pv></span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e7%b3%bb%e7%bb%9f%e9%85%8d%e7%bd%ae aria-label=系统配置>系统配置</a><ul><li><a href=#%e5%ad%97%e7%ac%a6%e9%9b%86%e7%9a%84%e8%ae%be%e7%bd%ae aria-label=字符集的设置>字符集的设置</a></li><li><a href=#%e8%af%b7%e6%b1%82%e5%88%b0%e5%93%8d%e5%ba%94%e8%bf%87%e7%a8%8b%e4%b8%ad%e5%ad%97%e7%ac%a6%e9%9b%86%e7%9a%84%e5%8f%98%e5%8c%96 aria-label=请求到响应过程中字符集的变化><strong>请求到响应过程中字符集的变化</strong></a></li><li><a href=#sql%e5%a4%a7%e5%b0%8f%e5%86%99%e7%9a%84%e8%ae%be%e7%bd%ae aria-label=SQL大小写的设置>SQL大小写的设置</a></li><li><a href=#sql%e7%bc%96%e5%86%99%e5%bb%ba%e8%ae%ae aria-label=SQL编写建议>SQL编写建议</a></li><li><a href=#sql_mode%e7%9a%84%e8%ae%be%e7%bd%ae aria-label=SQL_MODE的设置>SQL_MODE的设置</a></li><li><a href=#%e6%95%b0%e6%8d%ae%e7%9b%ae%e5%bd%95 aria-label=数据目录>数据目录</a></li><li><a href=#%e6%95%b0%e6%8d%ae%e5%ba%93%e4%b8%8e%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e7%9a%84%e5%85%b3%e7%b3%bb aria-label=数据库与文件系统的关系>数据库与文件系统的关系</a></li><li><a href=#%e8%a1%a8%e5%9c%a8%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e7%9a%84%e8%a1%a8%e7%a4%ba aria-label=表在文件系统的表示>表在文件系统的表示</a></li><li><a href=#innodb aria-label=InnoDB>InnoDB</a><ul><li><a href=#myisam aria-label=MyISAM>MyISAM</a></li></ul></li></ul></li><li><a href=#mysql%e6%9e%b6%e6%9e%84 aria-label=Mysql架构>Mysql架构</a><ul><li><a href=#%e8%bf%9e%e6%8e%a5%e5%b1%82 aria-label=连接层>连接层</a></li><li><a href=#%e6%9c%8d%e5%8a%a1%e5%b1%82 aria-label=服务层>服务层</a><ul><li><a href=#sql-interface-sql%e6%8e%a5%e5%8f%a3 aria-label="SQL Interface: SQL接口">SQL Interface: SQL接口</a></li><li><a href=#parser-%e8%a7%a3%e6%9e%90%e5%99%a8 aria-label="Parser: 解析器"><strong>Parser:</strong> <strong>解析器</strong></a></li><li><a href=#optimizer-%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96%e5%99%a8 aria-label="Optimizer: 查询优化器"><strong>Optimizer:</strong> <strong>查询优化器</strong></a></li><li><a href=#caches--buffers-%e6%9f%a5%e8%af%a2%e7%bc%93%e5%ad%98%e7%bb%84%e4%bb%b6 aria-label="Caches &amp;amp; Buffers： 查询缓存组件"><strong>Caches & Buffers： 查询缓存组件</strong></a></li><li><a href=#%e5%bc%95%e6%93%8e%e5%b1%82 aria-label=引擎层><strong>引擎层</strong></a></li></ul></li></ul></li><li><a href=#sql%e6%89%a7%e8%a1%8c aria-label=SQL执行>SQL执行</a><ul><li><a href=#mysql%e6%89%a7%e8%a1%8c%e6%b5%81%e7%a8%8b aria-label=MySQL执行流程>MySQL执行流程</a></li><li><a href=#%e6%95%b0%e6%8d%ae%e5%ba%93%e7%bc%93%e5%86%b2%e6%b1%a0-buff---pool aria-label="数据库缓冲池 Buff - Pool">数据库缓冲池 Buff - Pool</a><ul><li><a href=#%e7%bc%93%e5%86%b2%e6%b1%a0 aria-label=缓冲池>缓冲池</a><ul><li><a href=#%e7%bc%93%e5%ad%98%e5%8e%9f%e5%88%99 aria-label=缓存原则>缓存原则</a></li><li><a href=#%e7%bc%93%e5%86%b2%e6%b1%a0%e7%9a%84%e9%a2%84%e8%af%bb%e7%89%b9%e6%80%a7 aria-label=缓冲池的预读特性>缓冲池的预读特性</a></li><li><a href=#%e8%af%bb%e5%8f%96%e6%95%b0%e6%8d%ae aria-label=读取数据>读取数据</a></li><li><a href=#%e6%9b%b4%e6%96%b0%e6%95%b0%e6%8d%ae%e6%b5%81%e7%a8%8b aria-label=更新数据流程>更新数据流程</a></li></ul></li></ul></li></ul></li><li><a href=#%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e aria-label=存储引擎>存储引擎</a><ul><li><a href=#innodb---%e5%85%b7%e6%9c%89%e5%a4%96%e9%94%ae%e7%9a%84%e6%94%af%e6%8c%81%e4%ba%8b%e7%89%a9%e5%bc%95%e6%93%8e aria-label="InnoDB - 具有外键的支持事物引擎">InnoDB - 具有外键的支持事物引擎</a></li><li><a href=#myisam---%e4%b8%bb%e8%a6%81%e7%9a%84%e9%9d%9e%e4%ba%8b%e5%8a%a1%e5%a4%84%e7%90%86%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e aria-label="MyISAM - 主要的非事务处理存储引擎">MyISAM - 主要的非事务处理存储引擎</a></li><li><a href=#archive%e7%94%a8%e4%ba%8e%e6%95%b0%e6%8d%ae%e5%ad%98%e6%a1%a3 aria-label=Archive：用于数据存档>Archive：用于数据存档</a></li><li><a href=#blackhole aria-label=Blackhole>Blackhole</a></li><li><a href=#csv aria-label=CSV>CSV</a></li><li><a href=#memory aria-label=Memory>Memory</a></li><li><a href=#federated aria-label=Federated>Federated</a></li><li><a href=#merge%e5%bc%95%e6%93%8e aria-label=Merge引擎>Merge引擎</a></li><li><a href=#ndb%e5%bc%95%e6%93%8e aria-label=NDB引擎>NDB引擎</a></li><li><a href=#innodb-%e4%b8%8e-myisam%e5%af%b9%e6%af%94 aria-label="InnoDB 与 MyISAM对比">InnoDB 与 MyISAM对比</a></li></ul></li><li><a href=#%e7%b4%a2%e5%bc%95 aria-label=索引>索引</a><ul><li><a href=#%e7%b4%a2%e5%bc%95%e5%8f%8a%e5%85%b6%e4%bc%98%e7%bc%ba%e7%82%b9 aria-label=索引及其优缺点>索引及其优缺点</a><ul><li><a href=#%e7%b4%a2%e5%bc%95%e6%a6%82%e8%bf%b0 aria-label=索引概述>索引概述</a></li><li><a href=#%e4%bc%98%e7%82%b9 aria-label=优点>优点</a></li><li><a href=#%e7%bc%ba%e7%82%b9 aria-label=缺点>缺点</a></li></ul></li><li><a href=#innodb%e7%b4%a2%e5%bc%95%e6%8e%a8%e6%bc%94 aria-label=InnoDB索引推演>InnoDB索引推演</a><ul><li><a href=#%e7%b4%a2%e5%bc%95%e4%b9%8b%e5%89%8d%e7%9a%84%e6%9f%a5%e6%89%be aria-label=索引之前的查找>索引之前的查找</a></li><li><a href=#%e8%ae%be%e8%ae%a1%e7%b4%a2%e5%bc%95 aria-label=设计索引>设计索引</a><ul><li><a href=#%e7%ae%80%e5%8d%95%e7%9a%84%e8%ae%be%e8%ae%a1%e7%b4%a2%e5%bc%95%e6%96%b9%e6%a1%88 aria-label=简单的设计索引方案>简单的设计索引方案</a></li><li><a href=#innodb%e7%9a%84%e7%b4%a2%e5%bc%95%e6%96%b9%e6%a1%88 aria-label=InnoDB的索引方案>InnoDB的索引方案</a><ul><li><a href=#%e8%bf%ad%e4%bb%a31%e6%ac%a1%e7%9b%ae%e5%bd%95%e9%a1%b9%e8%ae%b0%e5%bd%95%e7%9a%84%e7%9b%ae%e5%bd%95%e9%a1%b5 aria-label=迭代1次：目录项记录的目录页>迭代1次：目录项记录的目录页</a></li><li><a href=#%e8%bf%ad%e4%bb%a32%e6%ac%a1%e5%a4%9a%e4%b8%aa%e7%9b%ae%e5%bd%95%e9%a1%b9%e8%ae%b0%e5%bd%95%e7%9a%84%e9%a1%b5 aria-label=迭代2次：多个目录项记录的页>迭代2次：多个目录项记录的页</a></li><li><a href=#%e8%bf%ad%e4%bb%a33%e6%ac%a1%e7%9b%ae%e5%bd%95%e9%a1%b9%e8%ae%b0%e5%bd%95%e9%a1%b5%e7%9a%84%e7%9b%ae%e5%bd%95%e9%a1%b5 aria-label=迭代3次：目录项记录页的目录页>迭代3次：目录项记录页的目录页</a></li><li><a href=#btree aria-label=B+Tree>B+Tree</a></li></ul></li><li><a href=#%e5%b8%b8%e8%a7%81%e7%b4%a2%e5%bc%95%e6%a6%82%e5%bf%b5 aria-label=常见索引概念>常见索引概念</a><ul><li><a href=#%e8%81%9a%e7%b0%87%e7%b4%a2%e5%bc%95 aria-label=聚簇索引>聚簇索引</a><ul><li><a href=#%e7%89%b9%e7%82%b9 aria-label=特点>特点</a></li><li><a href=#%e4%bc%98%e7%82%b9-1 aria-label=优点>优点</a></li><li><a href=#%e7%bc%ba%e7%82%b9-1 aria-label=缺点>缺点</a></li><li><a href=#%e9%99%90%e5%88%b6 aria-label=限制>限制</a></li></ul></li><li><a href=#%e4%ba%8c%e7%ba%a7%e7%b4%a2%e5%bc%95%e8%be%85%e5%8a%a9%e7%b4%a2%e5%bc%95%e9%9d%9e%e8%81%9a%e7%b0%87%e7%b4%a2%e5%bc%95 aria-label=二级索引【辅助索引，非聚簇索引】>二级索引【辅助索引，非聚簇索引】</a></li><li><a href=#%e8%81%94%e5%90%88%e7%b4%a2%e5%bc%95 aria-label=联合索引>联合索引</a></li><li><a href=#innodb%e7%9a%84b%e6%a0%91%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9 aria-label=InnoDB的B+树注意事项>InnoDB的B+树注意事项</a><ul><li><a href=#1-%e6%a0%b9%e9%a1%b5%e9%9d%a2%e4%bd%8d%e7%bd%ae%e4%b8%87%e5%b9%b4%e4%b8%8d%e5%8a%a8 aria-label="1. 根页面位置万年不动">1. 根页面位置万年不动</a></li><li><a href=#2-%e5%86%85%e8%8a%82%e7%82%b9%e4%b8%ad%e7%9b%ae%e5%bd%95%e9%a1%b9%e8%ae%b0%e5%bd%95%e7%9a%84%e5%94%af%e4%b8%80%e6%80%a7 aria-label="2. 内节点中目录项记录的唯一性">2. 内节点中目录项记录的唯一性</a></li><li><a href=#%e4%b8%80%e4%b8%aa%e9%a1%b5%e9%9d%a2%e6%9c%80%e5%b0%91%e5%ad%98%e5%82%a82%e6%9d%a1%e8%ae%b0%e5%bd%95 aria-label=一个页面最少存储2条记录>一个页面最少存储2条记录</a></li></ul></li></ul></li></ul></li></ul></li><li><a href=#myisam%e7%9a%84%e7%b4%a2%e5%bc%95%e6%96%b9%e6%a1%88 aria-label=MyISAM的索引方案>MyISAM的索引方案</a><ul><li><a href=#myisam%e7%9a%84%e5%8e%9f%e7%90%86 aria-label=MyISAM的原理>MyISAM的原理</a></li><li><a href=#myisam-%e4%b8%8e-innodb%e5%af%b9%e6%af%94 aria-label="MyISAM** 与 InnoDB对比">MyISAM** <strong>与</strong> InnoDB对比</a></li><li><a href=#%e7%b4%a2%e5%bc%95%e4%bb%a3%e4%bb%b7 aria-label=索引代价>索引代价</a></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=系统配置>系统配置<a hidden class=anchor aria-hidden=true href=#系统配置>#</a></h1><h2 id=字符集的设置>字符集的设置<a hidden class=anchor aria-hidden=true href=#字符集的设置>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>show</span><span class=w> </span><span class=n>variables</span><span class=w> </span><span class=k>like</span><span class=w> </span><span class=s1>&#39;character%&#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><ul><li>character_set_server：服务器级别的字符集</li><li>character_set_database：当前数据库的字符集</li><li>character_set_client：服务器解码请求时使用的字符集</li><li>character_set_connection：服务器处理请求时会把请求字符串从character_set_client转为character_set_connection</li><li>character_set_results：服务器向客户端返回数据时使用的字符集</li></ul><p><strong>小结</strong></p><ul><li>如果<code>创建或修改列</code>时没有显式的指定字符集和比较规则，则该列<code>默认用表的</code>字符集和比较规则</li><li>如果<code>创建表时</code>没有显式的指定字符集和比较规则，则该表<code>默认用数据库的</code>字符集和比较规则</li><li>如果<code>创建数据库时</code>没有显式的指定字符集和比较规则，则该数据库<code>默认用服务器的</code>字符集和比较规则</li></ul><h2 id=请求到响应过程中字符集的变化><strong>请求到响应过程中字符集的变化</strong><a hidden class=anchor aria-hidden=true href=#请求到响应过程中字符集的变化>#</a></h2><pre tabindex=0><code class=language-mermaid data-lang=mermaid>graph TB
A(客户端) --&gt; |&#34;使用操作系统的字符集编码请求字符串&#34;| B(从character_set_client转换为character_set_connection)
B --&gt; C(从character_set_connection转换为具体的列使用的字符集)
C --&gt; D(将查询结果从具体的列上使用的字符集转换为character_set_results)
D --&gt; |&#34;使用操作系统的字符集解码响应的字符串&#34;| A
</code></pre><h2 id=sql大小写的设置>SQL大小写的设置<a hidden class=anchor aria-hidden=true href=#sql大小写的设置>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>show</span><span class=w> </span><span class=n>variables</span><span class=w> </span><span class=k>like</span><span class=w> </span><span class=s1>&#39;%lower_case_table_names%&#39;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>该参数只适用于</span><span class=mi>5</span><span class=p>.</span><span class=mi>7</span><span class=err>版本</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>默认为</span><span class=mi>0</span><span class=w> </span><span class=err>大小写敏感</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>设置为</span><span class=mi>1</span><span class=err>，大小写不敏感，创建的表都是以小写方式存放在磁盘上，对于</span><span class=n>sql</span><span class=err>语句都是转换为小写对表和数据库查找</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>设置为</span><span class=mi>2</span><span class=err>，创建的表和数据库依据语句上存放，凡是查找都是转换为小写进行</span><span class=w>
</span></span></span></code></pre></div><h2 id=sql编写建议>SQL编写建议<a hidden class=anchor aria-hidden=true href=#sql编写建议>#</a></h2><ol><li>关键字和函数名称全部大写</li><li>数据库名、表名、表别名、字段名、字段别名等全部小写</li><li>SQL语句必须以分号结尾</li></ol><h2 id=sql_mode的设置>SQL_MODE的设置<a hidden class=anchor aria-hidden=true href=#sql_mode的设置>#</a></h2><ul><li>宽松模式</li><li>严格模式</li></ul><p><strong>MySQL的sql_mode合理设置</strong></p><p>sql_mode是个很容易被忽视的变量,默认值是空值,在这种设置下是可以允许一些非法操作的,比如允许一些非法数据的插入。在生产环境必须将这个值设置为严格模式,所以开发、测试环境的数据库也必须要设置,这样在开发测试阶段就可以发现问题.</p><p><strong>sql model 常用来解决下面几类问题</strong></p><ol><li><p>通过设置sql mode, 可以完成不同严格程度的数据校验，有效地保障数据准备性。</p></li><li><p>通过设置sql model 为宽松模式，来保证大多数sql符合标准的sql语法，这样应用在不同数据库之间进行迁移时，则不需要对业务sql 进行较大的修改。</p></li></ol><p>　3. 在不同数据库之间进行数据迁移之前，通过设置SQL Mode 可以使MySQL 上的数据更方便地迁移到目标数据库中。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=o>#</span><span class=w> </span><span class=err>临时设置</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>set</span><span class=w> </span><span class=k>global</span><span class=w> </span><span class=n>sql_mode</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;&#39;</span><span class=p>;</span><span class=w> </span><span class=c1>-- 全局生效
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>set</span><span class=w> </span><span class=k>session</span><span class=w> </span><span class=n>sql_mode</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;&#39;</span><span class=p>;</span><span class=w> </span><span class=c1>-- 会话生效
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>#</span><span class=w> </span><span class=n>my</span><span class=p>.</span><span class=n>cnf</span><span class=err>可以修改，永久设置，设置完毕重启</span><span class=w> 	
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>生成环境：</span><span class=w> </span><span class=err>临时设置</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=err>全局设置。重启也会永久生效</span><span class=w>
</span></span></span></code></pre></div><h2 id=数据目录>数据目录<a hidden class=anchor aria-hidden=true href=#数据目录>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>show</span><span class=w> </span><span class=n>variables</span><span class=w> </span><span class=k>like</span><span class=w> </span><span class=s1>&#39;%datadir%&#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><h2 id=数据库与文件系统的关系>数据库与文件系统的关系<a hidden class=anchor aria-hidden=true href=#数据库与文件系统的关系>#</a></h2><p>存储引擎把表存储在文件系统上</p><p>四个默认数据库</p><ul><li>mysql: 用户、权限等</li><li>information_schema: 维护所有其他数据库的信息</li><li>performance_schema: mysql运行状态信息</li><li>sys: 通过视图的形式把information_schema与performance_schema结合起来，帮助开发人员和系统管理人员监控MYSQL的技术性能</li></ul><h2 id=表在文件系统的表示>表在文件系统的表示<a hidden class=anchor aria-hidden=true href=#表在文件系统的表示>#</a></h2><h2 id=innodb>InnoDB<a hidden class=anchor aria-hidden=true href=#innodb>#</a></h2><ul><li>db.opt: 针对该数据库的信息</li><li>*.frm: 存储表结构</li><li>*.ibd: 存储表数据，<strong>也可以放在ibdata1</strong>: 系统表空间</li></ul><ol><li>系统表空间（system tablespace）
默认情况下，InnoDB会在数据目录下创建一个名为<code>ibdata1</code>、大小为<code>12M</code>的<code>自拓展</code>文件，这个文件就是对应的<code>系统表空间</code>在文件系统上的表示。</li><li>独立表空间(file-per-table tablespace)
在MySQL5.6.6以及之后的版本中，InnoDB并不会默认的把各个表的数据存储到系统表空间中，而是为<code>每一个表建立一个独立表空间</code>，也就是说我们创建了多少个表，就有多少个独立表空间。使用<code>独立表空间</code>来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同。</li></ol><blockquote><p>MySQL8.0中不再单独提供<code>表名.frm</code>，而是<strong>合并</strong>在<code>表名.ibd</code>文件中，也没有db.opt文件</p><p>利用ibd2sdi 可以查看ibd文件</p></blockquote><ol start=3><li><p>系统表空间与独立表空间的设置
可以自己指定使用<code>系统表空间</code>还是<code>独立表空间</code>来存储数据，这个功能由启动参数<code>innodb_file_per_table</code>控制</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=p>[</span><span class=n>server</span><span class=p>]</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>innodb_file_per_table</span><span class=o>=</span><span class=mi>0</span><span class=w> </span><span class=o>#</span><span class=w> </span><span class=mi>0</span><span class=err>：代表使用系统表空间；</span><span class=w> </span><span class=mi>1</span><span class=err>：代表使用独立表空间</span><span class=w>
</span></span></span></code></pre></div></li><li><p>其他类型的表空间
随着MySQL的发展，除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间，比如通用表空间（general tablespace）、临时表空间（temporary tablespace）等。</p></li></ol><h3 id=myisam>MyISAM<a hidden class=anchor aria-hidden=true href=#myisam>#</a></h3><p>在MyISAM中的索引全部都是<code>二级索引</code>，该存储引擎的<code>数据和索引是分开存放</code>的。所以在文件系统中也是使用不同的文件来存储数据文件和索引文件，同时表数据都存放在对应的数据库子目录下。</p><ul><li>表结构： *.frm, MySQL8.0 改为了 b.xxx.sdi</li><li>表数据：*.myd</li><li>表索引：*.myi</li></ul><h1 id=mysql架构>Mysql架构<a hidden class=anchor aria-hidden=true href=#mysql架构>#</a></h1><p>C/S架构，既Client/Server架构，服务端使用<code>mysqld</code></p><p><code>Mysql5.7架构图</code></p><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230524193010225.png alt=image-20230524193010225></p><h2 id=连接层>连接层<a hidden class=anchor aria-hidden=true href=#连接层>#</a></h2><ul><li>三握手建立TCP连接</li><li>身份认证、权限认证</li></ul><h2 id=服务层>服务层<a hidden class=anchor aria-hidden=true href=#服务层>#</a></h2><h3 id=sql-interface-sql接口>SQL Interface: SQL接口<a hidden class=anchor aria-hidden=true href=#sql-interface-sql接口>#</a></h3><ul><li>接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT … FROM就是调用SQL Interface</li><li>MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口</li></ul><h3 id=parser-解析器><strong>Parser:</strong> <strong>解析器</strong><a hidden class=anchor aria-hidden=true href=#parser-解析器>#</a></h3><ul><li>在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。</li><li>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建<strong>语法树</strong>，并根据数据字典丰富查询语法树，会<code>验证该客户端是否具有执行该查询的权限</code>。创建好语法树后，MySQL还会对SQL查询进行语法上的优化，进行查询重写。</li></ul><h3 id=optimizer-查询优化器><strong>Optimizer:</strong> <strong>查询优化器</strong><a hidden class=anchor aria-hidden=true href=#optimizer-查询优化器>#</a></h3><ul><li>SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个<code>执行计划</code>。</li><li>这个执行计划表明应该<code>使用哪些索引</code>进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。</li><li>它使用**“选取-投影-连接”**策略进行查询。例如：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>id</span><span class=p>,</span><span class=n>name</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>student</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>gender</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;女&#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>这个SELECT查询先根据WHERE语句进行<code>选取</code>，而不是将表全部查询出来以后再进行gender过滤。 这个SELECT查询先根据id和name进行属性<code>投影</code>，而不是将属性全部取出以后再进行过滤，将这两个查询条件<code>连接</code>起来生成最终查询结果。</p><h3 id=caches--buffers-查询缓存组件><strong>Caches & Buffers： 查询缓存组件</strong><a hidden class=anchor aria-hidden=true href=#caches--buffers-查询缓存组件>#</a></h3><ul><li>MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。</li><li>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。</li><li>这个查询缓存可以在<code>不同客户端之间共享</code>。</li><li>从MySQL 5.7.20开始，不推荐使用查询缓存，并在<code>MySQL 8.0中删除</code></li></ul><h3 id=引擎层><strong>引擎层</strong><a hidden class=anchor aria-hidden=true href=#引擎层>#</a></h3><p>插件式存储引擎层（ Storage Engines），<strong>真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作</strong>，服务层通过API与存储引擎进行通信。开发人员也可以定制属于自己的引擎</p><h1 id=sql执行>SQL执行<a hidden class=anchor aria-hidden=true href=#sql执行>#</a></h1><h2 id=mysql执行流程>MySQL执行流程<a hidden class=anchor aria-hidden=true href=#mysql执行流程>#</a></h2><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230524210721611.png alt=image-20230524210721611></p><ol><li><p>查询缓存。缓存中发现这条语句，返回结果。但是由于命中率并不高。<strong>MySQL8.0取消缓存设置</strong></p><p>查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。这就意味着查询匹配的<code>鲁棒性大大降低</code>，只有<code>相同的查询操作才会命中查询缓存</code>。两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。因此 MySQL 的 查询缓存命中率不高 。</p><p>同时，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql、 information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。</p><p>此外，既然是缓存，那就有它<code>缓存失效的时候</code>。MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>TRUNCATE TABLE</code>、<code>ALTER TABLE</code>、<code>DROP TABLE</code>或<code>DROP DATABASE</code>语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！对于<code>更新压力大的数据库</code>来说，查询缓存的命中率会非常低。</p></li><li><p>解析器</p><ol><li>词法分析：识别字符串</li><li>语法分析：识别语法规则</li></ol></li><li><p>优化器：确定SQL的执行路径，是全表扫描，还是索引检索</p><ol><li>逻辑优化</li><li>物理查询</li></ol></li><li><p>执行器：在执行之前需要判断该用户是否<code>具备权限</code>。如果没有，就会返回权限错误。如果具备权限，就执行 SQL查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存</p></li></ol><p>**SQL 语句在 MySQL 中的流程是： SQL语句→查询缓存→解析器→优化器→执行器 **</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>show</span><span class=w> </span><span class=n>VARIABLES</span><span class=w> </span><span class=k>like</span><span class=w> </span><span class=s1>&#39;%query_cache_type%&#39;</span><span class=w> </span><span class=o>#</span><span class=w> </span><span class=n>mysql8</span><span class=p>.</span><span class=mi>0</span><span class=err>之后没有该参数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>有三个值</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=mi>0</span><span class=p>:</span><span class=err>关闭查询缓存</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=mi>1</span><span class=p>:</span><span class=err>代表开启</span><span class=k>On</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=mi>2</span><span class=p>:</span><span class=w> </span><span class=n>DEMAND</span><span class=p>,</span><span class=w> </span><span class=err>按需开启，</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>指定为</span><span class=mi>2</span><span class=err>时候，使用下面开启</span><span class=o>/</span><span class=err>关闭缓存</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>SQL_CACHE</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>users</span><span class=p>;</span><span class=w> </span><span class=o>#</span><span class=w> </span><span class=err>开启</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>SQL_NO_CACHE</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>users</span><span class=p>;</span><span class=w> </span><span class=o>#</span><span class=w> </span><span class=err>关闭</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>建议在静态表使用查询缓存，静态表：更新不频繁</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=w> </span><span class=err>查看缓存信息</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>show</span><span class=w> </span><span class=n>STATUS</span><span class=w> </span><span class=k>like</span><span class=w> </span><span class=s1>&#39;%Qcache%&#39;</span><span class=p>;</span><span class=w> </span><span class=o>#</span><span class=w> </span><span class=n>mysql8</span><span class=p>.</span><span class=mi>0</span><span class=err>之后没有该参数</span><span class=w>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=o>#</span><span class=w> </span><span class=err>开启</span><span class=n>sql</span><span class=err>记录执行</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w> </span><span class=o>@@</span><span class=n>profiling</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>set</span><span class=w> </span><span class=n>profiling</span><span class=w> </span><span class=o>=</span><span class=w>  </span><span class=mi>1</span><span class=p>;</span><span class=w> </span><span class=o>#</span><span class=err>开启</span><span class=w> </span><span class=n>session</span><span class=err>级别</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>job_history</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w> </span><span class=o>@@</span><span class=n>profiling</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>show</span><span class=w> </span><span class=n>PROFILES</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 最近一次
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>show</span><span class=w> </span><span class=n>profile</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 查询指定
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>show</span><span class=w> </span><span class=n>profile</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>query</span><span class=w> </span><span class=mi>98</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=w> </span><span class=err>查看</span><span class=n>cpu</span><span class=p>,</span><span class=w> </span><span class=n>io</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>show</span><span class=w> </span><span class=n>profile</span><span class=w> </span><span class=n>cpu</span><span class=p>,</span><span class=n>block</span><span class=w> </span><span class=n>io</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>query</span><span class=w> </span><span class=mi>137</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><h2 id=数据库缓冲池-buff---pool>数据库缓冲池 Buff - Pool<a hidden class=anchor aria-hidden=true href=#数据库缓冲池-buff---pool>#</a></h2><p><code>InnoDB</code>存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。而磁盘 I/O 需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请<code>占用内存来作为数据缓冲池</code>，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的<code>Buffer Pool</code>之后才可以访问。</p><p>这样做的好处是可以让磁盘活动最小化，从而<code>减少与磁盘直接进行 I/O 的时间</code>。要知道，这种策略对提升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。</p><h3 id=缓冲池>缓冲池<a hidden class=anchor aria-hidden=true href=#缓冲池>#</a></h3><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230525203527796.png alt=image-20230525203527796></p><h4 id=缓存原则>缓存原则<a hidden class=anchor aria-hidden=true href=#缓存原则>#</a></h4><p><code>位置 * 频次</code>这个原则，可以帮我们对 I/O 访问效率进行优化。</p><p>首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。</p><p>其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有 200G，但是内存只有 16G，缓冲池大小只有 1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会<strong>优先对使用频次高的热数据进行加载</strong>。</p><h4 id=缓冲池的预读特性>缓冲池的预读特性<a hidden class=anchor aria-hidden=true href=#缓冲池的预读特性>#</a></h4><p>在读取部分数据同时，会预先读取部分数据的上下可能引用的数据。</p><h4 id=读取数据>读取数据<a hidden class=anchor aria-hidden=true href=#读取数据>#</a></h4><p>缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>--</span>  <span class=err>查看缓冲池大小</span>
</span></span><span class=line><span class=cl><span class=n>show</span> <span class=n>variables</span> <span class=n>like</span> <span class=err>&#39;</span><span class=n>innodb_buffer_pool_size</span><span class=err>&#39;</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>--</span> <span class=err>修改缓冲池，也可以修改配置文件</span> <span class=err>全局修改</span>
</span></span><span class=line><span class=cl><span class=n>set</span> <span class=n>global</span> <span class=n>innodb_buffer_pool_size</span> <span class=o>=</span> <span class=mi>268435456</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>--</span> <span class=err>将单个</span><span class=n>buffer</span> <span class=n>poll</span> <span class=err>拆分成小的</span><span class=n>buffer</span> <span class=n>pool</span>
</span></span><span class=line><span class=cl><span class=n>show</span> <span class=n>variables</span> <span class=n>like</span> <span class=err>&#39;</span><span class=n>innodb_buffer_pool_instances</span><span class=err>&#39;</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>配置文件修改 buffer_poll
</span></span></span><span class=line><span class=cl><span class=cm>[server]
</span></span></span><span class=line><span class=cl><span class=cm>innodb_buffer_pool_instances = 
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=err>计算每个</span><span class=n>buffer</span> <span class=n>poll</span><span class=err>占比：</span> <span class=n>innodb_buffer_pool_size</span><span class=o>/</span><span class=n>innodb_buffer_pool_instances</span>
</span></span></code></pre></div><h4 id=更新数据流程>更新数据流程<a hidden class=anchor aria-hidden=true href=#更新数据流程>#</a></h4><p>更新某个数据，如果数据在Buffer Pool不存在，会先将数据从磁盘中国加载，修改完成之后，放入缓冲池当中，当达到一定的落盘时机，才会刷入磁盘中</p><p><strong>缓冲池无论是5.7还是8.0都存在，查询缓存在8.0中不存在</strong></p><h1 id=存储引擎>存储引擎<a hidden class=anchor aria-hidden=true href=#存储引擎>#</a></h1><ol><li>MyISAM</li><li>InnoDB</li><li>Memory</li><li>Blackhole</li><li>CSV</li><li>Performance_Schema</li><li>Archive</li><li>Federated</li><li>Mrg_Myisam</li></ol><h2 id=innodb---具有外键的支持事物引擎>InnoDB - 具有外键的支持事物引擎<a hidden class=anchor aria-hidden=true href=#innodb---具有外键的支持事物引擎>#</a></h2><ul><li>MySQL从3.23.34a开始就包含InnoDB存储引擎。<code>大于等于5.5之后，默认采用InnoDB引擎</code>。</li><li>InnoDB是MySQL的<code>默认事务型引擎</code>，它被设计用来处理大量的短期(short-lived)事务。可以确保事务的完整提交(Commit)和回滚(Rollback)。</li><li>除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。</li><li><strong>除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。</strong></li><li>数据文件结构：<ul><li>表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中）</li><li>表名.ibd 存储数据和索引</li></ul></li><li>InnoDB是<code>为处理巨大数据量的最大性能设计</code>。<ul><li>在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除了。比如：<code>.frm</code>，<code>.par</code>，<code>.trn</code>，<code>.isl</code>，<code>.db.opt</code>等都在MySQL8.0中不存在了。</li></ul></li><li>对比MyISAM的存储引擎，<strong>InnoDB写的处理效率差一些</strong>，并且会占用更多的磁盘空间以保存数据和索引。</li><li>MyISAM只缓存索引，不缓存真实数据；<strong>InnoDB不仅缓存索引还要缓存真实数据，<code>对内存要求较高</code></strong>，而且内存大小对性能有决定性的影响。</li></ul><h2 id=myisam---主要的非事务处理存储引擎>MyISAM - 主要的非事务处理存储引擎<a hidden class=anchor aria-hidden=true href=#myisam---主要的非事务处理存储引擎>#</a></h2><ul><li>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM<code>不支持事务、行级锁、外键</code>，有一个毫无疑问的缺陷就是<code>崩溃后无法安全恢复</code>。</li><li><code>5.5之前默认的存储引擎</code></li><li>优势是访问的<code>速度快</code>，对事务完整性没有要求或者以SELECT、INSERT为主的应用</li><li>针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高</li><li>数据文件结构：<ul><li>表名.frm 存储表结构</li><li>表名.MYD 存储数据 (MYData)</li><li>表名.MYI 存储索引 (MYIndex)</li></ul></li><li>应用场景：只读应用或者以读为主的业务</li></ul><h2 id=archive用于数据存档>Archive：用于数据存档<a hidden class=anchor aria-hidden=true href=#archive用于数据存档>#</a></h2><h2 id=blackhole>Blackhole<a hidden class=anchor aria-hidden=true href=#blackhole>#</a></h2><p>丢弃写操作，读操作会返回空内容</p><h2 id=csv>CSV<a hidden class=anchor aria-hidden=true href=#csv>#</a></h2><p>存储数据时，以逗号分隔各个数据项，作为数据交互</p><h2 id=memory>Memory<a hidden class=anchor aria-hidden=true href=#memory>#</a></h2><p>置于内存的表</p><h2 id=federated>Federated<a hidden class=anchor aria-hidden=true href=#federated>#</a></h2><p>访问远程表，默认禁用</p><h2 id=merge引擎>Merge引擎<a hidden class=anchor aria-hidden=true href=#merge引擎>#</a></h2><p>管理多个MyISAM表构成的表集合</p><h2 id=ndb引擎>NDB引擎<a hidden class=anchor aria-hidden=true href=#ndb引擎>#</a></h2><p>MySQL集群专用存储引擎</p><h2 id=innodb-与-myisam对比>InnoDB 与 MyISAM对比<a hidden class=anchor aria-hidden=true href=#innodb-与-myisam对比>#</a></h2><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230526204055829.png alt=image-20230526204055829></p><blockquote><p>阿里巴巴 Percona为Mysql数据库做了改进，新建存储引擎Xtradb替代Innodb, 并且在性能和并发上做的更好，阿里巴巴大部分数据库基于percona的原型进行修改</p></blockquote><h1 id=索引>索引<a hidden class=anchor aria-hidden=true href=#索引>#</a></h1><blockquote><p>减少IO次数，降低查询时间</p><p>索引具体实现与其存储引擎相关</p></blockquote><h2 id=索引及其优缺点>索引及其优缺点<a hidden class=anchor aria-hidden=true href=#索引及其优缺点>#</a></h2><h3 id=索引概述>索引概述<a hidden class=anchor aria-hidden=true href=#索引概述>#</a></h3><p>索引是帮助MySQL高效获取数据的<strong>数据结构</strong></p><p>**索引的本质：**索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现<code>高级查找算法</code>。</p><h3 id=优点>优点<a hidden class=anchor aria-hidden=true href=#优点>#</a></h3><ol><li>提高检索数据的效率，<strong>降低IO成本</strong></li><li>可以创建唯一索引，保证数据库的每一行的唯一性</li><li>加速表和表之间的连接</li><li>在使用分组和排序字句时候，可以<strong>减少分组和排序的时间</strong>，降低CPU消耗</li></ol><h3 id=缺点>缺点<a hidden class=anchor aria-hidden=true href=#缺点>#</a></h3><ol><li>创建索引和维护索引需要耗费时间，随着数据量的增加，时间也会增加</li><li>索引需要占据磁盘空间</li><li>索引提高查询速度，同时会降低表的更新速度。当对表中的数据进行增加、删除和修改的时候，索引也需要动态维护，降低了数据的维护成本</li></ol><blockquote><p>TIP:</p><p>索引提高查询速度，影响插入记录的速度。这种情况下，先删除表得索引，在插入数据，插入数据完成之后，再去恢复索引3的</p></blockquote><h2 id=innodb索引推演>InnoDB索引推演<a hidden class=anchor aria-hidden=true href=#innodb索引推演>#</a></h2><h3 id=索引之前的查找>索引之前的查找<a hidden class=anchor aria-hidden=true href=#索引之前的查找>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=p>[</span><span class=err>列名列表</span><span class=p>]</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=err>表名</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=err>列名</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>xxx</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><ol><li>在一个页的查找</li></ol><p>假设目前表中的记录比较少，所有的记录都可以被存放在一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：</p><ul><li>以主键为搜索条件<ul><li>可以在页目录中使用<code>二分法</code>快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</li></ul></li><li>以其他列作为搜索条件<ul><li>因为在数据页中并没有对非主键建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从最小记录开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。</li></ul></li></ul><ol start=2><li>在很多页中查找</li></ol><p>大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤：</p><ol><li>定位到记录所在的页。</li><li>从所在的页内查找相应的记录。</li></ol><p>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能<code>从第一个页</code>沿着<code>双向链表</code>一直往下找，在每一个页中根据我们上面的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是<code>超级耗时</code>的。</p><h3 id=设计索引>设计索引<a hidden class=anchor aria-hidden=true href=#设计索引>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=n>mysql</span><span class=o>&gt;</span><span class=w> </span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>index_demo</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>-&gt;</span><span class=w> </span><span class=n>c1</span><span class=w> </span><span class=nb>INT</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>-&gt;</span><span class=w> </span><span class=n>c2</span><span class=w> </span><span class=nb>INT</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>-&gt;</span><span class=w> </span><span class=n>c3</span><span class=w> </span><span class=nb>CHAR</span><span class=p>(</span><span class=mi>1</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>-&gt;</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=p>(</span><span class=n>c1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>-&gt;</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=n>ROW_FORMAT</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Compact</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>这个新建的<code>index_demo</code>表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键，这个表使用<code>Compact</code>行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图：</p><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230527181855398.png alt=image-20230527181855398></p><ul><li><code>record_type</code>：记录头信息的一项属性，表示记录的类型，<code>0</code>表示普通记录、<code>1</code>表示目录项记录、<code>2</code>表示最小记录、<code>3</code>表示最大记录。</li><li><code>next_record</code>：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁。</li><li><code>各个列的值</code>：这里只记录在<code>index_demo</code>表中的三个列，分别是<code>c1</code>、<code>c2</code>和<code>c3</code>。</li><li><code>其他信息</code>：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li></ul><p>将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：</p><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230527182053856.png alt=image-20230527182053856></p><p>记录放到页中示意图</p><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230527182127589.png alt=image-20230527182127589></p><h4 id=简单的设计索引方案>简单的设计索引方案<a hidden class=anchor aria-hidden=true href=#简单的设计索引方案>#</a></h4><p>在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们<code>想快速的定位到需要查找的记录在哪些数据页</code>中该咋办？我们可以为快速定位记录所在的数据页而<code>建立一个目录</code>，建这个目录必须完成下边这些事：</p><ul><li><strong>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值</strong></li><li><strong>给所有的页建立一个目录项</strong></li></ul><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230527182301724.png alt=image-20230527182301724></p><p>以<code>页28</code>为例，它对应<code>目录项2</code>，这个目录项中包含着该页的页号<code>28</code>以及该页中用户记录的最小主键值<code>5</code>。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为<code>20</code>的记录，具体查找过程分两步：</p><ol><li>先从目录项中根据<code>二分法</code>快速确定出主键值为<code>20</code>的记录在<code>目录项3</code>中（因为 12 &lt; 20 &lt; 209 ），它对应的页是<code>页9</code>。</li><li>再根据前边说的在页中查找记录的方式去<code>页9</code>中定位具体的记录。</li></ol><p><strong>页分裂</strong>：对页中的纪录进行增删改查，需要通过一些列诸如移动的操作，使得状态成立，下一个数据页记录的主键值大于上一个页中记录的主键值，这个过程被称为页分裂。</p><h4 id=innodb的索引方案>InnoDB的索引方案<a hidden class=anchor aria-hidden=true href=#innodb的索引方案>#</a></h4><h5 id=迭代1次目录项记录的目录页>迭代1次：目录项记录的目录页<a hidden class=anchor aria-hidden=true href=#迭代1次目录项记录的目录页>#</a></h5><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230527184236140.png alt></p><p>从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调<code>目录项记录</code>和普通的<code>用户记录</code>的<strong>不同点</strong>：</p><ul><li><code>目录项记录</code>的<code>record_type</code>值是1，而<code>普通用户记录</code>的<code>record_type</code>值是0。</li><li>目录项记录只有<code>主键值和页的编号</code>两个列，而普通的用户记录的列是用户自己定义的，可能包含<code>很多列</code>，另外还有InnoDB自己添加的隐藏列。</li><li>了解：记录头信息里还有一个叫<code>min_rec_mask</code>的属性，只有在存储<code>目录项记录</code>的页中的主键值最小的<code>目录项记录</code>的<code>min_rec_mask</code>值为<code>1</code>，其他别的记录的<code>min_rec_mask</code>值都是<code>0</code></li></ul><p>现在以查找主键为<code>20</code>的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：</p><ol><li>先到存储<code>目录项记录</code>的页，也就是页30中通过<code>二分法</code>快速定位到对应目录项，因为 12 &lt; 20 &lt; 209 ，所以定位到对应的记录所在的页就是页9。</li><li>再到存储用户记录的页9中根据<code>二分法</code>快速定位到主键值为<code>20</code>的用户记录。</li></ol><h5 id=迭代2次多个目录项记录的页>迭代2次：多个目录项记录的页<a hidden class=anchor aria-hidden=true href=#迭代2次多个目录项记录的页>#</a></h5><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230527184329890.png alt=image-20230527184329890></p><p>从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：</p><ul><li>为存储该用户记录而新生成了<code>页31</code>。</li><li>因为原先存储目录项记录的<code>页30的容量已满</code>（我们前边假设只能存储4条目录项记录），所以不得不需要一个新的<code>页32</code>来存放<code>页31</code>对应的目录项。</li></ul><p>现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为<code>20</code>的记录为例：</p><ol><li>确定<code>目录项记录页</code>我们现在的存储目录项记录的页有两个，即<code>页30</code>和<code>页32</code>，又因为页30表示的目录项的主键值的范围是 [1, 320) ，页32表示的目录项的主键值不小于 320 ，所以主键值为<code>20</code>的记录对应的目录项记录在<code>页30</code>中。</li><li>通过目录项记录页<code>确定用户记录真实所在的页</code>。在一个存储<code>目录项记录</code>的页中通过主键值定位一条目录项记录的方式说过了。</li><li>在真实存储用户记录的页中定位到具体的记录。</li></ol><h5 id=迭代3次目录项记录页的目录页>迭代3次：目录项记录页的目录页<a hidden class=anchor aria-hidden=true href=#迭代3次目录项记录页的目录页>#</a></h5><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230527184418438.png alt=image-20230527184418438></p><p>如图，我们生成了一个存储更高级目录项的<code>页33</code>，这个页中的两条记录分别代表页30和页32，如果用户记录的主键值在<code>[1, 320)</code>之间，则到页30中查找更详细的目录项记录，如果主键值<code>不小于320</code>的话，就到页32中查找更详细的目录项记录。</p><p><strong>这个数据结构，它的名称是<code>B+树</code>。</strong></p><h5 id=btree>B+Tree<a hidden class=anchor aria-hidden=true href=#btree>#</a></h5><p>一个B+树的节点其实可以分成好多层**，规定最下边的那层，也就是存放我们用户记录的那层为第<code>0</code>层**，之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页<code>最多存放3条记录</code>，存放目录项记录的页<code>最多存放4条记录</code>。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放<code>100条用户记录</code>，所有存放目录项记录的内节点代表的数据页可以存放<code>1000条目录项记录</code>，那么：</p><ul><li>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放<code>100</code>条记录。</li><li>如果B+树有2层，最多能存放<code>1000×100=10,0000</code>条记录。</li><li>如果B+树有3层，最多能存放<code>1000×1000×100=1,0000,0000</code>条记录。</li><li>如果B+树有4层，最多能存放<code>1000×1000×1000×100=1000,0000,0000</code>条记录。相当多的记录！！！</li></ul><p>所以一般情况下，我们<code>用到的B+树都不会超过4层</code>，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的<code>Page Directory</code>（页目录），<strong>所以在页面内也可以通过<code>二分法</code>实现快速定位记录</strong>。</p><h4 id=常见索引概念>常见索引概念<a hidden class=anchor aria-hidden=true href=#常见索引概念>#</a></h4><h5 id=聚簇索引>聚簇索引<a hidden class=anchor aria-hidden=true href=#聚簇索引>#</a></h5><p>索引既数据</p><h6 id=特点>特点<a hidden class=anchor aria-hidden=true href=#特点>#</a></h6><ol><li><p>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</p><ul><li><p><code>页内</code>的记录是按照主键的大小顺序排成一个<code>单向链表</code>。</p></li><li><p>各个存放<code>用户记录的页</code>也是根据页中用户记录的主键大小顺序排成一个<code>双向链表</code>。</p></li><li><p>存放<code>目录项记录的页</code>分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个<code>双向链表</code>。</p></li></ul></li><li><p><strong>B+树的<code>叶子节点</code>存储的是完整的用户记录。</strong></p><p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p></li></ol><h6 id=优点-1>优点<a hidden class=anchor aria-hidden=true href=#优点-1>#</a></h6><ul><li><code>数据访问更快</code>，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</li><li>聚簇索引对于主键的<code>排序查找</code>和<code>范围查找</code>速度非常快</li><li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以<code>节省了大量的io操作</code>。</li></ul><h6 id=缺点-1>缺点<a hidden class=anchor aria-hidden=true href=#缺点-1>#</a></h6><ul><li><code>插入速度严重依赖于插入顺序</code>，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<strong>自增ID列为主键</strong></li><li><code>更新主键的代价很高</code>，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义<strong>主键为不可更新</strong></li><li><code>二级索引访问需要两次索引查找</code>，第一次找到主键值，第二次根据主键值找到行数据</li></ul><h6 id=限制>限制<a hidden class=anchor aria-hidden=true href=#限制>#</a></h6><ul><li>对于MySQL数据库目前只有InnoDB支持聚簇索引，而MyISAM不支持</li><li>每个MySQL的表只能有一个聚簇索引</li><li>如果没有定义主键，选择非空唯一索引代替。如果没有这样的索引,InnoDB隐式定义一个主键作为聚簇索引</li><li><strong>innodb的表主键尽量选择有序的顺序id，不建议使用无序id</strong></li></ul><h5 id=二级索引辅助索引非聚簇索引>二级索引【辅助索引，非聚簇索引】<a hidden class=anchor aria-hidden=true href=#二级索引辅助索引非聚簇索引>#</a></h5><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230527190516777.png alt=image-20230527190516777></p><p><strong>叶子节点存放主键值</strong></p><p><strong>概念：回表</strong> 我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到<code>聚簇索引</code>中再查一遍，这个过程称为<code>回表</code>。也就是根据c2列的值查询一条完整的用户记录需要使用到<code>2</code>棵B+树！</p><h5 id=联合索引>联合索引<a hidden class=anchor aria-hidden=true href=#联合索引>#</a></h5><p>也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照<code>c2和c3列</code>的大小进行排序，这个包含两层含义：</p><ul><li><p>先把各个记录和页按照c2列进行排序。</p></li><li><p>在记录的c2列相同的情况下，采用c3列进行排序</p></li></ul><p>注意一点，以c2和c3列的大小为排序规则建立的B+树称为<code>联合索引</code>，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：</p><ul><li><p>建立<code>联合索引</code>只会建立如上图一样的1棵B+树。</p></li><li><p>为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。</p></li></ul><blockquote><ol><li>聚簇索引的叶子节点存储的是我们的数据记录，非聚簇索引存储的是数据位置。非聚簇索引不会影响数据表的物理存储顺序</li><li>一个表只能由一个聚餐索引，因为只能有一种排序存储的方式，但可以有多个非聚餐索引，多个索引目录提供数据检索</li><li>使用聚餐索引的时候，数据的查询效率高，但如果对数据进行插入、更新、删除等操作，效率会比非聚簇索引低</li></ol></blockquote><h5 id=innodb的b树注意事项>InnoDB的B+树注意事项<a hidden class=anchor aria-hidden=true href=#innodb的b树注意事项>#</a></h5><h6 id=1-根页面位置万年不动>1. 根页面位置万年不动<a hidden class=anchor aria-hidden=true href=#1-根页面位置万年不动>#</a></h6><p>真实创建B+树过程：</p><ul><li>每当为某个表创建一个B+树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个<code>根节点</code>页面。最开始表中没有数据的时候，每个B+树索引对应的<code>根节点</code>中既没有用户记录，也没有目录项记录。</li><li>随后向表中插入用户记录时，先把用户记录存储到这个<code>根节点</code>中。</li><li>当根节点中的可用<code>空间用完时</code>继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如<code>页a</code>中，然后对这个新页进行<code>页分裂</code>的操作，得到另一个新页，比如<code>页b</code>。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到<code>页a</code>或者<code>页b</code>中，而<code>根节点</code>便升级为存储目录项记录的页。</li></ul><p>这个过程特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是<code>InnoDB</code>存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。</p><h6 id=2-内节点中目录项记录的唯一性>2. 内节点中目录项记录的唯一性<a hidden class=anchor aria-hidden=true href=#2-内节点中目录项记录的唯一性>#</a></h6><p>道B+树索引的内节点中目录项记录的内容是<code>索引列+页号</code>的搭配，但是这个搭配对于二级索引来说有点不严谨。还拿<code>index_demo</code>表为例，假设这个表中的数据是这样的：</p><table><thead><tr><th>c1</th><th>c2</th><th>c3</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>&lsquo;u&rsquo;</td></tr><tr><td>3</td><td>1</td><td>&rsquo;d'</td></tr><tr><td>5</td><td>1</td><td>&lsquo;y&rsquo;</td></tr><tr><td>7</td><td>1</td><td>&lsquo;a&rsquo;</td></tr></tbody></table><p>如果二级索引中目录项的内容只是<code>索引号+页号</code>的搭配的话，那么为<code>c2</code>列建立索引后的B+树应该长这样：<img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230527194832595.png alt=image-20230527194832595></p><p>如果我们想要新插入一行记录，其中<code>c1</code>、<code>c2</code>、<code>c3</code>的值分别是：<code>9</code>、<code>1</code>、<code>c</code>，那么在修改这个为c2列建立的二级索引对应的B+树时便碰到了个大问题：由于<code>页3</code>中存储的目录项记录是由<code>c2列+页号</code>的值构成的，<code>页3</code>中的两条目录项记录对应的c2列的值都是<code>1</code>，那么我们这条新插入的记录到底应该放在<code>页4</code>中，还是应该放在<code>页5</code>中啊？答案是：对不起，懵了。</p><p>为了让新插入记录能找到自己在哪个页里，我们需要**保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的。**所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p><ul><li>索引列的值</li><li>主键值</li><li>页号</li></ul><p>也就是我们把主键值也添加到二级索引内节点中的目录项记录了，这样就能保证B+树每一层节点中各条目录项记录除页号这个字段外是唯一的，所以我们为c2列建立二级索引后的示意图实际上应该是这样子的：</p><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230527195001033.png alt=image-20230527195001033></p><p>这样我们再插入记录<code>(9, 1, 'c')</code>时，由于<code>页3</code>中存储的目录项记录是由<code>c2列+主键+页号</code>的值构成的，可以先把新记录的<code>c2</code>列的值和<code>页3</code>中各目录项记录的<code>c2</code>列的值作比较，如果<code>c2</code>列的值相同的话，可以接着比较主键值，因为B+树同一层中不同目录项记录的<code>c2列+主键</code>的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新记录应该被插入到<code>页5</code>中。</p><ol start=3><li><h6 id=一个页面最少存储2条记录>一个页面最少存储2条记录<a hidden class=anchor aria-hidden=true href=#一个页面最少存储2条记录>#</a></h6></li></ol><p>一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错！这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问的存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢？那就是目录层级非常非常非常多，而且最后的那个存放真实数据的目录中存放一条记录。费了半天劲只能存放一条真实的用户记录？所以<code>InnoDB的一个数据页至少可以存放两条记录</code></p><h2 id=myisam的索引方案>MyISAM的索引方案<a hidden class=anchor aria-hidden=true href=#myisam的索引方案>#</a></h2><p><strong>B树索引适用存储引擎如表所示：</strong></p><table><thead><tr><th>索引/存储引擎</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>B-Tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr></tbody></table><p>即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索引是Btree索引；<strong>而Memory默认的索引是Hash索引。</strong></p><p>MyISAM引擎使用<code>B+Tree</code>作为索引结构，叶子节点的data域存放的是<code>数据记录的地址</code>。</p><h3 id=myisam的原理>MyISAM的原理<a hidden class=anchor aria-hidden=true href=#myisam的原理>#</a></h3><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230527195158208.png alt=image-20230527195158208></p><h3 id=myisam-与-innodb对比>MyISAM** <strong>与</strong> InnoDB对比<a hidden class=anchor aria-hidden=true href=#myisam-与-innodb对比>#</a></h3><ol><li><p>在InnoDB存储引擎中，我们只需要根据主键值对<code>聚簇索引</code>进行一次查找就能找到对应的记录，而在<code>MyISAM</code>中却需要进行一次<code>回表</code>操作，意味着MyISAM中建立的索引相当于全部都是<code>二级索引</code>。</p></li><li><p>InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是<code>分离的</code>，索引文件仅保存数据记录的地址。</p></li><li><p>InnoDB的非聚簇索引data域存储相应记录<code>主键的值</code>，而MyISAM索引记录的是<code>地址</code>。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。</p></li><li><p>MyISAM的回表操作是十分<code>快速</code>的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。</p></li><li><p>InnoDB要求表<code>必须有主键</code>（<code>MyISAM可以没有</code>）。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。</p></li></ol><h3 id=索引代价>索引代价<a hidden class=anchor aria-hidden=true href=#索引代价>#</a></h3><ul><li><strong>空间上的代价</strong></li></ul><p>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用<code>16KB</code>的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。</p><ul><li><strong>时间上的代价</strong></li></ul><p>每次对表中的数据进行<code>增、删、改</code>操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每层节点都是按照索引列的值<code>从小到大的顺序排序</code>而组成了<code>双向链表</code>。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些<code>记录移位</code>，<code>页面分裂</code>、<code>页面回收</code>等操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。</p></div><div class=post-reward><div style=padding:0;margin:0;width:100%;font-size:16px;text-align:center><div id=QR style=opacity:0><div id=wechat style=display:inline-block><a class=fancybox rel=group><img id=wechat_qr src=https://AlfredNing.github.io alt=wechat_pay></a><p>微信</p></div><div id=alipay style=display:inline-block><a class=fancybox rel=group><img id=alipay_qr src=https://AlfredNing.github.io alt=alipay></a><p>支付宝</p></div></div><button id=rewardButton onclick='var qr=document.getElementById("QR");qr.style.opacity==="0"?qr.style.opacity="1":qr.style.opacity="0"'>
<span>🧧 鼓励</span></button></div></div><footer class=post-footer><nav class=paginav><a class=next href=https://AlfredNing.github.io/note/program/sql/distributed_database/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA/><span class=title>下一页 »</span><br><span>分布式数据库理论</span></a></nav></footer></div><div><div class=pagination__title><span class=pagination__title-h style=font-size:20px>💬评论</span><hr></div><div id=tcomment></div><script src=https://utteranc.es/client.js repo=AlfredNing/AlfredNing.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2023 <a href=https://AlfredNing.github.io>AlfredNing</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>