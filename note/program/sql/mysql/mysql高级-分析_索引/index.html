<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MySql高级 索引_集群 | AlfredNing</title><meta name=keywords content><meta name=description content="索引 索引的分类 从功能逻辑划分 普通索引 唯一索引 主键索引 全文索引 从物理实现方法划分 聚簇索引 非聚簇索引 从作用字段划分 单列索引 联合索引 InnoDB: 支持B-Tree，FullText索引，不支持Hash索引
MyISAM: 支持B-Tree，FullText索引，不支持Hash索引
Memory: 支持B-Tree，Hash索引，不支持FullText索引
NDB: 支持Hash索引，不支持 B-Tree, FullText索引
Archive: 不支持 B-Tree, FullText,Hash索引
创建索引 方式1- 创建表时候指定 普通索引 CREATE TABLE book( book_id INT , book_name VARCHAR(100), authors VARCHAR(100), info VARCHAR(100) , comment VARCHAR(100), year_publication YEAR, INDEX(year_publication) ); 创建唯一索引 CREATE TABLE test1( id INT NOT NULL, name varchar(30) NOT NULL, UNIQUE INDEX uk_idx_id(id) ); 主键索引 CREATE TABLE student ( id INT(10) UNSIGNED AUTO_INCREMENT, student_no VARCHAR(200), student_name VARCHAR(200), PRIMARY KEY(id) ); # 删除主键索引 ALTER TABLE student drop PRIMARY KEY ; 创建单列索引 CREATE TABLE test2( id INT NOT NULL, name CHAR(50) NULL, INDEX single_idx_name(name(20)) ); 创建组合索引 CREATE TABLE test3( id INT(11) NOT NULL, name CHAR(30) NOT NULL, age INT(11) NOT NULL, info VARCHAR(255), INDEX multi_idx(id,name,age) ); 全文索引 CREATE TABLE `papers` ( id` int(10) unsigned NOT NULL AUTO_INCREMENT, `title` varchar(200) DEFAULT NULL, `content` text, PRIMARY KEY (`id`), FULLTEXT KEY `title` (`title`,`content`) ) ENGINE=MyISAM DEFAULT CHARSET=utf8; SELECT * FROM papers WHERE MATCH(title,content) AGAINST (‘查询字符串’); 空间索引 CREATE TABLE test5( geo GEOMETRY NOT NULL, SPATIAL INDEX spa_idx_geo(geo) ) ENGINE=MyISAM; 方式2-已经创建表上的添加 alter 形式 ALTER TABLE table_name ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name[length],."><meta name=author content="AlfredNing"><link rel=canonical href=https://AlfredNing.github.io/note/program/sql/mysql/mysql%E9%AB%98%E7%BA%A7-%E5%88%86%E6%9E%90_%E7%B4%A2%E5%BC%95/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.27402031ac19c221a0356fba06f890a1a2bf8518669338f57cb7df4a3a1eabf9.css integrity="sha256-J0AgMawZwiGgNW+6BviQoaK/hRhmkzj1fLffSjoeq/k=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://AlfredNing.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://AlfredNing.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://AlfredNing.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://AlfredNing.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://AlfredNing.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="MySql高级 索引_集群"><meta property="og:description" content="索引 索引的分类 从功能逻辑划分 普通索引 唯一索引 主键索引 全文索引 从物理实现方法划分 聚簇索引 非聚簇索引 从作用字段划分 单列索引 联合索引 InnoDB: 支持B-Tree，FullText索引，不支持Hash索引
MyISAM: 支持B-Tree，FullText索引，不支持Hash索引
Memory: 支持B-Tree，Hash索引，不支持FullText索引
NDB: 支持Hash索引，不支持 B-Tree, FullText索引
Archive: 不支持 B-Tree, FullText,Hash索引
创建索引 方式1- 创建表时候指定 普通索引 CREATE TABLE book( book_id INT , book_name VARCHAR(100), authors VARCHAR(100), info VARCHAR(100) , comment VARCHAR(100), year_publication YEAR, INDEX(year_publication) ); 创建唯一索引 CREATE TABLE test1( id INT NOT NULL, name varchar(30) NOT NULL, UNIQUE INDEX uk_idx_id(id) ); 主键索引 CREATE TABLE student ( id INT(10) UNSIGNED AUTO_INCREMENT, student_no VARCHAR(200), student_name VARCHAR(200), PRIMARY KEY(id) ); # 删除主键索引 ALTER TABLE student drop PRIMARY KEY ; 创建单列索引 CREATE TABLE test2( id INT NOT NULL, name CHAR(50) NULL, INDEX single_idx_name(name(20)) ); 创建组合索引 CREATE TABLE test3( id INT(11) NOT NULL, name CHAR(30) NOT NULL, age INT(11) NOT NULL, info VARCHAR(255), INDEX multi_idx(id,name,age) ); 全文索引 CREATE TABLE `papers` ( id` int(10) unsigned NOT NULL AUTO_INCREMENT, `title` varchar(200) DEFAULT NULL, `content` text, PRIMARY KEY (`id`), FULLTEXT KEY `title` (`title`,`content`) ) ENGINE=MyISAM DEFAULT CHARSET=utf8; SELECT * FROM papers WHERE MATCH(title,content) AGAINST (‘查询字符串’); 空间索引 CREATE TABLE test5( geo GEOMETRY NOT NULL, SPATIAL INDEX spa_idx_geo(geo) ) ENGINE=MyISAM; 方式2-已经创建表上的添加 alter 形式 ALTER TABLE table_name ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name[length],."><meta property="og:type" content="article"><meta property="og:url" content="https://AlfredNing.github.io/note/program/sql/mysql/mysql%E9%AB%98%E7%BA%A7-%E5%88%86%E6%9E%90_%E7%B4%A2%E5%BC%95/"><meta property="article:section" content="note"><meta property="article:published_time" content="2023-06-04T11:20:59+08:00"><meta property="article:modified_time" content="2023-07-24T02:44:03+00:00"><meta property="og:site_name" content="Alfred.Ning"><meta name=twitter:card content="summary"><meta name=twitter:title content="MySql高级 索引_集群"><meta name=twitter:description content="索引 索引的分类 从功能逻辑划分 普通索引 唯一索引 主键索引 全文索引 从物理实现方法划分 聚簇索引 非聚簇索引 从作用字段划分 单列索引 联合索引 InnoDB: 支持B-Tree，FullText索引，不支持Hash索引
MyISAM: 支持B-Tree，FullText索引，不支持Hash索引
Memory: 支持B-Tree，Hash索引，不支持FullText索引
NDB: 支持Hash索引，不支持 B-Tree, FullText索引
Archive: 不支持 B-Tree, FullText,Hash索引
创建索引 方式1- 创建表时候指定 普通索引 CREATE TABLE book( book_id INT , book_name VARCHAR(100), authors VARCHAR(100), info VARCHAR(100) , comment VARCHAR(100), year_publication YEAR, INDEX(year_publication) ); 创建唯一索引 CREATE TABLE test1( id INT NOT NULL, name varchar(30) NOT NULL, UNIQUE INDEX uk_idx_id(id) ); 主键索引 CREATE TABLE student ( id INT(10) UNSIGNED AUTO_INCREMENT, student_no VARCHAR(200), student_name VARCHAR(200), PRIMARY KEY(id) ); # 删除主键索引 ALTER TABLE student drop PRIMARY KEY ; 创建单列索引 CREATE TABLE test2( id INT NOT NULL, name CHAR(50) NULL, INDEX single_idx_name(name(20)) ); 创建组合索引 CREATE TABLE test3( id INT(11) NOT NULL, name CHAR(30) NOT NULL, age INT(11) NOT NULL, info VARCHAR(255), INDEX multi_idx(id,name,age) ); 全文索引 CREATE TABLE `papers` ( id` int(10) unsigned NOT NULL AUTO_INCREMENT, `title` varchar(200) DEFAULT NULL, `content` text, PRIMARY KEY (`id`), FULLTEXT KEY `title` (`title`,`content`) ) ENGINE=MyISAM DEFAULT CHARSET=utf8; SELECT * FROM papers WHERE MATCH(title,content) AGAINST (‘查询字符串’); 空间索引 CREATE TABLE test5( geo GEOMETRY NOT NULL, SPATIAL INDEX spa_idx_geo(geo) ) ENGINE=MyISAM; 方式2-已经创建表上的添加 alter 形式 ALTER TABLE table_name ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name[length],."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"笔记","item":"https://AlfredNing.github.io/note/"},{"@type":"ListItem","position":3,"name":"编程","item":"https://AlfredNing.github.io/note/program/"},{"@type":"ListItem","position":4,"name":"MySql高级 索引_集群","item":"https://AlfredNing.github.io/note/program/sql/mysql/mysql%E9%AB%98%E7%BA%A7-%E5%88%86%E6%9E%90_%E7%B4%A2%E5%BC%95/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MySql高级 索引_集群","name":"MySql高级 索引_集群","description":"索引 索引的分类 从功能逻辑划分 普通索引 唯一索引 主键索引 全文索引 从物理实现方法划分 聚簇索引 非聚簇索引 从作用字段划分 单列索引 联合索引 InnoDB: 支持B-Tree，FullText索引，不支持Hash索引\nMyISAM: 支持B-Tree，FullText索引，不支持Hash索引\nMemory: 支持B-Tree，Hash索引，不支持FullText索引\nNDB: 支持Hash索引，不支持 B-Tree, FullText索引\nArchive: 不支持 B-Tree, FullText,Hash索引\n创建索引 方式1- 创建表时候指定 普通索引 CREATE TABLE book( book_id INT , book_name VARCHAR(100), authors VARCHAR(100), info VARCHAR(100) , comment VARCHAR(100), year_publication YEAR, INDEX(year_publication) ); 创建唯一索引 CREATE TABLE test1( id INT NOT NULL, name varchar(30) NOT NULL, UNIQUE INDEX uk_idx_id(id) ); 主键索引 CREATE TABLE student ( id INT(10) UNSIGNED AUTO_INCREMENT, student_no VARCHAR(200), student_name VARCHAR(200), PRIMARY KEY(id) ); # 删除主键索引 ALTER TABLE student drop PRIMARY KEY ; 创建单列索引 CREATE TABLE test2( id INT NOT NULL, name CHAR(50) NULL, INDEX single_idx_name(name(20)) ); 创建组合索引 CREATE TABLE test3( id INT(11) NOT NULL, name CHAR(30) NOT NULL, age INT(11) NOT NULL, info VARCHAR(255), INDEX multi_idx(id,name,age) ); 全文索引 CREATE TABLE `papers` ( id` int(10) unsigned NOT NULL AUTO_INCREMENT, `title` varchar(200) DEFAULT NULL, `content` text, PRIMARY KEY (`id`), FULLTEXT KEY `title` (`title`,`content`) ) ENGINE=MyISAM DEFAULT CHARSET=utf8; SELECT * FROM papers WHERE MATCH(title,content) AGAINST (‘查询字符串’); 空间索引 CREATE TABLE test5( geo GEOMETRY NOT NULL, SPATIAL INDEX spa_idx_geo(geo) ) ENGINE=MyISAM; 方式2-已经创建表上的添加 alter 形式 ALTER TABLE table_name ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name[length],.","keywords":[""],"articleBody":"索引 索引的分类 从功能逻辑划分 普通索引 唯一索引 主键索引 全文索引 从物理实现方法划分 聚簇索引 非聚簇索引 从作用字段划分 单列索引 联合索引 InnoDB: 支持B-Tree，FullText索引，不支持Hash索引\nMyISAM: 支持B-Tree，FullText索引，不支持Hash索引\nMemory: 支持B-Tree，Hash索引，不支持FullText索引\nNDB: 支持Hash索引，不支持 B-Tree, FullText索引\nArchive: 不支持 B-Tree, FullText,Hash索引\n创建索引 方式1- 创建表时候指定 普通索引 CREATE TABLE book( book_id INT , book_name VARCHAR(100), authors VARCHAR(100), info VARCHAR(100) , comment VARCHAR(100), year_publication YEAR, INDEX(year_publication) ); 创建唯一索引 CREATE TABLE test1( id INT NOT NULL, name varchar(30) NOT NULL, UNIQUE INDEX uk_idx_id(id) ); 主键索引 CREATE TABLE student ( id INT(10) UNSIGNED AUTO_INCREMENT, student_no VARCHAR(200), student_name VARCHAR(200), PRIMARY KEY(id) ); # 删除主键索引 ALTER TABLE student drop PRIMARY KEY ; 创建单列索引 CREATE TABLE test2( id INT NOT NULL, name CHAR(50) NULL, INDEX single_idx_name(name(20)) ); 创建组合索引 CREATE TABLE test3( id INT(11) NOT NULL, name CHAR(30) NOT NULL, age INT(11) NOT NULL, info VARCHAR(255), INDEX multi_idx(id,name,age) ); 全文索引 CREATE TABLE `papers` ( id` int(10) unsigned NOT NULL AUTO_INCREMENT, `title` varchar(200) DEFAULT NULL, `content` text, PRIMARY KEY (`id`), FULLTEXT KEY `title` (`title`,`content`) ) ENGINE=MyISAM DEFAULT CHARSET=utf8; SELECT * FROM papers WHERE MATCH(title,content) AGAINST (‘查询字符串’); 空间索引 CREATE TABLE test5( geo GEOMETRY NOT NULL, SPATIAL INDEX spa_idx_geo(geo) ) ENGINE=MyISAM; 方式2-已经创建表上的添加 alter 形式 ALTER TABLE table_name ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name[length],...) [ASC | DESC] create 形式 CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name ON table_name (col_name[length],...) [ASC | DESC] 删除索引-alter ALTER TABLE table_name DROP INDEX index_name; 删除索引-drop\nDROP INDEX index_name ON table_name; 添加Auto_Increment约束字段的唯一索引不能被删除\nMySQL8.0 - 新特性 降序索引 CREATE TABLE ts1(a int,b int,index idx_a_b(a,b desc)); 对InnoDB而言是支持的，Mysql之前是升序索引\n隐藏索引 -- 创建表时候指定 CREATE TABLE tablename( propname1 type1[CONSTRAINT1], propname2 type2[CONSTRAINT2], …… propnamen typen, INDEX [indexname](propname1 [(length)]) INVISIBLE ); -- 已经创建表的指定 CREATE INDEX indexname ON tablename(propname[(length)]) INVISIBLE; -- alter table 指定 ALTER TABLE tablename ADD INDEX indexname (propname [(length)]) INVISIBLE; -- 切换隐藏索引状态 ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; #切换成隐藏索引 ALTER TABLE tablename ALTER INDEX index_name VISIBLE; #切换成非隐藏索引 -- 是隐藏索引对查询优化器可见设置 -- 1. 查看优化器设置 select @@optimizer_switch set session optimizer_switch=\"use_invisible_indexes=on\" -- 开启 索引的设计原则 哪些情况适合创建索引 1. 字段的数值有唯一的限制 索引本身可以起到约束的作用，比如唯一索引、主键索引都可以起到唯一性约束的，因此在我们的数据表中，如果某个字段是唯一的，就可以直接创建唯一性索引，或者主键索引。这样可以更快速地通过该索引来确定某条记录\n业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba）\n说明：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的。\n2. 经常性作为where条件查询的字段 某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率\n3. 经常group by 和order by 的列 如果只是group by 或者order by单列字段，建立单列索引。\n如果既有group by 也有order by 建立联合索引\n4. UPDATE、DELETE 的 WHERE 条件列 对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。\n5. DISTINCT字段需要创建索引 有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。\n6. 多表创建索引注意事项 首先，连接表的数量尽量不要超过 3 张，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。\n其次，对 WHERE 条件创建索引，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。\n最后，对用于连接的字段创建索引，并且该字段在多张表中的类型必须一致。虽然这里能查询，但存在隐式转换，使用到了函数\n7. 使用列的类型小的创建索引 这里所说的类型大小指的就是该类型表示的数据范围的大小。\n数据类型越小，在查询时进行的比较操作越快 数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘I/O带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。 这个建议对于表的主键来说更加适用，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/O。\n8. 使用字符串前缀创建索引 计算公式\nselect count(distinct left(列名, 索引长度))/count(*) from table_name; --比值越接近1越好 -- 尝试 select count(distinct left(列名, 10))/count(*) as sub10 from table_name; select count(distinct left(列名, 15))/count(*) as sub15 from table_name; select count(distinct left(列名, 20))/count(*) as sub20 from table_name; select count(distinct left(列名, 25))/count(*) as sub25 from table_name; Alibaba《Java开发手册》\n【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。\n说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90% 以上\n索引类前缀对排序的影响 使用了索引列前缀的方式无法支持使用索引排序，只能使用文件排序，可能造成排序结果有偏差\n9. 区分度高(散列性高)的列适合作为索引 列的基数指的是某一列中不重复数据的个数，比方说某个列包含值2,5,8,2,5,8,2,5,8，虽然有9条记录，但该列的基数却是3。也就是说，**在记录行数一定的情况下，列的基数越大，该列中的值越分散；列的基数越小，该列中的值越集中。**这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列建立索引，为基数太小的列建立索引效果可能不好。\n可以使用公式select count(distinct a)/count(*) from t1计算区分度，越接近1越好，一般超过33%就算是比较高效的索引了。\n拓展：联合索引把区分度高（散列性高）的列放在前面。\n10. 使用最频繁的列放到联合索引的左侧 最左前缀匹配原则\n10. 在多个字段都要创建索引的情况下，联合索引优于单值索引 索引的数量限制 在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量不超过6个。原因：\n每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。 索引会影响INSERT、DELETE、UPDATE等语句的性能，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加MySQL优化器生成执行计划时间，降低查询性能。 不适合创建索引的情况 1. 在where,groupby orderby 使用不到的字段不需要创建 2. 数据量小的表不要使用索引 3. 有大量重复数据的列上不要创建索引 当数据重复度 大于10%，不需要创建索引\n4. 避免对经常更新的表创建过多的索引 频繁更新的字段不一定要创建索引 对经常更新的表避免创建过多的索引 5. 不建议用无序的值作为索引 身份证，uuid(索引比较时候转换为ASCII, 并且插入时可能造成页分裂，md5, hash，无序列长字符串)\n6. 删除不再使用或者使用很少的索引 7. 不要定义冗余或者重复的索引 冗余索引：联合索引含有的字段，有定义了单列索引\n重复索引\n性能分析工具 数据库优化步骤 查看系统参数 show [global | session] status like '参数名' 统计SQL的查询成本 SHOW STATUS LIKE 'last_query_cost'; 使用场景：它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。\nSQL 查询是一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论：\n位置决定效率。如果页就在数据库缓冲池中，那么效率是最高的，否则还需要从内存或者磁盘中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。 批量决定效率。如果我们从磁盘中对单一页进行随机读，那么效率是很低的（差不多10ms），而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。 所以说，遇到I/O并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是经常使用的数据就要尽量放到缓冲池中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。\n定位慢SQL 1. 开启慢查询日志参数 set global slow_query_log='ON'; # 查看 慢日志文件位置 show variables like `%slow_query_log%`; 2. 修改long_query_time阈值 # 该参数设置之后，仅对新连接的会话有效 set global long_query_time = 1; show global variables like '%long_query_time%'; # 对当前会话生效 set long_query_time=1; show variables like '%long_query_time%'; # 如果一直生效的话 该配置文件，重启 3. 查看慢查询数目 SHOW GLOBAL STATUS LIKE '%Slow_queries%'; 4. 慢查询日志分析工具 mysqldumpslow #得到返回记录集最多的10个SQL mysqldumpslow -s r -t 10 /var/lib/mysql/mysql-log.log #得到访问次数最多的10个SQL mysqldumpslow -s c -t 10 /var/lib/mysql/mysql-log.log #得到按照时间排序的前10条里面含有左连接的查询语句 mysqldumpslow -s t -t 10 -g \"left join\" /var/lib/mysql/mysql-log.log #另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况 mysqldumpslow -s r -t 10 /var/lib/mysql/mysql-log | more 5. 关闭慢查询日志 开发当中，如果不涉及调优尽量关闭\n永久关闭\n[mysqld] slow_query_log=OFF #或 [mysqld] #slow_query_log =OFF 重启服务器 临时关闭\nSET GLOBAL slow_query_log=off; 查看SQL执行成本 - profiling show variables like 'profiling'; #开启 set profiling = 'ON'; #查看 show profiles; show profile cpu,block io for query 2; profiling 常用参数\n日常开发注意点：\nconvert heap to MyISAM: 查询结果太大，内存不够，落盘 Creating tmp table: 创建临时表。先拷贝数据到临时表，用完后在删除临时表 Coping to tmp table on disk: 把内存中临时表复制到磁盘上 locked 如果在show profile诊断结果中出现了以上4条结果中的任何一条，则sql语句需要优化\n注意：show profile 命令将弃用，可以从information_schema中的profiling数据表进行查看\n分析查询语句 EXPLAIN EXPLAIN SELECT select_options #或者 DESCRIBE SELECT select_options EXPLAIN 语句输出的各个列的作用如下：\n列名 描述 id 在一个大的查询语句中每个SELECT关键字都对应一个唯一的id select_type SELECT关键字对应的那个查询的类型 table 表名 partitions 匹配的分区信息 type 针对单表的访问方法 possible_keys 可能用到的索引 key 实际上使用的索引 key_len 实际使用到的索引长度 ref 当使用索引列等值查询时，与索引列进行等值匹配的对象信息 rows 预估的需要读取的记录条数 filtered 某个表经过搜索条件过滤后剩余记录条数的百分比 Extra 一些额外的信息 Explain各列作用 1. table 记录查询时候的表名，MySQL规定EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，有时候不是真实的名字，可能是简称。排在前面的是驱动表，排在后面的是被驱动表\n2. id 在一个大的查询每个select 关键字对应一个id, 但并不是绝对。SQL优化器会帮我们优化。\nid如果相同，可以认为是一组，从上往下顺序执行 在所有组中，id值越大，优先级越高，越先执行 关注点：id号每个号码，表示一趟独立的查询,一个sql的查询趟数越少越好 3. select type MySQL为每一个SELECT关键字代表的小查询都定义了select_type属性。表示这小查询在大查询里面扮演着什么角色。\nselect type 描述 SIMPLE 简单的SELECT语句（不包括UNION操作或子查询操作） PRIMARY 查询中最外层的SELECT（如两表做UNION或者存在子查询的外层的表操作为PRIMARY，内层的操作为UNION） UNION UNION操作中，查询中处于内层的SELECT（内层的SELECT语句与外层的SELECT语句没有依赖关系） DEPENDENT UNION UNION操作中，查询中处于内层的SELECT（内层的SELECT语句与外层的SELECT语句有依赖关系） 相关子查询 UNION RESULT UNION操作的结果，id值通常为NULL SUBQUERY 子查询中首个SELECT（如果有多个子查询存在） DEPENDENT SUBQUERY 子查询中首个SELECT，但依赖于外层的表（如果有多个子查询存在） DERIVED 被驱动的SELECT子查询（子查询位于FROM子句） MATERIALIZED 被物化的子查询 UNCACHEABLE SUBQUERY 对于外层的主表，子查询不可被物化，每次都需要计算（耗时操作） UNCACHEABLE UNION UNION操作中，内层的不可被物化的子查询（类似于UNCACHEABLE SUBQUERY） 4. partitions 代表分区的命中情况，非分区表，该项为null\n5. type - 关键点 结果值从最好到最坏依次是： system \u003e const \u003e eq_ref \u003e ref \u003e fulltext \u003e ref_or_null \u003e index_merge \u003e unique_subquery \u003e index_subquery \u003e range \u003e index \u003e ALL\nSQL性能优化的目标：至少要达到 range级别，要求是ref级别，最好是consts级别。\n6. possible_keys和key possible_keys: 可能使用到的key, 并不是越多越好，需要筛选\nkey: 使用到的key\n7. key_len - 关键点 多数场景对于联合索引，使用到的索引长度。越大越好\n计算公式：\nvarchar(10)变长字段且允许NULL = 10 * ( character set： utf8=3,gbk=2,latin1=1)+1(NULL)+2(变长字段) varchar(10)变长字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+2(变长字段) char(10)固定字段且允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+1(NULL) char(10)固定字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1) 8. ref 当使用索引列等值查询时候，与索引列匹配的对象信息\n9. rows 需要读取的记录条数。该值越小越好\n10. filtered 某个表经过搜索条件后过滤剩下的记录条数百分比。越大越好\n对于单表查询来说，filtered值没有什么意义，但对于连接查询来说。驱动表对应执行计划的filtered值，它决定了被驱动表要执行的次数（rows * filtered)\n11. Extra 一些额外的信息，非常多。更准确的理解MySQL到底如何执行给定的查询语句\n类型 描述 distinct 在select部分使用了distinc关键字 Using index Condition 使用到了索引下推 Using where 表明使用了where过滤 Using join buffer 表明使用了连接缓存 impossible where where子句的值总是false，不能用来获取任何元组 no tables used 不带from字句的查询或者From dual查询。 使用not in()形式子查询或not exists运算符的连接查询，这种叫做反连接。即，一般连接查询是先查询内表，再查询外表，反连接就是先查询外表，再查询内表。 using filesort 排序时无法使用到索引时，就会出现这个。常见于order by和group by语句中 using index 查询时不需要回表查询，直接通过索引就可以获取查询的数据。 using_union 表示使用or连接各个使用索引的条件时，该信息表示从处理结果获取并集 using intersect 表示使用and的各个索引的条件时，该信息表示是从处理结果获取交集 using sort_union和using sort_intersection 与前面两个对应的类似，只是他们是出现在用and和or查询信息量大时，先查询主键，然后进行排序合并后，才能读取记录并返回。 using temporary 表示使用了临时表存储中间结果。临时表可以是内存临时表和磁盘临时表，执行计划中看不出来，需要查看status变量，used_tmp_table，used_tmp_disk_table才能看出来 filtered 使用explain extended时会出现这个列，5.7之后的版本默认就有这个字段，不需要使用explain extended了。这个字段表示存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例，注意是百分比，不是具体记录数 Using index:\n覆盖索引：根据索引查找，由于select字段在B+树叶子节点已经存在，直接使用索引查找。\n索引下推: 假设查询语句中含有类似like语句 根据索引查找到主键，主键在回表查找，匹配对应like字段，这种方式会产生随机IO。另外一种做法是在索引字段上进行like匹配，之后再次回表查询，使用到了索引下推。\n示例测试SQL数据\nExplain四种格式 传统格式 不加任何关键字信息\nJSON格式 explain format=JSON QUERY, 这里可以查看执行成本cost_info信息\nTree格式 TREE格式是8.0.16版本之后引入的新格式，主要根据查询的各个部分之间的关系和各部分的执行顺序来描述如何查询。\n可视化格式 借助WorkBench\nSHOW WARNINGS的使用 执行完Explain之后，可以使用SHOW WARNINGS,查看优化后执行的sql语句\n分析优化器执行计划 - Trace Trace是5.6追踪MySQL优化器执行过程\n# 开启 SET optimizer_trace=\"enabled=on\",end_markers_in_json=on; # 设置大小 set optimizer_trace_max_mem_size=1000000; # 使用 select * from student where id \u003c 10; select * from information_schema.optimizer_trace\\G 监控视图 sys schema -- 索引相关 #1. 查询冗余索引 select * from sys.schema_redundant_indexes; #2. 查询未使用过的索引 select * from sys.schema_unused_indexes; #3. 查询索引的使用情况 select index_name,rows_selected,rows_inserted,rows_updated,rows_deleted from sys.schema_index_statistics where table_schema='dbname' ; -- 表相关 # 1. 查询表的访问量 select table_schema,table_name,sum(io_read_requests+io_write_requests) as io from sys.schema_table_statistics group by table_schema,table_name order by io desc; # 2. 查询占用bufferpool较多的表 select object_schema,object_name,allocated,data from sys.innodb_buffer_stats_by_table order by allocated limit 10; # 3. 查看表的全表扫描情况 select * from sys.statements_with_full_table_scans where db='dbname'; -- 语句相关 #1. 监控SQL执行的频率 select db,exec_count,query from sys.statement_analysis order by exec_count desc; #2. 监控使用了排序的SQL select db,exec_count,first_seen,last_seen,query from sys.statements_with_sorting limit 1; #3. 监控使用了临时表或者磁盘临时表的SQL select db,exec_count,tmp_tables,tmp_disk_tables,query from sys.statement_analysis where tmp_tables\u003e0 or tmp_disk_tables \u003e0 order by (tmp_tables+tmp_disk_tables) desc; -- io相关 #1. 查看消耗磁盘IO的文件 select file,avg_read,avg_write,avg_read+avg_write as avg_io from sys.io_global_by_file_by_bytes order by avg_read limit 10; -- innodb相关 #1. 行锁阻塞情况 select * from sys.innodb_lock_waits; 索引优化与查询优化 物理查询优化： 索引、表连接 逻辑查询优化: 通过SQL等价变换提升查询效率，换一种写法 大多数情况下都（默认）采用B+树来构建索引。只是空间列类型的索引使用R-树，并且MEMORY表还支持hash索引。\n其实，用不用索引，最终都是优化器说了算。优化器是基于什么的优化器？基于cost开销(CostBaseOptimizer)，它不是基于规则(Rule-BasedOptimizer)，也不是基于语义。怎么样开销小就怎么来。另外，SQL语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。\n索引失效场景 任何时候都不是绝对的，基于成本分析\n全值匹配 按照索引进行匹配，不会失效\n最佳左前缀法则 - age建立索引 name建立索引 使用 EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age = 30 AND student.name = 'abcd';\t-- 只有索引age classid name 下面不会使用索引 但现在没有这样的索引，idx_age_classid_name的字段顺序是先找age，所以不符合，所以此时不能用索引 EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.classid = 1 AND student.name = 'abcd';\tEXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age = 30 AND student.name = 'abcd'; # 现在，删除idx_age和idx_age_classid，发现用到idx_age_classid_name，而key_len=5,即只用到age字段，int(4)+null(1) #因为索引完age后没有classid了，不能再查找到name 在MySQL建立联合索引时会遵守最佳左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。\n结论：MySQL可以为多个字段创建索引，一个索引可以包括16个字段。对于多列索引，**过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。**如果查询条件中没有使用这些字段中第1个字段时，多列（或联合）索引不会被使用。\n主键插入顺序 在定义表时，让主键auto_increment，否则，插入一条数据时可能会移动大量数据。 如，往 1 5 8 10 15 … 100 中插9，会放在8 10 中间，因为索引默认升序排列。那么10往后的数据都要挪动，页不够时又要放到下一页，每插一条数据都这样挪一次，开销很大 我们自定义的主键列id 拥有AUTO_INCREMENT 属性，在插入记录时存储引擎会自动为我们填入自增的主键值。这样的主键占用空间小，顺序写入，减少页分裂。\n计算、函数、类型转换(自动或手动)导致索引失效 ##### 例1：3 EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name LIKE 'abc%';\t#更好，能够使用上索引 # type=range 使用了索引中的排序 EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name,3) = 'abc';\t# left(text,num_chars):截取左侧n个字符 # type = all 全表的访问 # 该语句的执行过程：针对每一条数据，一个一个取出，先作用一遍函数，再拿函数结果与abc对比，用不上b+树 CREATE INDEX idx_name ON student(NAME); ##### 例2： CREATE INDEX idx_sno ON student(stuno); EXPLAIN SELECT SQL_NO_CACHE id,stuno,NAME FROM student WHERE stuno+1 = 900001; # type = all 需要做运算，无法直接用索引找值 EXPLAIN SELECT SQL_NO_CACHE id,stuno,NAME FROM student WHERE stuno = 900000; # type = ref 类型转换导致索引失效 # 未使用到索引 EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE NAME=123;\t# 这里使用了隐式转换 # 使用到索引 EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE NAME='123'; # name本身就是字符串类型 范围条件右边的列索引失效 -- 存在索引 age classId name 但是下面只会使用到 age classId EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age = 30 AND student.classId \u003e 20 AND student.name = 'abc';\t--改写 添加所以你 age name classId 使用到了索引 EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age = 30 AND student.name = 'abc' AND student.classId \u003e 20 ;\t创建的联合索引中，必须把涉及到范围的字段写在最后。 不等于(!= 或者\u003c\u003e)索引失效 -- 不等于(!= 或者\u003c\u003e)索引失效 CREATE INDEX idx_name ON student(NAME); EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name \u003c\u003e 'abc';\t# 索引失效 索引查的是等于 这里是* 结论：最好在设计表结构的时候将字段设置为not null约束，比如可以将int 默认值设置成0。 将字符类型设置为空字符串\n同理：在查询中not like 也无法使用到索引，导致全表扫描\nis null 可以使用索引 is not null 无法使用索引 is null : 触发索引\nlike以通配符%开头索引失效 # like以通配符%开头索引失效 EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE NAME LIKE 'ab%';\t# 可用索引 EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE NAME LIKE '%ab';\t# type = all 索引失效 页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。\nOR 前后存在非索引的列，索引失效 EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 10 OR classid = 100;\t# 未使用索引，索引+全表扫描-\u003e全表扫描 -- age是存在索引的，classId是没有索引的，导致全表all -- 给classId添加索引 此时type为 index_merge,key = idx_age,idx_cid 数据库和表的字符集统一使用utf8mb4 统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的字符集进行比较前需要进行转换会造成索引失效。\n总结：\n对于单利索引，进来选择对当前query过滤更好的索引 对于选择组合索引，对当前query过滤更好的索引字段顺序中，位置越靠前越好 在选择组合索引，尽量选择能够包含当前query的where字句中更多字段的索引 在选择组合索引，如果某个字段包含范围查询，尽量把这个字段放在索引次序的最后面 关联查询优化 外连接的关联条件中，两个关联字段的类型、字符集一定要保持一致，否则索引会失效。外连接查询优化器也会做驱动表与被驱动表的修改。\n结论1：对于内连接来说，查询优化器可以决定谁来作为驱动表，谁作为被驱动表出现\n结论2：对于内连接来讲，如果表的连接条件中只能有一个字段有索引，则有索引的字段所在的表会被作为被驱动表\n结论3：对于内连接来说，在两个表的连接条件都存在索引的情况下，会选择小表作为驱动表。小表驱动大表\n内连接优化器可以决定（被）驱动表。在只有一个表存在索引的情况下，会选择存在索引的表作为被驱动表(因为被驱动表查询次数更多，建立索引以后可以避免全表扫描)\nJOIN的底层原理 1. 驱动表与被驱动表 驱动表就是主表，被驱动表就是从表\n内连接，外连接优化器会根据优化结果选择先查询哪张表，这张表就是主表驱动表。\n2. Simple Nested Loop Join 简单嵌套循环连接 算法过程：从A表取出一条数据，遍历B表所有数据进行匹配。驱动表A每一条记录与B进行匹配\n效率非常低\n3. Index Nested Loop Join 索引嵌套循环 优化思路是减少内层表的数据匹配次数，所以要求对被驱动表建立索引。这样查询的转换成B+树的高度。通过外层表匹配条件直接与内层索引进行匹配，避免和内层表的每条记录进行比较，这样极大地减少了对内层表的匹配次数。 驱动表中的每条记录通过被驱动表的索引进行访问，因为索引查询的成本是比较固定的，故 MySQL 优化器都倾向于使用有索引的表作为被驱动表（减少被驱动表的多次全表扫描）\n如果被驱动表加索引，效率是非常高的，如果索引不是主键索引，所以还得进行一次回表查询。相比，被驱动表的索引是主键索引，效率会更高\n4. Blocked Nested Loop Join 块嵌套循环连接 如果存在索引，使用INLJ进行，如果join列没有索引，匹配的扫描次数又大大增加。每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把驱动表的记录再加载到内存匹配，这样周而复始，大大增加了 IO 次数。为了减少被驱动表的 IO 次数，就出现了 Block Nested-Loop Join 的方式。\n不再是逐条获取驱动表的数据，而是一块一块的获取，引入了 join buffer 缓冲区，将驱动表 join 相关的部分数据列（大小受 join buffer 的限制）缓存到 join buffer 中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和 join buffer 中的所有驱动表记录进行匹配（内存中操作），将简单嵌套循环中的多次比较合并成一次，降低了被动表的访问频率。\n注意： 这里缓存的不只是关联表的列，select 后面的列也会缓存起来 在一个有 N 个 join 关联的 SQL 中会分配 N-1 个 join buffer。所以查询的时候尽量减少不必要的字段，可以 让 join buffer 中存放更多的列。 Join Buffe参数设置\nblock_nested_loop\n通过 show variables like '%optimizer_switch%' 查看 block_nested_loop 状态。默认是开启的。\njoin_buffer_size\n驱动表能不能一次加载完，要看 join buffer 能不能存储所有的数据，默认情况下 join_buffer_size = 256K。\njoin buffer size 的最大值在 32 位系统可以申请 4G，而在 64 位操做系统下可以申请大于 4G 的 join_buffer空间（64 位 Windows 除外，其大值会被截断为 4GB并发出警告）。\n小结 保证被驱动表的 JOIN 字段已经创建了索引（减少内层表的循环匹配次数） 需要 JOIN 的字段，数据类型保持绝对一致。 LEFT JOIN 时，选择小表作为驱动表， 大表作为被驱动表 。减少外层循环的次数。 INNER JOIN 时，MySQL 会自动将小结果集的表选为驱动表 。选择相信 MySQL 优化策略。 能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数) 不建议使用多层嵌套子查询，建议将子查询 SQL 拆开结合程序多次查询，或使用 JOIN 来代替子查询。 衍生表建不了索引 默认效率比较：INLJ \u003e BNLJ \u003e SNLJ 正确理解小表驱动大表：大小不是指表中的记录数，而是永远用小结果集驱动大结果集（其本质就是减少外层循环的数据数量）。 比如A表有100条记录，B表有1000条记录，但是where条件过滤后，B表结果集只留下50个记录，A表结果集有80条记录，此时就可能是B表驱动A表。其实上面的例子还是不够准确，因为结果集的大小也不能粗略的用结果集的行数表示，而是表行数 每行大小。其实要理解你只需要结合Join Buffer就好了，因为表行数 每行大小越小，其占用内存越小,就可以在Join Buffer中尽量少的次数加载完了。 HashJoin 从 MySQL 8.0.20 版本开始将废弃 BNLJ，因为加入了 hash join 默认都会使用 hash join\nNested Loop：\n对于被连接的数据子集较小的情况，Nested Loop 是个较好的选择。\nHash Join 是做 大数据集连接 时的常用方法，优化器使用两个表中较小（相对较小）的表利用 join key 在内存中建立 散列表，然后扫描较大的表并探测散列表，找出与 Hash 表匹配的行。\n这种方式适用于较小的表完全可以放于内存中的情况，这样总成本就是访问两个表的成本之和 在表很大的情况下并不能完全放入内存，这时优化器会将它分割成 若干不同的分区，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高 I/O 的性能。 它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。大多数人都说它是 Join 的重型升降机。Hash Join 只能应用于等值连接（如 WHERE A.COL1 = B.COL2），这是由 Hash 的特点决定的。 类型 Nested Loop Hash Join 使用条件 任何条件 等值连接（=） 相关资源 CPU、磁盘 I/O 内存、临时空间 特点 当有高选择性索引或进行限制性搜索时效率比较高，能够快速返回第一次的搜索结果 当缺乏索引或者索引条件模糊时，Hash Join 比 Nested Loop 有效。在数据仓库环境下，如果表的记录数多，效率高 缺点 当索引丢失或者查询条件限制不够时，效率很低；当表的记录数较多，效率低 为遍历哈希表，需要大量内存。第一次的结果返回较慢 子查询优化 MySQL 从 4.1 版本开始支持子查询，使用子查询可以进行 SELECT 语句的嵌套查询，即一个 SELECT 查询的结果作为另一个 SELECT 语句的条件。子查询可以一次性完成很多逻辑上需要多个步骤才能完成的操作 。\n子查询是 MySQL 的一项重要的功能，可以帮助我们通过一个 SQL 语句实现比较复杂的查询。但是，子查询的执行效率不高。\n原因:\n执行子查询时，MySQL 需要为内层查询语句的查询结果建立一个临时表 ，然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表 。这样会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都 不会存在索引 ，所以查询性能会受到一定的影响。 对于返回结果集比较大的子查询，其对查询性能的影响也就越大。 在 MySQL 中，可以使用连接（JOIN）查询来替代子查询。 连接查询 不需要建立临时表，其 速度比子查询要快，如果查询中使用索引的话，性能就会更好。\n#创建班级表中班长的索引 CREATE INDEX idx_monitor ON class(monitor); #查询班长的信息 EXPLAIN SELECT * FROM student stu1 WHERE stu1.`stuno` IN ( SELECT monitor FROM class c WHERE monitor IS NOT NULL ); -- 改写 EXPLAIN SELECT stu1.* FROM student stu1 JOIN class c ON stu1.`stuno` = c.`monitor` WHERE c.`monitor` IS NOT NULL; #查询不为班长的学生信息 EXPLAIN SELECT SQL_NO_CACHE a.* FROM student a WHERE a.stuno NOT IN ( SELECT monitor FROM class b WHERE monitor IS NOT NULL); -- 改写 EXPLAIN SELECT SQL_NO_CACHE a.* FROM student a LEFT OUTER JOIN class b ON a.stuno =b.monitor WHERE b.monitor IS NULL; TIP：尽量不要使用 NOT IN 或者 NOT EXISTS，用 LEFT JOIN xxx ON xx WHERE xx IS NULL 替代\n排序优化 问题：在 WHERE 条件字段上加索引，但是为什么在 ORDER BY 字段上还要加索引呢？\n在 MySQL 中，支持两种排序方式，分别是 FileSort 和 Index 排序。 Index 排序中，索引可以保证数据的有序性，就不需要再进行排序，效率更更高。 FileSort 排序则一般在 内存中 进行排序，占用 CPU 较多。如果待排序的结果较大，会产生临时文件 I/O 到磁盘进行排序的情况，效率低。 优化建议:\nSQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中 避免全表扫描，在 ORDER BY 子句 避免使用 FileSort 排序。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。 尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列；如果不同就使用联合索引。 无法使用 Index 时，需要对 FileSort 方式进行调优。 -- 当前age classId,name 是有索引的 EXPLAIN SELECT SQL_NO_CACHE * FROM student ORDER BY age,classid; 1\tSIMPLE\tstudent\tALL\t498881\t100.00\tUsing filesort -- 没有使用索引的原因是，优化器通过计算分析，发现最终还是需要回表，使用索引的性能代价反而比不上不用索引的 EXPLAIN SELECT SQL_NO_CACHE age,classid,name,id FROM student ORDER BY age,classid; -- 这里就使用到了索引,覆盖索引 EXPLAIN SELECT SQL_NO_CACHE * FROM student ORDER BY age,classid LIMIT 10; -- 使用limit使用到了索引，因为优化器发现只需要10条，先根据索引查询，在回表返回10条数据 order by 时顺序错误，索引失效 order by 时规则不一致, 索引失效 （顺序错，不索引；方向反，不索引） 规则： 同时升序或者同时降序 顺序：索引建立的顺序 无过滤，不索引 上述是与其数据量有关的\nINDEX a_b_c(a,b,c) order by 能使用索引最左前缀\nORDER BY a ORDER BY a,b ORDER BY a,b,c ORDER BY a DESC,b DESC,c DESC 如果 WHERE 使用索引的最左前缀定义为常量，则 order by 能使用索引 WHERE a = const ORDER BY b,c WHERE a = const AND b = const ORDER BY c WHERE a = const ORDER BY b,c WHERE a = const AND b \u003e const ORDER BY b,c 不能使用索引进行排序\nORDER BY a ASC,b DESC,c DESC /* 排序不一致 */ WHERE g = const ORDER BY b,c /丢失a索引/ WHERE a = const ORDER BY c /丢失b索引/ WHERE a = const ORDER BY a,d /d不是索引的一部分/ WHERE a in (…) ORDER BY b,c /对于排序来说，多个相等条件也是范围查询 filesort算法 排序的字段不在索引列上，filesort会有两种算法: 双路排序和单路排序\n双路排序 - 慢\nMySQL4.1之前使用双路排序。两次扫描磁盘，最终得到数据。读取行指针和order by 列，然后从扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出。从磁盘读取字段，在buffer排序，在从磁盘读取其他字段，产生随机IO,比较耗时\n单路排序 - 块 从磁盘读取查询需要的 所有列 ，按照 order by 列在 buffer 对它们进行排序，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据。并且把随机 IO 变成了顺序 IO，但是它会使用更多的空间， 因为它把每一行都保存在内存中了。\n由于单路是后出的，总体而言好过双路 但是用单路有问题 在 sort_buffer 中，单路比多路要 多占用很多空间，因为单路是把所有字段都取出，所以可能取出的数据的总大小超出了 sort_buffer 的容量，导致每次只能取 sort_buffer 容量大小的数据，进行排序（创建 temp 文件，多路合并），排完再取 sort_buffer 容量大小，再排…从而多次I/O。 单路本来想省一次 I/O 操作，反而导致了大量的 I/O 操作，反而得不偿失。\n优化策略：\n提高 sort_buffer_size 提高max_length_for_sort_data SHOW VARIABLES LIKE ‘%max_length_for_sort_data%’; 但是如果设的太高，数据总容量超出 sort_buffer_size 的概率就增大，明显症状是高的磁盘 I/O 活动和低的处理器使用率。如果需要返回的列的总长度大于 max_length_for_sort_data，使用双路算法，否则使用单路算法。1024-8192字节之间调整。\nOrder by 时 select 是一个大忌。最好只Query需要的字段。\n当 Query 的字段大小综合小于 max_length_for_sort_data，而且排序字段不是 TEXT|BLOG 类型时，会改进后的算法——单路排序，否则用老算法——多路排序。 两种算法的数据都有可能超出 sort_buffer_size 的容量，超出之后，会创建 tmp 文件进行合并排序，导致多次 I/O，但是用单路排序算法的风险会更大一些，所以要提高 sort_buffer_size\nGroup By优化 group by 使用索引的原则几乎跟 order by 一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引。\ngroup by 先排序再分组，遵照索引建的最佳左前缀法则\n当无法使用索引列，增大 max_length_for_sort_data 和 sort_buffer_size 参数的设置\nwhere 效率高于 having，能写在 where 限定的条件就不要写在 having 中了\n减少使用 order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct 这些语句较为耗费 CPU，数据库的 CPU 资源是极其宝贵的\n包含了 order by、group by、distinct 这些查询的语句，where 条件过滤出来的结果集请保持在 1000 行以内，否则 SQL 会很慢\n分页查询优化 一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见有非常头疼的问题就是 limit 2000000,10，此时需要 MySQL 排序前 2000010 记录，仅仅返回 2000000-2000010 的记录，其他记录丢弃，查询排序的代价非常大。\nEXPLAIN SELECT * FROM student LIMIT 2000000,10; 优化思路1 该方案适用于主键自增的表，可以把 Limit 查询转换成某个位置的查询\nEXPLAIN SELECT * FROM student WHERE id \u003e 2000000 LIMIT 10; 优化思路2 在索引完成排序分页操作，最后根据主键关联到原表进行查询所需要的其它列内容\nEXPLAIN SELECT * FROM student t,(SELECT id FROM student order by id limit 2000000, 10) a where t.id = a.id 覆盖索引 覆盖索引的定义 索引列+主键 包含 SELECT 到 FROM 之间查询的列，不需要进行回表\n定义规则，再进行打破\n利弊 好处 避免InnoDB表进行回表 在覆盖索引中，二级索引的键值中可以获取所要的数据，避免了对主键的二次查询，减少了 IO 操作，提升了查询效率。 把随机IO变成顺序IO 由于覆盖索引是按键值的顺序存储的，对于 I/O 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 I/O 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 I/O 转变成索引查找的顺序 I/O。 由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。 弊端 索引字段的维护 总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务 DBA，或者称为业务数据架构师的工作。\n索引条件下推 需要回表，条件下推才有意义，如果是聚餐索引查询或者覆盖索引使用不到\n索引下推（Index Condition Pushdown, 简称ICP）是MySQL 5.6 版本的新特性，它能减少回表查询次数，提升检索效率。\n使用前后 在不使用ICP索引扫描的过程：\nstorage层：只将满足index key条件的索引记录对应的整行记录取出，返回给server层\nserver 层：对返回的数据，使用后面的where条件过滤，直至返回最后一行。\n使用ICP扫描的过程：\nstorage层：首先将index key条件满足的索引记录区间确定，然后在索引上使用index filter进行过滤。将满足的index filter条件的索引记录才去回表取出整行记录返回server层。不满足index filter条件的索引记录丢弃，不回表、也不会返回server层。\nserver 层：对返回的数据，使用table filter条件做最后的过滤。\n适用条件 当需要访问整表行时，ICP用于range、ref、eq_ref和ref_or_null访问方法。 ICP可以用于InnoDB和MyISAM表，包括分区的InnoDB和MyISAM表。 对于InnoDB表，ICP仅用于二级索引。ICP的目标是减少整行读取的数量，从而减少I/O操作。对于InnoDB聚集索引，完整的记录已经读入InnoDB缓冲区。在这种情况下使用ICP并不能减少I/O。（注意：Ⅰ说明减少完整记录（一条完整元组）读取的个数；Ⅱ是说明对于InnoDB聚集索引无效，只能是对SECOND INDEX这样的非聚集索引有效。） 在虚拟生成的列上创建的辅助索引不支持ICP。InnoDB支持虚拟生成列的二级索引。 引用子查询的条件不能向下推。 引用存储函数的条件不能向下推。存储引擎不能调用存储函数。 触发条件不能下推。 ICP的开启和关闭 索引条件默认启用“下推”。可以通过设置index_condition_pushdown标志来控制optimizer_switch系统变量: SET optimizer_switch = 'index_condition_pushdown=off'; SET optimizer_switch = 'index_condition_pushdown=on'; 其他查询优化策略 exists 与 in 区分 # 大表A驱动小表cc时用in；即当A表的数据量大于B表的数据量时 SELECT * FROM A WHERE cc IN (SELECT CC FROM B); # 当A表的数据量小于B表的数据量时 # 小表A驱动大表cc时用EXISTS ，因为执行时每次是从A中取一条数据到SELECT cc FROM B WHERE B.cc = a.cc中执行，A小一点更合适 SELECT * FROM A WHERE EXISTS (SELECT cc FROM B WHERE B.cc = a.cc) COUNT(*)与COUNT(具体字段)效率 COUNT(*)与COUNT(1)都是统计表的所有数量，效率差别不大 如果使用MyISAM存储引擎，统计数据表的行数只需要O(1)的复杂度 如果使用InnoDB存储引擎，使用O(n)的复杂度 在InnoDB存储引擎中，如果使用Count(具体字段)来统计数据行数，尽量采用二级索引，如果没有二级索引，才使用主键索引来使用 select 字段 在表查询中，建议明确字段，不要使用*作为查询的字段列表，推荐使用SELECT\u003c字段列表\u003e查询。原因： ①MySQL在解析的过程中，会通过查询数据字典将\"*\"按序转换成所有列名，这会大大的耗费资源和时间。 ②无法使用覆盖索引 limit 1 对优化的影响 针对的是会扫描全表的SQL语句，如果你可以确定结果集只有一条，那么加上LIMIT 1 的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。 如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上LIMIT 1 了。 多使用COMMIT 只要有可能，在程序中尽量多使用COMMIT，这样程序的性能得到提高，需求也会因为COMMIT所释放的资源而减少。 COMMIT所释放的资源： 回滚段上用于恢复数据的信息 被程序语句获得的锁 redo/ undo log buffer 中的空间 管理上述3种资源中的内部花费 淘宝数据库主键如何设计 自增ID问题 业务系统做主键 尽量不要用根业务有关的字段做主键，比较作为项目的设计人员，我们谁也无法预测在项目的整个生命周期中，哪个业务字段会因为业务的需求有重复，或者重用的情况出现。\n刚开始使用MySQL时候，很多人都很容易犯的错误喜欢用业务字段做主键，想当然的认为了解业务需求，但实际情况往往出乎意料，而更改主键设置的成本非常高\n淘宝的主键设计 订单ID = 时间 + 去重字段 + 用户ID后6位尾号\n推荐的主键设计 主键设计至少应该是全局唯一且是单调递增。 UUID SELECT uuid() FROM DUAL; 特点 全局唯一，占用36字节，数据无序，插入性能查\nMySQL UUID组成 UUID = 时间+UUID版本（16字节）- 时钟序列（4字节） - MAC地址（12字节）\n改造UUID MySQL 8.0可以更换时间低位和时间高位的存储方式，这样UUID就是有序的UUID了。 如果不是MySQL8.0 如何解决 手动赋值字段做主键\n","wordCount":"2321","inLanguage":"zh","datePublished":"2023-06-04T11:20:59+08:00","dateModified":"2023-07-24T02:44:03.587196342Z","author":[{"@type":"Person","name":"AlfredNing"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://AlfredNing.github.io/note/program/sql/mysql/mysql%E9%AB%98%E7%BA%A7-%E5%88%86%E6%9E%90_%E7%B4%A2%E5%BC%95/"},"publisher":{"@type":"Organization","name":"AlfredNing","logo":{"@type":"ImageObject","url":"https://AlfredNing.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://AlfredNing.github.io accesskey=h title="AlfredNing (Alt + H)">AlfredNing</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://AlfredNing.github.io/note/ title=📓笔记><span>📓笔记</span></a></li><li><a href=https://AlfredNing.github.io/thinking/ title=🤔黑洞><span>🤔黑洞</span></a></li><li><a href=https://AlfredNing.github.io/search/ title="🔎搜索 (Alt + /)" accesskey=/><span>🔎搜索</span></a></li><li><a href=https://AlfredNing.github.io/tags/ title=🏷️标签><span>🏷️标签</span></a></li><li><a href=https://AlfredNing.github.io/archives title=🗄️归档><span>🗄️归档</span></a></li><li><a href=https://AlfredNing.github.io/about title=🤙关于><span>🤙关于</span></a></li></ul></nav></header><main class="main page"><article class=post-single><div id=single-content><header class=post-header><div class=breadcrumbs><a href=https://AlfredNing.github.io>主页</a>&nbsp;»&nbsp;<a href=https://AlfredNing.github.io/note/>笔记</a>&nbsp;»&nbsp;<a href=https://AlfredNing.github.io/note/program/>编程</a></div><h1 class=post-title>MySql高级 索引_集群</h1><div class=post-meta>创建:&nbsp;<span title='2023-06-04 11:20:59 +0800 +0800'>2023年-06月-04日</span>&nbsp;|&nbsp;更新:&nbsp;2023年-07月-24日&nbsp;|&nbsp;字数:&nbsp;2321字&nbsp;|&nbsp;时长:&nbsp;11分钟&nbsp;|&nbsp;AlfredNing
&nbsp;|&nbsp;标签: &nbsp;<ul class=post-tags-meta><a href=https://AlfredNing.github.io/tags/mysql/>MySQL</a></ul></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e7%b4%a2%e5%bc%95 aria-label=索引>索引</a><ul><li><a href=#%e7%b4%a2%e5%bc%95%e7%9a%84%e5%88%86%e7%b1%bb aria-label=索引的分类>索引的分类</a></li><li><a href=#%e5%88%9b%e5%bb%ba%e7%b4%a2%e5%bc%95 aria-label=创建索引>创建索引</a><ul><li><a href=#%e6%96%b9%e5%bc%8f1--%e5%88%9b%e5%bb%ba%e8%a1%a8%e6%97%b6%e5%80%99%e6%8c%87%e5%ae%9a aria-label="方式1- 创建表时候指定">方式1- 创建表时候指定</a></li><li><a href=#%e6%96%b9%e5%bc%8f2-%e5%b7%b2%e7%bb%8f%e5%88%9b%e5%bb%ba%e8%a1%a8%e4%b8%8a%e7%9a%84%e6%b7%bb%e5%8a%a0 aria-label=方式2-已经创建表上的添加>方式2-已经创建表上的添加</a></li><li><a href=#%e5%88%a0%e9%99%a4%e7%b4%a2%e5%bc%95-alter aria-label=删除索引-alter>删除索引-alter</a></li></ul></li><li><a href=#mysql80---%e6%96%b0%e7%89%b9%e6%80%a7 aria-label="MySQL8.0 - 新特性">MySQL8.0 - 新特性</a><ul><li><a href=#%e9%99%8d%e5%ba%8f%e7%b4%a2%e5%bc%95 aria-label=降序索引>降序索引</a></li><li><a href=#%e9%9a%90%e8%97%8f%e7%b4%a2%e5%bc%95 aria-label=隐藏索引>隐藏索引</a></li></ul></li><li><a href=#%e7%b4%a2%e5%bc%95%e7%9a%84%e8%ae%be%e8%ae%a1%e5%8e%9f%e5%88%99 aria-label=索引的设计原则>索引的设计原则</a><ul><li><a href=#%e5%93%aa%e4%ba%9b%e6%83%85%e5%86%b5%e9%80%82%e5%90%88%e5%88%9b%e5%bb%ba%e7%b4%a2%e5%bc%95 aria-label=哪些情况适合创建索引>哪些情况适合创建索引</a><ul><li><a href=#1-%e5%ad%97%e6%ae%b5%e7%9a%84%e6%95%b0%e5%80%bc%e6%9c%89%e5%94%af%e4%b8%80%e7%9a%84%e9%99%90%e5%88%b6 aria-label="1. 字段的数值有唯一的限制">1. 字段的数值有唯一的限制</a></li><li><a href=#2-%e7%bb%8f%e5%b8%b8%e6%80%a7%e4%bd%9c%e4%b8%bawhere%e6%9d%a1%e4%bb%b6%e6%9f%a5%e8%af%a2%e7%9a%84%e5%ad%97%e6%ae%b5 aria-label="2. 经常性作为where条件查询的字段">2. 经常性作为where条件查询的字段</a></li><li><a href=#3-%e7%bb%8f%e5%b8%b8group-by-%e5%92%8corder-by-%e7%9a%84%e5%88%97 aria-label="3. 经常group by 和order by 的列">3. 经常group by 和order by 的列</a></li><li><a href=#4-updatedelete-%e7%9a%84-where-%e6%9d%a1%e4%bb%b6%e5%88%97 aria-label="4. UPDATE、DELETE 的 WHERE 条件列">4. UPDATE、DELETE <strong>的</strong> <strong>WHERE</strong> <strong>条件列</strong></a></li><li><a href=#5-distinct%e5%ad%97%e6%ae%b5%e9%9c%80%e8%a6%81%e5%88%9b%e5%bb%ba%e7%b4%a2%e5%bc%95 aria-label="5. DISTINCT字段需要创建索引">5. DISTINCT字段需要创建索引</a></li><li><a href=#6-%e5%a4%9a%e8%a1%a8%e5%88%9b%e5%bb%ba%e7%b4%a2%e5%bc%95%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9 aria-label="6. 多表创建索引注意事项">6. 多表创建索引注意事项</a></li><li><a href=#7-%e4%bd%bf%e7%94%a8%e5%88%97%e7%9a%84%e7%b1%bb%e5%9e%8b%e5%b0%8f%e7%9a%84%e5%88%9b%e5%bb%ba%e7%b4%a2%e5%bc%95 aria-label="7. 使用列的类型小的创建索引">7. 使用列的类型小的创建索引</a></li><li><a href=#8-%e4%bd%bf%e7%94%a8%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%89%8d%e7%bc%80%e5%88%9b%e5%bb%ba%e7%b4%a2%e5%bc%95 aria-label="8. 使用字符串前缀创建索引">8. 使用字符串前缀创建索引</a><ul><ul><li><a href=#%e7%b4%a2%e5%bc%95%e7%b1%bb%e5%89%8d%e7%bc%80%e5%af%b9%e6%8e%92%e5%ba%8f%e7%9a%84%e5%bd%b1%e5%93%8d aria-label=索引类前缀对排序的影响>索引类前缀对排序的影响</a></li></ul></ul></li><li><a href=#9-%e5%8c%ba%e5%88%86%e5%ba%a6%e9%ab%98%e6%95%a3%e5%88%97%e6%80%a7%e9%ab%98%e7%9a%84%e5%88%97%e9%80%82%e5%90%88%e4%bd%9c%e4%b8%ba%e7%b4%a2%e5%bc%95 aria-label="9. 区分度高(散列性高)的列适合作为索引">9. 区分度高(散列性高)的列适合作为索引</a></li><li><a href=#10-%e4%bd%bf%e7%94%a8%e6%9c%80%e9%a2%91%e7%b9%81%e7%9a%84%e5%88%97%e6%94%be%e5%88%b0%e8%81%94%e5%90%88%e7%b4%a2%e5%bc%95%e7%9a%84%e5%b7%a6%e4%be%a7 aria-label="10. 使用最频繁的列放到联合索引的左侧">10. 使用最频繁的列放到联合索引的左侧</a></li><li><a href=#10-%e5%9c%a8%e5%a4%9a%e4%b8%aa%e5%ad%97%e6%ae%b5%e9%83%bd%e8%a6%81%e5%88%9b%e5%bb%ba%e7%b4%a2%e5%bc%95%e7%9a%84%e6%83%85%e5%86%b5%e4%b8%8b%e8%81%94%e5%90%88%e7%b4%a2%e5%bc%95%e4%bc%98%e4%ba%8e%e5%8d%95%e5%80%bc%e7%b4%a2%e5%bc%95 aria-label="10. 在多个字段都要创建索引的情况下，联合索引优于单值索引">10. 在多个字段都要创建索引的情况下，联合索引优于单值索引</a></li></ul></li><li><a href=#%e7%b4%a2%e5%bc%95%e7%9a%84%e6%95%b0%e9%87%8f%e9%99%90%e5%88%b6 aria-label=索引的数量限制>索引的数量限制</a></li><li><a href=#%e4%b8%8d%e9%80%82%e5%90%88%e5%88%9b%e5%bb%ba%e7%b4%a2%e5%bc%95%e7%9a%84%e6%83%85%e5%86%b5 aria-label=不适合创建索引的情况>不适合创建索引的情况</a><ul><li><a href=#1-%e5%9c%a8wheregroupby-orderby-%e4%bd%bf%e7%94%a8%e4%b8%8d%e5%88%b0%e7%9a%84%e5%ad%97%e6%ae%b5%e4%b8%8d%e9%9c%80%e8%a6%81%e5%88%9b%e5%bb%ba aria-label="1. 在where,groupby orderby 使用不到的字段不需要创建">1. 在where,groupby orderby 使用不到的字段不需要创建</a></li><li><a href=#2-%e6%95%b0%e6%8d%ae%e9%87%8f%e5%b0%8f%e7%9a%84%e8%a1%a8%e4%b8%8d%e8%a6%81%e4%bd%bf%e7%94%a8%e7%b4%a2%e5%bc%95 aria-label="2. 数据量小的表不要使用索引">2. 数据量小的表不要使用索引</a></li><li><a href=#3-%e6%9c%89%e5%a4%a7%e9%87%8f%e9%87%8d%e5%a4%8d%e6%95%b0%e6%8d%ae%e7%9a%84%e5%88%97%e4%b8%8a%e4%b8%8d%e8%a6%81%e5%88%9b%e5%bb%ba%e7%b4%a2%e5%bc%95 aria-label="3. 有大量重复数据的列上不要创建索引">3. 有大量重复数据的列上不要创建索引</a></li><li><a href=#4-%e9%81%bf%e5%85%8d%e5%af%b9%e7%bb%8f%e5%b8%b8%e6%9b%b4%e6%96%b0%e7%9a%84%e8%a1%a8%e5%88%9b%e5%bb%ba%e8%bf%87%e5%a4%9a%e7%9a%84%e7%b4%a2%e5%bc%95 aria-label="4. 避免对经常更新的表创建过多的索引">4. 避免对经常更新的表创建过多的索引</a></li><li><a href=#5-%e4%b8%8d%e5%bb%ba%e8%ae%ae%e7%94%a8%e6%97%a0%e5%ba%8f%e7%9a%84%e5%80%bc%e4%bd%9c%e4%b8%ba%e7%b4%a2%e5%bc%95 aria-label="5. 不建议用无序的值作为索引">5. 不建议用无序的值作为索引</a></li><li><a href=#6-%e5%88%a0%e9%99%a4%e4%b8%8d%e5%86%8d%e4%bd%bf%e7%94%a8%e6%88%96%e8%80%85%e4%bd%bf%e7%94%a8%e5%be%88%e5%b0%91%e7%9a%84%e7%b4%a2%e5%bc%95 aria-label="6. 删除不再使用或者使用很少的索引">6. 删除不再使用或者使用很少的索引</a></li><li><a href=#7-%e4%b8%8d%e8%a6%81%e5%ae%9a%e4%b9%89%e5%86%97%e4%bd%99%e6%88%96%e8%80%85%e9%87%8d%e5%a4%8d%e7%9a%84%e7%b4%a2%e5%bc%95 aria-label="7. 不要定义冗余或者重复的索引">7. 不要定义冗余或者重复的索引</a></li></ul></li></ul></li></ul></li><li><a href=#%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90%e5%b7%a5%e5%85%b7 aria-label=性能分析工具>性能分析工具</a><ul><li><a href=#%e6%95%b0%e6%8d%ae%e5%ba%93%e4%bc%98%e5%8c%96%e6%ad%a5%e9%aa%a4 aria-label=数据库优化步骤>数据库优化步骤</a></li><li><a href=#%e6%9f%a5%e7%9c%8b%e7%b3%bb%e7%bb%9f%e5%8f%82%e6%95%b0 aria-label=查看系统参数>查看系统参数</a><ul><li><a href=#%e7%bb%9f%e8%ae%a1sql%e7%9a%84%e6%9f%a5%e8%af%a2%e6%88%90%e6%9c%ac aria-label=统计SQL的查询成本>统计SQL的查询成本</a></li></ul></li><li><a href=#%e5%ae%9a%e4%bd%8d%e6%85%a2sql aria-label=定位慢SQL>定位慢SQL</a><ul><li><a href=#1-%e5%bc%80%e5%90%af%e6%85%a2%e6%9f%a5%e8%af%a2%e6%97%a5%e5%bf%97%e5%8f%82%e6%95%b0 aria-label="1. 开启慢查询日志参数">1. 开启慢查询日志参数</a></li><li><a href=#2-%e4%bf%ae%e6%94%b9long_query_time%e9%98%88%e5%80%bc aria-label="2. 修改long_query_time阈值">2. 修改long_query_time阈值</a></li><li><a href=#3-%e6%9f%a5%e7%9c%8b%e6%85%a2%e6%9f%a5%e8%af%a2%e6%95%b0%e7%9b%ae aria-label="3. 查看慢查询数目">3. 查看慢查询数目</a></li><li><a href=#4-%e6%85%a2%e6%9f%a5%e8%af%a2%e6%97%a5%e5%bf%97%e5%88%86%e6%9e%90%e5%b7%a5%e5%85%b7--mysqldumpslow aria-label="4. 慢查询日志分析工具  mysqldumpslow">4. 慢查询日志分析工具 mysqldumpslow</a></li><li><a href=#5-%e5%85%b3%e9%97%ad%e6%85%a2%e6%9f%a5%e8%af%a2%e6%97%a5%e5%bf%97 aria-label="5. 关闭慢查询日志">5. 关闭慢查询日志</a></li></ul></li><li><a href=#%e6%9f%a5%e7%9c%8bsql%e6%89%a7%e8%a1%8c%e6%88%90%e6%9c%ac----profiling aria-label="查看SQL执行成本  - profiling">查看SQL执行成本 - profiling</a></li><li><a href=#%e5%88%86%e6%9e%90%e6%9f%a5%e8%af%a2%e8%af%ad%e5%8f%a5--explain aria-label="分析查询语句  EXPLAIN">分析查询语句 EXPLAIN</a><ul><li><a href=#explain%e5%90%84%e5%88%97%e4%bd%9c%e7%94%a8 aria-label=Explain各列作用>Explain各列作用</a><ul><li><a href=#1-table aria-label="1. table">1. table</a></li><li><a href=#2-id aria-label="2. id">2. id</a></li><li><a href=#3-select-type aria-label="3. select type">3. select type</a></li><li><a href=#4-partitions aria-label="4. partitions">4. partitions</a></li><li><a href=#5-type---%e5%85%b3%e9%94%ae%e7%82%b9 aria-label="5. type - 关键点">5. type - 关键点</a></li><li><a href=#6-possible_keys%e5%92%8ckey aria-label="6. possible_keys和key">6. possible_keys和key</a></li><li><a href=#7-key_len---%e5%85%b3%e9%94%ae%e7%82%b9 aria-label="7. key_len - 关键点">7. key_len - 关键点</a></li><li><a href=#8-ref aria-label="8. ref">8. ref</a></li><li><a href=#9-rows aria-label="9. rows">9. rows</a></li><li><a href=#10-filtered aria-label="10. filtered">10. filtered</a></li><li><a href=#11-extra aria-label="11. Extra">11. Extra</a></li></ul></li><li><a href=#explain%e5%9b%9b%e7%a7%8d%e6%a0%bc%e5%bc%8f aria-label=Explain四种格式>Explain四种格式</a><ul><li><a href=#%e4%bc%a0%e7%bb%9f%e6%a0%bc%e5%bc%8f aria-label=传统格式>传统格式</a></li><li><a href=#json%e6%a0%bc%e5%bc%8f aria-label=JSON格式>JSON格式</a></li><li><a href=#tree%e6%a0%bc%e5%bc%8f aria-label=Tree格式>Tree格式</a></li><li><a href=#%e5%8f%af%e8%a7%86%e5%8c%96%e6%a0%bc%e5%bc%8f aria-label=可视化格式>可视化格式</a></li></ul></li><li><a href=#show--warnings%e7%9a%84%e4%bd%bf%e7%94%a8 aria-label="SHOW  WARNINGS的使用">SHOW WARNINGS的使用</a></li></ul></li><li><a href=#%e5%88%86%e6%9e%90%e4%bc%98%e5%8c%96%e5%99%a8%e6%89%a7%e8%a1%8c%e8%ae%a1%e5%88%92----trace aria-label="分析优化器执行计划  - Trace">分析优化器执行计划 - Trace</a></li><li><a href=#%e7%9b%91%e6%8e%a7%e8%a7%86%e5%9b%be---sys-schema aria-label="监控视图   sys schema">监控视图 sys schema</a></li></ul></li><li><a href=#%e7%b4%a2%e5%bc%95%e4%bc%98%e5%8c%96%e4%b8%8e%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96 aria-label=索引优化与查询优化>索引优化与查询优化</a><ul><li><a href=#%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88%e5%9c%ba%e6%99%af aria-label=索引失效场景>索引失效场景</a><ul><li><a href=#%e5%85%a8%e5%80%bc%e5%8c%b9%e9%85%8d aria-label=全值匹配>全值匹配</a></li><li><a href=#%e6%9c%80%e4%bd%b3%e5%b7%a6%e5%89%8d%e7%bc%80%e6%b3%95%e5%88%99 aria-label=最佳左前缀法则>最佳左前缀法则</a></li><li><a href=#%e4%b8%bb%e9%94%ae%e6%8f%92%e5%85%a5%e9%a1%ba%e5%ba%8f aria-label=主键插入顺序>主键插入顺序</a></li><li><a href=#%e8%ae%a1%e7%ae%97%e5%87%bd%e6%95%b0%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2%e8%87%aa%e5%8a%a8%e6%88%96%e6%89%8b%e5%8a%a8%e5%af%bc%e8%87%b4%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88 aria-label=计算、函数、类型转换(自动或手动)导致索引失效>计算、函数、类型转换(自动或手动)导致索引失效</a></li><li><a href=#%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2%e5%af%bc%e8%87%b4%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88 aria-label=类型转换导致索引失效>类型转换导致索引失效</a></li><li><a href=#%e8%8c%83%e5%9b%b4%e6%9d%a1%e4%bb%b6%e5%8f%b3%e8%be%b9%e7%9a%84%e5%88%97%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88 aria-label=范围条件右边的列索引失效>范围条件右边的列索引失效</a></li><li><a href=#%e4%b8%8d%e7%ad%89%e4%ba%8e-%e6%88%96%e8%80%85%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88 aria-label="不等于(!= 或者&amp;lt;&amp;gt;)索引失效">不等于(!= 或者&lt;>)索引失效</a></li><li><a href=#is-null-%e5%8f%af%e4%bb%a5%e4%bd%bf%e7%94%a8%e7%b4%a2%e5%bc%95-is-not-null-%e6%97%a0%e6%b3%95%e4%bd%bf%e7%94%a8%e7%b4%a2%e5%bc%95 aria-label="is null 可以使用索引 is not null 无法使用索引">is null 可以使用索引 is not null 无法使用索引</a></li><li><a href=#like%e4%bb%a5%e9%80%9a%e9%85%8d%e7%ac%a6%e5%bc%80%e5%a4%b4%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88 aria-label=like以通配符%开头索引失效>like以通配符%开头索引失效</a></li><li><a href=#or-%e5%89%8d%e5%90%8e%e5%ad%98%e5%9c%a8%e9%9d%9e%e7%b4%a2%e5%bc%95%e7%9a%84%e5%88%97%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88 aria-label="OR 前后存在非索引的列，索引失效">OR 前后存在非索引的列，索引失效</a></li><li><a href=#%e6%95%b0%e6%8d%ae%e5%ba%93%e5%92%8c%e8%a1%a8%e7%9a%84%e5%ad%97%e7%ac%a6%e9%9b%86%e7%bb%9f%e4%b8%80%e4%bd%bf%e7%94%a8utf8mb4 aria-label=数据库和表的字符集统一使用utf8mb4>数据库和表的字符集统一使用utf8mb4</a></li></ul></li><li><a href=#%e5%85%b3%e8%81%94%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96 aria-label=关联查询优化>关联查询优化</a></li><li><a href=#join%e7%9a%84%e5%ba%95%e5%b1%82%e5%8e%9f%e7%90%86 aria-label=JOIN的底层原理>JOIN的底层原理</a><ul><li><a href=#1-%e9%a9%b1%e5%8a%a8%e8%a1%a8%e4%b8%8e%e8%a2%ab%e9%a9%b1%e5%8a%a8%e8%a1%a8 aria-label="1. 驱动表与被驱动表">1. 驱动表与被驱动表</a></li><li><a href=#2-simple-nested-loop-join-%e7%ae%80%e5%8d%95%e5%b5%8c%e5%a5%97%e5%be%aa%e7%8e%af%e8%bf%9e%e6%8e%a5 aria-label="2. Simple Nested Loop Join 简单嵌套循环连接">2. Simple Nested Loop Join 简单嵌套循环连接</a></li><li><a href=#3-index-nested-loop-join-%e7%b4%a2%e5%bc%95%e5%b5%8c%e5%a5%97%e5%be%aa%e7%8e%af aria-label="3. Index Nested Loop Join 索引嵌套循环">3. Index Nested Loop Join 索引嵌套循环</a></li><li><a href=#4-blocked-nested-loop-join-%e5%9d%97%e5%b5%8c%e5%a5%97%e5%be%aa%e7%8e%af%e8%bf%9e%e6%8e%a5 aria-label="4. Blocked Nested Loop Join 块嵌套循环连接">4. Blocked Nested Loop Join 块嵌套循环连接</a></li><li><a href=#%e5%b0%8f%e7%bb%93 aria-label=小结>小结</a></li><li><a href=#hashjoin aria-label=HashJoin>HashJoin</a></li></ul></li><li><a href=#%e5%ad%90%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96 aria-label=子查询优化>子查询优化</a></li><li><a href=#%e6%8e%92%e5%ba%8f%e4%bc%98%e5%8c%96 aria-label=排序优化>排序优化</a><ul><li><a href=#filesort%e7%ae%97%e6%b3%95 aria-label=filesort算法>filesort算法</a></li></ul></li><li><a href=#group-by%e4%bc%98%e5%8c%96 aria-label="Group By优化">Group By优化</a></li><li><a href=#%e5%88%86%e9%a1%b5%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96 aria-label=分页查询优化>分页查询优化</a><ul><li><a href=#%e4%bc%98%e5%8c%96%e6%80%9d%e8%b7%af1 aria-label=优化思路1>优化思路1</a></li><li><a href=#%e4%bc%98%e5%8c%96%e6%80%9d%e8%b7%af2 aria-label=优化思路2>优化思路2</a></li></ul></li><li><a href=#%e8%a6%86%e7%9b%96%e7%b4%a2%e5%bc%95 aria-label=覆盖索引>覆盖索引</a><ul><li><a href=#%e8%a6%86%e7%9b%96%e7%b4%a2%e5%bc%95%e7%9a%84%e5%ae%9a%e4%b9%89 aria-label=覆盖索引的定义>覆盖索引的定义</a></li><li><a href=#%e5%88%a9%e5%bc%8a aria-label=利弊>利弊</a><ul><li><a href=#%e5%a5%bd%e5%a4%84 aria-label=好处>好处</a></li><li><a href=#%e5%bc%8a%e7%ab%af aria-label=弊端>弊端</a></li></ul></li></ul></li><li><a href=#%e7%b4%a2%e5%bc%95%e6%9d%a1%e4%bb%b6%e4%b8%8b%e6%8e%a8 aria-label=索引条件下推>索引条件下推</a><ul><li><a href=#%e4%bd%bf%e7%94%a8%e5%89%8d%e5%90%8e aria-label=使用前后>使用前后</a></li><li><a href=#%e9%80%82%e7%94%a8%e6%9d%a1%e4%bb%b6 aria-label=适用条件>适用条件</a></li><li><a href=#icp%e7%9a%84%e5%bc%80%e5%90%af%e5%92%8c%e5%85%b3%e9%97%ad aria-label=ICP的开启和关闭>ICP的开启和关闭</a></li></ul></li><li><a href=#%e5%85%b6%e4%bb%96%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96%e7%ad%96%e7%95%a5 aria-label=其他查询优化策略>其他查询优化策略</a><ul><li><a href=#exists-%e4%b8%8e-in-%e5%8c%ba%e5%88%86 aria-label="exists 与 in 区分">exists 与 in 区分</a></li><li><a href=#count%e4%b8%8ecount%e5%85%b7%e4%bd%93%e5%ad%97%e6%ae%b5%e6%95%88%e7%8e%87 aria-label=COUNT(*)与COUNT(具体字段)效率>COUNT(*)与COUNT(具体字段)效率</a></li><li><a href=#select-%e5%ad%97%e6%ae%b5 aria-label="select 字段">select 字段</a></li><li><a href=#limit-1-%e5%af%b9%e4%bc%98%e5%8c%96%e7%9a%84%e5%bd%b1%e5%93%8d aria-label="limit 1 对优化的影响">limit 1 对优化的影响</a></li><li><a href=#%e5%a4%9a%e4%bd%bf%e7%94%a8commit aria-label=多使用COMMIT>多使用COMMIT</a></li></ul></li></ul></li><li><a href=#%e6%b7%98%e5%ae%9d%e6%95%b0%e6%8d%ae%e5%ba%93%e4%b8%bb%e9%94%ae%e5%a6%82%e4%bd%95%e8%ae%be%e8%ae%a1 aria-label=淘宝数据库主键如何设计>淘宝数据库主键如何设计</a><ul><ul><li><a href=#%e8%87%aa%e5%a2%9eid%e9%97%ae%e9%a2%98 aria-label=自增ID问题>自增ID问题</a></li><li><a href=#%e4%b8%9a%e5%8a%a1%e7%b3%bb%e7%bb%9f%e5%81%9a%e4%b8%bb%e9%94%ae aria-label=业务系统做主键>业务系统做主键</a></li><li><a href=#%e6%b7%98%e5%ae%9d%e7%9a%84%e4%b8%bb%e9%94%ae%e8%ae%be%e8%ae%a1 aria-label=淘宝的主键设计>淘宝的主键设计</a></li><li><a href=#%e6%8e%a8%e8%8d%90%e7%9a%84%e4%b8%bb%e9%94%ae%e8%ae%be%e8%ae%a1 aria-label=推荐的主键设计>推荐的主键设计</a><ul><li><a href=#%e4%b8%bb%e9%94%ae%e8%ae%be%e8%ae%a1%e8%87%b3%e5%b0%91%e5%ba%94%e8%af%a5%e6%98%af%e5%85%a8%e5%b1%80%e5%94%af%e4%b8%80%e4%b8%94%e6%98%af%e5%8d%95%e8%b0%83%e9%80%92%e5%a2%9e aria-label=主键设计至少应该是全局唯一且是单调递增。>主键设计至少应该是全局唯一且是单调递增。</a></li><li><a href=#uuid aria-label=UUID>UUID</a><ul><li><a href=#%e7%89%b9%e7%82%b9 aria-label=特点>特点</a></li></ul></li><li><a href=#mysql-uuid%e7%bb%84%e6%88%90 aria-label="MySQL UUID组成">MySQL UUID组成</a></li><li><a href=#%e6%94%b9%e9%80%a0uuid aria-label=改造UUID>改造UUID</a></li><li><a href=#mysql-80%e5%8f%af%e4%bb%a5%e6%9b%b4%e6%8d%a2%e6%97%b6%e9%97%b4%e4%bd%8e%e4%bd%8d%e5%92%8c%e6%97%b6%e9%97%b4%e9%ab%98%e4%bd%8d%e7%9a%84%e5%ad%98%e5%82%a8%e6%96%b9%e5%bc%8f%e8%bf%99%e6%a0%b7uuid%e5%b0%b1%e6%98%af%e6%9c%89%e5%ba%8f%e7%9a%84uuid%e4%ba%86 aria-label="MySQL 8.0可以更换时间低位和时间高位的存储方式，这样UUID就是有序的UUID了。">MySQL 8.0可以更换时间低位和时间高位的存储方式，这样UUID就是有序的UUID了。</a></li><li><a href=#%e5%a6%82%e6%9e%9c%e4%b8%8d%e6%98%afmysql8httpssocsdnnetsosearchqmysql8spm10012101300170200-%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3 aria-label="如果不是MySQL8.0 如何解决">如果不是<a href="https://so.csdn.net/so/search?q=MySQL8&amp;spm=1001.2101.3001.7020">MySQL8</a>.0 如何解决</a></li></ul></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=索引>索引<a hidden class=anchor aria-hidden=true href=#索引>#</a></h1><h2 id=索引的分类>索引的分类<a hidden class=anchor aria-hidden=true href=#索引的分类>#</a></h2><ol><li>从功能逻辑划分<ul><li>普通索引</li><li>唯一索引</li><li>主键索引</li><li>全文索引</li></ul></li><li>从物理实现方法划分<ul><li>聚簇索引</li><li>非聚簇索引</li></ul></li><li>从作用字段划分<ul><li>单列索引</li><li>联合索引</li></ul></li></ol><p>InnoDB: 支持B-Tree，FullText索引，不支持Hash索引</p><p>MyISAM: 支持B-Tree，FullText索引，不支持Hash索引</p><p>Memory: 支持B-Tree，Hash索引，不支持FullText索引</p><p>NDB: 支持Hash索引，不支持 B-Tree, FullText索引</p><p>Archive: 不支持 B-Tree, FullText,Hash索引</p><h2 id=创建索引>创建索引<a hidden class=anchor aria-hidden=true href=#创建索引>#</a></h2><h3 id=方式1--创建表时候指定>方式1- 创建表时候指定<a hidden class=anchor aria-hidden=true href=#方式1--创建表时候指定>#</a></h3><ol><li>普通索引</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>book</span><span class=p>(</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>book_id</span><span class=w> </span><span class=nb>INT</span><span class=w> </span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>book_name</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>100</span><span class=p>),</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>authors</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>100</span><span class=p>),</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>info</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>100</span><span class=p>)</span><span class=w> </span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>comment</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>100</span><span class=p>),</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>year_publication</span><span class=w> </span><span class=k>YEAR</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>INDEX</span><span class=p>(</span><span class=n>year_publication</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><ol start=2><li>创建唯一索引</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>test1</span><span class=p>(</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>id</span><span class=w> </span><span class=nb>INT</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>name</span><span class=w> </span><span class=nb>varchar</span><span class=p>(</span><span class=mi>30</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>UNIQUE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>uk_idx_id</span><span class=p>(</span><span class=n>id</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><ol start=3><li>主键索引</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>student</span><span class=w> </span><span class=p>(</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>id</span><span class=w> </span><span class=nb>INT</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span><span class=w> </span><span class=n>UNSIGNED</span><span class=w> </span><span class=n>AUTO_INCREMENT</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>student_no</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>200</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>student_name</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>200</span><span class=p>),</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=p>(</span><span class=n>id</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=w> </span><span class=err>删除主键索引</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>student</span><span class=w> </span><span class=k>drop</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><ol start=4><li>创建单列索引</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>test2</span><span class=p>(</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>id</span><span class=w> </span><span class=nb>INT</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>name</span><span class=w> </span><span class=nb>CHAR</span><span class=p>(</span><span class=mi>50</span><span class=p>)</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>INDEX</span><span class=w> </span><span class=n>single_idx_name</span><span class=p>(</span><span class=n>name</span><span class=p>(</span><span class=mi>20</span><span class=p>))</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><ol start=5><li>创建组合索引</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>test3</span><span class=p>(</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>id</span><span class=w> </span><span class=nb>INT</span><span class=p>(</span><span class=mi>11</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>name</span><span class=w> </span><span class=nb>CHAR</span><span class=p>(</span><span class=mi>30</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>age</span><span class=w> </span><span class=nb>INT</span><span class=p>(</span><span class=mi>11</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>info</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>255</span><span class=p>),</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>INDEX</span><span class=w> </span><span class=n>multi_idx</span><span class=p>(</span><span class=n>id</span><span class=p>,</span><span class=n>name</span><span class=p>,</span><span class=n>age</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><ol start=6><li>全文索引</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=o>`</span><span class=n>papers</span><span class=o>`</span><span class=w> </span><span class=p>(</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>id</span><span class=o>`</span><span class=w> </span><span class=nb>int</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span><span class=w> </span><span class=n>unsigned</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=n>AUTO_INCREMENT</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>`</span><span class=n>title</span><span class=o>`</span><span class=w> </span><span class=nb>varchar</span><span class=p>(</span><span class=mi>200</span><span class=p>)</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>`</span><span class=n>content</span><span class=o>`</span><span class=w> </span><span class=nb>text</span><span class=p>,</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=p>),</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>FULLTEXT</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=o>`</span><span class=n>title</span><span class=o>`</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>title</span><span class=o>`</span><span class=p>,</span><span class=o>`</span><span class=n>content</span><span class=o>`</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w> </span><span class=n>ENGINE</span><span class=o>=</span><span class=n>MyISAM</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=n>CHARSET</span><span class=o>=</span><span class=n>utf8</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>papers</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=k>MATCH</span><span class=p>(</span><span class=n>title</span><span class=p>,</span><span class=n>content</span><span class=p>)</span><span class=w> </span><span class=n>AGAINST</span><span class=w> </span><span class=p>(</span><span class=err>‘查询字符串’</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><ol start=7><li>空间索引</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>test5</span><span class=p>(</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>geo</span><span class=w> </span><span class=n>GEOMETRY</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>SPATIAL</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>spa_idx_geo</span><span class=p>(</span><span class=n>geo</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w> </span><span class=n>ENGINE</span><span class=o>=</span><span class=n>MyISAM</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><h3 id=方式2-已经创建表上的添加>方式2-已经创建表上的添加<a hidden class=anchor aria-hidden=true href=#方式2-已经创建表上的添加>#</a></h3><ol><li>alter 形式</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=k>table_name</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ADD</span><span class=w> </span><span class=p>[</span><span class=k>UNIQUE</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>FULLTEXT</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>SPATIAL</span><span class=p>]</span><span class=w> </span><span class=p>[</span><span class=k>INDEX</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=k>KEY</span><span class=p>]</span><span class=w> </span><span class=p>[</span><span class=n>index_name</span><span class=p>]</span><span class=w> </span><span class=p>(</span><span class=n>col_name</span><span class=p>[</span><span class=k>length</span><span class=p>],...)</span><span class=w> </span><span class=p>[</span><span class=k>ASC</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=k>DESC</span><span class=p>]</span><span class=w>
</span></span></span></code></pre></div><ol start=2><li>create 形式</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=p>[</span><span class=k>UNIQUE</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>FULLTEXT</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>SPATIAL</span><span class=p>]</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>index_name</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ON</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=p>(</span><span class=n>col_name</span><span class=p>[</span><span class=k>length</span><span class=p>],...)</span><span class=w> </span><span class=p>[</span><span class=k>ASC</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=k>DESC</span><span class=p>]</span><span class=w>
</span></span></span></code></pre></div><h3 id=删除索引-alter>删除索引-alter<a hidden class=anchor aria-hidden=true href=#删除索引-alter>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=k>DROP</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>index_name</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>删除索引-drop</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>DROP</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>index_name</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=k>table_name</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p><strong>添加Auto_Increment约束字段的唯一索引不能被删除</strong></p><h2 id=mysql80---新特性>MySQL8.0 - 新特性<a hidden class=anchor aria-hidden=true href=#mysql80---新特性>#</a></h2><h3 id=降序索引>降序索引<a hidden class=anchor aria-hidden=true href=#降序索引>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>ts1</span><span class=p>(</span><span class=n>a</span><span class=w> </span><span class=nb>int</span><span class=p>,</span><span class=n>b</span><span class=w> </span><span class=nb>int</span><span class=p>,</span><span class=k>index</span><span class=w> </span><span class=n>idx_a_b</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>b</span><span class=w> </span><span class=k>desc</span><span class=p>));</span><span class=w>
</span></span></span></code></pre></div><p>对InnoDB而言是支持的，Mysql之前是升序索引</p><h3 id=隐藏索引>隐藏索引<a hidden class=anchor aria-hidden=true href=#隐藏索引>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 创建表时候指定
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>tablename</span><span class=p>(</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>propname1</span><span class=w> </span><span class=n>type1</span><span class=p>[</span><span class=n>CONSTRAINT1</span><span class=p>],</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>propname2</span><span class=w> </span><span class=n>type2</span><span class=p>[</span><span class=n>CONSTRAINT2</span><span class=p>],</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=err>……</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>propnamen</span><span class=w> </span><span class=n>typen</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>INDEX</span><span class=w> </span><span class=p>[</span><span class=n>indexname</span><span class=p>](</span><span class=n>propname1</span><span class=w> </span><span class=p>[(</span><span class=k>length</span><span class=p>)])</span><span class=w> </span><span class=n>INVISIBLE</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 已经创建表的指定
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>indexname</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>tablename</span><span class=p>(</span><span class=n>propname</span><span class=p>[(</span><span class=k>length</span><span class=p>)])</span><span class=w> </span><span class=n>INVISIBLE</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- alter table 指定
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>tablename</span><span class=w> </span><span class=k>ADD</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>indexname</span><span class=w> </span><span class=p>(</span><span class=n>propname</span><span class=w> </span><span class=p>[(</span><span class=k>length</span><span class=p>)])</span><span class=w> </span><span class=n>INVISIBLE</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 切换隐藏索引状态
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>tablename</span><span class=w> </span><span class=k>ALTER</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>index_name</span><span class=w> </span><span class=n>INVISIBLE</span><span class=p>;</span><span class=w> </span><span class=o>#</span><span class=err>切换成隐藏索引</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>tablename</span><span class=w> </span><span class=k>ALTER</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>index_name</span><span class=w> </span><span class=n>VISIBLE</span><span class=p>;</span><span class=w> </span><span class=o>#</span><span class=err>切换成非隐藏索引</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 是隐藏索引对查询优化器可见设置
</span></span></span><span class=line><span class=cl><span class=c1>-- 1. 查看优化器设置
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>select</span><span class=w> </span><span class=o>@@</span><span class=n>optimizer_switch</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>set</span><span class=w> </span><span class=k>session</span><span class=w> </span><span class=n>optimizer_switch</span><span class=o>=</span><span class=s2>&#34;use_invisible_indexes=on&#34;</span><span class=w> </span><span class=c1>-- 开启
</span></span></span></code></pre></div><h2 id=索引的设计原则>索引的设计原则<a hidden class=anchor aria-hidden=true href=#索引的设计原则>#</a></h2><h3 id=哪些情况适合创建索引>哪些情况适合创建索引<a hidden class=anchor aria-hidden=true href=#哪些情况适合创建索引>#</a></h3><h4 id=1-字段的数值有唯一的限制>1. 字段的数值有唯一的限制<a hidden class=anchor aria-hidden=true href=#1-字段的数值有唯一的限制>#</a></h4><p>索引本身可以起到约束的作用，比如唯一索引、主键索引都可以起到唯一性约束的，因此在我们的数据表中，如果<code>某个字段是唯一的</code>，就可以直接<code>创建唯一性索引</code>，或者<code>主键索引</code>。这样可以更快速地通过该索引来确定某条记录</p><blockquote><p>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba）</p><p>说明：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的。</p></blockquote><h4 id=2-经常性作为where条件查询的字段>2. 经常性作为where条件查询的字段<a hidden class=anchor aria-hidden=true href=#2-经常性作为where条件查询的字段>#</a></h4><p>某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率</p><h4 id=3-经常group-by-和order-by-的列>3. 经常group by 和order by 的列<a hidden class=anchor aria-hidden=true href=#3-经常group-by-和order-by-的列>#</a></h4><p>如果只是group by 或者order by单列字段，建立单列索引。</p><p>如果既有group by 也有order by 建立联合索引</p><h4 id=4-updatedelete-的-where-条件列>4. UPDATE、DELETE <strong>的</strong> <strong>WHERE</strong> <strong>条件列</strong><a hidden class=anchor aria-hidden=true href=#4-updatedelete-的-where-条件列>#</a></h4><p>对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。<strong>如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。</strong></p><h4 id=5-distinct字段需要创建索引>5. DISTINCT字段需要创建索引<a hidden class=anchor aria-hidden=true href=#5-distinct字段需要创建索引>#</a></h4><p>有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。</p><h4 id=6-多表创建索引注意事项>6. 多表创建索引注意事项<a hidden class=anchor aria-hidden=true href=#6-多表创建索引注意事项>#</a></h4><p>首先，<code>连接表的数量尽量不要超过 3 张</code>，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。</p><p>其次，<code>对 WHERE 条件创建索引</code>，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。</p><p>最后，<code>对用于连接的字段创建索引</code>，并且该字段在多张表中的<code>类型必须一致</code>。<em>虽然这里能查询，但存在隐式转换，使用到了函数</em></p><h4 id=7-使用列的类型小的创建索引>7. 使用列的类型小的创建索引<a hidden class=anchor aria-hidden=true href=#7-使用列的类型小的创建索引>#</a></h4><p>这里所说的<code>类型大小</code>指的就是该类型表示的数据范围的大小。</p><ul><li>数据类型越小，在查询时进行的比较操作越快</li><li>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以<code>放下更多的记录</code>，从而减少磁盘<code>I/O</code>带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li></ul><p>这个建议对于表的<code>主键来说更加适用</code>，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/O。</p><h4 id=8-使用字符串前缀创建索引>8. 使用字符串前缀创建索引<a hidden class=anchor aria-hidden=true href=#8-使用字符串前缀创建索引>#</a></h4><p>计算公式</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=k>count</span><span class=p>(</span><span class=k>distinct</span><span class=w> </span><span class=k>left</span><span class=p>(</span><span class=err>列名</span><span class=p>,</span><span class=w> </span><span class=err>索引长度</span><span class=p>))</span><span class=o>/</span><span class=k>count</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=k>table_name</span><span class=p>;</span><span class=w> </span><span class=c1>--比值越接近1越好
</span></span></span><span class=line><span class=cl><span class=c1>-- 尝试
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>select</span><span class=w> </span><span class=k>count</span><span class=p>(</span><span class=k>distinct</span><span class=w> </span><span class=k>left</span><span class=p>(</span><span class=err>列名</span><span class=p>,</span><span class=w> </span><span class=mi>10</span><span class=p>))</span><span class=o>/</span><span class=k>count</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>sub10</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=k>table_name</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w> </span><span class=k>count</span><span class=p>(</span><span class=k>distinct</span><span class=w> </span><span class=k>left</span><span class=p>(</span><span class=err>列名</span><span class=p>,</span><span class=w> </span><span class=mi>15</span><span class=p>))</span><span class=o>/</span><span class=k>count</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>sub15</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=k>table_name</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w> </span><span class=k>count</span><span class=p>(</span><span class=k>distinct</span><span class=w> </span><span class=k>left</span><span class=p>(</span><span class=err>列名</span><span class=p>,</span><span class=w> </span><span class=mi>20</span><span class=p>))</span><span class=o>/</span><span class=k>count</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>sub20</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=k>table_name</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w> </span><span class=k>count</span><span class=p>(</span><span class=k>distinct</span><span class=w> </span><span class=k>left</span><span class=p>(</span><span class=err>列名</span><span class=p>,</span><span class=w> </span><span class=mi>25</span><span class=p>))</span><span class=o>/</span><span class=k>count</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>sub25</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=k>table_name</span><span class=p>;</span><span class=w> 
</span></span></span></code></pre></div><blockquote><p>Alibaba《Java开发手册》</p><p>【<code>强制</code>】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。</p><p>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会<code>高达 90% 以上</code></p></blockquote><h6 id=索引类前缀对排序的影响>索引类前缀对排序的影响<a hidden class=anchor aria-hidden=true href=#索引类前缀对排序的影响>#</a></h6><p><strong>使用了索引列前缀的方式无法支持使用索引排序，只能使用文件排序，可能造成排序结果有偏差</strong></p><h4 id=9-区分度高散列性高的列适合作为索引>9. 区分度高(散列性高)的列适合作为索引<a hidden class=anchor aria-hidden=true href=#9-区分度高散列性高的列适合作为索引>#</a></h4><p><code>列的基数</code>指的是某一列中不重复数据的个数，比方说某个列包含值<code>2,5,8,2,5,8,2,5,8</code>，虽然有<code>9</code>条记录，但该列的基数却是<code>3</code>。也就是说，**在记录行数一定的情况下，列的基数越大，该列中的值越分散；列的基数越小，该列中的值越集中。**这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列建立索引，为基数太小的列建立索引效果可能不好。</p><p>可以使用公式<code>select count(distinct a)/count(*) from t1</code>计算区分度，越接近1越好，一般超过<code>33%</code>就算是比较高效的索引了。</p><p>拓展：联合索引把区分度高（散列性高）的列放在前面。</p><h4 id=10-使用最频繁的列放到联合索引的左侧>10. 使用最频繁的列放到联合索引的左侧<a hidden class=anchor aria-hidden=true href=#10-使用最频繁的列放到联合索引的左侧>#</a></h4><p>最左前缀匹配原则</p><h4 id=10-在多个字段都要创建索引的情况下联合索引优于单值索引>10. 在多个字段都要创建索引的情况下，联合索引优于单值索引<a hidden class=anchor aria-hidden=true href=#10-在多个字段都要创建索引的情况下联合索引优于单值索引>#</a></h4><h3 id=索引的数量限制>索引的数量限制<a hidden class=anchor aria-hidden=true href=#索引的数量限制>#</a></h3><p>在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量<code>不超过6个</code>。原因：</p><ul><li>每个索引都需要占用<code>磁盘空间</code>，索引越多，需要的磁盘空间就越大。</li><li>索引会影响<code>INSERT、DELETE、UPDATE等语句的性能</code>，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。</li><li>优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的<code>索引来进行评估</code>，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加MySQL优化器生成执行计划时间，<strong>降低查询性能</strong>。</li></ul><h3 id=不适合创建索引的情况>不适合创建索引的情况<a hidden class=anchor aria-hidden=true href=#不适合创建索引的情况>#</a></h3><h4 id=1-在wheregroupby-orderby-使用不到的字段不需要创建>1. 在where,groupby orderby 使用不到的字段不需要创建<a hidden class=anchor aria-hidden=true href=#1-在wheregroupby-orderby-使用不到的字段不需要创建>#</a></h4><h4 id=2-数据量小的表不要使用索引>2. 数据量小的表不要使用索引<a hidden class=anchor aria-hidden=true href=#2-数据量小的表不要使用索引>#</a></h4><h4 id=3-有大量重复数据的列上不要创建索引>3. 有大量重复数据的列上不要创建索引<a hidden class=anchor aria-hidden=true href=#3-有大量重复数据的列上不要创建索引>#</a></h4><blockquote><p>当数据重复度 大于10%，不需要创建索引</p></blockquote><h4 id=4-避免对经常更新的表创建过多的索引>4. 避免对经常更新的表创建过多的索引<a hidden class=anchor aria-hidden=true href=#4-避免对经常更新的表创建过多的索引>#</a></h4><ol><li>频繁更新的字段不一定要创建索引</li><li>对经常更新的表避免创建过多的索引</li></ol><h4 id=5-不建议用无序的值作为索引>5. 不建议用无序的值作为索引<a hidden class=anchor aria-hidden=true href=#5-不建议用无序的值作为索引>#</a></h4><p>身份证，uuid(索引比较时候转换为ASCII, 并且插入时可能造成页分裂，md5, hash，无序列长字符串)</p><h4 id=6-删除不再使用或者使用很少的索引>6. 删除不再使用或者使用很少的索引<a hidden class=anchor aria-hidden=true href=#6-删除不再使用或者使用很少的索引>#</a></h4><h4 id=7-不要定义冗余或者重复的索引>7. 不要定义冗余或者重复的索引<a hidden class=anchor aria-hidden=true href=#7-不要定义冗余或者重复的索引>#</a></h4><p>冗余索引：联合索引含有的字段，有定义了单列索引</p><p>重复索引</p><h1 id=性能分析工具>性能分析工具<a hidden class=anchor aria-hidden=true href=#性能分析工具>#</a></h1><h2 id=数据库优化步骤>数据库优化步骤<a hidden class=anchor aria-hidden=true href=#数据库优化步骤>#</a></h2><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/2.jpg alt=2></p><h2 id=查看系统参数>查看系统参数<a hidden class=anchor aria-hidden=true href=#查看系统参数>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>show</span><span class=w> </span><span class=p>[</span><span class=k>global</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=k>session</span><span class=p>]</span><span class=w> </span><span class=n>status</span><span class=w> </span><span class=k>like</span><span class=w> </span><span class=s1>&#39;参数名&#39;</span><span class=w>
</span></span></span></code></pre></div><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230605204006975.png alt=image-20230605204006975></p><h3 id=统计sql的查询成本>统计SQL的查询成本<a hidden class=anchor aria-hidden=true href=#统计sql的查询成本>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SHOW</span><span class=w> </span><span class=n>STATUS</span><span class=w> </span><span class=k>LIKE</span><span class=w> </span><span class=s1>&#39;last_query_cost&#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>使用场景：它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。</p><blockquote><p>SQL 查询是一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论：</p><ol><li><code>位置决定效率</code>。如果页就在数据库<code>缓冲池</code>中，那么效率是最高的，否则还需要从<code>内存</code>或者<code>磁盘</code>中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。</li><li><code>批量决定效率</code>。如果我们从磁盘中对单一页进行随机读，那么效率是很低的（差不多10ms），而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。</li></ol><p>所以说，遇到I/O并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是经常使用的数据就要尽量放到<code>缓冲池</code>中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。</p></blockquote><h2 id=定位慢sql>定位慢SQL<a hidden class=anchor aria-hidden=true href=#定位慢sql>#</a></h2><h3 id=1-开启慢查询日志参数>1. 开启慢查询日志参数<a hidden class=anchor aria-hidden=true href=#1-开启慢查询日志参数>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>set</span><span class=w> </span><span class=k>global</span><span class=w> </span><span class=n>slow_query_log</span><span class=o>=</span><span class=s1>&#39;ON&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=w> </span><span class=err>查看</span><span class=w> </span><span class=err>慢日志文件位置</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>show</span><span class=w> </span><span class=n>variables</span><span class=w> </span><span class=k>like</span><span class=w> </span><span class=o>`%</span><span class=n>slow_query_log</span><span class=o>%`</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><h3 id=2-修改long_query_time阈值>2. 修改long_query_time阈值<a hidden class=anchor aria-hidden=true href=#2-修改long_query_time阈值>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=o>#</span><span class=w> </span><span class=err>该参数设置之后，仅对新连接的会话有效</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>set</span><span class=w> </span><span class=k>global</span><span class=w> </span><span class=n>long_query_time</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>show</span><span class=w> </span><span class=k>global</span><span class=w> </span><span class=n>variables</span><span class=w> </span><span class=k>like</span><span class=w> </span><span class=s1>&#39;%long_query_time%&#39;</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=w> </span><span class=err>对当前会话生效</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>set</span><span class=w> </span><span class=n>long_query_time</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>show</span><span class=w> </span><span class=n>variables</span><span class=w> </span><span class=k>like</span><span class=w> </span><span class=s1>&#39;%long_query_time%&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=w> </span><span class=err>如果一直生效的话</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>该配置文件，重启</span><span class=w>
</span></span></span></code></pre></div><h3 id=3-查看慢查询数目>3. 查看慢查询数目<a hidden class=anchor aria-hidden=true href=#3-查看慢查询数目>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SHOW</span><span class=w> </span><span class=k>GLOBAL</span><span class=w> </span><span class=n>STATUS</span><span class=w> </span><span class=k>LIKE</span><span class=w> </span><span class=s1>&#39;%Slow_queries%&#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><h3 id=4-慢查询日志分析工具--mysqldumpslow>4. 慢查询日志分析工具 mysqldumpslow<a hidden class=anchor aria-hidden=true href=#4-慢查询日志分析工具--mysqldumpslow>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=o>#</span><span class=err>得到返回记录集最多的</span><span class=mi>10</span><span class=err>个</span><span class=k>SQL</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>mysqldumpslow</span><span class=w> </span><span class=o>-</span><span class=n>s</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=o>-</span><span class=n>t</span><span class=w> </span><span class=mi>10</span><span class=w> </span><span class=o>/</span><span class=n>var</span><span class=o>/</span><span class=n>lib</span><span class=o>/</span><span class=n>mysql</span><span class=o>/</span><span class=n>mysql</span><span class=o>-</span><span class=n>log</span><span class=p>.</span><span class=n>log</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=err>得到访问次数最多的</span><span class=mi>10</span><span class=err>个</span><span class=k>SQL</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>mysqldumpslow</span><span class=w> </span><span class=o>-</span><span class=n>s</span><span class=w> </span><span class=k>c</span><span class=w> </span><span class=o>-</span><span class=n>t</span><span class=w> </span><span class=mi>10</span><span class=w> </span><span class=o>/</span><span class=n>var</span><span class=o>/</span><span class=n>lib</span><span class=o>/</span><span class=n>mysql</span><span class=o>/</span><span class=n>mysql</span><span class=o>-</span><span class=n>log</span><span class=p>.</span><span class=n>log</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=err>得到按照时间排序的前</span><span class=mi>10</span><span class=err>条里面含有左连接的查询语句</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>mysqldumpslow</span><span class=w> </span><span class=o>-</span><span class=n>s</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=o>-</span><span class=n>t</span><span class=w> </span><span class=mi>10</span><span class=w> </span><span class=o>-</span><span class=k>g</span><span class=w> </span><span class=s2>&#34;left join&#34;</span><span class=w> </span><span class=o>/</span><span class=n>var</span><span class=o>/</span><span class=n>lib</span><span class=o>/</span><span class=n>mysql</span><span class=o>/</span><span class=n>mysql</span><span class=o>-</span><span class=n>log</span><span class=p>.</span><span class=n>log</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=err>另外建议在使用这些命令时结合</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=err>和</span><span class=k>more</span><span class=w> </span><span class=err>使用</span><span class=w> </span><span class=err>，否则有可能出现爆屏情况</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>mysqldumpslow</span><span class=w> </span><span class=o>-</span><span class=n>s</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=o>-</span><span class=n>t</span><span class=w> </span><span class=mi>10</span><span class=w> </span><span class=o>/</span><span class=n>var</span><span class=o>/</span><span class=n>lib</span><span class=o>/</span><span class=n>mysql</span><span class=o>/</span><span class=n>mysql</span><span class=o>-</span><span class=n>log</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=k>more</span><span class=w>
</span></span></span></code></pre></div><h3 id=5-关闭慢查询日志>5. 关闭慢查询日志<a hidden class=anchor aria-hidden=true href=#5-关闭慢查询日志>#</a></h3><p>开发当中，如果不涉及调优尽量关闭</p><ol><li><p>永久关闭</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=p>[</span><span class=n>mysqld</span><span class=p>]</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>slow_query_log</span><span class=o>=</span><span class=k>OFF</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=err>或</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>[</span><span class=n>mysqld</span><span class=p>]</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=n>slow_query_log</span><span class=w> </span><span class=o>=</span><span class=k>OFF</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>重启服务器</span><span class=w>
</span></span></span></code></pre></div></li><li><p>临时关闭</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SET</span><span class=w> </span><span class=k>GLOBAL</span><span class=w> </span><span class=n>slow_query_log</span><span class=o>=</span><span class=k>off</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div></li></ol><h2 id=查看sql执行成本----profiling>查看SQL执行成本 - profiling<a hidden class=anchor aria-hidden=true href=#查看sql执行成本----profiling>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>show</span><span class=w> </span><span class=n>variables</span><span class=w> </span><span class=k>like</span><span class=w> </span><span class=s1>&#39;profiling&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=err>开启</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>set</span><span class=w> </span><span class=n>profiling</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;ON&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=err>查看</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>show</span><span class=w> </span><span class=n>profiles</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>show</span><span class=w> </span><span class=n>profile</span><span class=w> </span><span class=n>cpu</span><span class=p>,</span><span class=n>block</span><span class=w> </span><span class=n>io</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>query</span><span class=w> </span><span class=mi>2</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p><strong>profiling 常用参数</strong></p><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230605214559754.png alt=image-20230605214559754></p><p><strong>日常开发注意点：</strong></p><ol><li>convert heap to MyISAM: 查询结果太大，内存不够，落盘</li><li>Creating tmp table: 创建临时表。先拷贝数据到临时表，用完后在删除临时表</li><li>Coping to tmp table on disk: 把内存中临时表复制到磁盘上</li><li>locked</li></ol><p><strong>如果在show profile诊断结果中出现了以上4条结果中的任何一条，则sql语句需要优化</strong></p><p><em>注意：show profile 命令将弃用，可以从information_schema中的profiling数据表进行查看</em></p><h2 id=分析查询语句--explain>分析查询语句 EXPLAIN<a hidden class=anchor aria-hidden=true href=#分析查询语句--explain>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>select_options</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=err>或者</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>DESCRIBE</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>select_options</span><span class=w>
</span></span></span></code></pre></div><p>EXPLAIN 语句输出的各个列的作用如下：</p><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>在一个大的查询语句中每个SELECT关键字都对应一个<code>唯一的id</code></td></tr><tr><td>select_type</td><td>SELECT关键字对应的那个查询的类型</td></tr><tr><td>table</td><td>表名</td></tr><tr><td>partitions</td><td>匹配的分区信息</td></tr><tr><td>type</td><td>针对单表的访问方法</td></tr><tr><td>possible_keys</td><td>可能用到的索引</td></tr><tr><td>key</td><td>实际上使用的索引</td></tr><tr><td>key_len</td><td>实际使用到的索引长度</td></tr><tr><td>ref</td><td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td></tr><tr><td>rows</td><td>预估的需要读取的记录条数</td></tr><tr><td>filtered</td><td>某个表经过搜索条件过滤后剩余记录条数的百分比</td></tr><tr><td>Extra</td><td>一些额外的信息</td></tr></tbody></table><h3 id=explain各列作用>Explain各列作用<a hidden class=anchor aria-hidden=true href=#explain各列作用>#</a></h3><h4 id=1-table>1. table<a hidden class=anchor aria-hidden=true href=#1-table>#</a></h4><p>记录查询时候的表名，MySQL规定<strong>EXPLAIN语句输出的每条记录都对应着某个单表的访问方法</strong>，有时候不是真实的名字，可能是简称。排在前面的是驱动表，排在后面的是被驱动表</p><h4 id=2-id>2. id<a hidden class=anchor aria-hidden=true href=#2-id>#</a></h4><p>在一个大的查询每个select 关键字对应一个id, 但并不是绝对。SQL优化器会帮我们优化。</p><ul><li><strong>id如果相同，可以认为是一组，从上往下顺序执行</strong></li><li><strong>在所有组中，id值越大，优先级越高，越先执行</strong></li><li><strong>关注点：id号每个号码，表示一趟独立的查询,一个sql的查询趟数越少越好</strong></li></ul><h4 id=3-select-type>3. select type<a hidden class=anchor aria-hidden=true href=#3-select-type>#</a></h4><p>MySQL为每一个SELECT关键字代表的小查询都定义了select_type属性。表示这小查询在大查询里面扮演着什么角色。</p><table><thead><tr><th>select type</th><th>描述</th></tr></thead><tbody><tr><td>SIMPLE</td><td>简单的SELECT语句（不包括<a href="https://so.csdn.net/so/search?q=UNION&amp;spm=1001.2101.3001.7020">UNION</a>操作或子查询操作）</td></tr><tr><td>PRIMARY</td><td>查询中最外层的SELECT（如两表做UNION或者存在子查询的外层的表操作为PRIMARY，内层的操作为UNION）</td></tr><tr><td>UNION</td><td>UNION操作中，查询中处于内层的SELECT（内层的SELECT语句与外层的SELECT语句没有依赖关系）</td></tr><tr><td>DEPENDENT UNION</td><td>UNION操作中，查询中处于内层的SELECT（内层的SELECT语句与外层的SELECT语句有依赖关系） 相关子查询</td></tr><tr><td>UNION RESULT</td><td>UNION操作的结果，id值通常为NULL</td></tr><tr><td>SUBQUERY</td><td>子查询中首个SELECT（如果有多个子查询存在）</td></tr><tr><td>DEPENDENT SUBQUERY</td><td>子查询中首个SELECT，但依赖于外层的表（如果有多个子查询存在）</td></tr><tr><td>DERIVED</td><td>被驱动的SELECT子查询（子查询位于FROM子句）</td></tr><tr><td>MATERIALIZED</td><td>被物化的子查询</td></tr><tr><td>UNCACHEABLE SUBQUERY</td><td>对于外层的主表，子查询不可被物化，每次都需要计算（耗时操作）</td></tr><tr><td>UNCACHEABLE UNION</td><td>UNION操作中，内层的不可被物化的子查询（类似于UNCACHEABLE SUBQUERY）</td></tr></tbody></table><h4 id=4-partitions>4. partitions<a hidden class=anchor aria-hidden=true href=#4-partitions>#</a></h4><p>代表分区的命中情况，非分区表，该项为null</p><h4 id=5-type---关键点>5. type - 关键点<a hidden class=anchor aria-hidden=true href=#5-type---关键点>#</a></h4><p><strong>结果值从最好到最坏依次是：</strong> <strong>system > const > eq_ref > ref</strong> <strong>> fulltext > ref_or_null > index_merge > unique_subquery > index_subquery ></strong> <strong>range > index > ALL</strong></p><p><strong>SQL性能优化的目标：至少要达到 range级别，要求是ref级别，最好是consts级别。</strong></p><h4 id=6-possible_keys和key>6. possible_keys和key<a hidden class=anchor aria-hidden=true href=#6-possible_keys和key>#</a></h4><p>possible_keys: 可能使用到的key, 并不是越多越好，需要筛选</p><p>key: 使用到的key</p><h4 id=7-key_len---关键点>7. key_len - 关键点<a hidden class=anchor aria-hidden=true href=#7-key_len---关键点>#</a></h4><p>多数场景对于联合索引，使用到的索引长度。<code>越大越好</code></p><p>计算公式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=nb>varchar</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span><span class=err>变长字段且允许</span><span class=k>NULL</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>10</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=p>(</span><span class=w> </span><span class=nb>character</span><span class=w> </span><span class=k>set</span><span class=err>：</span><span class=w> </span><span class=n>utf8</span><span class=o>=</span><span class=mi>3</span><span class=p>,</span><span class=n>gbk</span><span class=o>=</span><span class=mi>2</span><span class=p>,</span><span class=n>latin1</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span><span class=o>+</span><span class=mi>1</span><span class=p>(</span><span class=k>NULL</span><span class=p>)</span><span class=o>+</span><span class=mi>2</span><span class=p>(</span><span class=err>变长字段</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nb>varchar</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span><span class=err>变长字段且不允许</span><span class=k>NULL</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>10</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=p>(</span><span class=w> </span><span class=nb>character</span><span class=w> </span><span class=k>set</span><span class=err>：</span><span class=n>utf8</span><span class=o>=</span><span class=mi>3</span><span class=p>,</span><span class=n>gbk</span><span class=o>=</span><span class=mi>2</span><span class=p>,</span><span class=n>latin1</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span><span class=o>+</span><span class=mi>2</span><span class=p>(</span><span class=err>变长字段</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nb>char</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span><span class=err>固定字段且允许</span><span class=k>NULL</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>10</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=p>(</span><span class=w> </span><span class=nb>character</span><span class=w> </span><span class=k>set</span><span class=err>：</span><span class=n>utf8</span><span class=o>=</span><span class=mi>3</span><span class=p>,</span><span class=n>gbk</span><span class=o>=</span><span class=mi>2</span><span class=p>,</span><span class=n>latin1</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span><span class=o>+</span><span class=mi>1</span><span class=p>(</span><span class=k>NULL</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nb>char</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span><span class=err>固定字段且不允许</span><span class=k>NULL</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>10</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=p>(</span><span class=w> </span><span class=nb>character</span><span class=w> </span><span class=k>set</span><span class=err>：</span><span class=n>utf8</span><span class=o>=</span><span class=mi>3</span><span class=p>,</span><span class=n>gbk</span><span class=o>=</span><span class=mi>2</span><span class=p>,</span><span class=n>latin1</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><h4 id=8-ref>8. ref<a hidden class=anchor aria-hidden=true href=#8-ref>#</a></h4><p>当使用索引列等值查询时候，与索引列匹配的对象信息</p><h4 id=9-rows>9. rows<a hidden class=anchor aria-hidden=true href=#9-rows>#</a></h4><p>需要读取的记录条数。该值越小越好</p><h4 id=10-filtered>10. filtered<a hidden class=anchor aria-hidden=true href=#10-filtered>#</a></h4><p>某个表经过搜索条件后过滤剩下的记录条数百分比。<strong>越大越好</strong></p><p>对于单表查询来说，filtered值没有什么意义，但对于连接查询来说。驱动表对应执行计划的filtered值，它决定了被驱动表要执行的次数（rows * filtered)</p><h4 id=11-extra>11. Extra<a hidden class=anchor aria-hidden=true href=#11-extra>#</a></h4><p>一些额外的信息，非常多。<strong>更准确的理解MySQL到底如何执行给定的查询语句</strong></p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>distinct</td><td>在select部分使用了distinc关键字</td></tr><tr><td>Using index Condition</td><td>使用到了索引下推</td></tr><tr><td>Using where</td><td>表明使用了where过滤</td></tr><tr><td>Using join buffer</td><td>表明使用了连接缓存</td></tr><tr><td>impossible where</td><td>where子句的值总是false，不能用来获取任何元组</td></tr><tr><td>no tables used</td><td>不带from字句的查询或者From dual查询。 使用not in()形式子查询或not exists运算符的连接查询，这种叫做反连接。即，一般连接查询是先查询内表，再查询外表，反连接就是先查询外表，再查询内表。</td></tr><tr><td>using filesort</td><td>排序时无法使用到索引时，就会出现这个。常见于order by和group by语句中</td></tr><tr><td>using index</td><td>查询时不需要回表查询，直接通过索引就可以获取查询的数据。</td></tr><tr><td>using_union</td><td>表示使用or连接各个使用索引的条件时，该信息表示从处理结果获取并集</td></tr><tr><td>using intersect</td><td>表示使用and的各个索引的条件时，该信息表示是从处理结果获取交集</td></tr><tr><td>using sort_union和using sort_intersection</td><td>与前面两个对应的类似，只是他们是出现在用and和or查询信息量大时，先查询主键，然后进行排序合并后，才能读取记录并返回。</td></tr><tr><td>using temporary</td><td>表示使用了临时表存储中间结果。临时表可以是内存临时表和磁盘临时表，执行计划中看不出来，需要查看status变量，used_tmp_table，used_tmp_disk_table才能看出来</td></tr><tr><td>filtered</td><td>使用explain extended时会出现这个列，5.7之后的版本默认就有这个字段，不需要使用explain extended了。这个字段表示存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例，注意是百分比，不是具体记录数</td></tr></tbody></table><p>Using index:</p><p><strong>覆盖索引</strong>：根据索引查找，由于select字段在B+树叶子节点已经存在，直接使用索引查找。</p><p><strong>索引下推:</strong> 假设查询语句中含有类似like语句 根据索引查找到主键，主键在回表查找，匹配对应like字段，这种方式会产生随机IO。另外一种做法是在索引字段上进行like匹配，之后再次回表查询，使用到了索引下推。</p><p><a href=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/file/EXPLAIN%E7%9A%84%E4%BD%BF%E7%94%A8.sql>示例测试SQL数据</a></p><h3 id=explain四种格式>Explain四种格式<a hidden class=anchor aria-hidden=true href=#explain四种格式>#</a></h3><h4 id=传统格式>传统格式<a hidden class=anchor aria-hidden=true href=#传统格式>#</a></h4><p>不加任何关键字信息</p><h4 id=json格式>JSON格式<a hidden class=anchor aria-hidden=true href=#json格式>#</a></h4><p>explain format=JSON QUERY, 这里可以查看执行成本cost_info信息</p><h4 id=tree格式>Tree格式<a hidden class=anchor aria-hidden=true href=#tree格式>#</a></h4><p>TREE格式是8.0.16版本之后引入的新格式，主要根据查询的<code>各个部分之间的关系</code>和<code>各部分的执行顺序</code>来描述如何查询。</p><h4 id=可视化格式>可视化格式<a hidden class=anchor aria-hidden=true href=#可视化格式>#</a></h4><p>借助WorkBench</p><h3 id=show--warnings的使用>SHOW WARNINGS的使用<a hidden class=anchor aria-hidden=true href=#show--warnings的使用>#</a></h3><p>执行完Explain之后，可以使用<code>SHOW WARNINGS</code>,查看优化后执行的sql语句</p><h2 id=分析优化器执行计划----trace>分析优化器执行计划 - Trace<a hidden class=anchor aria-hidden=true href=#分析优化器执行计划----trace>#</a></h2><p>Trace是5.6追踪MySQL优化器执行过程</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=o>#</span><span class=w> </span><span class=err>开启</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SET</span><span class=w> </span><span class=n>optimizer_trace</span><span class=o>=</span><span class=s2>&#34;enabled=on&#34;</span><span class=p>,</span><span class=n>end_markers_in_json</span><span class=o>=</span><span class=k>on</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=w> </span><span class=err>设置大小</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>set</span><span class=w> </span><span class=n>optimizer_trace_max_mem_size</span><span class=o>=</span><span class=mi>1000000</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=w> </span><span class=err>使用</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>student</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=mi>10</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>information_schema</span><span class=p>.</span><span class=n>optimizer_trace</span><span class=err>\</span><span class=k>G</span><span class=w>
</span></span></span></code></pre></div><h2 id=监控视图---sys-schema>监控视图 sys schema<a hidden class=anchor aria-hidden=true href=#监控视图---sys-schema>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 索引相关
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>#</span><span class=mi>1</span><span class=p>.</span><span class=w> </span><span class=err>查询冗余索引</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>sys</span><span class=p>.</span><span class=n>schema_redundant_indexes</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=mi>2</span><span class=p>.</span><span class=w> </span><span class=err>查询未使用过的索引</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>sys</span><span class=p>.</span><span class=n>schema_unused_indexes</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=mi>3</span><span class=p>.</span><span class=w> </span><span class=err>查询索引的使用情况</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w> </span><span class=n>index_name</span><span class=p>,</span><span class=n>rows_selected</span><span class=p>,</span><span class=n>rows_inserted</span><span class=p>,</span><span class=n>rows_updated</span><span class=p>,</span><span class=n>rows_deleted</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>sys</span><span class=p>.</span><span class=n>schema_index_statistics</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>table_schema</span><span class=o>=</span><span class=s1>&#39;dbname&#39;</span><span class=w> </span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 表相关
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>#</span><span class=w> </span><span class=mi>1</span><span class=p>.</span><span class=w> </span><span class=err>查询表的访问量</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w> </span><span class=n>table_schema</span><span class=p>,</span><span class=k>table_name</span><span class=p>,</span><span class=k>sum</span><span class=p>(</span><span class=n>io_read_requests</span><span class=o>+</span><span class=n>io_write_requests</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>io</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>sys</span><span class=p>.</span><span class=n>schema_table_statistics</span><span class=w> </span><span class=k>group</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>table_schema</span><span class=p>,</span><span class=k>table_name</span><span class=w> </span><span class=k>order</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>io</span><span class=w> </span><span class=k>desc</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=w> </span><span class=mi>2</span><span class=p>.</span><span class=w> </span><span class=err>查询占用</span><span class=n>bufferpool</span><span class=err>较多的表</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w> </span><span class=n>object_schema</span><span class=p>,</span><span class=n>object_name</span><span class=p>,</span><span class=n>allocated</span><span class=p>,</span><span class=k>data</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>from</span><span class=w> </span><span class=n>sys</span><span class=p>.</span><span class=n>innodb_buffer_stats_by_table</span><span class=w> </span><span class=k>order</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>allocated</span><span class=w> </span><span class=k>limit</span><span class=w> </span><span class=mi>10</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=w> </span><span class=mi>3</span><span class=p>.</span><span class=w> </span><span class=err>查看表的全表扫描情况</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>sys</span><span class=p>.</span><span class=n>statements_with_full_table_scans</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>db</span><span class=o>=</span><span class=s1>&#39;dbname&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 语句相关
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>#</span><span class=mi>1</span><span class=p>.</span><span class=w> </span><span class=err>监控</span><span class=n>SQL</span><span class=err>执行的频率</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w> </span><span class=n>db</span><span class=p>,</span><span class=n>exec_count</span><span class=p>,</span><span class=n>query</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>sys</span><span class=p>.</span><span class=n>statement_analysis</span><span class=w> </span><span class=k>order</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>exec_count</span><span class=w> </span><span class=k>desc</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=mi>2</span><span class=p>.</span><span class=w> </span><span class=err>监控使用了排序的</span><span class=k>SQL</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w> </span><span class=n>db</span><span class=p>,</span><span class=n>exec_count</span><span class=p>,</span><span class=n>first_seen</span><span class=p>,</span><span class=n>last_seen</span><span class=p>,</span><span class=n>query</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>from</span><span class=w> </span><span class=n>sys</span><span class=p>.</span><span class=n>statements_with_sorting</span><span class=w> </span><span class=k>limit</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=mi>3</span><span class=p>.</span><span class=w> </span><span class=err>监控使用了临时表或者磁盘临时表的</span><span class=k>SQL</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w> </span><span class=n>db</span><span class=p>,</span><span class=n>exec_count</span><span class=p>,</span><span class=n>tmp_tables</span><span class=p>,</span><span class=n>tmp_disk_tables</span><span class=p>,</span><span class=n>query</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>from</span><span class=w> </span><span class=n>sys</span><span class=p>.</span><span class=n>statement_analysis</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>tmp_tables</span><span class=o>&gt;</span><span class=mi>0</span><span class=w> </span><span class=k>or</span><span class=w> </span><span class=n>tmp_disk_tables</span><span class=w> </span><span class=o>&gt;</span><span class=mi>0</span><span class=w> </span><span class=k>order</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=p>(</span><span class=n>tmp_tables</span><span class=o>+</span><span class=n>tmp_disk_tables</span><span class=p>)</span><span class=w> </span><span class=k>desc</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- io相关
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>#</span><span class=mi>1</span><span class=p>.</span><span class=w> </span><span class=err>查看消耗磁盘</span><span class=n>IO</span><span class=err>的文件</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w> </span><span class=n>file</span><span class=p>,</span><span class=n>avg_read</span><span class=p>,</span><span class=n>avg_write</span><span class=p>,</span><span class=n>avg_read</span><span class=o>+</span><span class=n>avg_write</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>avg_io</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>from</span><span class=w> </span><span class=n>sys</span><span class=p>.</span><span class=n>io_global_by_file_by_bytes</span><span class=w> </span><span class=k>order</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>avg_read</span><span class=w> </span><span class=k>limit</span><span class=w> </span><span class=mi>10</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- innodb相关
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>#</span><span class=mi>1</span><span class=p>.</span><span class=w> </span><span class=err>行锁阻塞情况</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>sys</span><span class=p>.</span><span class=n>innodb_lock_waits</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><h1 id=索引优化与查询优化>索引优化与查询优化<a hidden class=anchor aria-hidden=true href=#索引优化与查询优化>#</a></h1><ul><li>物理查询优化： 索引、表连接</li><li>逻辑查询优化: 通过SQL等价变换提升查询效率，换一种写法</li></ul><blockquote><p>大多数情况下都（默认）采用<code>B+树</code>来构建索引。只是空间列类型的索引使用<code>R-树</code>，并且MEMORY表还支持<code>hash索引</code>。</p><p>其实，用不用索引，最终都是优化器说了算。优化器是基于什么的优化器？基于<code>cost开销(CostBaseOptimizer)</code>，它不是基于<code>规则(Rule-BasedOptimizer)</code>，也不是基于<code>语义</code>。怎么样开销小就怎么来。另外，<strong>SQL语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。</strong></p></blockquote><h2 id=索引失效场景>索引失效场景<a hidden class=anchor aria-hidden=true href=#索引失效场景>#</a></h2><blockquote><p>任何时候都不是绝对的，基于成本分析</p></blockquote><h3 id=全值匹配>全值匹配<a hidden class=anchor aria-hidden=true href=#全值匹配>#</a></h3><p>按照索引进行匹配，<strong>不会失效</strong></p><h3 id=最佳左前缀法则>最佳左前缀法则<a hidden class=anchor aria-hidden=true href=#最佳左前缀法则>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=o>-</span><span class=w> </span><span class=n>age</span><span class=err>建立索引</span><span class=w> </span><span class=n>name</span><span class=err>建立索引</span><span class=w> </span><span class=err>使用</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>SQL_NO_CACHE</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>student</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>student</span><span class=p>.</span><span class=n>age</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>30</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>student</span><span class=p>.</span><span class=n>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;abcd&#39;</span><span class=p>;</span><span class=w>	
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 只有索引age classid name 下面不会使用索引 但现在没有这样的索引，idx_age_classid_name的字段顺序是先找age，所以不符合，所以此时不能用索引
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>SQL_NO_CACHE</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>student</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>student</span><span class=p>.</span><span class=n>classid</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>student</span><span class=p>.</span><span class=n>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;abcd&#39;</span><span class=p>;</span><span class=w>	
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>SQL_NO_CACHE</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>student</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>student</span><span class=p>.</span><span class=n>age</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>30</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>student</span><span class=p>.</span><span class=n>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;abcd&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=w> </span><span class=err>现在，删除</span><span class=n>idx_age</span><span class=err>和</span><span class=n>idx_age_classid</span><span class=err>，发现用到</span><span class=n>idx_age_classid_name</span><span class=err>，而</span><span class=n>key_len</span><span class=o>=</span><span class=mi>5</span><span class=p>,</span><span class=err>即只用到</span><span class=n>age</span><span class=err>字段，</span><span class=nb>int</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span><span class=o>+</span><span class=k>null</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=err>因为索引完</span><span class=n>age</span><span class=err>后没有</span><span class=n>classid</span><span class=err>了，不能再查找到</span><span class=n>name</span><span class=w>
</span></span></span></code></pre></div><p>在MySQL建立联合索引时会遵守最佳左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p><p>结论：MySQL可以为多个字段创建索引，一个索引可以包括16个字段。对于多列索引，**过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。**如果查询条件中没有使用这些字段中第1个字段时，多列（或联合）索引不会被使用。</p><h3 id=主键插入顺序>主键插入顺序<a hidden class=anchor aria-hidden=true href=#主键插入顺序>#</a></h3><p>在定义表时，让主键auto_increment，否则，插入一条数据时可能会移动大量数据。
如，往 1 5 8 10 15 … 100 中插9，会放在8 10 中间，因为索引默认升序排列。那么10往后的数据都要挪动，页不够时又要放到下一页，每插一条数据都这样挪一次，开销很大
我们自定义的主键列id 拥有AUTO_INCREMENT 属性，在插入记录时存储引擎会自动为我们填入自增的主键值。这样的主键占用空间小，顺序写入，<strong>减少页分裂。</strong></p><h3 id=计算函数类型转换自动或手动导致索引失效>计算、函数、类型转换(自动或手动)导致索引失效<a hidden class=anchor aria-hidden=true href=#计算函数类型转换自动或手动导致索引失效>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=o>#####</span><span class=w> </span><span class=err>例</span><span class=mi>1</span><span class=err>：</span><span class=mi>3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>SQL_NO_CACHE</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>student</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>student</span><span class=p>.</span><span class=n>name</span><span class=w> </span><span class=k>LIKE</span><span class=w> </span><span class=s1>&#39;abc%&#39;</span><span class=p>;</span><span class=w>	</span><span class=o>#</span><span class=err>更好，能够使用上索引</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=w> </span><span class=k>type</span><span class=o>=</span><span class=n>range</span><span class=w> </span><span class=err>使用了索引中的排序</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>SQL_NO_CACHE</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>student</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=k>LEFT</span><span class=p>(</span><span class=n>student</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=mi>3</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;abc&#39;</span><span class=p>;</span><span class=w>	</span><span class=o>#</span><span class=w> </span><span class=k>left</span><span class=p>(</span><span class=nb>text</span><span class=p>,</span><span class=n>num_chars</span><span class=p>):</span><span class=err>截取左侧</span><span class=n>n</span><span class=err>个字符</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=w> </span><span class=k>type</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>all</span><span class=w> </span><span class=err>全表的访问</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=w> </span><span class=err>该语句的执行过程：针对每一条数据，一个一个取出，先作用一遍函数，再拿函数结果与</span><span class=n>abc</span><span class=err>对比，用不上</span><span class=n>b</span><span class=o>+</span><span class=err>树</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>idx_name</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>student</span><span class=p>(</span><span class=n>NAME</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#####</span><span class=w> </span><span class=err>例</span><span class=mi>2</span><span class=err>：</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>idx_sno</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>student</span><span class=p>(</span><span class=n>stuno</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>SQL_NO_CACHE</span><span class=w> </span><span class=n>id</span><span class=p>,</span><span class=n>stuno</span><span class=p>,</span><span class=n>NAME</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>student</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>stuno</span><span class=o>+</span><span class=mi>1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>900001</span><span class=p>;</span><span class=w> 	</span><span class=o>#</span><span class=w> </span><span class=k>type</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>all</span><span class=w> </span><span class=err>需要做运算，无法直接用索引找值</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>SQL_NO_CACHE</span><span class=w> </span><span class=n>id</span><span class=p>,</span><span class=n>stuno</span><span class=p>,</span><span class=n>NAME</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>student</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>stuno</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>900000</span><span class=p>;</span><span class=w> 	</span><span class=o>#</span><span class=w> </span><span class=k>type</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>ref</span><span class=w>
</span></span></span></code></pre></div><h3 id=类型转换导致索引失效>类型转换导致索引失效<a hidden class=anchor aria-hidden=true href=#类型转换导致索引失效>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=o>#</span><span class=w> </span><span class=err>未使用到索引</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>SQL_NO_CACHE</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>student</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>NAME</span><span class=o>=</span><span class=mi>123</span><span class=p>;</span><span class=w>	</span><span class=o>#</span><span class=w> </span><span class=err>这里使用了隐式转换</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=w> </span><span class=err>使用到索引</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>SQL_NO_CACHE</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>student</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>NAME</span><span class=o>=</span><span class=s1>&#39;123&#39;</span><span class=p>;</span><span class=w> 	</span><span class=o>#</span><span class=w> </span><span class=n>name</span><span class=err>本身就是字符串类型</span><span class=w>
</span></span></span></code></pre></div><h3 id=范围条件右边的列索引失效>范围条件右边的列索引失效<a hidden class=anchor aria-hidden=true href=#范围条件右边的列索引失效>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 存在索引 age classId name 但是下面只会使用到 age classId
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>SQL_NO_CACHE</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>student</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>student</span><span class=p>.</span><span class=n>age</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>30</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>student</span><span class=p>.</span><span class=n>classId</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>20</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>student</span><span class=p>.</span><span class=n>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;abc&#39;</span><span class=p>;</span><span class=w>	
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>--改写 添加所以你 age name classId 使用到了索引
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>SQL_NO_CACHE</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>student</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>student</span><span class=p>.</span><span class=n>age</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>30</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>student</span><span class=p>.</span><span class=n>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;abc&#39;</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>student</span><span class=p>.</span><span class=n>classId</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>20</span><span class=w> </span><span class=p>;</span><span class=w>	
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>创建的联合索引中，必须把涉及到范围的字段写在最后。</span><span class=w>
</span></span></span></code></pre></div><h3 id=不等于-或者索引失效>不等于(!= 或者&lt;>)索引失效<a hidden class=anchor aria-hidden=true href=#不等于-或者索引失效>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 不等于(!= 或者&lt;&gt;)索引失效
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>idx_name</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>student</span><span class=p>(</span><span class=n>NAME</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>SQL_NO_CACHE</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>student</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>student</span><span class=p>.</span><span class=n>name</span><span class=w> </span><span class=o>&lt;&gt;</span><span class=w> </span><span class=s1>&#39;abc&#39;</span><span class=p>;</span><span class=w>	</span><span class=o>#</span><span class=w> </span><span class=err>索引失效</span><span class=w> </span><span class=err>索引查的是等于</span><span class=w> </span><span class=err>这里是</span><span class=o>*</span><span class=w> 
</span></span></span></code></pre></div><blockquote><p>结论：最好在设计表结构的时候将字段设置为not null约束，比如可以将int 默认值设置成0。 将字符类型设置为空字符串</p><p>同理：在查询中not like 也无法使用到索引，导致全表扫描</p></blockquote><h3 id=is-null-可以使用索引-is-not-null-无法使用索引>is null 可以使用索引 is not null 无法使用索引<a hidden class=anchor aria-hidden=true href=#is-null-可以使用索引-is-not-null-无法使用索引>#</a></h3><p>is null : 触发索引</p><h3 id=like以通配符开头索引失效>like以通配符%开头索引失效<a hidden class=anchor aria-hidden=true href=#like以通配符开头索引失效>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=o>#</span><span class=w> </span><span class=n>like</span><span class=err>以通配符</span><span class=o>%</span><span class=err>开头索引失效</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>SQL_NO_CACHE</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>student</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>NAME</span><span class=w> </span><span class=k>LIKE</span><span class=w> </span><span class=s1>&#39;ab%&#39;</span><span class=p>;</span><span class=w>	</span><span class=o>#</span><span class=w> </span><span class=err>可用索引</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>SQL_NO_CACHE</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>student</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>NAME</span><span class=w> </span><span class=k>LIKE</span><span class=w> </span><span class=s1>&#39;%ab&#39;</span><span class=p>;</span><span class=w>	</span><span class=o>#</span><span class=w> </span><span class=k>type</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>all</span><span class=w> </span><span class=err>索引失效</span><span class=w>
</span></span></span></code></pre></div><p><strong>页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</strong></p><h3 id=or-前后存在非索引的列索引失效>OR 前后存在非索引的列，索引失效<a hidden class=anchor aria-hidden=true href=#or-前后存在非索引的列索引失效>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>SQL_NO_CACHE</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>student</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>age</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>10</span><span class=w> </span><span class=k>OR</span><span class=w> </span><span class=n>classid</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>100</span><span class=p>;</span><span class=w>	</span><span class=o>#</span><span class=w> </span><span class=err>未使用索引，索引</span><span class=o>+</span><span class=err>全表扫描</span><span class=o>-&gt;</span><span class=err>全表扫描</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- age是存在索引的，classId是没有索引的，导致全表all
</span></span></span><span class=line><span class=cl><span class=c1>-- 给classId添加索引 此时type为 index_merge,key = idx_age,idx_cid
</span></span></span></code></pre></div><h3 id=数据库和表的字符集统一使用utf8mb4>数据库和表的字符集统一使用utf8mb4<a hidden class=anchor aria-hidden=true href=#数据库和表的字符集统一使用utf8mb4>#</a></h3><p>统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的字符集进行比较前需要进行转换会造成索引失效。</p><p><strong>总结：</strong></p><ol><li>对于单利索引，进来选择对当前query过滤更好的索引</li><li>对于选择组合索引，对当前query过滤更好的索引字段顺序中，位置越靠前越好</li><li>在选择组合索引，尽量选择能够包含当前query的where字句中更多字段的索引</li><li>在选择组合索引，如果某个字段包含范围查询，尽量把这个字段放在索引次序的最后面</li></ol><h2 id=关联查询优化>关联查询优化<a hidden class=anchor aria-hidden=true href=#关联查询优化>#</a></h2><p>外连接的关联条件中，两个关联字段的类型、字符集一定要保持一致，否则索引会失效。外连接查询优化器也会做驱动表与被驱动表的修改。</p><blockquote><p>结论1：对于内连接来说，查询优化器可以决定谁来作为驱动表，谁作为被驱动表出现</p><p>结论2：对于内连接来讲，如果表的连接条件中只能有一个字段有索引，则有索引的字段所在的表会被作为被驱动表</p><p>结论3：对于内连接来说，在两个表的连接条件都存在索引的情况下，会选择小表作为驱动表。<code>小表驱动大表</code></p></blockquote><p><strong>内连接优化器</strong>可以<strong>决定</strong>（被）驱动表。在只有<strong>一个表存在索引</strong>的情况下，会选择<strong>存在索引的表</strong>作为<strong>被驱动表</strong>(因为被驱动表查询次数更多，建立索引以后可以<strong>避免全表扫描</strong>)</p><h2 id=join的底层原理>JOIN的底层原理<a hidden class=anchor aria-hidden=true href=#join的底层原理>#</a></h2><h3 id=1-驱动表与被驱动表>1. 驱动表与被驱动表<a hidden class=anchor aria-hidden=true href=#1-驱动表与被驱动表>#</a></h3><p>驱动表就是<strong>主表</strong>，被驱动表就是<strong>从表</strong></p><p>内连接，外连接优化器会根据优化结果选择先查询哪张表，这张表就是主表驱动表。</p><h3 id=2-simple-nested-loop-join-简单嵌套循环连接>2. Simple Nested Loop Join 简单嵌套循环连接<a hidden class=anchor aria-hidden=true href=#2-simple-nested-loop-join-简单嵌套循环连接>#</a></h3><p>算法过程：从A表取出一条数据，遍历B表所有数据进行匹配。驱动表A每一条记录与B进行匹配</p><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230610174106019.png alt=image-20230610174106019></p><p><strong>效率非常低</strong></p><h3 id=3-index-nested-loop-join-索引嵌套循环>3. Index Nested Loop Join 索引嵌套循环<a hidden class=anchor aria-hidden=true href=#3-index-nested-loop-join-索引嵌套循环>#</a></h3><p><strong>优化思路是减少内层表的数据匹配次数，所以要求对被驱动表建立索引</strong>。这样查询的转换成B+树的高度。通过外层表匹配条件直接与内层索引进行匹配，<strong>避免</strong>和内层表的<strong>每条记录进行比较</strong>，这样极<strong>大地减少</strong>了对内层表的匹配次数。<img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230610174249335.png alt=image-20230610174249335></p><p>驱动表中的每条记录通过被驱动表的<strong>索引</strong>进行访问，因为索引查询的成本是比较固定的，故 MySQL 优化器都倾向于使用有索引的表作为被驱动表（减少被驱动表的多次全表扫描）</p><p>如果被驱动表加索引，效率是非常高的，如果索引<strong>不是主键索引</strong>，所以还得进行一次<strong>回表</strong>查询。相比，被驱动表的索引<strong>是主键索引</strong>，<strong>效率会更高</strong></p><h3 id=4-blocked-nested-loop-join-块嵌套循环连接>4. Blocked Nested Loop Join 块嵌套循环连接<a hidden class=anchor aria-hidden=true href=#4-blocked-nested-loop-join-块嵌套循环连接>#</a></h3><p>如果存在索引，使用INLJ进行，如果join列没有索引，匹配的扫描次数又大大增加。每次访问被驱动表，其表中的记录都会被<strong>加载到内存</strong>中，然后再从驱动表中取一条与其匹配，匹配结束后<strong>清除内存</strong>，然后再<strong>从驱动表中加载一条记录</strong>，然后把驱动表的记录<strong>再加载到内存</strong>匹配，这样<strong>周而复始</strong>，大大增加了 IO 次数。为了减少被驱动表的 IO 次数，就出现了 Block Nested-Loop Join 的方式。</p><p>不再是<strong>逐条</strong>获取驱动表的数据，而是<strong>一块一块</strong>的获取，引入了 join buffer 缓冲区，将驱动表 join 相关的部分数据列（大小受 join buffer 的限制）<strong>缓存到 join buffer 中</strong>，然后<strong>全表扫描</strong>被驱动表，被驱动表的每一条记录一次性和 join buffer 中的所有驱动表记录进行匹配（内存中操作），将<strong>简单嵌套循环</strong>中的<code>多次比较</code><strong>合并</strong>成<code>一次</code>，<strong>降低了被动表的访问频率</strong>。</p><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=err>注意：</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>这里缓存的不只是关联表的列，</span><span class=k>select</span><span class=w> </span><span class=err>后面的列也会缓存起来</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>在一个有</span><span class=w> </span><span class=n>N</span><span class=w> </span><span class=err>个</span><span class=w> </span><span class=k>join</span><span class=w> </span><span class=err>关联的</span><span class=w> </span><span class=k>SQL</span><span class=w> </span><span class=err>中会分配</span><span class=w> </span><span class=n>N</span><span class=o>-</span><span class=mi>1</span><span class=w> </span><span class=err>个</span><span class=w> </span><span class=k>join</span><span class=w> </span><span class=n>buffer</span><span class=err>。所以查询的时候尽量减少不必要的字段，可以</span><span class=w> </span><span class=err>让</span><span class=w> </span><span class=k>join</span><span class=w> </span><span class=n>buffer</span><span class=w> </span><span class=err>中存放更多的列。</span><span class=w>
</span></span></span></code></pre></div></blockquote><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230610174555178.png alt=image-20230610174555178></p><p><strong>Join Buffe参数设置</strong></p><ul><li><p>block_nested_loop</p><p>通过 <code>show variables like '%optimizer_switch%'</code> 查看 <code>block_nested_loop</code> 状态。默认是开启的。</p></li><li><p>join_buffer_size</p><p>驱动表能不能一次加载完，要看 join buffer 能不能存储所有的数据，默认情况下 <code>join_buffer_size = 256K</code>。</p><p>join <em>buffer</em> size 的最大值在 32 位系统可以申请 4G，而在 64 位操做系统下可以申请大于 4G 的 join_buffer空间（64 位 Windows 除外，其大值会被截断为 4GB并发出警告）。</p></li></ul><h3 id=小结>小结<a hidden class=anchor aria-hidden=true href=#小结>#</a></h3><ol><li>保证被驱动表的 JOIN 字段已经创建了索引（减少内层表的循环匹配次数）</li><li>需要 JOIN 的字段，数据类型保持绝对一致。</li><li>LEFT JOIN 时，选择小表作为驱动表， 大表作为被驱动表 。减少外层循环的次数。</li><li>INNER JOIN 时，MySQL 会自动将小结果集的表选为驱动表 。选择相信 MySQL 优化策略。</li><li>能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数)</li><li><strong>不建议使用多层嵌套子查询，建议将子查询 SQL 拆开结合程序多次查询，或使用 JOIN 来代替子查询。</strong></li><li>衍生表建不了索引</li><li>默认效率比较：INLJ > BNLJ > SNLJ</li><li>正确理解小表驱动大表：<strong>大小不是指表中的记录数，而是永远用小结果集驱动大结果集（其本质就是减少外层循环的数据数量）</strong>。 比如A表有100条记录，B表有1000条记录，但是where条件过滤后，B表结果集只留下50个记录，A表结果集有80条记录，此时就可能是B表驱动A表。其实上面的例子还是不够准确，因为结果集的大小也不能粗略的用结果集的行数表示，而是表行数 <em>每行大小。其实要理解你只需要结合Join Buffer就好了，因为表行数</em> 每行大小越小，其占用内存越小,就可以在Join Buffer中尽量少的次数加载完了。</li></ol><h3 id=hashjoin>HashJoin<a hidden class=anchor aria-hidden=true href=#hashjoin>#</a></h3><p>从 MySQL 8.0.20 版本开始将废弃 BNLJ，因为加入了 hash join 默认都会使用 hash join</p><ul><li><p>Nested Loop：</p><p>对于被连接的数据子集较小的情况，Nested Loop 是个较好的选择。</p></li><li><p>Hash Join 是做 <strong>大数据集连接</strong> 时的常用方法，优化器使用两个表中较小（相对较小）的表利用 join key 在内存中建立 <strong>散列表</strong>，然后扫描较大的表并探测散列表，找出与 Hash 表匹配的行。</p><ul><li>这种方式适用于较小的表完全可以放于内存中的情况，这样总成本就是访问两个表的成本之和</li><li>在表很大的情况下并不能完全放入内存，这时优化器会将它分割成 若干不同的分区，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高 I/O 的性能。</li><li>它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。大多数人都说它是 Join 的重型升降机。Hash Join 只能应用于等值连接（如 WHERE A.COL1 = B.COL2），这是由 Hash 的特点决定的。</li></ul></li></ul><table><thead><tr><th style=text-align:left>类型</th><th style=text-align:left>Nested Loop</th><th style=text-align:left>Hash Join</th></tr></thead><tbody><tr><td style=text-align:left>使用条件</td><td style=text-align:left>任何条件</td><td style=text-align:left>等值连接（=）</td></tr><tr><td style=text-align:left>相关资源</td><td style=text-align:left>CPU、磁盘 I/O</td><td style=text-align:left>内存、临时空间</td></tr><tr><td style=text-align:left>特点</td><td style=text-align:left>当有高选择性索引或进行限制性搜索时效率比较高，能够快速返回第一次的搜索结果</td><td style=text-align:left>当缺乏索引或者索引条件模糊时，Hash Join 比 Nested Loop 有效。在数据仓库环境下，如果表的记录数多，效率高</td></tr><tr><td style=text-align:left>缺点</td><td style=text-align:left>当索引丢失或者查询条件限制不够时，效率很低；当表的记录数较多，效率低</td><td style=text-align:left>为遍历哈希表，需要大量内存。第一次的结果返回较慢</td></tr></tbody></table><h2 id=子查询优化>子查询优化<a hidden class=anchor aria-hidden=true href=#子查询优化>#</a></h2><p>MySQL 从 4.1 版本开始支持子查询，使用子查询可以进行 SELECT 语句的嵌套查询，即一个 SELECT 查询的结果作为另一个 SELECT 语句的条件。子查询可以一次性完成很多逻辑上需要多个步骤才能完成的操作 。</p><p>子查询是 MySQL 的一项重要的功能，可以帮助我们通过一个 SQL 语句实现比较复杂的查询。但是，子查询的执行效率不高。</p><p>原因:</p><p>执行子查询时，MySQL 需要为内层查询语句的查询结果建立一<strong>个临时表</strong> ，然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表 。这样会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都 不会存在索引 ，所以查询性能会受到一定的影响。 对于返回结果集比较大的子查询，其对查询性能的影响也就越大。 在 MySQL 中，可以使用连接（JOIN）查询来替代子查询。 连接查询 不需要建立临时表，其 速度比子查询要快，如果查询中使用索引的话，性能就会更好。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=o>#</span><span class=err>创建班级表中班长的索引</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>idx_monitor</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=k>class</span><span class=p>(</span><span class=n>monitor</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=err>查询班长的信息</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>student</span><span class=w> </span><span class=n>stu1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>WHERE</span><span class=w> </span><span class=n>stu1</span><span class=p>.</span><span class=o>`</span><span class=n>stuno</span><span class=o>`</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>SELECT</span><span class=w> </span><span class=n>monitor</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>FROM</span><span class=w> </span><span class=k>class</span><span class=w> </span><span class=k>c</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>WHERE</span><span class=w> </span><span class=n>monitor</span><span class=w> </span><span class=k>IS</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 改写
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>stu1</span><span class=p>.</span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>student</span><span class=w> </span><span class=n>stu1</span><span class=w> </span><span class=k>JOIN</span><span class=w> </span><span class=k>class</span><span class=w> </span><span class=k>c</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ON</span><span class=w> </span><span class=n>stu1</span><span class=p>.</span><span class=o>`</span><span class=n>stuno</span><span class=o>`</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>c</span><span class=p>.</span><span class=o>`</span><span class=n>monitor</span><span class=o>`</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=k>c</span><span class=p>.</span><span class=o>`</span><span class=n>monitor</span><span class=o>`</span><span class=w> </span><span class=k>IS</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=err>查询不为班长的学生信息</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>SQL_NO_CACHE</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=o>*</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>student</span><span class=w> </span><span class=n>a</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w>  </span><span class=n>a</span><span class=p>.</span><span class=n>stuno</span><span class=w>  </span><span class=k>NOT</span><span class=w>  </span><span class=k>IN</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>SELECT</span><span class=w> </span><span class=n>monitor</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=k>class</span><span class=w> </span><span class=n>b</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>WHERE</span><span class=w> </span><span class=n>monitor</span><span class=w> </span><span class=k>IS</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 改写
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>SQL_NO_CACHE</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=o>*</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w>  </span><span class=n>student</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=k>LEFT</span><span class=w> </span><span class=k>OUTER</span><span class=w> </span><span class=k>JOIN</span><span class=w> </span><span class=k>class</span><span class=w> </span><span class=n>b</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ON</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=n>stuno</span><span class=w> </span><span class=o>=</span><span class=n>b</span><span class=p>.</span><span class=n>monitor</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=n>b</span><span class=p>.</span><span class=n>monitor</span><span class=w> </span><span class=k>IS</span><span class=w> </span><span class=k>NULL</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p><strong>TIP：尽量不要使用 NOT IN 或者 NOT EXISTS，用 LEFT JOIN xxx ON xx WHERE xx IS NULL 替代</strong></p><h2 id=排序优化>排序优化<a hidden class=anchor aria-hidden=true href=#排序优化>#</a></h2><p>问题：在 WHERE 条件字段上加索引，但是为什么在 ORDER BY 字段上还要加索引呢？</p><ul><li>在 MySQL 中，支持两种排序方式，分别是 <strong>FileSort</strong> 和 <strong>Index</strong> 排序。 Index 排序中，索引可以保证数据的有序性，就不需要再进行排序，效率更更高。</li><li><strong>FileSort</strong> 排序则一般在 内存中 进行排序，占用 CPU 较多。如果待排序的结果较大，会产生临时文件 I/O 到磁盘进行排序的情况，效率低。</li></ul><p>优化建议:</p><ul><li>SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中 避免全表扫描，在 ORDER BY 子句 避免使用 FileSort 排序。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。</li><li>尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列；如果不同就使用联合索引。</li><li>无法使用 Index 时，需要对 FileSort 方式进行调优。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 当前age classId,name 是有索引的
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>SQL_NO_CACHE</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>student</span><span class=w> </span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>age</span><span class=p>,</span><span class=n>classid</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=mi>1</span><span class=w>	</span><span class=k>SIMPLE</span><span class=w>	</span><span class=n>student</span><span class=w>		</span><span class=k>ALL</span><span class=w>					</span><span class=mi>498881</span><span class=w>	</span><span class=mi>100</span><span class=p>.</span><span class=mi>00</span><span class=w>	</span><span class=k>Using</span><span class=w> </span><span class=n>filesort</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 没有使用索引的原因是，优化器通过计算分析，发现最终还是需要回表，使用索引的性能代价反而比不上不用索引的
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>EXPLAIN</span><span class=w>  </span><span class=k>SELECT</span><span class=w> </span><span class=n>SQL_NO_CACHE</span><span class=w> </span><span class=n>age</span><span class=p>,</span><span class=n>classid</span><span class=p>,</span><span class=n>name</span><span class=p>,</span><span class=n>id</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>student</span><span class=w> </span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>age</span><span class=p>,</span><span class=n>classid</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 这里就使用到了索引,覆盖索引
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>EXPLAIN</span><span class=w>  </span><span class=k>SELECT</span><span class=w> </span><span class=n>SQL_NO_CACHE</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>student</span><span class=w> </span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>age</span><span class=p>,</span><span class=n>classid</span><span class=w> </span><span class=k>LIMIT</span><span class=w> </span><span class=mi>10</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 使用limit使用到了索引，因为优化器发现只需要10条，先根据索引查询，在回表返回10条数据
</span></span></span></code></pre></div><ul><li>order by 时顺序错误，索引失效</li><li>order by 时规则不一致, 索引失效 （顺序错，不索引；方向反，不索引）
规则： 同时升序或者同时降序 顺序：索引建立的顺序</li><li>无过滤，不索引</li></ul><p><strong>上述是与其数据量有关的</strong></p><blockquote><p><strong>INDEX a_b_c(a,b,c) order by 能使用索引最左前缀</strong></p></blockquote><ul><li>ORDER BY a</li><li>ORDER BY a,b</li><li>ORDER BY a,b,c</li><li>ORDER BY a DESC,b DESC,c DESC 如果 WHERE 使用索引的最左前缀定义为常量，则 order by 能使用索引</li><li>WHERE a = const ORDER BY b,c</li><li>WHERE a = const AND b = const ORDER BY c</li><li>WHERE a = const ORDER BY b,c</li><li>WHERE a = const AND b > const ORDER BY b,c</li></ul><p>不能使用索引进行排序</p><ul><li>ORDER BY a ASC,b DESC,c DESC /* 排序不一致 */</li><li>WHERE g = const ORDER BY b,c /<em>丢失a索引</em>/</li><li>WHERE a = const ORDER BY c /<em>丢失b索引</em>/</li><li>WHERE a = const ORDER BY a,d /<em>d不是索引的一部分</em>/</li><li>WHERE a in (…) ORDER BY b,c /<em>对于排序来说，多个相等条件也是范围查询</em></li></ul><h3 id=filesort算法>filesort算法<a hidden class=anchor aria-hidden=true href=#filesort算法>#</a></h3><p>排序的字段不在索引列上，filesort会有两种算法: 双路排序和单路排序</p><ul><li><p>双路排序 - 慢</p><p>MySQL4.1之前使用双路排序。两次扫描磁盘，最终得到数据。读取行指针和order by 列，然后从扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出。从磁盘读取字段，在buffer排序，在从磁盘读取其他字段，产生随机IO,比较耗时</p></li><li><p>单路排序 - 块
从磁盘读取查询需要的 所有列 ，按照 order by 列在 buffer 对它们进行排序，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据。并且把随机 IO 变成了顺序 IO，但是它会使用更多的空间， 因为它把每一行都保存在内存中了。</p></li></ul><blockquote><p>由于单路是后出的，总体而言好过双路 但是用单路有问题 在 sort_buffer 中，单路比多路要 多占用很多空间，因为单路是把所有字段都取出，所以可能取出的数据的总大小超出了 sort_buffer 的容量，导致每次只能取 sort_buffer 容量大小的数据，进行排序（创建 temp 文件，多路合并），排完再取 sort_buffer 容量大小，再排…从而多次I/O。 单路本来想省一次 I/O 操作，反而导致了大量的 I/O 操作，反而得不偿失。</p><p>优化策略：</p><ul><li>提高 sort_buffer_size</li><li>提高max_length_for_sort_data
SHOW VARIABLES LIKE &lsquo;%max_length_for_sort_data%&rsquo;;</li></ul><p>但是如果设的太高，数据总容量超出 sort_buffer_size 的概率就增大，明显症状是高的磁盘 I/O 活动和低的处理器使用率。如果需要返回的列的总长度大于 max_length_for_sort_data，使用双路算法，否则使用单路算法。1024-8192字节之间调整。</p><p>Order by 时 select 是一个大忌。最好只Query需要的字段。</p><p>当 Query 的字段大小综合小于 max_length_for_sort_data，而且排序字段不是 TEXT|BLOG 类型时，会改进后的算法——单路排序，否则用老算法——多路排序。 两种算法的数据都有可能超出 sort_buffer_size 的容量，超出之后，会创建 tmp 文件进行合并排序，导致多次 I/O，但是用单路排序算法的风险会更大一些，所以要提高 sort_buffer_size</p></blockquote><h2 id=group-by优化>Group By优化<a hidden class=anchor aria-hidden=true href=#group-by优化>#</a></h2><ul><li><p>group by 使用索引的原则几乎跟 order by 一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引。</p></li><li><p>group by 先排序再分组，遵照索引建的最佳左前缀法则</p></li><li><p>当无法使用索引列，增大 max_length_for_sort_data 和 sort_buffer_size 参数的设置</p></li><li><p>where 效率高于 having，能写在 where 限定的条件就不要写在 having 中了</p></li><li><p>减少使用 order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct 这些语句较为耗费 CPU，数据库的 CPU 资源是极其宝贵的</p></li><li><p>包含了 order by、group by、distinct 这些查询的语句，where 条件过滤出来的结果集请保持在 1000 行以内，否则 SQL 会很慢</p></li></ul><h2 id=分页查询优化>分页查询优化<a hidden class=anchor aria-hidden=true href=#分页查询优化>#</a></h2><p>一般分页查询时，通过创建<a href="https://so.csdn.net/so/search?q=%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95&amp;spm=1001.2101.3001.7020">覆盖索引</a>能够比较好地提高性能。一个常见有非常头疼的问题就是 limit 2000000,10，此时需要 MySQL 排序前 2000010 记录，仅仅返回 2000000-2000010 的记录，其他记录丢弃，查询排序的代价非常大。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>student</span><span class=w> </span><span class=k>LIMIT</span><span class=w> </span><span class=mi>2000000</span><span class=p>,</span><span class=mi>10</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><h3 id=优化思路1>优化思路1<a hidden class=anchor aria-hidden=true href=#优化思路1>#</a></h3><p>该方案适用于主键自增的表，可以把 Limit 查询转换成某个位置的查询</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>student</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>2000000</span><span class=w> </span><span class=k>LIMIT</span><span class=w> </span><span class=mi>10</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><h3 id=优化思路2>优化思路2<a hidden class=anchor aria-hidden=true href=#优化思路2>#</a></h3><p>在索引完成排序分页操作，最后根据主键关联到原表进行查询所需要的其它列内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>student</span><span class=w> </span><span class=n>t</span><span class=p>,(</span><span class=k>SELECT</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>student</span><span class=w> </span><span class=k>order</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=k>limit</span><span class=w> </span><span class=mi>2000000</span><span class=p>,</span><span class=w> </span><span class=mi>10</span><span class=p>)</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>t</span><span class=p>.</span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=n>id</span><span class=w>
</span></span></span></code></pre></div><h2 id=覆盖索引>覆盖索引<a hidden class=anchor aria-hidden=true href=#覆盖索引>#</a></h2><h3 id=覆盖索引的定义>覆盖索引的定义<a hidden class=anchor aria-hidden=true href=#覆盖索引的定义>#</a></h3><p><strong>索引列+主键 包含 SELECT 到 FROM 之间查询的列</strong>，<strong>不需要进行回表</strong></p><blockquote><p>定义规则，再进行打破</p></blockquote><h3 id=利弊>利弊<a hidden class=anchor aria-hidden=true href=#利弊>#</a></h3><h4 id=好处>好处<a hidden class=anchor aria-hidden=true href=#好处>#</a></h4><ol><li>避免InnoDB表进行回表
在覆盖索引中，二级索引的键值中可以获取所要的数据，避免了对主键的二次查询，减少了 IO 操作，提升了查询效率。</li><li>把随机IO变成顺序IO
由于覆盖索引是按键值的顺序存储的，对于 I/O 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 I/O 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 I/O 转变成索引查找的顺序 I/O。
<strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong></li></ol><h4 id=弊端>弊端<a hidden class=anchor aria-hidden=true href=#弊端>#</a></h4><p>索引字段的维护 总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务 DBA，或者称为业务数据架构师的工作。</p><h2 id=索引条件下推>索引条件下推<a hidden class=anchor aria-hidden=true href=#索引条件下推>#</a></h2><blockquote><p>需要回表，条件下推才有意义，如果是聚餐索引查询或者覆盖索引使用不到</p></blockquote><p>索引下推（Index Condition Pushdown, 简称ICP）是MySQL 5.6 版本的新特性，它能减少回表查询次数，提升检索效率。</p><h3 id=使用前后>使用前后<a hidden class=anchor aria-hidden=true href=#使用前后>#</a></h3><p><strong>在不使用ICP索引扫描的过程：</strong></p><p>storage层：只将满足index key条件的索引记录对应的整行记录取出，返回给server层</p><p>server 层：对返回的数据，使用后面的where条件过滤，直至返回最后一行。</p><p><strong>使用ICP扫描的过程：</strong></p><p>storage层：首先将index key条件满足的索引记录区间确定，然后在索引上使用index filter进行过滤。将满足的index filter条件的索引记录才去回表取出整行记录返回server层。不满足index filter条件的索引记录丢弃，不回表、也不会返回server层。</p><p>server 层：对返回的数据，使用table filter条件做最后的过滤。</p><h3 id=适用条件>适用条件<a hidden class=anchor aria-hidden=true href=#适用条件>#</a></h3><ol><li>当需要访问整表行时，ICP用于range、ref、eq_ref和ref_or_null访问方法。</li><li>ICP可以用于InnoDB和MyISAM表，包括分区的InnoDB和MyISAM表。</li><li>对于InnoDB表，ICP仅用于二级索引。ICP的目标是减少整行读取的数量，从而减少I/O操作。对于InnoDB聚集索引，完整的记录已经读入InnoDB缓冲区。在这种情况下使用ICP并不能减少I/O。（注意：Ⅰ说明减少<strong>完整记录（一条完整元组）读取的个数</strong>；Ⅱ是说明对于InnoDB聚集索引无效，只能是对SECOND INDEX这样的非聚集索引有效。）</li><li>在虚拟生成的列上创建的辅助索引不支持ICP。InnoDB支持虚拟生成列的二级索引。</li><li>引用子查询的条件不能向下推。</li><li>引用存储函数的条件不能向下推。存储引擎不能调用存储函数。</li><li>触发条件不能下推。</li></ol><h3 id=icp的开启和关闭>ICP的开启和关闭<a hidden class=anchor aria-hidden=true href=#icp的开启和关闭>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=err>索引条件默认启用“下推”。可以通过设置</span><span class=n>index_condition_pushdown</span><span class=err>标志来控制</span><span class=n>optimizer_switch</span><span class=err>系统变量</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SET</span><span class=w> </span><span class=n>optimizer_switch</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;index_condition_pushdown=off&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SET</span><span class=w> </span><span class=n>optimizer_switch</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;index_condition_pushdown=on&#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><h2 id=其他查询优化策略>其他查询优化策略<a hidden class=anchor aria-hidden=true href=#其他查询优化策略>#</a></h2><h3 id=exists-与-in-区分>exists 与 in 区分<a hidden class=anchor aria-hidden=true href=#exists-与-in-区分>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=o>#</span><span class=w> </span><span class=err>大表</span><span class=n>A</span><span class=err>驱动小表</span><span class=n>cc</span><span class=err>时用</span><span class=k>in</span><span class=err>；即当</span><span class=n>A</span><span class=err>表的数据量大于</span><span class=n>B</span><span class=err>表的数据量时</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>A</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>cc</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=n>CC</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>B</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=w> </span><span class=err>当</span><span class=n>A</span><span class=err>表的数据量小于</span><span class=n>B</span><span class=err>表的数据量时</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=w> </span><span class=err>小表</span><span class=n>A</span><span class=err>驱动大表</span><span class=n>cc</span><span class=err>时用</span><span class=k>EXISTS</span><span class=w> </span><span class=err>，因为执行时每次是从</span><span class=n>A</span><span class=err>中取一条数据到</span><span class=k>SELECT</span><span class=w> </span><span class=n>cc</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>B</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>B</span><span class=p>.</span><span class=n>cc</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=n>cc</span><span class=err>中执行，</span><span class=n>A</span><span class=err>小一点更合适</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>A</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=k>EXISTS</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=n>cc</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>B</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>B</span><span class=p>.</span><span class=n>cc</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=n>cc</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><h3 id=count与count具体字段效率>COUNT(*)与COUNT(具体字段)效率<a hidden class=anchor aria-hidden=true href=#count与count具体字段效率>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=err>与</span><span class=k>COUNT</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=err>都是统计表的所有数量，效率差别不大</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>如果使用</span><span class=n>MyISAM</span><span class=err>存储引擎，统计数据表的行数只需要</span><span class=n>O</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=err>的复杂度</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>如果使用</span><span class=n>InnoDB</span><span class=err>存储引擎，使用</span><span class=n>O</span><span class=p>(</span><span class=n>n</span><span class=p>)</span><span class=err>的复杂度</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>在</span><span class=n>InnoDB</span><span class=err>存储引擎中，如果使用</span><span class=k>Count</span><span class=p>(</span><span class=err>具体字段</span><span class=p>)</span><span class=err>来统计数据行数，尽量采用二级索引，如果没有二级索引，才使用主键索引来使用</span><span class=w>
</span></span></span></code></pre></div><h3 id=select-字段>select 字段<a hidden class=anchor aria-hidden=true href=#select-字段>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=err>在表查询中，建议明确字段，不要使用</span><span class=o>*</span><span class=err>作为查询的字段列表，推荐使用</span><span class=k>SELECT</span><span class=o>&lt;</span><span class=err>字段列表</span><span class=o>&gt;</span><span class=err>查询。原因：</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>①</span><span class=n>MySQL</span><span class=err>在解析的过程中，会通过查询数据字典将</span><span class=s2>&#34;*&#34;</span><span class=err>按序转换成所有列名，这会大大的耗费资源和时间。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>②无法使用覆盖索引</span><span class=w>
</span></span></span></code></pre></div><h3 id=limit-1-对优化的影响>limit 1 对优化的影响<a hidden class=anchor aria-hidden=true href=#limit-1-对优化的影响>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=err>针对的是会扫描全表的</span><span class=n>SQL</span><span class=err>语句，如果你可以确定结果集只有一条，那么加上</span><span class=k>LIMIT</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=err>的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上</span><span class=k>LIMIT</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=err>了。</span><span class=w>
</span></span></span></code></pre></div><h3 id=多使用commit>多使用COMMIT<a hidden class=anchor aria-hidden=true href=#多使用commit>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=err>只要有可能，在程序中尽量多使用</span><span class=k>COMMIT</span><span class=err>，这样程序的性能得到提高，需求也会因为</span><span class=n>COMMIT</span><span class=err>所释放的资源而减少。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>COMMIT</span><span class=err>所释放的资源：</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=err>回滚段上用于恢复数据的信息</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=err>被程序语句获得的锁</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>redo</span><span class=o>/</span><span class=w> </span><span class=n>undo</span><span class=w> </span><span class=n>log</span><span class=w> </span><span class=n>buffer</span><span class=w> </span><span class=err>中的空间</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=err>管理上述</span><span class=mi>3</span><span class=err>种资源中的内部花费</span><span class=w>
</span></span></span></code></pre></div><h1 id=淘宝数据库主键如何设计>淘宝数据库主键如何设计<a hidden class=anchor aria-hidden=true href=#淘宝数据库主键如何设计>#</a></h1><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230611134726925.png alt=image-20230611134726925></p><h3 id=自增id问题>自增ID问题<a hidden class=anchor aria-hidden=true href=#自增id问题>#</a></h3><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230611134752779.png alt=image-20230611134752779></p><h3 id=业务系统做主键>业务系统做主键<a hidden class=anchor aria-hidden=true href=#业务系统做主键>#</a></h3><p><strong>尽量不要用根业务有关的字段做主键，比较作为项目的设计人员，我们谁也无法预测在项目的整个生命周期中，哪个业务字段会因为业务的需求有重复，或者重用的情况出现。</strong></p><blockquote><p>刚开始使用MySQL时候，很多人都很容易犯的错误喜欢用业务字段做主键，想当然的认为了解业务需求，但实际情况往往出乎意料，而更改主键设置的成本非常高</p></blockquote><h3 id=淘宝的主键设计>淘宝的主键设计<a hidden class=anchor aria-hidden=true href=#淘宝的主键设计>#</a></h3><p><strong>订单ID = 时间 + 去重字段 + 用户ID后6位尾号</strong></p><h3 id=推荐的主键设计>推荐的主键设计<a hidden class=anchor aria-hidden=true href=#推荐的主键设计>#</a></h3><blockquote><h4 id=主键设计至少应该是全局唯一且是单调递增>主键设计至少应该是全局唯一且是单调递增。<a hidden class=anchor aria-hidden=true href=#主键设计至少应该是全局唯一且是单调递增>#</a></h4></blockquote><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230611135139209.png alt=image-20230611135139209></p><h4 id=uuid>UUID<a hidden class=anchor aria-hidden=true href=#uuid>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>uuid</span><span class=p>()</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>DUAL</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><h5 id=特点>特点<a hidden class=anchor aria-hidden=true href=#特点>#</a></h5><p>全局唯一，占用36字节，数据无序，插入性能查</p><h4 id=mysql-uuid组成>MySQL UUID组成<a hidden class=anchor aria-hidden=true href=#mysql-uuid组成>#</a></h4><p><strong>UUID = 时间+UUID版本（16字节）- 时钟序列（4字节） - MAC地址（12字节）</strong></p><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230611135345985.png alt=image-20230611135345985></p><h4 id=改造uuid>改造UUID<a hidden class=anchor aria-hidden=true href=#改造uuid>#</a></h4><blockquote><h4 id=mysql-80可以更换时间低位和时间高位的存储方式这样uuid就是有序的uuid了>MySQL 8.0可以更换时间低位和时间高位的存储方式，这样UUID就是有序的UUID了。<a hidden class=anchor aria-hidden=true href=#mysql-80可以更换时间低位和时间高位的存储方式这样uuid就是有序的uuid了>#</a></h4></blockquote><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230611135422552.png alt=image-20230611135422552></p><h4 id=如果不是mysql8httpssocsdnnetsosearchqmysql8spm10012101300170200-如何解决>如果不是<a href="https://so.csdn.net/so/search?q=MySQL8&amp;spm=1001.2101.3001.7020">MySQL8</a>.0 如何解决<a hidden class=anchor aria-hidden=true href=#如果不是mysql8httpssocsdnnetsosearchqmysql8spm10012101300170200-如何解决>#</a></h4><p><strong>手动赋值字段做主键</strong></p><p><img loading=lazy src=C:%5cUsers%5c15667%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20230611135551610.png alt=image-20230611135551610></p></div><footer class=post-footer><nav class=paginav><a class=prev href=https://AlfredNing.github.io/note/program/sql/mysql/mysql%E9%AB%98%E7%BA%A7-%E4%BA%8B%E5%8A%A1/><span class=title>« 上一页</span><br><span>MySql高级 事务</span></a>
<a class=next href=https://AlfredNing.github.io/note/program/front_end/vue/><span class=title>下一页 »</span><br><span>Vue</span></a></nav></footer></div><div><div class=pagination__title><span class=pagination__title-h style=font-size:20px>💬评论</span><hr></div><div id=tcomment></div><script src=https://utteranc.es/client.js repo=AlfredNing/AlfredNing.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2023 <a href=https://AlfredNing.github.io>AlfredNing</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>