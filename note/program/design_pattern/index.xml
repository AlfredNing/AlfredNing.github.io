<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>设计模式 on AlfredNing</title>
    <link>https://AlfredNing.github.io/note/program/design_pattern/</link>
    <description>Recent content in 设计模式 on AlfredNing</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 06 Jan 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://AlfredNing.github.io/note/program/design_pattern/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>构建者模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E6%9E%84%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 07 Feb 2023 22:47:44 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E6%9E%84%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>分离对象的的属性与创建过程，用户创建重的对象。
写法分类：
在Builder里面直接new对象的方式，MyBatis的SqlSessionFactoryBuilder就是这种写法，适用于属性之间关联不多且大量属性都有默认值的场景。 间接new的方式：例如Guava的Cache都是这种写法，适用于属性之间有一定关联性的场景。 建造者模式的优点及适用场景
建造者模式这种设计模式，优缺点比较明显。从优点来说：
客户端不比知道产品内部细节，将产品本身与产品创建过程解耦，使得相同的创建过程可以创建不同的产品对象 可以更加精细地控制产品的创建过程，将复杂对象分门别类抽出不同的类别来，使得开发者可以更加方便地得到想要的产品 想了想，说缺点，建造者模式说不上缺点，只能说这种设计模式的使用比较受限：
产品属性之间差异很大且属性没有默认值可以指定，这种情况是没法使用建造者模式的，我们可以试想，一个对象20个属性，彼此之间毫无关联且每个都需要手动指定，那么很显然，即使使用了建造者模式也是毫无作用 代码示例</description>
    </item>
    
    <item>
      <title>访问者模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 07 Feb 2023 21:17:34 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>对象的行为模式。在不修改已有程序的前提下，通过添加额外的访问者来完成对已有代码功能的提升。
将数据结构与操作分离
角色：
抽象访问者: 声明了一个或者多个方法操作，形成所有的具体访问者角色必须实现的接口 具体访问者: 实现抽象访问者所声明的接口，也就是抽象访问者所声明的各个访问操作 抽象节点: 声明一个接受操作，接受一个访问者对象作为一个参数 具体节点: 实现了抽象节点所规定的接受操作 结构对象: 遍历结构的元素 访问者模式优点：
扩展性好，可以在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能； 符合单一职责原则，通过访问者将无关的行为分离，使职责单一；
访问者模式缺点：
违反了迪米特原则，因为具体元素对访问者公布细节； 违反了依赖倒置原则，依赖了具体类，没有依赖抽象； 对象结构变化困难，若对象结构发生了改变，访问者的接口和访问者的实现也都要发生相应的改变；
使用场景：
对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作； 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作&amp;quot;污染&amp;quot;这些对象的类，也不希望在增加新操作时修改这些类。
访问者模式示例</description>
    </item>
    
    <item>
      <title>迭代器模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 07 Feb 2023 20:57:19 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description> 迭代器模式又叫做游标模式，作用：提供一种方法访问一个容器元素中的各个对象，而又不暴露该对象的内部细节
角色：
迭代器角色 具体迭代器角色 容器角色 具体容器角色 </description>
    </item>
    
    <item>
      <title>代理模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 07 Feb 2023 20:48:23 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid>
      <description>代理模式是一种使用代理对象来执行目标对象的方法并在代理对象中增强目标对象方法的一种设计模式
静态代理 动态代理 静态代理的特点如下：
使用静态代理时，通常客户类不需要感知RealSubject。 静态代理的缺点：代理对象需要与目标对象实现一样的接口，因此接口较多时需要定义和维护大量的代理类代码。 与适配器的差异：适配器通常考虑改变接口形态，而代理则不会也不能改变接口形态。 与装饰器的差异：被代理对象由代理对象创建，客户端甚至不需要知道被代理类的存在；被装饰对象则由客户端创建并传给装饰对象，可以层层嵌套，层层装饰。代理模式常用于控制被代理对象的访问，而装饰模式是增加被装饰者的功能。
JDK动态代理的特点如下：
通过实现InvocationHandler接口完成代理逻辑。 通过反射代理方法，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。 代理类必须实现接口。 代理模式</description>
    </item>
    
    <item>
      <title>享元模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 07 Feb 2023 20:29:05 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</guid>
      <description> 对象的结构模式，以共享的方式高效的支持大量的细粒度对象
java中String类型就是享元模式 享元模式采用一个共享来避免大量拥有相同内容对象的开销
分类 单纯享元模式 所有的享元对象都是可以共享的
角色：
抽象享元(Flyweight)角色：抽象接口 具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口 享元工厂(FlyweightFactory)角色：本角色负责创建和管理享元角色 复合享元模式 抽象享元(Flyweight)角色：抽象接口 具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口 复合享元角色：复合享元角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解成为多个本身是单纯享元对象的组合。复合享元角色又称作不可共享的享元对象 享元工厂(FlyweightFactory)角色：本角色负责创建和管理享元角色 </description>
    </item>
    
    <item>
      <title>组合模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 07 Feb 2023 20:13:12 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</guid>
      <description>描述部分与整体的关系，组装树形结构
角色 抽象构件角色 树叶构件角色 树枝构件角色 分类 透明式：在该方式中，由于抽象构件声明了所有子类中的全部方法，所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的 安全式：在该方式中，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题，但由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性 组合模式代码</description>
    </item>
    
    <item>
      <title>观察者模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 07 Feb 2023 19:50:02 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>观察者模式-对象行为模式。发布/订阅模式，模型-视图模式、源-监听器模式，从属者模式。
定义一对多的依赖关系，让多个观察者同时监听某一个主题对象。这个对象在状态上发生变化时，会通知所有观察者对象，是它们能够主动更新自己的状态。
角色：
抽象主题角色：提供一个接口，可以增加和减少观察者对象，抽象主题角色又叫做抽象被观察者角色。 具体主题角色：将有关状态存入具体观察者对象 抽象观察者角色：为所有的观察者提供一个接口，在得到主题的通知时更新自己。 具体观察者角色：存储与主题状态自恰的状态。 模式分类：
推模式
主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。
拉模式 主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。
java对观察者模式的支持
Observer接口： 观察者 Observable类： 被观察者 示例代码</description>
    </item>
    
    <item>
      <title>责任链模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 06 Feb 2023 08:09:32 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</guid>
      <description>对象的行为模式，允许你将请求沿着处理链进行发送。收到请求后，每个处理者可对请求进行处理，或将其传递给链上的下个处理者
角色：
抽象处理者：定义处理请求的接口。 具体处理者：具体处理者接到请求，可以将请求处理，或者将请求传给下家。 示例代码</description>
    </item>
    
    <item>
      <title>装饰者模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 05 Feb 2023 23:28:12 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>动态的将责任添加到对象上，动态添加功能。
分类：
父组件，供子组件使用 装饰者：组合其他组件，一部分功能是自己的，调用被装饰者，等同于保留被装饰者的功能 具体组件：实现具体方法 饮料添加各种配料，返回最终的价格。
代码示例</description>
    </item>
    
    <item>
      <title>调停者模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E8%B0%83%E5%81%9C%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 05 Feb 2023 16:05:46 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E8%B0%83%E5%81%9C%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>门面模式对外，调停者模式对内
对象的行为模式，调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显引用。从而使它们可以较松散地耦合。当这些对象中的某些对象之间的相互作用发生改变时，不会立即影响到其他的一些对象之间的相互作用。从而保证这些相互作用可以彼此独立地变化
角色：
抽象调停者角色 具体调停者角色 抽象同事类角色 具体公式类角色 示例代码</description>
    </item>
    
    <item>
      <title>门面模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 05 Feb 2023 15:50:55 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/</guid>
      <description>提供高层次的接口，统一门面对象进行，使得子系统易于使用。
选择性的暴露方法
角色分类：
门面角色: 客户端可以调用这个角色的方法 子系统角色：可以同时有一个或者多个子系统 门面模式示例代码</description>
    </item>
    
    <item>
      <title>工厂模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 04 Feb 2023 10:18:28 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>任何可以产生对象的方法和类，都可以被称为工厂。
创建型设计模式，父类提供创建对象的方法，允许子类决定实例化对象的类型
分类 根据产品是具体产品还是具体工厂：
简单工厂模式 工厂方法模式 根据工厂的抽象程度
工厂方法模式 抽象工厂模式 简单工厂模式 只对不同类对象的创建进行了一层薄薄的封装，通过向工厂传递类型来指定要创建的对象。
工厂方法模式 工厂方法模式将生产具体产品的任务分发给具体的产品工厂
抽象工厂模式 针对不同产品的创建。在工厂方法模式下，在抽象工厂里面增加创建产品的接口，并在具体子工厂中实现产品的创建
工厂模式代码示例合</description>
    </item>
    
    <item>
      <title>策略模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 03 Feb 2023 07:38:26 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>对于做同一件事有多种方法，Comparator接口。
Context：环境类 Strategy: 抽象策略类 ConcreteStrategy: 具体策略类 使用场景 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。
策略模式示例代码</description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 16 Jan 2023 08:36:37 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>保持内存中只有一个对象
分类：
是否加载实例
饿汉式 饱汉式 是否线程安全
安全 不安全 特殊实现方式：
静态内部类 枚举 单例模式代码</description>
    </item>
    
  </channel>
</rss>
