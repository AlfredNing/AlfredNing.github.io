<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Dubbo Level01 | AlfredNing</title>
<meta name=keywords content><meta name=description content='基础理论 “分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”，分布式系统（distributed system）是建立在网络之上的软件系统。分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。
架构演变 单一应用架构
适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。
缺点： 1、性能扩展比较难
2、协同开发问题 3、不利于升级维护 垂直应用架构
适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。
缺点： 1、性能扩展比较难
2、协同开发问题 3、不利于升级维护 分布式服务架构 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的**分布式服务框架(RPC)**是关键
流动计算架构 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)[ Service Oriented Architecture]是关键
RPC RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同.
RPC框架：dubbo gRpc 、Thrift 、HSF(High Speed Service Framework)
dubbo Apache Dubbo (incubating) |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。
设计架构 zookeeper 监控 dubbo-admin 核心配置 加载配置 jvm启动参数 -> dubbo.properties -> spring配置
启动时候检查 Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题，默认 check="true"。
可以通过 check="false" 关闭检查，比如，测试时，有些服务不关心，或者出现了循环依赖，必须有一方先启动。
另外，如果你的 Spring 容器是懒加载的，或者通过 API 编程延迟引用服务，请关闭 check，否则服务临时不可用时，会抛出异常，拿到 null 引用，如果 check="false"，总是会返回引用，当服务恢复时，能自动连上。'><meta name=author content="AlfredNing"><link rel=canonical href=https://AlfredNing.github.io/note/program/dubbo/dubbo-level01/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.992dd02838d36453c6b1ff2a12a60049a3e447cd982ad5f7b4470d32eb4648e2.css integrity="sha256-mS3QKDjTZFPGsf8qEqYASaPkR82YKtX3tEcNMutGSOI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://AlfredNing.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://AlfredNing.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://AlfredNing.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://AlfredNing.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://AlfredNing.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://AlfredNing.github.io/note/program/dubbo/dubbo-level01/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Dubbo Level01"><meta property="og:description" content='基础理论 “分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”，分布式系统（distributed system）是建立在网络之上的软件系统。分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。
架构演变 单一应用架构
适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。
缺点： 1、性能扩展比较难
2、协同开发问题 3、不利于升级维护 垂直应用架构
适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。
缺点： 1、性能扩展比较难
2、协同开发问题 3、不利于升级维护 分布式服务架构 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的**分布式服务框架(RPC)**是关键
流动计算架构 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)[ Service Oriented Architecture]是关键
RPC RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同.
RPC框架：dubbo gRpc 、Thrift 、HSF(High Speed Service Framework)
dubbo Apache Dubbo (incubating) |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。
设计架构 zookeeper 监控 dubbo-admin 核心配置 加载配置 jvm启动参数 -> dubbo.properties -> spring配置
启动时候检查 Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题，默认 check="true"。
可以通过 check="false" 关闭检查，比如，测试时，有些服务不关心，或者出现了循环依赖，必须有一方先启动。
另外，如果你的 Spring 容器是懒加载的，或者通过 API 编程延迟引用服务，请关闭 check，否则服务临时不可用时，会抛出异常，拿到 null 引用，如果 check="false"，总是会返回引用，当服务恢复时，能自动连上。'><meta property="og:type" content="article"><meta property="og:url" content="https://AlfredNing.github.io/note/program/dubbo/dubbo-level01/"><meta property="article:section" content="note"><meta property="article:published_time" content="2023-09-03T12:31:43+08:00"><meta property="article:modified_time" content="2023-09-04T23:48:11+08:00"><meta property="og:site_name" content="Alfred.Ning"><meta name=twitter:card content="summary"><meta name=twitter:title content="Dubbo Level01"><meta name=twitter:description content='基础理论 “分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”，分布式系统（distributed system）是建立在网络之上的软件系统。分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。
架构演变 单一应用架构
适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。
缺点： 1、性能扩展比较难
2、协同开发问题 3、不利于升级维护 垂直应用架构
适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。
缺点： 1、性能扩展比较难
2、协同开发问题 3、不利于升级维护 分布式服务架构 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的**分布式服务框架(RPC)**是关键
流动计算架构 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)[ Service Oriented Architecture]是关键
RPC RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同.
RPC框架：dubbo gRpc 、Thrift 、HSF(High Speed Service Framework)
dubbo Apache Dubbo (incubating) |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。
设计架构 zookeeper 监控 dubbo-admin 核心配置 加载配置 jvm启动参数 -> dubbo.properties -> spring配置
启动时候检查 Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题，默认 check="true"。
可以通过 check="false" 关闭检查，比如，测试时，有些服务不关心，或者出现了循环依赖，必须有一方先启动。
另外，如果你的 Spring 容器是懒加载的，或者通过 API 编程延迟引用服务，请关闭 check，否则服务临时不可用时，会抛出异常，拿到 null 引用，如果 check="false"，总是会返回引用，当服务恢复时，能自动连上。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"笔记","item":"https://AlfredNing.github.io/note/"},{"@type":"ListItem","position":2,"name":"编程","item":"https://AlfredNing.github.io/note/program/"},{"@type":"ListItem","position":3,"name":"Dubbo Level01","item":"https://AlfredNing.github.io/note/program/dubbo/dubbo-level01/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Dubbo Level01","name":"Dubbo Level01","description":"基础理论 “分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”，分布式系统（distributed system）是建立在网络之上的软件系统。分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。\n架构演变 单一应用架构\n适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。\n缺点： 1、性能扩展比较难\n2、协同开发问题 3、不利于升级维护 垂直应用架构\n适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。\n缺点： 1、性能扩展比较难\n2、协同开发问题 3、不利于升级维护 分布式服务架构 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的**分布式服务框架(RPC)**是关键\n流动计算架构 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)[ Service Oriented Architecture]是关键\nRPC RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同.\nRPC框架：dubbo gRpc 、Thrift 、HSF(High Speed Service Framework)\ndubbo Apache Dubbo (incubating) |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。\n设计架构 zookeeper 监控 dubbo-admin 核心配置 加载配置 jvm启动参数 -\u0026gt; dubbo.properties -\u0026gt; spring配置\n启动时候检查 Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题，默认 check=\u0026quot;true\u0026quot;。\n可以通过 check=\u0026quot;false\u0026quot; 关闭检查，比如，测试时，有些服务不关心，或者出现了循环依赖，必须有一方先启动。\n另外，如果你的 Spring 容器是懒加载的，或者通过 API 编程延迟引用服务，请关闭 check，否则服务临时不可用时，会抛出异常，拿到 null 引用，如果 check=\u0026quot;false\u0026quot;，总是会返回引用，当服务恢复时，能自动连上。","keywords":[""],"articleBody":"基础理论 “分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”，分布式系统（distributed system）是建立在网络之上的软件系统。分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。\n架构演变 单一应用架构\n适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。\n缺点： 1、性能扩展比较难\n2、协同开发问题 3、不利于升级维护 垂直应用架构\n适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。\n缺点： 1、性能扩展比较难\n2、协同开发问题 3、不利于升级维护 分布式服务架构 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的**分布式服务框架(RPC)**是关键\n流动计算架构 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)[ Service Oriented Architecture]是关键\nRPC RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同.\nRPC框架：dubbo gRpc 、Thrift 、HSF(High Speed Service Framework)\ndubbo Apache Dubbo (incubating) |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。\n设计架构 zookeeper 监控 dubbo-admin 核心配置 加载配置 jvm启动参数 -\u003e dubbo.properties -\u003e spring配置\n启动时候检查 Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题，默认 check=\"true\"。\n可以通过 check=\"false\" 关闭检查，比如，测试时，有些服务不关心，或者出现了循环依赖，必须有一方先启动。\n另外，如果你的 Spring 容器是懒加载的，或者通过 API 编程延迟引用服务，请关闭 check，否则服务临时不可用时，会抛出异常，拿到 null 引用，如果 check=\"false\"，总是会返回引用，当服务恢复时，能自动连上。\ndubbo3 单独服务检查\n全局检查\n超时配置 调用超时，方法级别优先 -\u003e 接口 -\u003e 全局\n重试 异常重试，保持幂等行\n多版本 升级存在多版本情况。\n服务提供者，设置版本，消费者设置版本机制，灰度发布\n本地存根 做 ThreadLocal 缓存，提前验证参数，调用失败后伪造容错数据等等，此时就需要在 API 中带上 Stub，客户端生成 Proxy 实例，会把 Proxy 通过构造函数传给 Stub 1，然后把 Stub 暴露给用户，Stub 可以决定要不要去调 Proxy。\n消费者实现调用接口，构造传入 消费端指定本地存根 高可用场景 zookeeper宕机与dubbo直连 现象：zookeeper注册中心宕机，还可以消费dubbo暴露的服务。 l 监控中心宕掉不影响使用，只是丢失部分采样数据\nl 数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务\nl 注册中心对等集群，任意一台宕掉后，将自动切换到另一台\nl 注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯\nl 服务提供者无状态，任意一台宕掉后，不影响使用\nl 服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复\n负载均衡 服务提供者指定 或者消费端指定\nRandom LoadBalance - Dubbo默认机制 随机，按权重设置随机概率。在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。\nRoundRobin LoadBalance 轮循，按公约后的权重设置轮循比率。\n存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上\nLeastActive LoadBalance 最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。\n使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。\nConsistentHash LoadBalance 一致性 Hash，相同参数的请求总是发到同一提供者。\n当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。算法参见：http://en.wikipedia.org/wiki/Consistent_hashing。缺省只对第一个参数 Hash，如果要修改，请配置 缺省用 160 份虚拟节点，如果要修改，请配置 服务降级 当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作\n可以通过服务降级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。也可以通过监控设置\n向注册中心写入动态配置覆盖规则：\nRegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf(\"zookeeper://10.20.153.10:2181\")); registry.register(URL.valueOf(\"override://0.0.0.0/com.foo.BarService?category=configurators\u0026dynamic=false\u0026application=foo\u0026mock=force:return+null\")); 其中：\nmock=force:return+null 表示消费方对该服务的方法调用都直接返回 null 值，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。 还可以改为 mock=fail:return+null 表示消费方对该服务的方法调用在失败后，再返回 null 值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。 集群容错 在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。\n集群容错模式\n- Failover Cluster 默认 失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=\"2\" 来设置重试次数(不含第一次)。 重试次数配置如下： \u003cdubbo:service retries=\"2\" /\u003e 或 \u003cdubbo:reference retries=\"2\" /\u003e 或 \u003cdubbo:reference\u003e \u003cdubbo:method name=\"findFoo\" retries=\"2\" /\u003e \u003c/dubbo:reference\u003e - Failfast Cluster 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。 - Failsafe Cluster 失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。 - Failback Cluster 失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。 - Forking Cluster 并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=\"2\" 来设置最大并行数。 - Broadcast Cluster 广播调用所有提供者，逐个调用，任意一台报错则报错 [2]。通常用于通知所有提供者更新缓存或日志等本地资源信息。 集群模式配置 按照以下示例在服务提供方和消费方配置集群模式 \u003cdubbo:service cluster=\"failsafe\" /\u003e 或 \u003cdubbo:reference cluster=\"failsafe\" /\u003e 配合hystrix实现容错调用\n原理 RPC原理 一次完整的RPC调用流程（同步调用，异步另说）如下：\n服务消费方（client）调用以本地调用方式调用服务； client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体； client stub找到服务地址，并将消息发送到服务端； server stub收到消息后进行解码； server stub根据解码结果调用本地的服务； 本地服务执行并将结果返回给server stub； server stub将返回结果打包成消息并发送至消费方； client stub接收到消息，并进行解码； 服务消费方得到最终结果。 RPC框架的目标就是要2~8这些步骤都封装起来，这些细节对用户来说是透明的，不可见的。\nNetty原理 Netty是一个异步事件驱动的网络应用程序框架， 用于快速开发可维护的高性能协议服务器和客户端。它极大地简化并简化了TCP和UDP套接字服务器等网络编程。\nBIO NIO Selector 一般称 为选择器 ，也可以翻译为 多路复用器，\nConnect（连接就绪）、Accept（接受就绪）、Read（读就绪）、Write（写就绪）\n框架设计 标签解析 DubboBeanDefinitionParser ： Bean的xml标签解析\nAnnotationBeanDefinitionParser : Bean的注解解析\nDubboNamespaceHandler ： 标签对应class解析\n服务暴露 服务引用流程 ReferenceBean\n服务调用 ","wordCount":"281","inLanguage":"zh","datePublished":"2023-09-03T12:31:43+08:00","dateModified":"2023-09-04T23:48:11+08:00","author":[{"@type":"Person","name":"AlfredNing"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://AlfredNing.github.io/note/program/dubbo/dubbo-level01/"},"publisher":{"@type":"Organization","name":"AlfredNing","logo":{"@type":"ImageObject","url":"https://AlfredNing.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://AlfredNing.github.io/ accesskey=h title="AlfredNing (Alt + H)">AlfredNing</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://AlfredNing.github.io/note/ title=📓笔记><span>📓笔记</span></a></li><li><a href=https://AlfredNing.github.io/thinking/ title=🤔黑洞><span>🤔黑洞</span></a></li><li><a href=https://AlfredNing.github.io/search/ title="🔎搜索 (Alt + /)" accesskey=/><span>🔎搜索</span></a></li><li><a href=https://AlfredNing.github.io/tags/ title=🏷️标签><span>🏷️标签</span></a></li><li><a href=https://AlfredNing.github.io/archives title=🗄️归档><span>🗄️归档</span></a></li><li><a href=https://AlfredNing.github.io/about title=🤙关于><span>🤙关于</span></a></li></ul></nav></header><main class="main page"><article class=post-single><div id=single-content><header class=post-header><div class=breadcrumbs><a href=https://AlfredNing.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://AlfredNing.github.io/note/>笔记</a>&nbsp;»&nbsp;<a href=https://AlfredNing.github.io/note/program/>编程</a></div><h1 class=post-title>Dubbo Level01</h1><div class=post-meta>创建:&amp;nbsp;&lt;span title='2023-09-03 12:31:43 +0800 +0800'>2023年-09月-03日&lt;/span>&amp;nbsp;|&amp;nbsp;更新:&amp;nbsp;2023年-09月-04日&amp;nbsp;|&amp;nbsp;字数:&amp;nbsp;281字&amp;nbsp;|&amp;nbsp;时长:&amp;nbsp;2分钟&amp;nbsp;|&amp;nbsp;AlfredNing
&nbsp;|&nbsp;标签: &nbsp;<ul class=post-tags-meta><a href=https://AlfredNing.github.io/tags/dubbo/>Dubbo</a></ul></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%9f%ba%e7%a1%80%e7%90%86%e8%ae%ba aria-label=基础理论>基础理论</a><ul><li><a href=#%e6%9e%b6%e6%9e%84%e6%bc%94%e5%8f%98 aria-label=架构演变>架构演变</a><ul><ul><li><a href=#%e6%b5%81%e5%8a%a8%e8%ae%a1%e7%ae%97%e6%9e%b6%e6%9e%84 aria-label=流动计算架构>流动计算架构</a></li></ul></ul></li><li><a href=#rpc aria-label=RPC>RPC</a></li><li><a href=#dubbo aria-label=dubbo>dubbo</a><ul><li><a href=#%e8%ae%be%e8%ae%a1%e6%9e%b6%e6%9e%84 aria-label=设计架构>设计架构</a></li></ul></li></ul></li><li><a href=#%e6%a0%b8%e5%bf%83%e9%85%8d%e7%bd%ae aria-label=核心配置>核心配置</a><ul><li><a href=#%e5%8a%a0%e8%bd%bd%e9%85%8d%e7%bd%ae aria-label=加载配置>加载配置</a></li><li><a href=#%e5%90%af%e5%8a%a8%e6%97%b6%e5%80%99%e6%a3%80%e6%9f%a5 aria-label=启动时候检查>启动时候检查</a></li><li><a href=#%e8%b6%85%e6%97%b6%e9%85%8d%e7%bd%ae aria-label=超时配置>超时配置</a></li><li><a href=#%e9%87%8d%e8%af%95 aria-label=重试>重试</a></li><li><a href=#%e5%a4%9a%e7%89%88%e6%9c%ac aria-label=多版本>多版本</a></li><li><a href=#%e6%9c%ac%e5%9c%b0%e5%ad%98%e6%a0%b9 aria-label=本地存根>本地存根</a></li></ul></li><li><a href=#%e9%ab%98%e5%8f%af%e7%94%a8%e5%9c%ba%e6%99%af aria-label=高可用场景>高可用场景</a><ul><li><a href=#zookeeper%e5%ae%95%e6%9c%ba%e4%b8%8edubbo%e7%9b%b4%e8%bf%9e aria-label=zookeeper宕机与dubbo直连>zookeeper宕机与dubbo直连</a></li><li><a href=#%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1 aria-label=负载均衡>负载均衡</a><ul><li><a href=#random-loadbalance---dubbo%e9%bb%98%e8%ae%a4%e6%9c%ba%e5%88%b6 aria-label="Random LoadBalance - Dubbo默认机制"><strong>Random LoadBalance</strong> - Dubbo默认机制</a></li><li><a href=#roundrobin-loadbalance aria-label="RoundRobin LoadBalance"><strong>RoundRobin LoadBalance</strong></a></li><li><a href=#leastactive-loadbalance aria-label="LeastActive LoadBalance"><strong>LeastActive LoadBalance</strong></a></li><li><a href=#consistenthash-loadbalance aria-label="ConsistentHash LoadBalance"><strong>ConsistentHash LoadBalance</strong></a></li></ul></li><li><a href=#%e6%9c%8d%e5%8a%a1%e9%99%8d%e7%ba%a7 aria-label=服务降级>服务降级</a></li><li><a href=#%e9%9b%86%e7%be%a4%e5%ae%b9%e9%94%99 aria-label=集群容错>集群容错</a></li></ul></li><li><a href=#%e5%8e%9f%e7%90%86 aria-label=原理>原理</a><ul><li><a href=#rpc%e5%8e%9f%e7%90%86 aria-label=RPC原理>RPC原理</a></li><li><a href=#netty%e5%8e%9f%e7%90%86 aria-label=Netty原理>Netty原理</a><ul><li><a href=#bio aria-label=BIO>BIO</a></li><li><a href=#nio aria-label=NIO>NIO</a></li></ul></li><li><a href=#%e6%a1%86%e6%9e%b6%e8%ae%be%e8%ae%a1 aria-label=框架设计>框架设计</a></li><li><a href=#%e6%a0%87%e7%ad%be%e8%a7%a3%e6%9e%90 aria-label=标签解析>标签解析</a></li><li><a href=#%e6%9c%8d%e5%8a%a1%e6%9a%b4%e9%9c%b2 aria-label=服务暴露>服务暴露</a></li><li><a href=#%e6%9c%8d%e5%8a%a1%e5%bc%95%e7%94%a8%e6%b5%81%e7%a8%8b aria-label=服务引用流程>服务引用流程</a></li><li><a href=#%e6%9c%8d%e5%8a%a1%e8%b0%83%e7%94%a8 aria-label=服务调用>服务调用</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=基础理论>基础理论<a hidden class=anchor aria-hidden=true href=#基础理论>#</a></h1><p>“分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”，分布式系统（distributed system）是建立在网络之上的软件系统。分布式服务架构以及流动计算架构势在必行，亟需<strong>一个治理系统</strong>确保架构有条不紊的演进。</p><h2 id=架构演变>架构演变<a hidden class=anchor aria-hidden=true href=#架构演变>#</a></h2><ol><li><p>单一应用架构</p><p>适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。</p><p>缺点： 1、性能扩展比较难</p><pre><code> 	  2、协同开发问题

 	  3、不利于升级维护
</code></pre></li><li><p>垂直应用架构</p><p>适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。</p><p>缺点： 1、性能扩展比较难</p><pre><code> 	  2、协同开发问题

 	 3、不利于升级维护
</code></pre></li><li><p>分布式服务架构
当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的**分布式服务框架(RPC)**是关键</p></li><li><h4 id=流动计算架构>流动计算架构<a hidden class=anchor aria-hidden=true href=#流动计算架构>#</a></h4><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于<strong>提高机器利用率的资源调度和治理中心(SOA)[ Service Oriented Architecture]是关键</strong></p></li></ol><h2 id=rpc>RPC<a hidden class=anchor aria-hidden=true href=#rpc>#</a></h2><p>RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同.</p><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230903124625260.png alt=image-20230903124625260></p><p>RPC框架：dubbo gRpc 、Thrift 、HSF(High Speed Service Framework)</p><h2 id=dubbo>dubbo<a hidden class=anchor aria-hidden=true href=#dubbo>#</a></h2><p>Apache Dubbo (incubating) |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p><h3 id=设计架构>设计架构<a hidden class=anchor aria-hidden=true href=#设计架构>#</a></h3><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230903131047505.png alt=image-20230903131047505></p><ul><li>zookeeper</li><li>监控 dubbo-admin</li></ul><h1 id=核心配置>核心配置<a hidden class=anchor aria-hidden=true href=#核心配置>#</a></h1><h2 id=加载配置>加载配置<a hidden class=anchor aria-hidden=true href=#加载配置>#</a></h2><p>jvm启动参数 -> dubbo.properties -> spring配置</p><h2 id=启动时候检查>启动时候检查<a hidden class=anchor aria-hidden=true href=#启动时候检查>#</a></h2><p>Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题，默认 <code>check="true"</code>。</p><p>可以通过 <code>check="false"</code> 关闭检查，比如，测试时，有些服务不关心，或者出现了循环依赖，必须有一方先启动。</p><p>另外，如果你的 Spring 容器是懒加载的，或者通过 API 编程延迟引用服务，请关闭 check，否则服务临时不可用时，会抛出异常，拿到 null 引用，如果 <code>check="false"</code>，总是会返回引用，当服务恢复时，能自动连上。</p><p><code>dubbo3 单独服务检查</code></p><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230903210255885.png alt=image-20230903210255885></p><p>全局检查</p><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230903210415533.png alt=image-20230903210415533></p><h2 id=超时配置>超时配置<a hidden class=anchor aria-hidden=true href=#超时配置>#</a></h2><p>调用超时，方法级别优先 -> 接口 -> 全局</p><h2 id=重试>重试<a hidden class=anchor aria-hidden=true href=#重试>#</a></h2><p>异常重试，保持幂等行</p><h2 id=多版本>多版本<a hidden class=anchor aria-hidden=true href=#多版本>#</a></h2><p>升级存在多版本情况。</p><p>服务提供者，设置版本，消费者设置版本机制，灰度发布</p><h2 id=本地存根>本地存根<a hidden class=anchor aria-hidden=true href=#本地存根>#</a></h2><p>做 ThreadLocal 缓存，提前验证参数，调用失败后伪造容错数据等等，此时就需要在 API 中带上 Stub，客户端生成 Proxy 实例，会把 Proxy 通过构造函数传给 Stub <a href=https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/advanced-features-and-usage/service/local-stub/#fn:1>1</a>，然后把 Stub 暴露给用户，Stub 可以决定要不要去调 Proxy。</p><ol><li>消费者实现调用接口，构造传入</li><li>消费端指定本地存根</li></ol><h1 id=高可用场景>高可用场景<a hidden class=anchor aria-hidden=true href=#高可用场景>#</a></h1><h2 id=zookeeper宕机与dubbo直连>zookeeper宕机与dubbo直连<a hidden class=anchor aria-hidden=true href=#zookeeper宕机与dubbo直连>#</a></h2><ul><li>现象：zookeeper注册中心宕机，还可以消费dubbo暴露的服务。</li></ul><p>l 监控中心宕掉不影响使用，只是丢失部分采样数据</p><p>l 数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务</p><p>l 注册中心对等集群，任意一台宕掉后，将自动切换到另一台</p><p>l <strong>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</strong></p><p>l 服务提供者无状态，任意一台宕掉后，不影响使用</p><p>l 服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</p><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230904080533274.png alt=image-20230904080533274></p><h2 id=负载均衡>负载均衡<a hidden class=anchor aria-hidden=true href=#负载均衡>#</a></h2><p>服务提供者指定 或者消费端指定</p><h3 id=random-loadbalance---dubbo默认机制><strong>Random LoadBalance</strong> - Dubbo默认机制<a hidden class=anchor aria-hidden=true href=#random-loadbalance---dubbo默认机制>#</a></h3><p>随机，按权重设置随机概率。在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</p><h3 id=roundrobin-loadbalance><strong>RoundRobin LoadBalance</strong><a hidden class=anchor aria-hidden=true href=#roundrobin-loadbalance>#</a></h3><p>轮循，按公约后的权重设置轮循比率。</p><p>存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上</p><h3 id=leastactive-loadbalance><strong>LeastActive LoadBalance</strong><a hidden class=anchor aria-hidden=true href=#leastactive-loadbalance>#</a></h3><p>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。</p><p>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</p><h3 id=consistenthash-loadbalance><strong>ConsistentHash LoadBalance</strong><a hidden class=anchor aria-hidden=true href=#consistenthash-loadbalance>#</a></h3><p>一致性 Hash，相同参数的请求总是发到同一提供者。</p><p>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。算法参见：http://en.wikipedia.org/wiki/Consistent_hashing。缺省只对第一个参数 Hash，如果要修改，请配置 &lt;dubbo:parameter key=&ldquo;hash.arguments&rdquo; value=&ldquo;0,1&rdquo; /></p><p>缺省用 160 份虚拟节点，如果要修改，请配置 &lt;dubbo:parameter key=&ldquo;hash.nodes&rdquo; value=&ldquo;320&rdquo; /></p><h2 id=服务降级>服务降级<a hidden class=anchor aria-hidden=true href=#服务降级>#</a></h2><p><strong>当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作</strong></p><p>可以通过服务降级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。也可以通过监控设置</p><p>向注册中心写入动态配置覆盖规则：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>RegistryFactory</span><span class=w>  </span><span class=n>registryFactory</span><span class=w> </span><span class=o>=</span><span class=w>  </span><span class=n>ExtensionLoader</span><span class=p>.</span><span class=na>getExtensionLoader</span><span class=p>(</span><span class=n>RegistryFactory</span><span class=p>.</span><span class=na>class</span><span class=p>).</span><span class=na>getAdaptiveExtension</span><span class=p>();</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Registry</span><span class=w>  </span><span class=n>registry</span><span class=w> </span><span class=o>=</span><span class=w>  </span><span class=n>registryFactory</span><span class=p>.</span><span class=na>getRegistry</span><span class=p>(</span><span class=n>URL</span><span class=p>.</span><span class=na>valueOf</span><span class=p>(</span><span class=s>&#34;zookeeper://10.20.153.10:2181&#34;</span><span class=p>));</span><span class=w> </span><span class=n>registry</span><span class=p>.</span><span class=na>register</span><span class=p>(</span><span class=n>URL</span><span class=p>.</span><span class=na>valueOf</span><span class=p>(</span><span class=s>&#34;override://0.0.0.0/com.foo.BarService?category=configurators&amp;dynamic=false&amp;application=foo&amp;mock=force:return+null&#34;</span><span class=p>));</span><span class=w>  
</span></span></span></code></pre></div><p>其中：</p><ul><li>mock=force:return+null 表示消费方对该服务的方法调用都直接返回 null 值，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。</li><li>还可以改为 mock=fail:return+null 表示消费方对该服务的方法调用在失败后，再返回 null 值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。</li></ul><h2 id=集群容错>集群容错<a hidden class=anchor aria-hidden=true href=#集群容错>#</a></h2><p>在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。</p><p><strong>集群容错模式</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=o>-</span><span class=w> </span><span class=n>Failover</span><span class=w> </span><span class=n>Cluster</span><span class=w>  </span><span class=n>默认</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>失败自动切换</span><span class=err>，</span><span class=n>当出现失败</span><span class=err>，</span><span class=n>重试其它服务器</span><span class=err>。</span><span class=n>通常用于读操作</span><span class=err>，</span><span class=n>但重试会带来更长延迟</span><span class=err>。</span><span class=n>可通过</span><span class=w> </span><span class=n>retries</span><span class=o>=</span><span class=s>&#34;2&#34;</span><span class=w> </span><span class=n>来设置重试次数</span><span class=p>(</span><span class=n>不含第一次</span><span class=p>)</span><span class=err>。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>重试次数配置如下</span><span class=err>：</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>&lt;</span><span class=n>dubbo</span><span class=p>:</span><span class=n>service</span><span class=w> </span><span class=n>retries</span><span class=o>=</span><span class=s>&#34;2&#34;</span><span class=w> </span><span class=o>/&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>或</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>&lt;</span><span class=n>dubbo</span><span class=p>:</span><span class=n>reference</span><span class=w> </span><span class=n>retries</span><span class=o>=</span><span class=s>&#34;2&#34;</span><span class=w> </span><span class=o>/&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>或</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>&lt;</span><span class=n>dubbo</span><span class=p>:</span><span class=n>reference</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>&lt;</span><span class=n>dubbo</span><span class=p>:</span><span class=n>method</span><span class=w> </span><span class=n>name</span><span class=o>=</span><span class=s>&#34;findFoo&#34;</span><span class=w> </span><span class=n>retries</span><span class=o>=</span><span class=s>&#34;2&#34;</span><span class=w> </span><span class=o>/&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>&lt;/</span><span class=n>dubbo</span><span class=p>:</span><span class=n>reference</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>-</span><span class=w> </span><span class=n>Failfast</span><span class=w> </span><span class=n>Cluster</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>快速失败</span><span class=err>，</span><span class=n>只发起一次调用</span><span class=err>，</span><span class=n>失败立即报错</span><span class=err>。</span><span class=n>通常用于非幂等性的写操作</span><span class=err>，</span><span class=n>比如新增记录</span><span class=err>。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>-</span><span class=w> </span><span class=n>Failsafe</span><span class=w> </span><span class=n>Cluster</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>失败安全</span><span class=err>，</span><span class=n>出现异常时</span><span class=err>，</span><span class=n>直接忽略</span><span class=err>。</span><span class=n>通常用于写入审计日志等操作</span><span class=err>。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>-</span><span class=w> </span><span class=n>Failback</span><span class=w> </span><span class=n>Cluster</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>失败自动恢复</span><span class=err>，</span><span class=n>后台记录失败请求</span><span class=err>，</span><span class=n>定时重发</span><span class=err>。</span><span class=n>通常用于消息通知操作</span><span class=err>。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>-</span><span class=w> </span><span class=n>Forking</span><span class=w> </span><span class=n>Cluster</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>并行调用多个服务器</span><span class=err>，</span><span class=n>只要一个成功即返回</span><span class=err>。</span><span class=n>通常用于实时性要求较高的读操作</span><span class=err>，</span><span class=n>但需要浪费更多服务资源</span><span class=err>。</span><span class=n>可通过</span><span class=w> </span><span class=n>forks</span><span class=o>=</span><span class=s>&#34;2&#34;</span><span class=w> </span><span class=n>来设置最大并行数</span><span class=err>。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>-</span><span class=w> </span><span class=n>Broadcast</span><span class=w> </span><span class=n>Cluster</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>广播调用所有提供者</span><span class=err>，</span><span class=n>逐个调用</span><span class=err>，</span><span class=n>任意一台报错则报错</span><span class=w> </span><span class=o>[</span><span class=n>2</span><span class=o>]</span><span class=err>。</span><span class=n>通常用于通知所有提供者更新缓存或日志等本地资源信息</span><span class=err>。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>集群模式配置</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>按照以下示例在服务提供方和消费方配置集群模式</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>&lt;</span><span class=n>dubbo</span><span class=p>:</span><span class=n>service</span><span class=w> </span><span class=n>cluster</span><span class=o>=</span><span class=s>&#34;failsafe&#34;</span><span class=w> </span><span class=o>/&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>或</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>&lt;</span><span class=n>dubbo</span><span class=p>:</span><span class=n>reference</span><span class=w> </span><span class=n>cluster</span><span class=o>=</span><span class=s>&#34;failsafe&#34;</span><span class=w> </span><span class=o>/&gt;</span><span class=w>
</span></span></span></code></pre></div><p>配合hystrix实现容错调用</p><h1 id=原理>原理<a hidden class=anchor aria-hidden=true href=#原理>#</a></h1><h2 id=rpc原理>RPC原理<a hidden class=anchor aria-hidden=true href=#rpc原理>#</a></h2><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230904083308545.png alt=image-20230904083308545></p><p>一次完整的RPC调用流程（同步调用，异步另说）如下：</p><ol><li><strong>服务消费方（client）调用以本地调用方式调用服务；</strong></li><li>client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</li><li>client stub找到服务地址，并将消息发送到服务端；</li><li>server stub收到消息后进行解码；</li><li>server stub根据解码结果调用本地的服务；</li><li>本地服务执行并将结果返回给server stub；</li><li>server stub将返回结果打包成消息并发送至消费方；</li><li>client stub接收到消息，并进行解码；</li><li><strong>服务消费方得到最终结果。</strong></li></ol><p><strong>RPC框架的目标就是要2~8这些步骤都封装起来，这些细节对用户来说是透明的，不可见的。</strong></p><h2 id=netty原理>Netty原理<a hidden class=anchor aria-hidden=true href=#netty原理>#</a></h2><p>Netty是一个异步事件驱动的网络应用程序框架， 用于快速开发可维护的高性能协议服务器和客户端。它极大地简化并简化了TCP和UDP套接字服务器等网络编程。</p><h3 id=bio>BIO<a hidden class=anchor aria-hidden=true href=#bio>#</a></h3><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230904083619400.png alt=image-20230904083619400></p><h3 id=nio>NIO<a hidden class=anchor aria-hidden=true href=#nio>#</a></h3><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230904083630060.png alt=image-20230904083630060></p><p>Selector 一般称 为<strong>选择器</strong> ，也可以翻译为 <strong>多路复用器，</strong></p><p>Connect（连接就绪）、Accept（接受就绪）、Read（读就绪）、Write（写就绪）</p><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230904083658958.png alt=image-20230904083658958></p><h2 id=框架设计>框架设计<a hidden class=anchor aria-hidden=true href=#框架设计>#</a></h2><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230904221503943.png alt=image-20230904221503943></p><h2 id=标签解析>标签解析<a hidden class=anchor aria-hidden=true href=#标签解析>#</a></h2><p><code>DubboBeanDefinitionParser</code> ： Bean的xml标签解析</p><p><code>AnnotationBeanDefinitionParser</code> : Bean的注解解析</p><p><code>DubboNamespaceHandler</code> ： 标签对应class解析</p><h2 id=服务暴露>服务暴露<a hidden class=anchor aria-hidden=true href=#服务暴露>#</a></h2><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230904223107018.png alt=image-20230904223107018></p><h2 id=服务引用流程>服务引用流程<a hidden class=anchor aria-hidden=true href=#服务引用流程>#</a></h2><p><code>ReferenceBean</code></p><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230904233307228.png alt=image-20230904233307228></p><h2 id=服务调用>服务调用<a hidden class=anchor aria-hidden=true href=#服务调用>#</a></h2><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230904233727674.png alt=image-20230904233727674></p></div><footer class=post-footer><nav class=paginav><a class=prev href=https://AlfredNing.github.io/note/program/rocket/rocket-level01/><span class=title>« 上一页</span><br><span>Rocket Level01</span>
</a><a class=next href=https://AlfredNing.github.io/note/program/mybatis/mybatis_generator/><span class=title>下一页 »</span><br><span>Mybatis_generator</span></a></nav></footer></div><div><div class=pagination__title><span class=pagination__title-h style=font-size:20px>💬评论</span><hr></div><div id=tcomment></div><script src=https://utteranc.es/client.js repo=AlfredNing/AlfredNing.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2024 <a href=https://AlfredNing.github.io/>AlfredNing</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>