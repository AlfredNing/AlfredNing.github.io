<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>运行时内存 | AlfredNing</title><meta name=keywords content><meta name=description content="jvm内存结构图
哪些内存结构与线程意义对应，其实问的是线程共有和私有 共有： 堆和方法区 私有： 本地方法栈、虚拟机栈、程序计数器
程序计数器 保证程序在程序系统中能够执行下去，CPU必须具有某些手段来确定下一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器 一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器。 在程序开始执行前，必须将它的起始地址，即程序的一条指令所在的内存单元地址送入PC，因此程序计数器（PC）的内容即是从内存提取的第一条指令的地址。当执行指令时，CPU将自动修改PC的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数，以便使其保持的总是将要执行的下一条指令的地址 由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单的对PC加1 当程序转移时，转移指令执行的最终结果就是要改变PC的值，此PC值就是转去的地址，以此实现转移。有些机器中也称PC为指令指针IP（Instruction Pointer） 特征 JVM中的程序计数寄存器（Program Counter Register）中， Register 的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。 CPU只有把数据装载到寄存器才能够运行。
JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟
很小的内存结构，忽略不计，也是运行最快的存储区域，不会随着程序的运行需要更大的空间 在JVM规范中，每个线程都有自己的程序计数器，是线程私有的，生命周期与线程生命周期保持一致 它是唯一一个在JVM虚拟机规范中没有规定任何OutOtMemoryError 情况的区域 问题 为什么使用PC寄存器来记录当前线程的执行地址 因为CPU需要不停的切换各个线程，准确知道执行的位置。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令 PC寄存器为什么被设置为线程私有 多线程在一个特定的时间段内之会执行某一个线程的方法，CPU需要不停的做任务切换**。为了准确记录各个线程正在执行的当前字节码指令，最好的办法就是为每一个线程分配PC寄存器**，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况 虚拟机栈 栈管运行，堆管内存
栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿
Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。 是线程私有的 生命周期: 生命周期和线程一致。
特点: 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。
栈是否有GC？ 不存在GC, 但有OOM
抛出的异常：
StackOverFlowError OutOfMemoryError Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个 StackOverflowError 异常 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出—个 OutOfMemoryError 异常 设置栈大小 -Xsssize (即：-XX:ThreadStackSize)
一般为：512k-1M 栈的大小直接决定了函数调用的最大深度 设置的栈空间值过大，会导致系统可以用于创建线程的数量减少 一般一个进程中通常有3000-5000个线程
jdk5.0之前，默认为256k jdk5.0之后，默认为1024k
栈帧 栈的基本单位是栈帧，每个线程都有自己的栈，栈中的数据都是以栈帧存在的。
方法与栈帧的关系 在这个线程执行的方法都有一个栈帧 栈帧是一个内存区块，是一个数据集，维护着方法执行过程中的各种数据信息 栈的内部结构 局部变量表 操作数栈或表达式栈 动态链接或指向运行时常量池的方法引用 方法返回地址（或方法正常退出或者异常退出的定义） 一些附加信息 局部变量表 - Local Varibales 局部变量表被称为局部变量数组或者本地变量表 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，数据类别包括：基本数据类型，对象引用、以returnAddress类型 局部变量表的大小是在编译器确定，保存在方法的code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的 方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减 **局部变量表的变量只在当前方法调用中有效。**在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。 静态变量与局部变量区别 类变量表有两次初始化的机会，第一次准备阶段，执行系统初始化，赋零值，另一次是在初始化阶段，赋予代码中指定的初始值 和类变量初始化不同，局部变量表不存在系统初始化的过程，一旦定义了局部变量则必须人为的初始化，否则无法使用 与GC ROOTS的关系 局部变量表的变量也是重要的垃圾回收节点，只要被局部变量中直接或者间接引用的对象都不会被回收"><meta name=author content="AlfredNing"><link rel=canonical href=https://AlfredNing.github.io/note/program/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.e5771fb9e0e77d8883948ff5d616e3cd0e8c4fa356f5087dd942639feab30802.css integrity="sha256-5XcfueDnfYiDlI/11hbjzQ6MT6NW9Qh92UJjn+qzCAI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://AlfredNing.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://AlfredNing.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://AlfredNing.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://AlfredNing.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://AlfredNing.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="运行时内存"><meta property="og:description" content="jvm内存结构图
哪些内存结构与线程意义对应，其实问的是线程共有和私有 共有： 堆和方法区 私有： 本地方法栈、虚拟机栈、程序计数器
程序计数器 保证程序在程序系统中能够执行下去，CPU必须具有某些手段来确定下一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器 一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器。 在程序开始执行前，必须将它的起始地址，即程序的一条指令所在的内存单元地址送入PC，因此程序计数器（PC）的内容即是从内存提取的第一条指令的地址。当执行指令时，CPU将自动修改PC的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数，以便使其保持的总是将要执行的下一条指令的地址 由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单的对PC加1 当程序转移时，转移指令执行的最终结果就是要改变PC的值，此PC值就是转去的地址，以此实现转移。有些机器中也称PC为指令指针IP（Instruction Pointer） 特征 JVM中的程序计数寄存器（Program Counter Register）中， Register 的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。 CPU只有把数据装载到寄存器才能够运行。
JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟
很小的内存结构，忽略不计，也是运行最快的存储区域，不会随着程序的运行需要更大的空间 在JVM规范中，每个线程都有自己的程序计数器，是线程私有的，生命周期与线程生命周期保持一致 它是唯一一个在JVM虚拟机规范中没有规定任何OutOtMemoryError 情况的区域 问题 为什么使用PC寄存器来记录当前线程的执行地址 因为CPU需要不停的切换各个线程，准确知道执行的位置。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令 PC寄存器为什么被设置为线程私有 多线程在一个特定的时间段内之会执行某一个线程的方法，CPU需要不停的做任务切换**。为了准确记录各个线程正在执行的当前字节码指令，最好的办法就是为每一个线程分配PC寄存器**，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况 虚拟机栈 栈管运行，堆管内存
栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿
Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。 是线程私有的 生命周期: 生命周期和线程一致。
特点: 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。
栈是否有GC？ 不存在GC, 但有OOM
抛出的异常：
StackOverFlowError OutOfMemoryError Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个 StackOverflowError 异常 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出—个 OutOfMemoryError 异常 设置栈大小 -Xsssize (即：-XX:ThreadStackSize)
一般为：512k-1M 栈的大小直接决定了函数调用的最大深度 设置的栈空间值过大，会导致系统可以用于创建线程的数量减少 一般一个进程中通常有3000-5000个线程
jdk5.0之前，默认为256k jdk5.0之后，默认为1024k
栈帧 栈的基本单位是栈帧，每个线程都有自己的栈，栈中的数据都是以栈帧存在的。
方法与栈帧的关系 在这个线程执行的方法都有一个栈帧 栈帧是一个内存区块，是一个数据集，维护着方法执行过程中的各种数据信息 栈的内部结构 局部变量表 操作数栈或表达式栈 动态链接或指向运行时常量池的方法引用 方法返回地址（或方法正常退出或者异常退出的定义） 一些附加信息 局部变量表 - Local Varibales 局部变量表被称为局部变量数组或者本地变量表 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，数据类别包括：基本数据类型，对象引用、以returnAddress类型 局部变量表的大小是在编译器确定，保存在方法的code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的 方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减 **局部变量表的变量只在当前方法调用中有效。**在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。 静态变量与局部变量区别 类变量表有两次初始化的机会，第一次准备阶段，执行系统初始化，赋零值，另一次是在初始化阶段，赋予代码中指定的初始值 和类变量初始化不同，局部变量表不存在系统初始化的过程，一旦定义了局部变量则必须人为的初始化，否则无法使用 与GC ROOTS的关系 局部变量表的变量也是重要的垃圾回收节点，只要被局部变量中直接或者间接引用的对象都不会被回收"><meta property="og:type" content="article"><meta property="og:url" content="https://AlfredNing.github.io/note/program/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98/"><meta property="article:section" content="note"><meta property="article:published_time" content="2023-02-27T21:33:26+08:00"><meta property="article:modified_time" content="2023-02-27T21:33:26+08:00"><meta property="og:site_name" content="Alfred.Ning"><meta name=twitter:card content="summary"><meta name=twitter:title content="运行时内存"><meta name=twitter:description content="jvm内存结构图
哪些内存结构与线程意义对应，其实问的是线程共有和私有 共有： 堆和方法区 私有： 本地方法栈、虚拟机栈、程序计数器
程序计数器 保证程序在程序系统中能够执行下去，CPU必须具有某些手段来确定下一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器 一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器。 在程序开始执行前，必须将它的起始地址，即程序的一条指令所在的内存单元地址送入PC，因此程序计数器（PC）的内容即是从内存提取的第一条指令的地址。当执行指令时，CPU将自动修改PC的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数，以便使其保持的总是将要执行的下一条指令的地址 由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单的对PC加1 当程序转移时，转移指令执行的最终结果就是要改变PC的值，此PC值就是转去的地址，以此实现转移。有些机器中也称PC为指令指针IP（Instruction Pointer） 特征 JVM中的程序计数寄存器（Program Counter Register）中， Register 的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。 CPU只有把数据装载到寄存器才能够运行。
JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟
很小的内存结构，忽略不计，也是运行最快的存储区域，不会随着程序的运行需要更大的空间 在JVM规范中，每个线程都有自己的程序计数器，是线程私有的，生命周期与线程生命周期保持一致 它是唯一一个在JVM虚拟机规范中没有规定任何OutOtMemoryError 情况的区域 问题 为什么使用PC寄存器来记录当前线程的执行地址 因为CPU需要不停的切换各个线程，准确知道执行的位置。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令 PC寄存器为什么被设置为线程私有 多线程在一个特定的时间段内之会执行某一个线程的方法，CPU需要不停的做任务切换**。为了准确记录各个线程正在执行的当前字节码指令，最好的办法就是为每一个线程分配PC寄存器**，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况 虚拟机栈 栈管运行，堆管内存
栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿
Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。 是线程私有的 生命周期: 生命周期和线程一致。
特点: 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。
栈是否有GC？ 不存在GC, 但有OOM
抛出的异常：
StackOverFlowError OutOfMemoryError Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个 StackOverflowError 异常 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出—个 OutOfMemoryError 异常 设置栈大小 -Xsssize (即：-XX:ThreadStackSize)
一般为：512k-1M 栈的大小直接决定了函数调用的最大深度 设置的栈空间值过大，会导致系统可以用于创建线程的数量减少 一般一个进程中通常有3000-5000个线程
jdk5.0之前，默认为256k jdk5.0之后，默认为1024k
栈帧 栈的基本单位是栈帧，每个线程都有自己的栈，栈中的数据都是以栈帧存在的。
方法与栈帧的关系 在这个线程执行的方法都有一个栈帧 栈帧是一个内存区块，是一个数据集，维护着方法执行过程中的各种数据信息 栈的内部结构 局部变量表 操作数栈或表达式栈 动态链接或指向运行时常量池的方法引用 方法返回地址（或方法正常退出或者异常退出的定义） 一些附加信息 局部变量表 - Local Varibales 局部变量表被称为局部变量数组或者本地变量表 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，数据类别包括：基本数据类型，对象引用、以returnAddress类型 局部变量表的大小是在编译器确定，保存在方法的code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的 方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减 **局部变量表的变量只在当前方法调用中有效。**在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。 静态变量与局部变量区别 类变量表有两次初始化的机会，第一次准备阶段，执行系统初始化，赋零值，另一次是在初始化阶段，赋予代码中指定的初始值 和类变量初始化不同，局部变量表不存在系统初始化的过程，一旦定义了局部变量则必须人为的初始化，否则无法使用 与GC ROOTS的关系 局部变量表的变量也是重要的垃圾回收节点，只要被局部变量中直接或者间接引用的对象都不会被回收"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"笔记","item":"https://AlfredNing.github.io/note/"},{"@type":"ListItem","position":3,"name":"编程","item":"https://AlfredNing.github.io/note/program/"},{"@type":"ListItem","position":4,"name":"jvm","item":"https://AlfredNing.github.io/note/program/jvm/"},{"@type":"ListItem","position":5,"name":"运行时内存","item":"https://AlfredNing.github.io/note/program/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"运行时内存","name":"运行时内存","description":"jvm内存结构图\n哪些内存结构与线程意义对应，其实问的是线程共有和私有 共有： 堆和方法区 私有： 本地方法栈、虚拟机栈、程序计数器\n程序计数器 保证程序在程序系统中能够执行下去，CPU必须具有某些手段来确定下一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器 一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器。 在程序开始执行前，必须将它的起始地址，即程序的一条指令所在的内存单元地址送入PC，因此程序计数器（PC）的内容即是从内存提取的第一条指令的地址。当执行指令时，CPU将自动修改PC的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数，以便使其保持的总是将要执行的下一条指令的地址 由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单的对PC加1 当程序转移时，转移指令执行的最终结果就是要改变PC的值，此PC值就是转去的地址，以此实现转移。有些机器中也称PC为指令指针IP（Instruction Pointer） 特征 JVM中的程序计数寄存器（Program Counter Register）中， Register 的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。 CPU只有把数据装载到寄存器才能够运行。\nJVM中的PC寄存器是对物理PC寄存器的一种抽象模拟\n很小的内存结构，忽略不计，也是运行最快的存储区域，不会随着程序的运行需要更大的空间 在JVM规范中，每个线程都有自己的程序计数器，是线程私有的，生命周期与线程生命周期保持一致 它是唯一一个在JVM虚拟机规范中没有规定任何OutOtMemoryError 情况的区域 问题 为什么使用PC寄存器来记录当前线程的执行地址 因为CPU需要不停的切换各个线程，准确知道执行的位置。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令 PC寄存器为什么被设置为线程私有 多线程在一个特定的时间段内之会执行某一个线程的方法，CPU需要不停的做任务切换**。为了准确记录各个线程正在执行的当前字节码指令，最好的办法就是为每一个线程分配PC寄存器**，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况 虚拟机栈 栈管运行，堆管内存\n栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿\nJava虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。 是线程私有的 生命周期: 生命周期和线程一致。\n特点: 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。\n栈是否有GC？ 不存在GC, 但有OOM\n抛出的异常：\nStackOverFlowError OutOfMemoryError Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个 StackOverflowError 异常 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出—个 OutOfMemoryError 异常 设置栈大小 -Xsssize (即：-XX:ThreadStackSize)\n一般为：512k-1M 栈的大小直接决定了函数调用的最大深度 设置的栈空间值过大，会导致系统可以用于创建线程的数量减少 一般一个进程中通常有3000-5000个线程\njdk5.0之前，默认为256k jdk5.0之后，默认为1024k\n栈帧 栈的基本单位是栈帧，每个线程都有自己的栈，栈中的数据都是以栈帧存在的。\n方法与栈帧的关系 在这个线程执行的方法都有一个栈帧 栈帧是一个内存区块，是一个数据集，维护着方法执行过程中的各种数据信息 栈的内部结构 局部变量表 操作数栈或表达式栈 动态链接或指向运行时常量池的方法引用 方法返回地址（或方法正常退出或者异常退出的定义） 一些附加信息 局部变量表 - Local Varibales 局部变量表被称为局部变量数组或者本地变量表 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，数据类别包括：基本数据类型，对象引用、以returnAddress类型 局部变量表的大小是在编译器确定，保存在方法的code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的 方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减 **局部变量表的变量只在当前方法调用中有效。**在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。 静态变量与局部变量区别 类变量表有两次初始化的机会，第一次准备阶段，执行系统初始化，赋零值，另一次是在初始化阶段，赋予代码中指定的初始值 和类变量初始化不同，局部变量表不存在系统初始化的过程，一旦定义了局部变量则必须人为的初始化，否则无法使用 与GC ROOTS的关系 局部变量表的变量也是重要的垃圾回收节点，只要被局部变量中直接或者间接引用的对象都不会被回收","keywords":[""],"articleBody":"jvm内存结构图\n哪些内存结构与线程意义对应，其实问的是线程共有和私有 共有： 堆和方法区 私有： 本地方法栈、虚拟机栈、程序计数器\n程序计数器 保证程序在程序系统中能够执行下去，CPU必须具有某些手段来确定下一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器 一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器。 在程序开始执行前，必须将它的起始地址，即程序的一条指令所在的内存单元地址送入PC，因此程序计数器（PC）的内容即是从内存提取的第一条指令的地址。当执行指令时，CPU将自动修改PC的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数，以便使其保持的总是将要执行的下一条指令的地址 由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单的对PC加1 当程序转移时，转移指令执行的最终结果就是要改变PC的值，此PC值就是转去的地址，以此实现转移。有些机器中也称PC为指令指针IP（Instruction Pointer） 特征 JVM中的程序计数寄存器（Program Counter Register）中， Register 的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。 CPU只有把数据装载到寄存器才能够运行。\nJVM中的PC寄存器是对物理PC寄存器的一种抽象模拟\n很小的内存结构，忽略不计，也是运行最快的存储区域，不会随着程序的运行需要更大的空间 在JVM规范中，每个线程都有自己的程序计数器，是线程私有的，生命周期与线程生命周期保持一致 它是唯一一个在JVM虚拟机规范中没有规定任何OutOtMemoryError 情况的区域 问题 为什么使用PC寄存器来记录当前线程的执行地址 因为CPU需要不停的切换各个线程，准确知道执行的位置。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令 PC寄存器为什么被设置为线程私有 多线程在一个特定的时间段内之会执行某一个线程的方法，CPU需要不停的做任务切换**。为了准确记录各个线程正在执行的当前字节码指令，最好的办法就是为每一个线程分配PC寄存器**，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况 虚拟机栈 栈管运行，堆管内存\n栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿\nJava虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。 是线程私有的 生命周期: 生命周期和线程一致。\n特点: 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。\n栈是否有GC？ 不存在GC, 但有OOM\n抛出的异常：\nStackOverFlowError OutOfMemoryError Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个 StackOverflowError 异常 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出—个 OutOfMemoryError 异常 设置栈大小 -Xsssize (即：-XX:ThreadStackSize)\n一般为：512k-1M 栈的大小直接决定了函数调用的最大深度 设置的栈空间值过大，会导致系统可以用于创建线程的数量减少 一般一个进程中通常有3000-5000个线程\njdk5.0之前，默认为256k jdk5.0之后，默认为1024k\n栈帧 栈的基本单位是栈帧，每个线程都有自己的栈，栈中的数据都是以栈帧存在的。\n方法与栈帧的关系 在这个线程执行的方法都有一个栈帧 栈帧是一个内存区块，是一个数据集，维护着方法执行过程中的各种数据信息 栈的内部结构 局部变量表 操作数栈或表达式栈 动态链接或指向运行时常量池的方法引用 方法返回地址（或方法正常退出或者异常退出的定义） 一些附加信息 局部变量表 - Local Varibales 局部变量表被称为局部变量数组或者本地变量表 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，数据类别包括：基本数据类型，对象引用、以returnAddress类型 局部变量表的大小是在编译器确定，保存在方法的code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的 方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减 **局部变量表的变量只在当前方法调用中有效。**在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。 静态变量与局部变量区别 类变量表有两次初始化的机会，第一次准备阶段，执行系统初始化，赋零值，另一次是在初始化阶段，赋予代码中指定的初始值 和类变量初始化不同，局部变量表不存在系统初始化的过程，一旦定义了局部变量则必须人为的初始化，否则无法使用 与GC ROOTS的关系 局部变量表的变量也是重要的垃圾回收节点，只要被局部变量中直接或者间接引用的对象都不会被回收\n操作数栈 Operand Stack 操作数栈（Operand Stack）\n我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。\n每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出（Last-In-First-Out）的操作数栈，也可以称之为表达式栈（Expression Stack）。\n操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。\n每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值。\n栈中的任何一个元素都是可以任意的Java数据类型。\n32bit的类型占用一个栈单位深度\n64bit的类型占用两个栈单位深度\n操作数栈，在方法执行过程中，根据字节码指令，并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈（push）和出栈（pop）操作，往栈中写入数据或提取数据来完成一次数据访问。\n某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。比如：执行复制、交换、求和等操作\n如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。\n栈顶缓存 由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（ToS，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。\n动态链接（或指向运行时常量池的方法引用） 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic指令 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。 常量池的作用 常量池的作用，就是为了提供一些符号和常量，便于指令的识别。\n方法返回地址 存放调用该方法的pc寄存器的值。\n一个方法的结束，有两种方式：\n正常执行完成\n出现未处理的异常，非正常退出\n无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。\n本地方法与本地方法栈 本地方法 简单地讲，一个Native Method就是一个Java调用非Java代码的接口。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern “C\"告知C++编译器去调用一个C的函数。\n“A native method is a Java method whose implementation is provided by non-java code.”\n在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。\n本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合 C/C++程序。\n本地方法栈 Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。 本地方法栈，也是线程私有的。 允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的） 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个 StackOverflowError 异常。 如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个 OutOfMemoryError 异常。 本地方法是使用C语言实现的。 它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。 堆 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。\nJava 堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。\n堆内存的大小是可以调节的。\n《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。\n堆，是GC ( Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。\n在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。\n对象都分配在堆上？\n《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated ) 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置 “几乎”所有的对象实例都在这里分配内存。——从实际使用角度看的。TLAB的存在 TLAB Thread Local Allocation Buffer\n堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。 所以，多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。\n堆的内部结构\n现代垃圾收集器大部分都基于分代收集理论设计。\nJava 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区 Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区 Tenure generation space 养老区 Old/Tenure Permanent Space 永久区 Perm Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间 Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区 Tenure generation space 养老区 Old/Tenure Meta Space 元空间 Meta 年轻代与老年代 存储在JVM中的Java对象可以被划分为两类： 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。 Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（OldGen） 其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）。 几乎所有的Java对象都是在Eden区被new出来的。 绝大部分的Java对象的销毁都在新生代进行了。 IBM 公司的专门研究表明，新生代中 80% 的对象都是“朝生夕死”的。 设置堆内存 设置新生代与老年代的比例 配置新生代与老年代在堆结构的占比。 默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3 可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5 可以使用选项”-Xmn”设置新生代最大内存大小 这个参数一般使用默认值就可以了。\n设置Eden 与Suvivor比例 在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1 可以通过选项“-XX:SurvivorRatio”调整这个空间比例。比如**-XX:SurvivorRatio=8** 参数设置 堆空间大小的设置 -Xms:初始内存 （默认为物理内存的1/64） -Xmx:最大内存（默认为物理内存的1/4） 新生代大小设置 -Xmn\n设置新生代的大小。(初始值及最大值) 通常默认即可。\n设置新生代垃圾的最大年龄。超过此值，仍未被回收的话，则进入老年代 默认值为15 -XX:MaxTenuringThreshold=0：表示年轻代对象不经过Survivor区，直接进入老年代。对于老年代比较多的应用，可以提高效率。 如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代的存活时间，增加在年轻代即被回收的概率 输出详细的GC处理日志 -XX:+PrintGCDetails\n在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间 -XX:HandlePromotionFailure\n如果大于，则此次Minor GC是安全的 如果小于，则虚拟机会查看-XX:HandlePromotionFailure设置值是否允许担保失败。 如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于或者HandlePromotionFailure=false，则改为进行一次Full GC。 查看所有的参数的最终值 -XX:+PrintFlagsFinal\n具体查看某个参数的指令： jps：查看当前运行中的进程 jinfo -flag SurvivorRatio 进程id -Xms60m -Xmx60m -XX:NewRatio=2 -XX:SurvivorRatio=8 -XX:+PrintGCDetails 对象分配过程 1.new的对象先放伊甸园区。此区有大小限制。\n2.当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC/YGC)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区\n3.然后将伊甸园中的剩余对象移动到幸存者0区。\n4.如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。\n5.如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。\n6.啥时候能去养老区呢？可以设置次数。默认是15次。\n可以设置参数：-XX:MaxTenuringThreshold= 设置对象晋升老年代的年龄阈值。 7.在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理。\n8.若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生OOM异常 java.lang.OutOfMemoryError: Java heap space\n分配策略 内存分配策略（或对象提升(promotion)规则):\n如果对象在Eden 出生并经过第一次MinorGC 后仍然存活，并且能被Survivor 容纳的话，将被移动到Survivor 空间中，并将对象年龄设为1 。对象在Survivor 区中每熬过一次MinorGC ， 年龄就增加1岁，当它的年龄增加到一定程度（默认为15 岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代中。\n内存分配原则 针对不同年龄段的对象分配原则如下所示：\n优先分配到Eden 大对象直接分配到老年代 尽量避免程序中出现过多的大对象 长期存活的对象分配到老年代 动态对象年龄判断 如果Survivor 区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。 空间分配担保 -XX:HandlePromotionFailure ","wordCount":"350","inLanguage":"zh","datePublished":"2023-02-27T21:33:26+08:00","dateModified":"2023-02-27T21:33:26+08:00","author":[{"@type":"Person","name":"AlfredNing"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://AlfredNing.github.io/note/program/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98/"},"publisher":{"@type":"Organization","name":"AlfredNing","logo":{"@type":"ImageObject","url":"https://AlfredNing.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://AlfredNing.github.io accesskey=h title="AlfredNing (Alt + H)">AlfredNing</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://AlfredNing.github.io/note/ title=📓笔记><span>📓笔记</span></a></li><li><a href=https://AlfredNing.github.io/thinking/ title=🤔想法><span>🤔想法</span></a></li><li><a href=https://AlfredNing.github.io/search/ title="🔎搜索 (Alt + /)" accesskey=/><span>🔎搜索</span></a></li><li><a href=https://AlfredNing.github.io/tags/ title=🏷️标签><span>🏷️标签</span></a></li><li><a href=https://AlfredNing.github.io/archives title=🗄️归档><span>🗄️归档</span></a></li><li><a href=https://AlfredNing.github.io/about title=🤙关于><span>🤙关于</span></a></li></ul></nav></header><main class="main page"><article class=post-single><div id=single-content><header class=post-header><div class=breadcrumbs><a href=https://AlfredNing.github.io>主页</a>&nbsp;»&nbsp;<a href=https://AlfredNing.github.io/note/>笔记</a>&nbsp;»&nbsp;<a href=https://AlfredNing.github.io/note/program/>编程</a>&nbsp;»&nbsp;<a href=https://AlfredNing.github.io/note/program/jvm/>jvm</a></div><h1 class=post-title>运行时内存</h1><div class=post-meta>创建:&nbsp;<span title='2023-02-27 21:33:26 +0800 +0800'>2023年-02月-27日</span>&nbsp;|&nbsp;更新:&nbsp;2023年-02月-27日&nbsp;|&nbsp;字数:&nbsp;350字&nbsp;|&nbsp;时长:&nbsp;2分钟&nbsp;|&nbsp;AlfredNing
&nbsp;|&nbsp;标签: &nbsp;<ul class=post-tags-meta><a href=https://AlfredNing.github.io/tags/jvm/>jvm</a></ul><span id=busuanzi_container_page_pv>&nbsp;| 访问: <span id=busuanzi_value_page_pv></span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e7%a8%8b%e5%ba%8f%e8%ae%a1%e6%95%b0%e5%99%a8 aria-label=程序计数器>程序计数器</a><ul><li><a href=#%e7%89%b9%e5%be%81 aria-label=特征>特征</a></li><li><a href=#%e9%97%ae%e9%a2%98 aria-label=问题>问题</a></li></ul></li><li><a href=#%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%a0%88 aria-label=虚拟机栈>虚拟机栈</a><ul><li><a href=#%e8%ae%be%e7%bd%ae%e6%a0%88%e5%a4%a7%e5%b0%8f aria-label=设置栈大小>设置栈大小</a></li><li><a href=#%e6%a0%88%e5%b8%a7 aria-label=栈帧>栈帧</a><ul><li><a href=#%e6%96%b9%e6%b3%95%e4%b8%8e%e6%a0%88%e5%b8%a7%e7%9a%84%e5%85%b3%e7%b3%bb aria-label=方法与栈帧的关系>方法与栈帧的关系</a></li><li><a href=#%e6%a0%88%e7%9a%84%e5%86%85%e9%83%a8%e7%bb%93%e6%9e%84 aria-label=栈的内部结构>栈的内部结构</a><ul><li><a href=#%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f%e8%a1%a8---local-varibales aria-label="局部变量表 - Local Varibales">局部变量表 - Local Varibales</a><ul><li><a href=#%e9%9d%99%e6%80%81%e5%8f%98%e9%87%8f%e4%b8%8e%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f%e5%8c%ba%e5%88%ab aria-label=静态变量与局部变量区别>静态变量与局部变量区别</a></li><li><a href=#%e4%b8%8egc-roots%e7%9a%84%e5%85%b3%e7%b3%bb aria-label="与GC ROOTS的关系">与GC ROOTS的关系</a></li></ul></li><li><a href=#%e6%93%8d%e4%bd%9c%e6%95%b0%e6%a0%88-operand-stack aria-label="操作数栈 Operand Stack">操作数栈 Operand Stack</a><ul><li><a href=#%e6%a0%88%e9%a1%b6%e7%bc%93%e5%ad%98 aria-label=栈顶缓存>栈顶缓存</a></li><li><a href=#%e5%8a%a8%e6%80%81%e9%93%be%e6%8e%a5%e6%88%96%e6%8c%87%e5%90%91%e8%bf%90%e8%a1%8c%e6%97%b6%e5%b8%b8%e9%87%8f%e6%b1%a0%e7%9a%84%e6%96%b9%e6%b3%95%e5%bc%95%e7%94%a8 aria-label=动态链接（或指向运行时常量池的方法引用）>动态链接（或指向运行时常量池的方法引用）</a></li><li><a href=#%e5%b8%b8%e9%87%8f%e6%b1%a0%e7%9a%84%e4%bd%9c%e7%94%a8 aria-label=常量池的作用>常量池的作用</a></li><li><a href=#%e6%96%b9%e6%b3%95%e8%bf%94%e5%9b%9e%e5%9c%b0%e5%9d%80 aria-label=方法返回地址>方法返回地址</a></li></ul></li></ul></li></ul></li></ul></li><li><a href=#%e6%9c%ac%e5%9c%b0%e6%96%b9%e6%b3%95%e4%b8%8e%e6%9c%ac%e5%9c%b0%e6%96%b9%e6%b3%95%e6%a0%88 aria-label=本地方法与本地方法栈>本地方法与本地方法栈</a><ul><li><a href=#%e6%9c%ac%e5%9c%b0%e6%96%b9%e6%b3%95 aria-label=本地方法>本地方法</a></li><li><a href=#%e6%9c%ac%e5%9c%b0%e6%96%b9%e6%b3%95%e6%a0%88 aria-label=本地方法栈>本地方法栈</a></li></ul></li><li><a href=#%e5%a0%86 aria-label=堆>堆</a><ul><li><a href=#tlab aria-label=TLAB>TLAB</a><ul><li><a href=#%e5%b9%b4%e8%bd%bb%e4%bb%a3%e4%b8%8e%e8%80%81%e5%b9%b4%e4%bb%a3 aria-label=年轻代与老年代>年轻代与老年代</a></li></ul></li><li><a href=#%e8%ae%be%e7%bd%ae%e5%a0%86%e5%86%85%e5%ad%98 aria-label=设置堆内存>设置堆内存</a><ul><li><a href=#%e8%ae%be%e7%bd%ae%e6%96%b0%e7%94%9f%e4%bb%a3%e4%b8%8e%e8%80%81%e5%b9%b4%e4%bb%a3%e7%9a%84%e6%af%94%e4%be%8b aria-label=设置新生代与老年代的比例>设置新生代与老年代的比例</a></li><li><a href=#%e8%ae%be%e7%bd%aeeden-%e4%b8%8esuvivor%e6%af%94%e4%be%8b aria-label="设置Eden 与Suvivor比例">设置Eden 与Suvivor比例</a></li></ul></li><li><a href=#%e5%8f%82%e6%95%b0%e8%ae%be%e7%bd%ae aria-label=参数设置>参数设置</a><ul><li><a href=#%e5%a0%86%e7%a9%ba%e9%97%b4%e5%a4%a7%e5%b0%8f%e7%9a%84%e8%ae%be%e7%bd%ae aria-label=堆空间大小的设置>堆空间大小的设置</a></li><li><a href=#%e6%96%b0%e7%94%9f%e4%bb%a3%e5%a4%a7%e5%b0%8f%e8%ae%be%e7%bd%ae aria-label=新生代大小设置>新生代大小设置</a></li><li><a href=#%e8%ae%be%e7%bd%ae%e6%96%b0%e7%94%9f%e4%bb%a3%e5%9e%83%e5%9c%be%e7%9a%84%e6%9c%80%e5%a4%a7%e5%b9%b4%e9%be%84%e8%b6%85%e8%bf%87%e6%ad%a4%e5%80%bc%e4%bb%8d%e6%9c%aa%e8%a2%ab%e5%9b%9e%e6%94%b6%e7%9a%84%e8%af%9d%e5%88%99%e8%bf%9b%e5%85%a5%e8%80%81%e5%b9%b4%e4%bb%a3 aria-label=设置新生代垃圾的最大年龄。超过此值，仍未被回收的话，则进入老年代>设置新生代垃圾的最大年龄。超过此值，仍未被回收的话，则进入老年代</a></li><li><a href=#%e8%be%93%e5%87%ba%e8%af%a6%e7%bb%86%e7%9a%84gc%e5%a4%84%e7%90%86%e6%97%a5%e5%bf%97 aria-label=输出详细的GC处理日志>输出详细的GC处理日志</a></li><li><a href=#%e5%9c%a8%e5%8f%91%e7%94%9fminor-gc%e4%b9%8b%e5%89%8d%e8%99%9a%e6%8b%9f%e6%9c%ba%e4%bc%9a%e6%a3%80%e6%9f%a5%e8%80%81%e5%b9%b4%e4%bb%a3%e6%9c%80%e5%a4%a7%e5%8f%af%e7%94%a8%e7%9a%84%e8%bf%9e%e7%bb%ad%e7%a9%ba%e9%97%b4%e6%98%af%e5%90%a6%e5%a4%a7%e4%ba%8e%e6%96%b0%e7%94%9f%e4%bb%a3%e6%89%80%e6%9c%89%e5%af%b9%e8%b1%a1%e7%9a%84%e6%80%bb%e7%a9%ba%e9%97%b4 aria-label="在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间">在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间</a></li><li><a href=#%e6%9f%a5%e7%9c%8b%e6%89%80%e6%9c%89%e7%9a%84%e5%8f%82%e6%95%b0%e7%9a%84%e6%9c%80%e7%bb%88%e5%80%bc aria-label=查看所有的参数的最终值>查看所有的参数的最终值</a></li></ul></li><li><a href=#%e5%af%b9%e8%b1%a1%e5%88%86%e9%85%8d%e8%bf%87%e7%a8%8b aria-label=对象分配过程>对象分配过程</a><ul><li><a href=#%e5%88%86%e9%85%8d%e7%ad%96%e7%95%a5 aria-label=分配策略>分配策略</a></li><li><a href=#%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%8e%9f%e5%88%99 aria-label=内存分配原则>内存分配原则</a></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>jvm内存结构图</p><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230227213433004.png alt=image-20230227213433004></p><p>哪些内存结构与线程意义对应，其实问的是线程共有和私有
共有： 堆和方法区
私有： 本地方法栈、虚拟机栈、程序计数器</p><h1 id=程序计数器>程序计数器<a hidden class=anchor aria-hidden=true href=#程序计数器>#</a></h1><ol><li>保证程序在程序系统中能够执行下去，CPU必须具有某些手段来确定下一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器</li><li>一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器。
在程序开始执行前，必须将它的起始地址，即程序的一条指令所在的内存单元地址送入PC，因此程序计数器（PC）的内容即是从内存提取的第一条指令的地址。当执行指令时，CPU将自动修改PC的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数，以便使其保持的总是将要执行的下一条指令的地址</li><li>由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单的对PC加1</li><li>当程序转移时，转移指令执行的最终结果就是要改变PC的值，此PC值就是转去的地址，以此实现转移。有些机器中也称PC为指令指针IP（Instruction Pointer）</li></ol><h2 id=特征>特征<a hidden class=anchor aria-hidden=true href=#特征>#</a></h2><blockquote><p>JVM中的程序计数寄存器（Program Counter Register）中， Register 的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。 CPU只有把数据装载到寄存器才能够运行。</p></blockquote><p><strong>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟</strong></p><ul><li>很小的内存结构，忽略不计，也是运行最快的存储区域，不会随着程序的运行需要更大的空间</li><li>在JVM规范中，每个线程都有自己的程序计数器，是线程私有的，生命周期与线程生命周期保持一致</li><li><strong>它是唯一一个在JVM虚拟机规范中没有规定任何OutOtMemoryError 情况的区域</strong></li></ul><h2 id=问题>问题<a hidden class=anchor aria-hidden=true href=#问题>#</a></h2><ol><li>为什么使用PC寄存器来记录当前线程的执行地址
因为CPU需要不停的切换各个线程，准确知道执行的位置。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令</li><li>PC寄存器为什么被设置为线程私有
多线程在一个特定的时间段内之会执行某一个线程的方法，CPU需要不停的做任务切换**。为了准确记录各个线程正在执行的当前字节码指令，最好的办法就是为每一个线程分配PC寄存器**，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况</li></ol><h1 id=虚拟机栈>虚拟机栈<a hidden class=anchor aria-hidden=true href=#虚拟机栈>#</a></h1><blockquote><p>栈管运行，堆管内存</p><p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿</p><ul><li>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。</li><li>是线程私有的</li></ul><p>生命周期: 生命周期和线程一致。</p><p>特点: 栈是一种快速有效的分配存储方式，<strong>访问速度仅次于程序计数器</strong>。</p></blockquote><p>栈是否有GC？ 不存在GC, 但有OOM</p><p>抛出的异常：</p><ul><li>StackOverFlowError</li><li>OutOfMemoryError</li></ul><ol><li>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的</li><li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个 StackOverflowError 异常</li><li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出—个 OutOfMemoryError 异常</li></ol><h2 id=设置栈大小>设置栈大小<a hidden class=anchor aria-hidden=true href=#设置栈大小>#</a></h2><p>-Xsssize (即：-XX:ThreadStackSize)</p><ul><li>一般为：512k-1M</li><li>栈的大小直接决定了函数调用的最大深度</li><li>设置的栈空间值过大，会导致系统可以用于创建线程的数量减少</li></ul><p>一般一个进程中通常有3000-5000个线程</p><p>jdk5.0之前，默认为256k
jdk5.0之后，默认为1024k</p><h2 id=栈帧>栈帧<a hidden class=anchor aria-hidden=true href=#栈帧>#</a></h2><p>栈的基本单位是栈帧，每个线程都有自己的栈，栈中的数据都是以栈帧存在的。</p><h3 id=方法与栈帧的关系>方法与栈帧的关系<a hidden class=anchor aria-hidden=true href=#方法与栈帧的关系>#</a></h3><ul><li>在这个线程执行的方法都有一个栈帧</li><li>栈帧是一个内存区块，是一个数据集，维护着方法执行过程中的各种数据信息</li></ul><h3 id=栈的内部结构>栈的内部结构<a hidden class=anchor aria-hidden=true href=#栈的内部结构>#</a></h3><ul><li>局部变量表</li><li>操作数栈或表达式栈</li><li>动态链接或指向运行时常量池的方法引用</li><li>方法返回地址（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/53BA4F99-EA72-4192-B3B8-44BDE74899EF.png alt=img></p><h4 id=局部变量表---local-varibales>局部变量表 - Local Varibales<a hidden class=anchor aria-hidden=true href=#局部变量表---local-varibales>#</a></h4><ul><li>局部变量表被称为局部变量数组或者本地变量表</li><li><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，数据类别包括：基本数据类型，对象引用、以returnAddress类型</li><li><strong>局部变量表的大小是在编译器确定</strong>，保存在方法的code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的</li><li><strong>方法嵌套调用的次数由栈的大小决定</strong>。一般来说，<strong>栈越大，方法嵌套调用次数越多</strong>。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减</li><li>**局部变量表的变量只在当前方法调用中有效。**在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。<strong>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</strong></li></ul><h5 id=静态变量与局部变量区别>静态变量与局部变量区别<a hidden class=anchor aria-hidden=true href=#静态变量与局部变量区别>#</a></h5><ul><li>类变量表有两次初始化的机会，第一次准备阶段，执行系统初始化，赋零值，另一次是在初始化阶段，赋予代码中指定的初始值</li><li>和类变量初始化不同，局部变量表不存在系统初始化的过程，<strong>一旦定义了局部变量则必须人为的初始化，否则无法使用</strong></li></ul><h5 id=与gc-roots的关系>与GC ROOTS的关系<a hidden class=anchor aria-hidden=true href=#与gc-roots的关系>#</a></h5><p><strong>局部变量表的变量也是重要的垃圾回收节点，只要被局部变量中直接或者间接引用的对象都不会被回收</strong></p><h4 id=操作数栈-operand-stack>操作数栈 Operand Stack<a hidden class=anchor aria-hidden=true href=#操作数栈-operand-stack>#</a></h4><p>操作数栈（Operand Stack）</p><ul><li><p>我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。</p></li><li><p>每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出（Last-In-First-Out）的操作数栈，也可以称之为表达式栈（Expression Stack）。</p></li><li><p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。</p></li><li><p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值。</p></li><li><p>栈中的任何一个元素都是可以任意的Java数据类型。</p></li><li><p>32bit的类型占用一个栈单位深度</p></li><li><p>64bit的类型占用两个栈单位深度</p></li><li><p>操作数栈，在方法执行过程中，根据字节码指令，并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈（push）和出栈（pop）操作，往栈中写入数据或提取数据来完成一次数据访问。</p></li><li><p>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。比如：执行复制、交换、求和等操作</p></li><li><p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</p></li></ul><h5 id=栈顶缓存>栈顶缓存<a hidden class=anchor aria-hidden=true href=#栈顶缓存>#</a></h5><p>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（ToS，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</p><h5 id=动态链接或指向运行时常量池的方法引用>动态链接（或指向运行时常量池的方法引用）<a hidden class=anchor aria-hidden=true href=#动态链接或指向运行时常量池的方法引用>#</a></h5><ul><li>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic指令</li><li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</li></ul><h5 id=常量池的作用>常量池的作用<a hidden class=anchor aria-hidden=true href=#常量池的作用>#</a></h5><p>常量池的作用，就是为了提供一些符号和常量，便于指令的识别。</p><h5 id=方法返回地址>方法返回地址<a hidden class=anchor aria-hidden=true href=#方法返回地址>#</a></h5><ul><li><p>存放调用该方法的pc寄存器的值。</p></li><li><p>一个方法的结束，有两种方式：</p></li><li><p>正常执行完成</p></li><li><p>出现未处理的异常，非正常退出</p></li><li><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p></li></ul><h1 id=本地方法与本地方法栈>本地方法与本地方法栈<a hidden class=anchor aria-hidden=true href=#本地方法与本地方法栈>#</a></h1><h2 id=本地方法>本地方法<a hidden class=anchor aria-hidden=true href=#本地方法>#</a></h2><p>简单地讲，一个Native Method就是一个Java调用非Java代码的接口。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern &ldquo;C"告知C++编译器去调用一个C的函数。</p><p>&ldquo;A native method is a Java method whose implementation is provided by non-java code.&rdquo;</p><p>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</p><p>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合 C/C++程序。</p><h2 id=本地方法栈>本地方法栈<a hidden class=anchor aria-hidden=true href=#本地方法栈>#</a></h2><ul><li>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。</li><li>本地方法栈，也是线程私有的。</li><li>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）</li><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个 StackOverflowError 异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个 OutOfMemoryError 异常。</li><li>本地方法是使用C语言实现的。</li><li>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</li></ul><h1 id=堆>堆<a hidden class=anchor aria-hidden=true href=#堆>#</a></h1><ul><li><p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</p></li><li><p>Java 堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。</p></li><li><p>堆内存的大小是可以调节的。</p></li><li><p>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</p></li><li><p>堆，是GC ( Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</p></li><li><p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</p></li></ul><blockquote><p>对象都分配在堆上？</p><ul><li>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated ) 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置</li><li>“几乎”所有的对象实例都在这里分配内存。——从实际使用角度看的。TLAB的存在</li></ul></blockquote><h2 id=tlab>TLAB<a hidden class=anchor aria-hidden=true href=#tlab>#</a></h2><p><strong>Thread Local Allocation Buffer</strong></p><ul><li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li><li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li><li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</li></ul><p><strong>所以，多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。</strong></p><p>堆的内部结构</p><p>现代垃圾收集器大部分都基于分代收集理论设计。</p><ol><li>Java 7及之前堆内存逻辑上分为三部分：<strong>新生区+养老区+永久区</strong>
Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区
Tenure generation space 养老区 Old/Tenure
Permanent Space 永久区 Perm</li><li>Java 8及之后堆内存逻辑上分为三部分：<strong>新生区+养老区+元空间</strong>
Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区
Tenure generation space 养老区 Old/Tenure
Meta Space 元空间 Meta
<img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/428161D7-41DB-4FFE-8D47-74F45FDAC0CE.png alt=img></li></ol><h3 id=年轻代与老年代>年轻代与老年代<a hidden class=anchor aria-hidden=true href=#年轻代与老年代>#</a></h3><ul><li>存储在JVM中的Java对象可以被划分为两类：</li><li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速</li><li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。</li><li>Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（OldGen）</li><li>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）。</li></ul><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/34DC8A34-8FC1-4410-AAD6-421A3CE7010B.png alt=img></p><ul><li>几乎所有的Java对象都是在Eden区被new出来的。</li><li>绝大部分的Java对象的销毁都在新生代进行了。</li><li>IBM 公司的专门研究表明，新生代中 80% 的对象都是“朝生夕死”的。</li></ul><h2 id=设置堆内存>设置堆内存<a hidden class=anchor aria-hidden=true href=#设置堆内存>#</a></h2><h3 id=设置新生代与老年代的比例>设置新生代与老年代的比例<a hidden class=anchor aria-hidden=true href=#设置新生代与老年代的比例>#</a></h3><p><img loading=lazy src=https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/3361B78F-4E9C-47DF-AA94-C10367777ECE.png alt=img></p><ul><li>配置新生代与老年代在堆结构的占比。</li><li>默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</li><li>可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5</li><li>可以使用选项”-Xmn”设置新生代最大内存大小</li></ul><p><strong>这个参数一般使用默认值就可以了。</strong></p><h3 id=设置eden-与suvivor比例>设置Eden 与Suvivor比例<a hidden class=anchor aria-hidden=true href=#设置eden-与suvivor比例>#</a></h3><ul><li>在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1</li><li>可以通过选项“-XX:SurvivorRatio”调整这个空间比例。比如**-XX:SurvivorRatio=8**</li></ul><h2 id=参数设置>参数设置<a hidden class=anchor aria-hidden=true href=#参数设置>#</a></h2><h3 id=堆空间大小的设置>堆空间大小的设置<a hidden class=anchor aria-hidden=true href=#堆空间大小的设置>#</a></h3><ul><li>-Xms:初始内存 （默认为物理内存的1/64）</li><li>-Xmx:最大内存（默认为物理内存的1/4）</li></ul><h3 id=新生代大小设置>新生代大小设置<a hidden class=anchor aria-hidden=true href=#新生代大小设置>#</a></h3><p><strong>-Xmn</strong></p><p>设置新生代的大小。(初始值及最大值) <strong>通常默认即可。</strong></p><h3 id=设置新生代垃圾的最大年龄超过此值仍未被回收的话则进入老年代>设置新生代垃圾的最大年龄。超过此值，仍未被回收的话，则进入老年代<a hidden class=anchor aria-hidden=true href=#设置新生代垃圾的最大年龄超过此值仍未被回收的话则进入老年代>#</a></h3><ul><li>默认值为15</li><li>-<strong>XX:MaxTenuringThreshold</strong>=0：表示年轻代对象不经过Survivor区，直接进入老年代。对于老年代比较多的应用，可以提高效率。</li><li>如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代的存活时间，增加在年轻代即被回收的概率</li></ul><h3 id=输出详细的gc处理日志>输出详细的GC处理日志<a hidden class=anchor aria-hidden=true href=#输出详细的gc处理日志>#</a></h3><p><strong>-XX:+PrintGCDetails</strong></p><h3 id=在发生minor-gc之前虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间<a hidden class=anchor aria-hidden=true href=#在发生minor-gc之前虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间>#</a></h3><p><strong>-XX:HandlePromotionFailure</strong></p><ul><li>如果大于，则此次Minor GC是安全的</li><li>如果小于，则虚拟机会查看-XX:HandlePromotionFailure设置值是否允许担保失败。</li><li>如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于或者HandlePromotionFailure=false，则改为进行一次Full GC。</li></ul><h3 id=查看所有的参数的最终值>查看所有的参数的最终值<a hidden class=anchor aria-hidden=true href=#查看所有的参数的最终值>#</a></h3><p><strong>-XX:+PrintFlagsFinal</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=err>具体查看某个参数的指令：</span> <span class=n>jps</span><span class=err>：查看当前运行中的进程</span>
</span></span><span class=line><span class=cl> <span class=n>jinfo</span> <span class=o>-</span><span class=n>flag</span> <span class=n>SurvivorRatio</span> <span class=err>进程</span><span class=n>id</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=o>-</span><span class=n>Xms60m</span> <span class=o>-</span><span class=n>Xmx60m</span> <span class=o>-</span><span class=n>XX</span><span class=o>:</span><span class=n>NewRatio</span><span class=o>=</span><span class=mi>2</span> <span class=o>-</span><span class=n>XX</span><span class=o>:</span><span class=n>SurvivorRatio</span><span class=o>=</span><span class=mi>8</span> <span class=o>-</span><span class=n>XX</span><span class=o>:+</span><span class=n>PrintGCDetails</span>    
</span></span></code></pre></div><h2 id=对象分配过程>对象分配过程<a hidden class=anchor aria-hidden=true href=#对象分配过程>#</a></h2><p>1.new的对象先放伊甸园区。此区有大小限制。</p><p>2.当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC/YGC)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</p><p>3.然后将伊甸园中的剩余对象移动到幸存者0区。</p><p>4.如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</p><p>5.如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</p><p>6.啥时候能去养老区呢？可以设置次数。默认是15次。</p><ul><li>可以设置参数：-XX:MaxTenuringThreshold= 设置对象晋升老年代的年龄阈值。</li></ul><p>7.在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理。</p><p>8.若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生OOM异常 java.lang.OutOfMemoryError: Java heap space</p><h3 id=分配策略>分配策略<a hidden class=anchor aria-hidden=true href=#分配策略>#</a></h3><p>内存分配策略（或对象提升(promotion)规则):</p><p>如果对象在Eden 出生并经过第一次MinorGC 后仍然存活，并且能被Survivor 容纳的话，将被移动到Survivor 空间中，并将对象年龄设为1 。对象在Survivor 区中每熬过一次MinorGC ， 年龄就增加1岁，当它的年龄增加到一定程度（默认为15 岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代中。</p><h3 id=内存分配原则>内存分配原则<a hidden class=anchor aria-hidden=true href=#内存分配原则>#</a></h3><p>针对不同年龄段的对象分配原则如下所示：</p><ul><li>优先分配到Eden</li><li>大对象直接分配到老年代</li><li>尽量避免程序中出现过多的大对象</li><li>长期存活的对象分配到老年代</li><li>动态对象年龄判断</li><li>如果Survivor 区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。</li><li>空间分配担保</li><li>-XX:HandlePromotionFailure</li></ul></div><div class=post-reward><div style=padding:0;margin:0;width:100%;font-size:16px;text-align:center><div id=QR style=opacity:0><div id=wechat style=display:inline-block><a class=fancybox rel=group><img id=wechat_qr src=https://AlfredNing.github.io alt=wechat_pay></a><p>微信</p></div><div id=alipay style=display:inline-block><a class=fancybox rel=group><img id=alipay_qr src=https://AlfredNing.github.io alt=alipay></a><p>支付宝</p></div></div><button id=rewardButton onclick='var qr=document.getElementById("QR");qr.style.opacity==="0"?qr.style.opacity="1":qr.style.opacity="0"'>
<span>🧧 鼓励</span></button></div></div><footer class=post-footer><nav class=paginav><a class=prev href=https://AlfredNing.github.io/note/program/game/c++/c++%E5%9F%BA%E7%A1%801/><span class=title>« 上一页</span><br><span>C++初始</span></a>
<a class=next href=https://AlfredNing.github.io/note/program/jvm/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/><span class=title>下一页 »</span><br><span>类的加载</span></a></nav></footer></div><div><div class=pagination__title><span class=pagination__title-h style=font-size:20px>💬评论</span><hr></div><div id=tcomment></div><script src=https://utteranc.es/client.js repo=AlfredNing/AlfredNing.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2023 <a href=https://AlfredNing.github.io>AlfredNing</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>