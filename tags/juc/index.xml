<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>juc on AlfredNing</title>
    <link>https://AlfredNing.github.io/tags/juc/</link>
    <description>Recent content in juc on AlfredNing</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Wed, 19 Jul 2023 16:22:32 +0800</lastBuildDate><atom:link href="https://AlfredNing.github.io/tags/juc/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>04 ThreadLocal</title>
      <link>https://AlfredNing.github.io/note/program/juc/04-threadlocal/</link>
      <pubDate>Wed, 19 Jul 2023 16:22:32 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/juc/04-threadlocal/</guid>
      <description>定义 ThreadLocal提供线程局部变量。这些变量与正常的变量不同，因为每一个线程在访问ThreadLocal实例的时候（通过其get或set方法）都有自己的、独立初始化的变量副本。ThreadLocal实例通常是类中的私有静态字段，使用它的目的是希望将状态（例如，用户ID或事务ID）与线程关联起来。
每个ThreadLocl都是自己专属的本地变量副本,不存在多线程间共享的问题
初始化 ThreadLocal&amp;lt;Integer&amp;gt; tl1 = new ThreadLocal&amp;lt;Integer&amp;gt;() { @Override protected Integer initialValue() { return 2; } }; ThreadLocal&amp;lt;Integer&amp;gt; tl2 = ThreadLocal.withInitial(() -&amp;gt; 2); </description>
    </item>
    
    <item>
      <title>03-Cas-原子操作</title>
      <link>https://AlfredNing.github.io/note/program/juc/03-cas-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Wed, 12 Jul 2023 16:20:37 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/juc/03-cas-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</guid>
      <description>CAS定义 Compare And Swap：比较并交换 V: 位置内存值 A: 旧的预期值 B: 要修改更新的值
当且仅当V中的值和A值相等，用B值更新V中的值
硬件级别保证 CAS底层是一条CPU的原子指令 cmpxchg指令，不会造成数据不一致的问题，Java底层提供由Unsafe类提供的CAS方法
执行cmpxchg指令的时候，会判断当前系统是否为多核系统，如果是就给总线加锁，只有一个线程会对总线加锁成功，加锁成功之后会执行cas操作，也就是说CAS的原子性实际上是CPU实现的， 其实在这一点上还是有排他锁的，只是比起用synchronized， 这里的排他时间要短的多， 所以在多线程情况下性能会比较好
Unsafe类 是CAS的核心类，Unsafe位于sun.misc包中，通过CAS类可以直接通过操作特定内存的数据**，所有的方法都是用native修饰， 也就是说Unsafe类底层都直接调用操作系统底层资源执行相应任务**
变量offSet代表变量值在内存的地址
变量value用volatile修饰，保证了多线程之间的内存可见性。
AtomicInteger类 AtomicInteger主要是通过CAS + volatile + native方法类保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。
CAS并发原语体现在JAVA语言中就是sun.misc.Unsafe类中的各个方法。调用UnSafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令。这是一种完全依赖于硬件的功能，通过它实现了原子操作。再次强调，由于CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题。
CAS是靠硬件实现的从而在硬件层面提升效率，最底层还是交给硬件来保证原子性和可见性
实现方式是基于硬件平台的汇编指令，在intel的CPU中(X86机器上)，使用的是汇编指令cmpxchg指令。
核心思想就是：比较要更新变量的值V和预期值E（compare），相等才会将V的值设为新值N（swap）如果不相等自旋再来。
原子引用 AtomicInteger原子整型，可以自定义自己的原理引用类型
自定义原子引用 import java.util.concurrent.atomic.AtomicReference; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; /** * 自定义原子类型引用 * * @author Alfred.Ning * @since 2023年07月18日 11:41:00 */ public class AtomicReferenceDemo { public static void main(String[] args) { User u1 = new User(&amp;#34;u1&amp;#34;, 20); User u2 = new User(&amp;#34;u2&amp;#34;, 30); AtomicReference&amp;lt;User&amp;gt; userAtomicReference = new AtomicReference&amp;lt;&amp;gt;(); userAtomicReference.</description>
    </item>
    
    <item>
      <title>02-Volatile</title>
      <link>https://AlfredNing.github.io/note/program/juc/02-volatile/</link>
      <pubDate>Tue, 11 Jul 2023 08:04:59 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/juc/02-volatile/</guid>
      <description>JMM 现代计算机组成体系之上，CPU与内存之间的运行速度差距较大，为了缓存速度上的差异，引入了多级缓存。
Java Memory Model 本身是一种抽象的概念并不真实存在它仅仅描述的是一组约定或规范，通过这组规范定义了
程序中各个变量的读写访问方式 决定另一个线程对共享变量的写入以及如何变成对另一个线程可见 关键技术点围绕多线程的原子性、可见性、原子性
通过JMM来实现线程和主内存的抽象关系 屏蔽各个硬件平台和操作系统的内存访问差异以实现让Java程序在各种平台下都能达到一致的内存访问效果 特性 可见性 是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道该变更 ，JMM规定了所有的变量都存储在主内存中。
Java中普通的共享变量不保证可见性，因为数据修改被写入内存的时机是不确定的，多线程并发下很可能出现&amp;quot;脏读&amp;quot;，所以每个线程都有自己的工作内存，线程自己的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取，赋值等 ）都必需在线程自己的工作内存中进行，而不能够直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成
原子性 指一个操作是不可中断的，即多线程环境下，操作不能被其他线程干扰
有序性 对于一个线程的执行代码而言，我们总是习惯性认为代码的执行总是从上到下，有序执行。
但为了提供性能，编译器和处理器通常会对指令序列进行重新排序。
**指令重排可以保证串行语义一致，但没有义务保证多线程间的语义也一致，即可能产生&amp;quot;脏读&amp;quot;，**简单说，
两行以上不相干的代码在执行的时候有可能先执行的不是第一条，不见得是从上到下顺序执行，执行顺序会被优化。
单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。处理器在进行重排序时必须要考虑指令之间的数据依赖性，多线程环境中线程交替执行,由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的,结果无法预测
多线程度变量的读写过程 读写过程 JVM运行过程的实体是线程，而每个线程创建JVM时都会为其创建工作内存（栈空间）属于私有数据区，而java内存模型规定的所有变量都在主内存中。主内存是共享内存区域，所有线程都可以访问。
线程对变量的操作必须在工作内存中进行，首先要将变量从主内存中拷贝到自己的工作内存空间，然后对变量进行操作，操作完成之后在写回主内存
不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完
总结 我们定义的所有共享变量都储存在物理主内存中 每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本(主内存中该变量的一份拷贝) 线程对共享变量所有的操作都必须先在线程自己的工作内存中进行后写回主内存，不能直接从主内存中读写(不能越级) 不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行(同级不能相互访问) 多线程先行发生原则之happens-before 定义 在JMM中，如果一个操作执行的结果需要对另一个操作可见性或者 代码重排序，那么这两个操作之间必须存在happens-before关系。包含可见性和有序性的约束
说明 如果Java内存模型中所有的有序性都仅靠volatile和synchronized来完成，那么有很多操作都将会变得非常啰嗦，但是我们在编写Java并发代码的时候并没有察觉到这一点。
我们没有时时、处处、次次，添加volatile和synchronized来完成程序，这是因为Java语言中JMM原则下，有一个“先行发生”(Happens-Before)的原则限制和规矩
原则：
它是判断数据是否存在竞争，线程是否安全的非常有用的手段。依赖这个原则，我们可以通过几条简单规则一揽子解决并发环境下两个操作之间是否可能存在冲突的所有问题，而不需要陷入Java内存模型苦涩难懂的底层编译原理之中
总原则 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。 两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。 8条规则 次序规则 一个线程内，按照代码顺序，写在前面的操作先行发生于写在后面的操作
锁定规则 一个unLock操作先行发生于后面((这里的“后面”是指时间上的先后))对同一个锁的lock操作
volatile变量规则 对一个volatile变量的写操作先行发生于后面对这个变量的读操作，前面的写对后面的读是可见的，这里的“后面”同样是指时间上的先后
传递规则 如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
线程启动规则(Thread Start Rule) Thread对象的start()方法先行发生于此线程的每一个动作
线程中断规则(Thread Interruption Rule) 对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
可以通过Thread.interrupted()检测到是否发生中断
线程终止规则(Thread Termination Rule) 线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。
对象终结规则(Finalizer Rule) 一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始</description>
    </item>
    
    <item>
      <title>01-Thread</title>
      <link>https://AlfredNing.github.io/note/program/juc/01-thread/</link>
      <pubDate>Mon, 19 Jun 2023 19:56:37 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/juc/01-thread/</guid>
      <description>前置知识 1. 为什么多线程如何重要 硬件方面：摩尔定律失效，主频不在提高，核数在不断增加的情况下，让程序运行更快就需要用到并行或者并发编程
软件方面：高并发系统： 异步 + 回调等生产需求
2. 进程 是程序的一次执行，是系统进行资源分配和调度的独立单位，每个进程都有它自己的内存空间和系统资源
3. 线程 在同一进程有1个或多个线程，执行多个任务，每个任务可以看做线程，共享内存空间和资源
操作系统
多进程形式，允许多个任务同时进行 多线程形式，允许单个任务进行拆分不同的部分允许 提供协调机制：一方面进程和线程之间产生冲突，一方面进程和线程之间共享资源 4. 管程 操作系统层面：监视器(Monitor), 同步机制，是保证（同一时间）只有一个线程可以访问被保护的数据和代码。JVM中同步是基于进入和退出监视器对象(Monitor,管程对象)来实现的，每个对象实例都会有一个Monitor对象，底层是由C++实现。
5. 用户线程和守护线程 Java线程分为用户线程和守护线程
线程的daemon属性默认为false:用户线程
守护线程：特殊线程，后台执行任务，比如垃圾回收线程
用户线程：系统的工作线程，完成程序所执行的业务操作
当程序的所有用户线程执行完毕，不管是否守护线程执行完毕，系统自动退出 设置守护线程，需要在start()方法之前 6. 异步编排 Future 与 Callable Future 定义了操作异步执行任务的一些方法，如：获取异步执行的结果，取消任务执行，判断任务是否取消，判断任务执行是否完毕等。子线程去执行任务，比较耗时，主线程继续执行 Callable定义了具有返回值的任务 FutureTask **get阻塞：**一旦调用get方法，无论执行完成都会阻塞，生成禁****用
解决措施：轮询替代阻塞
高并发中，不要阻塞，尽可能少加锁，使用CAS
isDone轮询：
轮询方式也是会耗费cpu资源，不能立即获得计算结果 如果想要异步获取结果,通常都会以轮询的方式去获取结果尽量不要阻塞 import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; import java.util.concurrent.TimeUnit; import java.util.concurrent.TimeoutException; /** * @author Alfred.Ning * @since 2023年06月20日 20:59:00 */ public class FutureTaskDemo { public static void main(String[] args) throws ExecutionException, InterruptedException, TimeoutException { FutureTask&amp;lt;String&amp;gt; futureTask = new FutureTask&amp;lt;&amp;gt;(() -&amp;gt; { System.</description>
    </item>
    
  </channel>
</rss>
