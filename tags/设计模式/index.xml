<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>设计模式 on AlfredNing</title>
    <link>https://AlfredNing.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
    <description>Recent content in 设计模式 on AlfredNing</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 05 Feb 2023 23:28:12 +0800</lastBuildDate><atom:link href="https://AlfredNing.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>装饰者模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 05 Feb 2023 23:28:12 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>动态的将责任添加到对象上，动态添加功能。
分类：
父组件，供子组件使用 装饰者：组合其他组件，一部分功能是自己的，调用被装饰者，等同于保留被装饰者的功能 具体组件：实现具体方法 饮料添加各种配料，返回最终的价格。
代码示例</description>
    </item>
    
    <item>
      <title>调停者模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E8%B0%83%E5%81%9C%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 05 Feb 2023 16:05:46 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E8%B0%83%E5%81%9C%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>门面模式对外，调停者模式对内
对象的行为模式，调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显引用。从而使它们可以较松散地耦合。当这些对象中的某些对象之间的相互作用发生改变时，不会立即影响到其他的一些对象之间的相互作用。从而保证这些相互作用可以彼此独立地变化
角色：
抽象调停者角色 具体调停者角色 抽象同事类角色 具体公式类角色 示例代码</description>
    </item>
    
    <item>
      <title>门面模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 05 Feb 2023 15:50:55 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/</guid>
      <description>提供高层次的接口，统一门面对象进行，使得子系统易于使用。
选择性的暴露方法
角色分类：
门面角色: 客户端可以调用这个角色的方法 子系统角色：可以同时有一个或者多个子系统 门面模式示例代码</description>
    </item>
    
    <item>
      <title>工厂模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 04 Feb 2023 10:18:28 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>任何可以产生对象的方法和类，都可以被称为工厂。
创建型设计模式，父类提供创建对象的方法，允许子类决定实例化对象的类型
分类 根据产品是具体产品还是具体工厂：
简单工厂模式 工厂方法模式 根据工厂的抽象程度
工厂方法模式 抽象工厂模式 简单工厂模式 只对不同类对象的创建进行了一层薄薄的封装，通过向工厂传递类型来指定要创建的对象。
工厂方法模式 工厂方法模式将生产具体产品的任务分发给具体的产品工厂
抽象工厂模式 针对不同产品的创建。在工厂方法模式下，在抽象工厂里面增加创建产品的接口，并在具体子工厂中实现产品的创建
工厂模式代码示例合</description>
    </item>
    
    <item>
      <title>策略模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 03 Feb 2023 07:38:26 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>对于做同一件事有多种方法，Comparator接口。
Context：环境类 Strategy: 抽象策略类 ConcreteStrategy: 具体策略类 使用场景 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。
策略模式示例代码</description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>https://AlfredNing.github.io/note/program/design_pattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 16 Jan 2023 08:36:37 +0800</pubDate>
      
      <guid>https://AlfredNing.github.io/note/program/design_pattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>保持内存中只有一个对象
分类：
是否加载实例
饿汉式 饱汉式 是否线程安全
安全 不安全 特殊实现方式：
静态内部类 枚举 单例模式代码</description>
    </item>
    
  </channel>
</rss>
