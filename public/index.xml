<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>AlfredNing</title>
    <link>https://github.com/AlfredNing/</link>
    <description>Recent content on AlfredNing</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 01 Apr 2023 12:04:42 +0800</lastBuildDate><atom:link href="https://github.com/AlfredNing/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>虚幻引擎安装</title>
      <link>https://github.com/AlfredNing/note/program/game/ue4/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E5%AE%89%E8%A3%85/</link>
      <pubDate>Sat, 01 Apr 2023 12:04:42 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/game/ue4/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E5%AE%89%E8%A3%85/</guid>
      <description>安装虚幻引擎 官网注册登录
下载EpicGames启动器
安装虚幻引擎修改缓存
缓存默认是在：
修改缓存优点:
减少c盘容量 项目分析减少着色器编译的时间 安装目录\unreal_engine\UE_4.24\Engine\Config\BaseEngine.ini
找到InstalledDerivedDataBackendGraph标签
修改path:%GAMEDIR%DerivedDataCache</description>
    </item>
    
    <item>
      <title>C&#43;&#43;基础5</title>
      <link>https://github.com/AlfredNing/note/program/game/c&#43;&#43;/c&#43;&#43;%E5%9F%BA%E7%A1%805/</link>
      <pubDate>Tue, 28 Mar 2023 22:10:36 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/game/c&#43;&#43;/c&#43;&#43;%E5%9F%BA%E7%A1%805/</guid>
      <description>信号处理 号是由操作系统传给进程的中断，会提早终止一个程序。在 UNIX、LINUX、Mac OS X 或 Windows 系统上，可以通过按 Ctrl+C 产生中断
可以在程序捕获的信号
信号 描述 SIGABRT 程序的异常终止，如调用 abort。 SIGFPE 错误的算术运算，比如除以零或导致溢出的操作。 SIGILL 检测非法指令。 SIGINT 接收到交互注意信号。 SIGSEGV 非法访问内存。 SIGTERM 发送到程序的终止请求。 signal函数： 捕获突发事件 raise函数：生成信号 c++多线程 基于进程 ： 程序的并发执行
基于线程：同一程序的片段并发执行
多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径
使用 POSIX 编写多线程 C++ 程序。POSIX Threads 或 Pthreads 提供的 API 可在多种类 Unix POSIX 系统上可用，比如 FreeBSD、NetBSD、GNU/Linux、Mac OS X 和 Solaris
创建线程 #include &amp;lt;pthread.h&amp;gt;pthread_create (thread, attr, start_routine, arg) 在这里，pthread_create 创建一个新的线程，并让它可执行。下面是关于参数的说明：
参数 描述 thread 指向线程标识符指针。 attr 一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。 start_routine 线程运行函数起始地址，一旦线程被创建就会执行。 arg 运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。 创建线程成功时，函数返回 0，若返回值不为 0 则说明创建线程失败</description>
    </item>
    
    <item>
      <title>C&#43;&#43;基础4</title>
      <link>https://github.com/AlfredNing/note/program/game/c&#43;&#43;/c&#43;&#43;%E5%9F%BA%E7%A1%804/</link>
      <pubDate>Mon, 27 Mar 2023 20:10:47 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/game/c&#43;&#43;/c&#43;&#43;%E5%9F%BA%E7%A1%804/</guid>
      <description>数据封装 面向对象编程中把数据和操作数据的函数绑定在一起的一个概念。同等概念既数据隐藏
默认情况下，在类中定义的所有项目都是私有的。
把一个类定义为另一个类的友元类，会暴露实现细节，从而降低了封装性。理想的做法是尽可能地对外隐藏每个类的实现细节
设计策略 通常情况下，我们都会设置类成员状态为私有（private），除非我们真的需要将其暴露，这样才能保证良好的封装性。
这通常应用于数据成员，但它同样适用于所有成员，包括虚函数
接口（抽象类） 接口描述类的行为和功能，而不需要完成特定类的实现。
c++中的接口是用抽象类来实现，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与数据分离开的概念
抽象类: 类中至少有一个函数被声明为纯虚函数，纯虚函数是通过在声明中使用 &amp;ldquo;= 0&amp;rdquo; 来指定的
设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。
因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重载纯虚函数，就尝试实例化该类的对象，会导致编译错误。
可用于实例化对象的类被称为具体类。
#include &amp;lt;iostream&amp;gt; using namespace std; // 基类 class Shape {public: // 提供接口框架的纯虚函数 virtual int getArea() = 0; void setWidth(int w) { width = w; } void setHeight(int h) { height = h; }protected: int width; int height;}; // 派生类 class Rectangle: public Shape{public: int getArea() { return (width * height); }}; class Triangle : public Shape { public: int getArea() { return (width * height) / 2; } }; int main(void) { Rectangle Rect; Triangle Tri; Rect.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;基础3</title>
      <link>https://github.com/AlfredNing/note/program/game/c&#43;&#43;/c&#43;&#43;%E5%9F%BA%E7%A1%803/</link>
      <pubDate>Sun, 26 Mar 2023 19:04:24 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/game/c&#43;&#43;/c&#43;&#43;%E5%9F%BA%E7%A1%803/</guid>
      <description>指针 表示内存的地址。指针是一个变量，值为另一个变量的内存地址。内存位置的直接地址
必须先声明，后使用 所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表存地址的长的十六进制数 不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同 概念 描述 C++ Null 指针 C++ 支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。 C++ 指针的算术运算 可以对指针进行四种算术运算：++、&amp;ndash;、+、- C++ 指针 vs 数组 指针和数组之间有着密切的关系。 C++ 指针数组 可以定义用来存储指针的数组。 C++ 指向指针的指针 C++ 允许指向指针的指针。 C++ 传递指针给函数 通过引用或地址传递参数，使传递的参数在调用函数中被改变。 C++ 从函数返回指针 C++ 允许函数返回指针到局部变量、静态变量和动态内存分配。 #include &amp;lt;iostream&amp;gt; using namespace std; int main() { int var = 20; // 指针变量声明 int* ip; double* dp; ip = &amp;amp;var; // 使用: 变量存储的地址 cout &amp;lt;&amp;lt; &amp;#34;ip: &amp;#34; &amp;lt;&amp;lt; ip &amp;lt;&amp;lt; endl; // 访问地址 cout &amp;lt;&amp;lt; *ip &amp;lt;&amp;lt; endl; return 0; } 引用 引用变量是一个别名，他是一件存在的变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</description>
    </item>
    
    <item>
      <title>并查集</title>
      <link>https://github.com/AlfredNing/note/program/algorithm/%E5%B9%B6%E6%9F%A5%E9%9B%86/</link>
      <pubDate>Sat, 25 Mar 2023 08:37:28 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/algorithm/%E5%B9%B6%E6%9F%A5%E9%9B%86/</guid>
      <description>算法定义 有若干个样本a、c、d、e&amp;hellip; 类型假设是V
在并查集一开始认为每个样本都在单独的集合里
设计两个方法
`isSameSet(V x, V y)： 查询两个样本x和有是否在同一个集合里面 union(V x, V y) : 把x和y各自所有集合的样本合并成一个集合 两个算法的时间复杂度越小越好
算法流程 算法实现 import java.util.HashMap; import java.util.List; import java.util.Stack; /** * 并查集实现 * * @author Alfred.Ning * @since 2023年03月25日 09:23:00 */ public class UnionFindImpl { public static class Node&amp;lt;V&amp;gt; { V value; public Node(V v) { value = v; } } public static class UnionFind&amp;lt;V&amp;gt; { private HashMap&amp;lt;V, Node&amp;lt;V&amp;gt;&amp;gt; nodes; private HashMap&amp;lt;Node&amp;lt;V&amp;gt;, Node&amp;lt;V&amp;gt;&amp;gt; parents; private HashMap&amp;lt;Node&amp;lt;V&amp;gt;, Integer&amp;gt; sizeMap; public UnionFind(List&amp;lt;V&amp;gt; values) { nodes = new HashMap&amp;lt;&amp;gt;(); parents = new HashMap&amp;lt;&amp;gt;(); sizeMap = new HashMap&amp;lt;&amp;gt;(); for (V v : values) { Node&amp;lt;V&amp;gt; node = new Node&amp;lt;&amp;gt;(v); nodes.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;基础2</title>
      <link>https://github.com/AlfredNing/note/program/game/c&#43;&#43;/c&#43;&#43;%E5%9F%BA%E7%A1%802/</link>
      <pubDate>Wed, 22 Mar 2023 22:40:59 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/game/c&#43;&#43;/c&#43;&#43;%E5%9F%BA%E7%A1%802/</guid>
      <description>c++运算符 算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 杂项运算符 算术运算符 假设变量 A 的值为 10，变量 B 的值为 20，则：
运算符 描述 实例 + 把两个操作数相加 A + B 将得到 30 - 从第一个操作数中减去第二个操作数 A - B 将得到 -10 * 把两个操作数相乘 A * B 将得到 200 / 分子除以分母 B / A 将得到 2 % 取模运算符，整除后的余数 B % A 将得到 0 ++ 自增运算符，整数值增加 1 A++ 将得到 11 &amp;ndash; 自减运算符，整数值减少 1 A&amp;ndash; 将得到 9 关系运算符 假设变量 A 的值为 10，变量 B 的值为 20，则：</description>
    </item>
    
    <item>
      <title>C&#43;&#43;初始</title>
      <link>https://github.com/AlfredNing/note/program/game/c&#43;&#43;/c&#43;&#43;%E5%9F%BA%E7%A1%801/</link>
      <pubDate>Wed, 22 Mar 2023 07:31:48 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/game/c&#43;&#43;/c&#43;&#43;%E5%9F%BA%E7%A1%801/</guid>
      <description>简介 C++一种静态类型、编译式、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。
c++是一门中级语言，综合高级语言和低级语言的特点。
C++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。
静态类型的编程语言都是在编译时候执行类型检查，而不是在运行时候执行类型检查
面向对象四大特点 封装 继承 抽象 多态 开发工具，window使用Visual Studio
对象 - 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。 类 - 类可以定义为描述对象行为/状态的模板/蓝图。 方法 - 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。 即时变量 - 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。 程序结构 #include &amp;lt;iostream&amp;gt; using namespace std; int main() { cout &amp;lt;&amp;lt; &amp;#34;Hello, world!&amp;#34; &amp;lt;&amp;lt; endl; return 0; } g++ hello.cpp$ ./a.outHello Wo 头文件：包含程序必须的或有用的信息 命名空间 main 函数程序开始 分号是语句结束符，每个语句必须以分号结束。c++不以行末作为结束符，一行可以放置多个语句 块是一组使用大括号括起来的按逻辑连接的语句 标识符 以字母A-Z或a-z或下划线_开始，后跟多个字母数字下划线
关键字 asm else new this auto enum operator throw bool explicit private true break export protected try case extern public typedef catch false register typeid char float reinterpret_cast typename class for return union const friend short unsigned const_cast goto signed using continue if sizeof virtual default inline static void delete int static_cast volatile do long struct wchar_t double mutable switch while dynamic_cast namespace template 三字符组 用于表示另一个字符的三个字符系列，又称为三字符系列</description>
    </item>
    
    <item>
      <title>运行时内存</title>
      <link>https://github.com/AlfredNing/note/program/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98/</link>
      <pubDate>Mon, 27 Feb 2023 21:33:26 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98/</guid>
      <description>jvm内存结构图
哪些内存结构与线程意义对应，其实问的是线程共有和私有 共有： 堆和方法区 私有： 本地方法栈、虚拟机栈、程序计数器
程序计数器 保证程序在程序系统中能够执行下去，CPU必须具有某些手段来确定下一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器 一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器。 在程序开始执行前，必须将它的起始地址，即程序的一条指令所在的内存单元地址送入PC，因此程序计数器（PC）的内容即是从内存提取的第一条指令的地址。当执行指令时，CPU将自动修改PC的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数，以便使其保持的总是将要执行的下一条指令的地址 由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单的对PC加1 当程序转移时，转移指令执行的最终结果就是要改变PC的值，此PC值就是转去的地址，以此实现转移。有些机器中也称PC为指令指针IP（Instruction Pointer） 特征 JVM中的程序计数寄存器（Program Counter Register）中， Register 的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。 CPU只有把数据装载到寄存器才能够运行。
JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟
很小的内存结构，忽略不计，也是运行最快的存储区域，不会随着程序的运行需要更大的空间 在JVM规范中，每个线程都有自己的程序计数器，是线程私有的，生命周期与线程生命周期保持一致 它是唯一一个在JVM虚拟机规范中没有规定任何OutOtMemoryError 情况的区域 问题 为什么使用PC寄存器来记录当前线程的执行地址 因为CPU需要不停的切换各个线程，准确知道执行的位置。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令 PC寄存器为什么被设置为线程私有 多线程在一个特定的时间段内之会执行某一个线程的方法，CPU需要不停的做任务切换**。为了准确记录各个线程正在执行的当前字节码指令，最好的办法就是为每一个线程分配PC寄存器**，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况 虚拟机栈 栈管运行，堆管内存
栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿
Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。 是线程私有的 生命周期: 生命周期和线程一致。
特点: 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。
栈是否有GC？ 不存在GC, 但有OOM
抛出的异常：
StackOverFlowError OutOfMemoryError Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个 StackOverflowError 异常 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出—个 OutOfMemoryError 异常 设置栈大小 -Xsssize (即：-XX:ThreadStackSize)
一般为：512k-1M 栈的大小直接决定了函数调用的最大深度 设置的栈空间值过大，会导致系统可以用于创建线程的数量减少 一般一个进程中通常有3000-5000个线程
jdk5.0之前，默认为256k jdk5.0之后，默认为1024k
栈帧 栈的基本单位是栈帧，每个线程都有自己的栈，栈中的数据都是以栈帧存在的。
方法与栈帧的关系 在这个线程执行的方法都有一个栈帧 栈帧是一个内存区块，是一个数据集，维护着方法执行过程中的各种数据信息 栈的内部结构 局部变量表 操作数栈或表达式栈 动态链接或指向运行时常量池的方法引用 方法返回地址（或方法正常退出或者异常退出的定义） 一些附加信息 局部变量表 - Local Varibales 局部变量表被称为局部变量数组或者本地变量表 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，数据类别包括：基本数据类型，对象引用、以returnAddress类型 局部变量表的大小是在编译器确定，保存在方法的code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的 方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减 **局部变量表的变量只在当前方法调用中有效。**在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。 静态变量与局部变量区别 类变量表有两次初始化的机会，第一次准备阶段，执行系统初始化，赋零值，另一次是在初始化阶段，赋予代码中指定的初始值 和类变量初始化不同，局部变量表不存在系统初始化的过程，一旦定义了局部变量则必须人为的初始化，否则无法使用 与GC ROOTS的关系 局部变量表的变量也是重要的垃圾回收节点，只要被局部变量中直接或者间接引用的对象都不会被回收</description>
    </item>
    
    <item>
      <title>类的加载</title>
      <link>https://github.com/AlfredNing/note/program/jvm/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/</link>
      <pubDate>Thu, 23 Feb 2023 20:16:54 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/jvm/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/</guid>
      <description>类的加载过程 Java数据类型分为数据基本数据类型和引用数据类型
基本类型由虚拟机预先定义，引用类型需要进行类的加载
类的加载大过程分为三步, 总过程七步
装载 将java的class文件加载到机器内存，并在内存中构建出Java类的原型-类模板对象
查找类的二进制文件，生成class实例
加载类，需要完成以下三件事情：
通过类的全名，获取类的二进制数据流 解析类的二进制数据流转换为方法区的数据结构(Java类模型) 创建java.lang.class类的实例，表示该类型 类模板对象 Java类在内存中的一个快照，JVM从字节码文件解析出来的常量池、类字段、类方法等类信息存储到类模板中。在运行期通过类模板获取Java类的任意信息，能够对Java类的成员变量进行遍历，进行方法调用。反射机制也是基于此，如果没有存储Java类的声明信息，JVM在运行期也无法进行反射
获取二进制数据流 class字节码文件符号JVM规范
通过读取class后缀的文件 读入jar、zip等归档数据包，提取类文件(热部署jar包原理基础) 事先存放在数据库的二进制数据 使用类型Http之类的协议通过网络进行加载 在运行时生成一段class的二进制信息等 class实例位置 类将.class文件加载至元空间后，会在堆中创建一个Java.lang.Class对象，用来封装类位于方法区内的数据结构，该Class对象是在加载类的过程中创建的，每个类都对应有一个Class类型的对象数组类的加载 数组类本身不是由类加载器负责创建，而是由JVM在运行时根据需要去创建。加载器只负责加载数据元素的数据类型(基本数据类型和引用数据类型)，申请内存分配长度
链接 验证阶段 保证加载的字节码是合法、合理并符合jvm规范
格式验证回合装载阶段一起执行。验证通过之后，类加载器才会把验证成功的二级制数据信息加载到方法区中 格式验证之外的验证操作都在方法区中进行 准备阶段 为类的静态变量分配内存，并将其初始化为默认值。
Java并不支持boolean类型，对于boolean类型，内部实现是int,由于int的默认值是0,故对应的，boolean的默认值就是false
解析阶段 将类、接口、自动和方法的符号引用转换为直接应用
符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。比较容易理解的就是在Class类文件中，通过常量池进行了大量的符号引用。通过解析操作，符号引用就可以转化为目标方法在类中方法表的位置，从而使得方法被成功调用。
解析就是将符号引用转换为直接引用。换言之，直接引用存在，一定存在符号引用，反之不然
Java虚拟机规范并没有要求解析操作一定要按照顺序执行
在HotSpot VM中，加载、验证、准备和初始化会按照顺序有条不紊地执行，但链接阶段中的解析操作往往会伴随着JVM在执行完初始化之后再执行
初始化 为静态变量赋予正确的初始值
开始执行java字节码，执行类的初始化方法
clinit方法：该方法只能由JVM编译器生成，程序开发者无法自定义一个同名的方法，无法在java程序中调用该方法，该方法由java字节码组成 init方法：由类的静态成员变量赋值及其static语句块产生 clinit方法的生成 以下几种情况，不会生产clinit方法
一个类中没有声明任何类变量，也没静态代码块 一个类中声明类变量，但没有明确使用类的初始化语句以及静态代码块进行初始化操作 一个类中包含static final 修饰的基本类型字段，这些类字段使用编译时常量表达式 clinit是由虚拟机保证在多线程环境下正确的加锁同步，是线程安全的。如果有很长的耗时操作，是会造成死锁的。
类的加载 加载 = 装载 + 链接 + 初始化
Java程序的主动使用
主动使用的说明 Class只有在必须要首次使用的时候才会被装载，Java虚拟机不会无条件地装载Class类型。Java虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用。
主动使用只有下列几种情况：（即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成。）
当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化。
当调用类的静态方法时，即当使用了字节码invokestatic指令。
当使用类、接口的静态字段时(final修饰特殊考虑)，比如，使用getstatic或者putstatic指令。
当使用java.lang.reflect包中的方法反射类的方法时。比如：Class.forName(&amp;ldquo;com.atguigu.java.Test&amp;rdquo;)
当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</description>
    </item>
    
    <item>
      <title>Java8</title>
      <link>https://github.com/AlfredNing/note/program/java8/java8/</link>
      <pubDate>Sat, 18 Feb 2023 12:47:59 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/java8/java8/</guid>
      <description>新特性 lambda表达式 方法引用 函数接口 流式处理 新日期时间API Optional类 新工具、JavaScript执行引擎 javaFx 函数编程 lambda表达式 想要在代码块以后某个时间点执行 可以转换为函数式接口 闭包作用域中有效访问final变量 任何一个lambda表达式都可以转换为所使用API中对应的函数式接口，注意：lambda表达式转换为函数式接口时候，注意检查期异常 不允许声明一个与局部变量同名的参数或者局部变量 lambda使用this,创建该lambda表达式方法的参数 组成 可选的类型声明 可选的参数小括号 可选的大括号 可选的返回值【只有一句表达式可以省略】 功能 内联功能的实现
注意 变量引用不可变，实际内容可变
函数接口 只包含一个抽象方法的接口，可以通过lambda表达式创建该接口的对象
方法引用 方法引用用其名称指向方法
引用符号:: 指向方法
对象::实例方法 类:: 静态方法 类::实例方法（第一个参数会成为执行方法的对象) 构造器引用 类::new
java中无法构造一个泛型类型T的数组，但可以通过数组引用解决。
例如：stream.toArray(Class::new)
默认方法 类优先原则
接口中有一个默认方法，一个类也有同名的方法。另一个类继承了父类，实现了该接口。这种情况下，只有父类的方法会起作用。 出于兼容性，这样在接口中添加方法，不会对以前的编写的代码产生影响。不能对Object的方法定义默认方法
静态方法 为接口添加静态方法
Stream API 原则：做什么，而不是怎么做
Stream不会自己存储元素。元素可能被存储在底层的集合当中，或者根据需要产生出来 Stream操作符不会改变源对象的。相反，他们会返回一个持有结果的新Stream Stream操作符可能是延迟执行的。意味着他们等到需要结果的时候才执行 Stream使用三阶段 创建Stream 中间操作 终止操作产生结果 创建Stream Stream.of() Arrays.Stream 可选长度参数
空Stream: Stream.Empty()
Stream.generate(Supplier func);
Stream.iterate(seed, operator)
Pattern类的splitAsStream
Files.lines(path) : 记得使用try-with-resources语句</description>
    </item>
    
    <item>
      <title>字节码文件</title>
      <link>https://github.com/AlfredNing/note/program/jvm/%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6/</link>
      <pubDate>Fri, 17 Feb 2023 08:01:55 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/jvm/%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6/</guid>
      <description>字节码文件 字节码文件 字节码文件跨平台 JVM实现遵守JVM虚拟机规范，所有JVM的环境都是一样的，所以字节码文件可以在各种虚拟机上执行
通过Class文件，更多的计算机语言支持Java虚拟机平台。Class文件不仅仅是Java虚拟机的执行入口，更是Java生态圈的核心
字节码文件内容 源代码经过编译器生成一个字节码文件，字节码文件是一种二进制的文件，内容是JVM的指令，而C/C++由编译器直接生成机器码。随着Java平台的不断发展，在将来，Class文件的内容也一定会做进一步的扩充，但是其基本的格式和结构不会做重大调整
字节码文件编译器 作用范围 编译器种类 前端编译器
javac (全量编译器)/Eclipse中的ECJ	Eclipse Compiler for Java （增量编译器） 主要任务：将java源代码转化为符合jvm规范的字节码文件 劣势：前端编译器并不会直接涉及编译优化等方面的技术，而是将这些具体优化细节移交给HotSpot的JIT编译器负责 后端编译器
AOT(静态提前编译器，Ahead Of Time Compiler)
jdk9引入了AOT编译器(静态提前编译器，Ahead Of Time Compiler)
Java 9 引入了实验性 AOT 编译工具jaotc。它借助了 Graal 编译器，将所输入的 Java 类文件转换为机器码，并存放至生成的动态共享库之中。
所谓 AOT 编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而 AOT 编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。
.java -&amp;gt; .class -&amp;gt; .so
最大好处：Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢”的不良体验。
缺点：
破坏了java“一次编译，到处运行”，必须为每个不同硬件、OS编译对应的发行包。 降低了Java链接过程的动态性，加载的代码在编译期就必须全部已知。 还需要继续优化中，最初只支持Linux x64 java base
类的class对象 外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类 接口 数组 枚举 注解 基本数据类型 void 字节码指令 Java虚拟机的指令是由一个字节长度、代表着某种特定操作含义的操作码[opcode]以及跟随其后的零至多个代表此操作所需操作数的操作数[operand]组成。虚拟机中许多指令并不包含操作数，只有一个操作码
字节码相关面试
idea插件：jclasslib
import org.testng.annotations.Test; /** * @author Alfred.</description>
    </item>
    
    <item>
      <title>HTTP权威指南</title>
      <link>https://github.com/AlfredNing/note/book/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/</link>
      <pubDate>Wed, 15 Feb 2023 12:22:58 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/book/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/</guid>
      <description>Web的基础 HTTP概述 http使用的是可靠的数据传输协议 组成 web客户端 类似浏览器
web服务器： 通常web服务器使用http协议，通常成为http服务器
资源 Web服务器是Web资源（Web resource）的宿主。Web资源是Web内容的源头。资源并不一定非的是静态文件，根据需要生成的软件程序
html文件 word文件 其它任何格式 媒体类型 MIME类型(MIME TYPE) ： 数据格式标签，最初是用于解决在不同的电子邮件系统中之间搬移报文时候存在的问题，http借鉴了。weu服务器会为所有的http对象数据附近一个MIME类型（Content-Type,Content-Length)
URI 每一个web服务服务器资源名都有一个名字，被称为统一资源标识符(Uniform Resouce Identifier)，具有两种形式URL、URN
URL: 统一资源定位符 HTTP 协议 + 地址 + 某个资源
URN： 统一资源名 URN是作为特定内容的唯一名称使用的，与目前的资源所在地无关
事务 </description>
    </item>
    
    <item>
      <title>Jvm初识</title>
      <link>https://github.com/AlfredNing/note/program/jvm/jvm%E5%88%9D%E8%AF%86/</link>
      <pubDate>Tue, 14 Feb 2023 07:58:50 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/jvm/jvm%E5%88%9D%E8%AF%86/</guid>
      <description>JDK关系 Oracle JDK 与 Open JDK 关系
Oracle JDK是由oracle 公司开发的，Open JDK 是由IBM，Apple，SAP AG，Redhat等顶级公司合作开发 Oracle JDK大多数的功能是开源的，一些功能是开源。Open JDK完全开源 Oracle JDK以前的1.0版以前的版本是由Sun开发的，后来被Oracle收购并为其他版本维护，而OpenJDK最初只基于Java SDK或JDK版本7 Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本 Oracle JDK将从其10.0.X版本将收费，用户必须付费或必须依赖OpenJDK才能使用其免费版本 Oracle JDK在运行JDK时不会产生任何问题，而OpenJDK在为某些用户运行JDK时会产生一些问题 在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能 Oracle JDK具有良好的GC选项和更好的渲染器，而OpenJDK具有更少的GC选项，并且由于其包含自己的渲染器的分布，因此具有较慢的图形渲染器选项 Oracle JDK的构建过程基于OpenJDK，因此OpenJDK与Oracle JDK之间没有技术差异 Oracle JDK将更多地关注稳定性，它重视更多的企业级用户，而OpenJDK经常发布以支持其他性能，这可能会导致不稳定 JDK与JVM的关系 JDK: Java Development ToolKit(java开发工具包)。JDK是整个java的核心，包括了运行环境，java工具和java的基础类库。
jvm:Java Virtual Machine(java虚拟机)。通过在实际的计算机上模拟仿真各种计算机功能来实现。
使用JDK（调用JAVA API）开发JAVA程序后，通过JDK中的编译程序（javac）将Java程序编译为Java字节码，在JRE上运行这些字节码，JVM会解析并映射到真实操作系统的CPU指令集和OS的系统调用
如何理解java是跨平台的语言 当java的源代码经过编译程序编译成字节码，需要运行在不同的平台上面时，无需编译。
如何理解JVM是跨语言的平台 jvm面对的是字节码文件，只关心字节码文件，不关心何种编程语言，只要实现jvm规范即可。Java不是最强大的语言，但是JVM是最强大的虚拟机。
JVM的类型 Sun Classic VM &amp;ndash;&amp;gt;解释型
Exact VM &amp;ndash;&amp;gt; Solaris
SUN公司的 HotSpot VM
BEA 的 JRockit &amp;ndash;&amp;gt; 不包含解释器，服务器端，JMC
IBM 的 J9
KVM和CDC/CLDC Hotspot</description>
    </item>
    
    <item>
      <title>设计原则</title>
      <link>https://github.com/AlfredNing/note/program/design_pattern/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</link>
      <pubDate>Thu, 09 Feb 2023 23:36:46 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/design_pattern/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</guid>
      <description>指导思想 可维护性：修改功能少，需要改动的地方越少，可维护性越好 可复用性：代码被以后重复使用，写出自己总结的类库 可扩展性：添加功能无需修改原来的代码 灵活性：代码接口可以灵活调用 原则 单一职责原则 SRP 一个类别太大，别太累。负责单一的职责 高内聚，低耦合 开闭原则 OCP 对扩展开放，对修改关闭：尽量不修改原来的代码进行扩展 抽象化，多态是开闭原则的关键 里氏替换原则 LSP 所有使用父类的方法，必须能够透明的使用子类对象 依赖倒置原则 DIP 依赖抽象，而不是依赖具体 面向抽象/接口编程 接口隔离原则 ISP 每一个接口应该承担独立的角色，不干自己不该干的事情 避免子类不需要实现的方法 需要对客户提供接口的时候，只需要暴露最小的接口 迪米特法则 LOD 尽量不要和陌生人说话 在迪米特法则中，对于一个对象，非陌生人包含以下几类 当前对象本身this 以参数形式传入到当前对象方法中的对象 当前对象的成员对象 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友 当前对象所创建的对象 和其它类的耦合度变低 工具类例外 </description>
    </item>
    
    <item>
      <title>解释器模式</title>
      <link>https://github.com/AlfredNing/note/program/design_pattern/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 09 Feb 2023 23:18:43 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/design_pattern/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>解释器模式是类的行为模式。给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子
角色 抽象表达式(Expression)角色：声明一个所有的具体表达式角色都需要实现的抽象接口。这个接口主要是一个interpret()方法，称做解释操作 终结符表达式(Terminal Expression)角色：实现了抽象表达式角色所要求的接口 非终结符表达式(Nonterminal Expression)角色：文法中的每一条规则都需要一个具体的非终结符表达式 环境(Context)角色：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值 示例代码</description>
    </item>
    
    <item>
      <title>状态模式</title>
      <link>https://github.com/AlfredNing/note/program/design_pattern/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 09 Feb 2023 22:12:21 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/design_pattern/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</guid>
      <description>状态模式，状态对象行为模式。允许对一个对象在其内部状态改变的时候改变其行为。这个对象看上去就像是改变了它的类一样
状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变
角色 环境角色:定义客户端所感兴趣的接口，并且保留一个具体状态类的实例。这个具体状态类的实例给出此环境对象的现有状态 抽象状态(State)角色：定义一个接口，用以封装环境（Context）对象的一个特定的状态所对应的行为 具体状态(ConcreteState)角色：每一个具体状态类都实现了环境（Context）的一个状态所对应的行为 认识状态模式 状态和行为
所谓对象的状态，通常指的就是对象实例的属性的值；而行为指的就是对象的功能，再具体点说，行为大多可以对应到方法上。
状态模式的功能就是分离状态的行为，通过维护状态的变化，来调用不同状态对应的不同功能。也就是说，状态和行为是相关联的，它们的关系可以描述为：状态决定行为。
由于状态是在运行期被改变的，因此行为也会在运行期根据状态的改变而改变。
行为的平行性
注意平行线而不是平等性。所谓平行性指的是各个状态的行为所处的层次是一样的，相互独立的、没有关联的，是根据不同的状态来决定到底走平行线的哪一条。行为是不同的，当然对应的实现也是不同的，相互之间是不可替换的。
策略模式的比较
状态模式的结构和策略模式的结构完全一样，但是，它们的目的、实现、本质却是完全不一样的。还有行为之间的特性也是状态模式和策略模式一个很重要的区别，状态模式的行为是平行性的，不可相互替换的；而策略模式的行为是平等性的，是可以相互替换的。
环境和状态处理对象
在状态模式中，环境(Context)是持有状态的对象，但是环境(Context)自身并不处理跟状态相关的行为，而是把处理状态的功能委托给了状态对应的状态处理类来处理。
在具体的状态处理类中经常需要获取环境(Context)自身的数据，甚至在必要的时候会回调环境(Context)的方法，因此，通常将环境(Context)自身当作一个参数传递给具体的状态处理类。
客户端一般只和环境(Context)交互。客户端可以用状态对象来配置一个环境(Context)，一旦配置完毕，就不再需要和状态对象打交道了。客户端通常不负责运行期间状态的维护，也不负责决定后续到底使用哪一个具体的状态处理对象
示例代码</description>
    </item>
    
    <item>
      <title>模板方法模式</title>
      <link>https://github.com/AlfredNing/note/program/design_pattern/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 09 Feb 2023 21:50:27 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/design_pattern/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</guid>
      <description>类的行为模式。使用示例：Servlet的应用
抽象类：将部分逻辑以具体的方法以及具体的构造函数的形式实现。然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的实现方式实现这些抽象方法，从而对剩余逻辑有不同的实现。
模板方法所代表的行为称为顶级行为，其逻辑称为顶级逻辑
角色 抽象模板：顶层逻辑骨架 具体模板：具体实现顶层逻辑 子类可以置换掉父类的可变部分，但是子类却不可以改变模板方法所代表的顶级逻辑
方法 模板方法：一个抽象类可以有任意多个模板方法，而不限于一个。每一个模板方法都可以调用任意多个具体方法 基本方法： 抽象方法：一个抽象方法由抽象类声明，由具体子类实现 具体方法：一个具体方法由抽象类声明并实现，而子类并不实现或置换 钩子方法：一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个空实现，作为方法的默认实现 示例代码</description>
    </item>
    
    <item>
      <title>备忘录模式</title>
      <link>https://github.com/AlfredNing/note/program/design_pattern/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 09 Feb 2023 21:37:39 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/design_pattern/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</guid>
      <description>对象的行为模式。又称为快照模式，对象的行为模式。一个用来存储另外一个对象内部状态的快照对象。
指在不破坏封装的条件下，将一个对象的状态捕捉住，并且外部化，进行存储，从而可以在将来合适的时候把这个对象还原存储起来的状态。备忘录模式常常与命令模式和迭代子模式一同使用
角色 备忘录角色 备忘录角色又如下责任：
（1）将发起人（Originator）对象的内战状态存储起来。备忘录可以根据发起人对象的判断来决定存储多少发起人（Originator）对象的内部状态。
（2）备忘录可以保护其内容不被发起人（Originator）对象之外的任何对象所读取。
备忘录有两个等效的接口：
●　**窄接口：**负责人（Caretaker）对象（和其他除发起人对象之外的任何对象）看到的是备忘录的窄接口(narrow interface)，这个窄接口只允许它把备忘录对象传给其他的对象。
●　**宽接口：**与负责人对象看到的窄接口相反的是，发起人对象可以看到一个宽接口(wide interface)，这个宽接口允许它读取所有的数据，以便根据这些数据恢复这个发起人对象的内部状态。
发起人角色 发起人角色有如下责任：
（1）创建一个含有当前的内部状态的备忘录对象。
（2）使用备忘录对象存储其内部状态。
负责人角色 负责人角色有如下责任：
（1）负责保存备忘录对象。
（2）不检查备忘录对象的内容。
示例代码</description>
    </item>
    
    <item>
      <title>原型模式</title>
      <link>https://github.com/AlfredNing/note/program/design_pattern/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 09 Feb 2023 08:54:46 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/design_pattern/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>对象的创建模式。通过一个原型对象来指明所有创建的对象的类型，然后复用这个原型对象的方法来创建出更多同类型的对象。
实现一个自身可以克隆的接口
分类 简单形式 角色：
客户角色 抽象原型角色 具体原型角色 登记形式 角色：
客户角色 抽象原型角色 具体原型角色 原型管理角色 两种形式的比较 简单形式和登记形式的原型模式各有其长处和短处。
如果需要创建的原型对象数目较少而且比较固定的话，可以采取第一种形式。在这种情况下，原型对象的引用可以由客户端自己保存。
如果要创建的原型对象数目不固定的话，可以采取第二种形式。在这种情况下，客户端不保存对原型对象的引用，这个任务被交给管理员对象。在复制一个原型对象之前，客户端可以查看管理员对象是否已经有一个满足要求的原型对象。如果有，可以直接从管理员类取得这个对象引用；如果没有，客户端就需要自行复制此原型对象。
Java中的克隆方法 Java的所有类都是从java.lang.Object类继承而来的，而Object类提供protected Object clone()方法对对象进行复制，子类当然也可以把这个方法置换掉，提供满足自己需要的复制方法。对象的复制有一个基本问题，就是对象通常都有对其他的对象的引用。当使用Object类的clone()方法来复制一个对象时，此对象对其他对象的引用也同时会被复制一份
Java语言提供的Cloneable接口只起一个作用，就是在运行时期通知Java虚拟机可以安全地在这个类上使用clone()方法。通过调用这个clone()方法可以得到一个对象的复制。由于Object类本身并不实现Cloneable接口，因此如果所考虑的类没有实现Cloneable接口时，调用clone()方法会抛出CloneNotSupportedException异常。
原型模式的优点 原型模式允许在运行时动态改变具体的实现类型。原型模式可以在运行期间，由客户来注册符合原型接口的实现类型，也可以动态地改变具体的实现类型，看起来接口没有任何变化，但其实运行的已经是另外一个类实例了。因为克隆一个原型就类似于实例化一个类。
原型模式的缺点 原型模式最主要的缺点是每一个类都必须配备一个克隆方法。配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类来说不是很难，而对于已经有的类不一定很容易，特别是当一个类引用不支持序列化的间接对象，或者引用含有循环结构的时候。
示例代码</description>
    </item>
    
    <item>
      <title>命令模式</title>
      <link>https://github.com/AlfredNing/note/program/design_pattern/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 09 Feb 2023 08:23:19 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/design_pattern/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</guid>
      <description>命令模式属于对象的行为模式，又成交易模式或行动模式。　命令模式把一个请求或者操作封装到一个对象中。命令模式允许系统使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能
角色 命令角色 具体命令角色 请求者角色 接收者角色 客户端角色 优点 更松散的耦合 更动态的控制 很自然的复合命令 更好的扩展性 代码示例</description>
    </item>
    
    <item>
      <title>桥接模式</title>
      <link>https://github.com/AlfredNing/note/program/design_pattern/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 08 Feb 2023 22:36:18 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/design_pattern/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>将抽象部分与实现部分相分离，使他们都可以独立的变化。结构式模式
角色 实现接口 抽象接口 具体实现 具体抽象实现 应用 具体到实际应用上，需要将抽象与实现分离开来，对客户端无感知的一种行为。
示例代码</description>
    </item>
    
    <item>
      <title>适配器模式</title>
      <link>https://github.com/AlfredNing/note/program/design_pattern/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 08 Feb 2023 08:11:47 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/design_pattern/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>把一个类的接口变成客户端所期待的另一种接口，从而使原本因接口不匹配而无法完成一起工作的两个类可以一起工作
结构 类的适配器模式 对象的适配器模式 类的适配器模式 把适配类的API转换成目标API
角色：
●　目标(Target)角色：这就是所期待得到的接口。注意：由于这里讨论的是类适配器模式，因此目标不可以是类。
●　源(Adapee)角色：现在需要适配的接口。
●　适配器(Adaper)角色：适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。
对象的适配器模式 类的适配器模式一样，对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类
类适配器和对象适配器的权衡 ●　类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。
●　对于类适配器，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静态的关系，当适配器继承了Adaptee后，就不可能再去处理 Adaptee的子类了。
对于对象适配器，一个适配器可以把多种不同的源适配到同一个目标。换言之，同一个适配器可以把源类和它的子类都适配到目标接口。因为对象适配器采用的是对象组合的关系，只要对象类型正确，是不是子类都无所谓。
●　对于类适配器，适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。
对于对象适配器，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。
●　对于类适配器，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。
对于对象适配器，需要额外的引用来间接得到Adaptee。
建议尽量使用对象适配器的实现方式，多用合成/聚合、少用继承。当然，具体问题具体分析，根据需要来选用实现方式，最适合的才是最好的
优点 复用性 扩展性 缺点 过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构
代码示例
缺省适配器模式 抽象类中实现顶层接口的默认实现</description>
    </item>
    
    <item>
      <title>构建者模式</title>
      <link>https://github.com/AlfredNing/note/program/design_pattern/%E6%9E%84%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 07 Feb 2023 22:47:44 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/design_pattern/%E6%9E%84%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>分离对象的的属性与创建过程，用户创建重的对象。
写法分类：
在Builder里面直接new对象的方式，MyBatis的SqlSessionFactoryBuilder就是这种写法，适用于属性之间关联不多且大量属性都有默认值的场景。 间接new的方式：例如Guava的Cache都是这种写法，适用于属性之间有一定关联性的场景。 建造者模式的优点及适用场景
建造者模式这种设计模式，优缺点比较明显。从优点来说：
客户端不比知道产品内部细节，将产品本身与产品创建过程解耦，使得相同的创建过程可以创建不同的产品对象 可以更加精细地控制产品的创建过程，将复杂对象分门别类抽出不同的类别来，使得开发者可以更加方便地得到想要的产品 想了想，说缺点，建造者模式说不上缺点，只能说这种设计模式的使用比较受限：
产品属性之间差异很大且属性没有默认值可以指定，这种情况是没法使用建造者模式的，我们可以试想，一个对象20个属性，彼此之间毫无关联且每个都需要手动指定，那么很显然，即使使用了建造者模式也是毫无作用 代码示例</description>
    </item>
    
    <item>
      <title>访问者模式</title>
      <link>https://github.com/AlfredNing/note/program/design_pattern/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 07 Feb 2023 21:17:34 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/design_pattern/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>对象的行为模式。在不修改已有程序的前提下，通过添加额外的访问者来完成对已有代码功能的提升。
将数据结构与操作分离
角色：
抽象访问者: 声明了一个或者多个方法操作，形成所有的具体访问者角色必须实现的接口 具体访问者: 实现抽象访问者所声明的接口，也就是抽象访问者所声明的各个访问操作 抽象节点: 声明一个接受操作，接受一个访问者对象作为一个参数 具体节点: 实现了抽象节点所规定的接受操作 结构对象: 遍历结构的元素 访问者模式优点：
扩展性好，可以在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能； 符合单一职责原则，通过访问者将无关的行为分离，使职责单一；
访问者模式缺点：
违反了迪米特原则，因为具体元素对访问者公布细节； 违反了依赖倒置原则，依赖了具体类，没有依赖抽象； 对象结构变化困难，若对象结构发生了改变，访问者的接口和访问者的实现也都要发生相应的改变；
使用场景：
对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作； 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作&amp;quot;污染&amp;quot;这些对象的类，也不希望在增加新操作时修改这些类。
访问者模式示例</description>
    </item>
    
    <item>
      <title>迭代器模式</title>
      <link>https://github.com/AlfredNing/note/program/design_pattern/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 07 Feb 2023 20:57:19 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/design_pattern/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description> 迭代器模式又叫做游标模式，作用：提供一种方法访问一个容器元素中的各个对象，而又不暴露该对象的内部细节
角色：
迭代器角色 具体迭代器角色 容器角色 具体容器角色 </description>
    </item>
    
    <item>
      <title>代理模式</title>
      <link>https://github.com/AlfredNing/note/program/design_pattern/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 07 Feb 2023 20:48:23 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/design_pattern/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid>
      <description>代理模式是一种使用代理对象来执行目标对象的方法并在代理对象中增强目标对象方法的一种设计模式
静态代理 动态代理 静态代理的特点如下：
使用静态代理时，通常客户类不需要感知RealSubject。 静态代理的缺点：代理对象需要与目标对象实现一样的接口，因此接口较多时需要定义和维护大量的代理类代码。 与适配器的差异：适配器通常考虑改变接口形态，而代理则不会也不能改变接口形态。 与装饰器的差异：被代理对象由代理对象创建，客户端甚至不需要知道被代理类的存在；被装饰对象则由客户端创建并传给装饰对象，可以层层嵌套，层层装饰。代理模式常用于控制被代理对象的访问，而装饰模式是增加被装饰者的功能。
JDK动态代理的特点如下：
通过实现InvocationHandler接口完成代理逻辑。 通过反射代理方法，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。 代理类必须实现接口。 代理模式</description>
    </item>
    
    <item>
      <title>享元模式</title>
      <link>https://github.com/AlfredNing/note/program/design_pattern/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 07 Feb 2023 20:29:05 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/design_pattern/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</guid>
      <description> 对象的结构模式，以共享的方式高效的支持大量的细粒度对象
java中String类型就是享元模式 享元模式采用一个共享来避免大量拥有相同内容对象的开销
分类 单纯享元模式 所有的享元对象都是可以共享的
角色：
抽象享元(Flyweight)角色：抽象接口 具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口 享元工厂(FlyweightFactory)角色：本角色负责创建和管理享元角色 复合享元模式 抽象享元(Flyweight)角色：抽象接口 具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口 复合享元角色：复合享元角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解成为多个本身是单纯享元对象的组合。复合享元角色又称作不可共享的享元对象 享元工厂(FlyweightFactory)角色：本角色负责创建和管理享元角色 </description>
    </item>
    
    <item>
      <title>组合模式</title>
      <link>https://github.com/AlfredNing/note/program/design_pattern/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 07 Feb 2023 20:13:12 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/design_pattern/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</guid>
      <description>描述部分与整体的关系，组装树形结构
角色 抽象构件角色 树叶构件角色 树枝构件角色 分类 透明式：在该方式中，由于抽象构件声明了所有子类中的全部方法，所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的 安全式：在该方式中，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题，但由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性 组合模式代码</description>
    </item>
    
    <item>
      <title>观察者模式</title>
      <link>https://github.com/AlfredNing/note/program/design_pattern/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 07 Feb 2023 19:50:02 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/design_pattern/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>观察者模式-对象行为模式。发布/订阅模式，模型-视图模式、源-监听器模式，从属者模式。
定义一对多的依赖关系，让多个观察者同时监听某一个主题对象。这个对象在状态上发生变化时，会通知所有观察者对象，是它们能够主动更新自己的状态。
角色：
抽象主题角色：提供一个接口，可以增加和减少观察者对象，抽象主题角色又叫做抽象被观察者角色。 具体主题角色：将有关状态存入具体观察者对象 抽象观察者角色：为所有的观察者提供一个接口，在得到主题的通知时更新自己。 具体观察者角色：存储与主题状态自恰的状态。 模式分类：
推模式
主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。
拉模式 主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。
java对观察者模式的支持
Observer接口： 观察者 Observable类： 被观察者 示例代码</description>
    </item>
    
    <item>
      <title>责任链模式</title>
      <link>https://github.com/AlfredNing/note/program/design_pattern/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 06 Feb 2023 08:09:32 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/design_pattern/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</guid>
      <description>对象的行为模式，允许你将请求沿着处理链进行发送。收到请求后，每个处理者可对请求进行处理，或将其传递给链上的下个处理者
角色：
抽象处理者：定义处理请求的接口。 具体处理者：具体处理者接到请求，可以将请求处理，或者将请求传给下家。 示例代码</description>
    </item>
    
    <item>
      <title>装饰者模式</title>
      <link>https://github.com/AlfredNing/note/program/design_pattern/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 05 Feb 2023 23:28:12 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/design_pattern/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>动态的将责任添加到对象上，动态添加功能。
分类：
父组件，供子组件使用 装饰者：组合其他组件，一部分功能是自己的，调用被装饰者，等同于保留被装饰者的功能 具体组件：实现具体方法 饮料添加各种配料，返回最终的价格。
代码示例</description>
    </item>
    
    <item>
      <title>调停者模式</title>
      <link>https://github.com/AlfredNing/note/program/design_pattern/%E8%B0%83%E5%81%9C%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 05 Feb 2023 16:05:46 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/design_pattern/%E8%B0%83%E5%81%9C%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>门面模式对外，调停者模式对内
对象的行为模式，调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显引用。从而使它们可以较松散地耦合。当这些对象中的某些对象之间的相互作用发生改变时，不会立即影响到其他的一些对象之间的相互作用。从而保证这些相互作用可以彼此独立地变化
角色：
抽象调停者角色 具体调停者角色 抽象同事类角色 具体公式类角色 示例代码</description>
    </item>
    
    <item>
      <title>门面模式</title>
      <link>https://github.com/AlfredNing/note/program/design_pattern/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 05 Feb 2023 15:50:55 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/design_pattern/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/</guid>
      <description>提供高层次的接口，统一门面对象进行，使得子系统易于使用。
选择性的暴露方法
角色分类：
门面角色: 客户端可以调用这个角色的方法 子系统角色：可以同时有一个或者多个子系统 门面模式示例代码</description>
    </item>
    
    <item>
      <title>工厂模式</title>
      <link>https://github.com/AlfredNing/note/program/design_pattern/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 04 Feb 2023 10:18:28 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/design_pattern/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>任何可以产生对象的方法和类，都可以被称为工厂。
创建型设计模式，父类提供创建对象的方法，允许子类决定实例化对象的类型
分类 根据产品是具体产品还是具体工厂：
简单工厂模式 工厂方法模式 根据工厂的抽象程度
工厂方法模式 抽象工厂模式 简单工厂模式 只对不同类对象的创建进行了一层薄薄的封装，通过向工厂传递类型来指定要创建的对象。
工厂方法模式 工厂方法模式将生产具体产品的任务分发给具体的产品工厂
抽象工厂模式 针对不同产品的创建。在工厂方法模式下，在抽象工厂里面增加创建产品的接口，并在具体子工厂中实现产品的创建
工厂模式代码示例合</description>
    </item>
    
    <item>
      <title>策略模式</title>
      <link>https://github.com/AlfredNing/note/program/design_pattern/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 03 Feb 2023 07:38:26 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/design_pattern/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>对于做同一件事有多种方法，Comparator接口。
Context：环境类 Strategy: 抽象策略类 ConcreteStrategy: 具体策略类 使用场景 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。
策略模式示例代码</description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>https://github.com/AlfredNing/note/program/design_pattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 16 Jan 2023 08:36:37 +0800</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/design_pattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>保持内存中只有一个对象
分类：
是否加载实例
饿汉式 饱汉式 是否线程安全
安全 不安全 特殊实现方式：
静态内部类 枚举 单例模式代码</description>
    </item>
    
    <item>
      <title>Kmp</title>
      <link>https://github.com/AlfredNing/note/program/algorithm/kmp/</link>
      <pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://github.com/AlfredNing/note/program/algorithm/kmp/</guid>
      <description>使用场景 多用于子串匹配问题
流程 在暴力解的过程当中有加速
定义： 在该位置之前的前缀与后缀的长度，但不能取到字符串的整体长度，定义为指标信息
解释：
对匹配串建立上述指标信息 匹配过程 求解证明 x-r 与 y-r&amp;rsquo;是相同，从i位置匹配match串等同于从match的q位置进行匹配
i位置到r位置一定不能匹配match
验证：假设i位置到r位置，有个k位置能够匹配match串，那就说明从k位置到x位置是相同的，也就是match串y位置之前字符串的一个后缀，此时，与next的数组定义违反，出现了一个更长的。假设不成立。
next数组生成 match长度为M,时间复杂度为O(M)
next[0] = -1;
next[1] = 0;
next[2] = 0位置和1位置决定;
求i位置的next[i]时候，前面所有位置都已经准备好
next证明 来到i位置next[i]最大为next[i+1]+1
假设next[i]&amp;gt;next[i-1] + 1,
那么说明next[i-1]求解错误，矛盾，不成立
代码实现 public class Kmp { public static int getIndexOf(String s, String match) { if (s == null || match == null || match.length() &amp;lt; 1 || s.length() &amp;lt; match.length()) { return -1; } char[] strs = s.toCharArray(); char[] matchs = match.</description>
    </item>
    
    
    
  </channel>
</rss>
