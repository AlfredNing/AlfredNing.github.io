<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>AlfredNing</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on AlfredNing</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Sat, 07 Sep 2024 14:59:46 +0800</lastBuildDate><atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ORM框架设计</title>
      <link>http://localhost:1313/note/program/mysql/orm%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Sat, 07 Sep 2024 14:59:46 +0800</pubDate>
      
      <guid>http://localhost:1313/note/program/mysql/orm%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/</guid>
      <description>经典的软件架构 分层架构：经典的MVC 事件驱动架构 管道-过滤器架构 微核架构：vsCode , idea ORM的架构层次 接口层：向上支持程序调用 处理层：参数映射-&amp;gt; SQL生成 -&amp;gt; SQL执行 -&amp;gt; 结果处理 支撑层：事务管理 连接池管理 连接层： 数据库连接驱动 </description>
    </item>
    
    <item>
      <title>MySQL查询优化</title>
      <link>http://localhost:1313/note/program/mysql/mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</link>
      <pubDate>Sat, 07 Sep 2024 09:25:42 +0800</pubDate>
      
      <guid>http://localhost:1313/note/program/mysql/mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</guid>
      <description>一个SQL是如何执行的 查询缓存：
执行查询过得语句先缓存 推荐使用缓存：数据表修改后，会删除所有缓存相关的。Mysql8 去掉缓存 分析器：
知道干什么 词法分析 句法分析 优化器：
优化器的作用知道是怎么做 决定如何使用索引 执行器：
校验权限，调用存储引擎 没有索引情况，执行器会查询所有行 索引组织表 索引：数据库中对某一列或者多个列的值进行预排序的数据结构
主键：非空唯一索引；不指定主键，与声明顺序有关
主流索引查找 线性查找 二分查找 二叉查找树 平衡二叉树 B树 B+树 二叉树特殊情况下，可以退化成链表，所有引入了平衡二叉树，通过旋转的方式，保证子树间的高度。二叉树明显的缺点是每个节点存储的数据太少。硬盘按块（默认4k）读取
B树 叶子存储多节点，多数据节点降低树的高度。
B+树 叶子间通过链表相连。只有叶子存储数据
高度一般为2-4层，查找速度快
Innodb采用B+树结构
聚簇索引 根据表的主键构造B+树
数据和索引放在一起
叶子节点之间存放数据，而不是指针
辅助索引 叶子节点不包含数据，存储主键 Innodb存储逻辑结构 数据记录格式 索引建立 联合索引：最左前缀，“带头大哥不能死，中间兄弟不能丢” 字符串的前缀索引：字符串过长，使用前缀索引节约空间； 前缀区分度太小：倒序存储，取的时候反向存储 新建hash字段 字符串like: 全模糊：“%like%” 索引失效 右模糊：&amp;quot;%like&amp;quot; 索引失效 左模糊才可以使用索引 查询优化 覆盖索引 取消回表操作，提高查询性能 数据的查询不只使用到了一个索引，则不是覆盖索引 优化sql语句或者优化联合索引，来使用覆盖索引 有更合适的索引不走 Mysql索引的选择-基于基数 参考索引的基数
反应字段有多少种取值 选取几个页中取值的平均值，在乘以页数，则为基数 查看索引
show index from tableName
区分度越大，mysql最可能选取
解决措施: 强制使用索引 force index 强制使用索引 优化索引，让mysql重新统计索引 analyze table 会重新统计索引基数 count比较慢 count：统计结果集合不为null的数据个数</description>
    </item>
    
    <item>
      <title>排序之归并排序</title>
      <link>http://localhost:1313/note/program/java/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 18 Aug 2024 13:30:46 +0800</pubDate>
      
      <guid>http://localhost:1313/note/program/java/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</guid>
      <description>原理介绍 采用分治核心思想 代码实现 import java.util.Arrays; /** * 归并排序 * * @author Alfred.Ning * @since 2024年08月18日 20:24:00 */ public class MergeSort { public static void main(String[] args) { int[] nums = {8, 4, 5, 7, 9, 3, 2, 6, 1}; int[] nums1 = new int[nums.length]; System.arraycopy(nums, 0, nums1, 0, nums.length); MergeSort mergeSort = new MergeSort(); mergeSort.mergeSort(nums); mergeSort.sort(nums1); for (int i = 0; i &amp;lt; nums.length; i++) { if (nums[i] != nums1[i]) { System.</description>
    </item>
    
    <item>
      <title>排序之冒泡排序</title>
      <link>http://localhost:1313/note/program/java/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 18 Aug 2024 13:30:39 +0800</pubDate>
      
      <guid>http://localhost:1313/note/program/java/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</guid>
      <description></description>
    </item>
    
    <item>
      <title>SpringBoot工具</title>
      <link>http://localhost:1313/note/program/spring/spring%E5%B7%A5%E5%85%B7-%E6%97%A5%E5%BF%97%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</link>
      <pubDate>Mon, 12 Aug 2024 23:24:51 +0800</pubDate>
      
      <guid>http://localhost:1313/note/program/spring/spring%E5%B7%A5%E5%85%B7-%E6%97%A5%E5%BF%97%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</guid>
      <description>springCloud和springboot版本之间的对应关系：https://spring.io/projects/spring-cloud springboot和kafka的版本对应关系：https://spring.io/projects/spring-kafka
SpringBoot全局异常处理 package com.example.demo01.infra.advice; import jakarta.servlet.http.HttpServletResponse; import lombok.extern.slf4j.Slf4j; import org.springframework.http.HttpStatus; import org.springframework.validation.BindingResult; import org.springframework.validation.FieldError; import org.springframework.validation.ObjectError; import org.springframework.web.bind.MethodArgumentNotValidException; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.bind.annotation.RestControllerAdvice; /** * 全局异常处理器 * * @author Alfred.Ning * @since 2024年08月15日 21:17:00 */ @RestControllerAdvice @ResponseBody @Slf4j public class GlobalExceptionHandler { @ExceptionHandler(value = {MethodArgumentNotValidException.class}) public ResponseResult&amp;lt;String&amp;gt; handleValidException(MethodArgumentNotValidException ex, HttpServletResponse httpServletResponse) { log.error(&amp;#34;[GlobalExceptionHandler][handleValidException] 参数校验exception&amp;#34;, ex); return wrapperBindingResult(ex.getBindingResult(), httpServletResponse); } private ResponseResult&amp;lt;String&amp;gt; wrapperBindingResult(BindingResult bindingResult, HttpServletResponse httpServletResponse) { StringBuilder errorMsg = new StringBuilder(); for (ObjectError error : bindingResult.</description>
    </item>
    
    <item>
      <title>记20240714</title>
      <link>http://localhost:1313/thinking/%E8%AE%B020240714/</link>
      <pubDate>Sun, 14 Jul 2024 19:39:52 +0800</pubDate>
      
      <guid>http://localhost:1313/thinking/%E8%AE%B020240714/</guid>
      <description>背景 今天打扫了房间，清理掉了很多没有用的东西，最根本性发现几个问题。
很多东西，都是不需要的 今天扔了好多东西，有的东西甚至都还是全新的，有的甚至当初留下来，想的是以后能用到。可往往占据了地方，结果到最后还是扔掉了。
仔细想想，其实人生并不是需要那么多额外的东西
反而拥有那么多的东西，会让人变得迷茫，也会使自己的空间变得暗小。 对于之后的借鉴意义，想买一个东西，想流下一个东西，需要用长期的眼光来审视它，假如之后都不会在用到它，那就不假思索的将他挥之而去。
功能归类，才是最好的选择 之前每次打扫房间，都会有一个疑问。为什么我上次刚打扫的房间，收拾的干干净净，这次就有变的很乱了呢。回过头来，自己想想，因为从上次之后，回家就不会把同一个东西放到它以前的位置上，而只是顺手放的。 像这种情况，最好的解法，放东西的时候，想好它最应该摆放在哪里。每次拿完重新饭的时候，不要懒惰，放到时候自己想想，它和之前放的是不是同一个位置。最忌讳的就是，回来之后放纵自己，随手丢。
警惕奶头乐 这个时代最想毒品的就是手机了。想我一样，好不容易有个周末，结果刷了剧，特别的那种短视频，就很容易让人上瘾，长期以往，包括的自己的神经和生活都会受到影响。
奶头乐这类东西，现在有，将来也有。未有能做到，当触及到奶头乐边缘的时候里面停止，进行心里批判。
拥有一个好的习惯 上面说了那么多，如果落到具体实践中来，就是一定需要养成一个良好的生活习惯。开始去做很难，就容易被其他事物分心，长期就会变成间歇性的努力。而这种现状就是在去执行好的习惯时候，被奶头乐占据了上方。
好的习惯，是习惯成自然。不随其他情况发生变化。也不是因为今天很累，忘记了诸如此类的而去打破养成习惯。 当习惯一旦养成，万物皆不可摧毁。
成长就是不断地对抗天性
人生最值钱的是自己的时间，在你走后，你也许给这个世界留下不了什么。但你一定要证明自己曾来过这个世界。 长远的审视自己，时间很快。 保持专注，保证警醒</description>
    </item>
    
    <item>
      <title>Test02</title>
      <link>http://localhost:1313/test02/</link>
      <pubDate>Mon, 01 Jul 2024 12:00:39 +0800</pubDate>
      
      <guid>http://localhost:1313/test02/</guid>
      <description></description>
    </item>
    
    <item>
      <title>浪潮之巔所感</title>
      <link>http://localhost:1313/thinking/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%94%E6%89%80%E6%84%9F/</link>
      <pubDate>Sun, 04 Jun 2023 21:08:54 +0800</pubDate>
      
      <guid>http://localhost:1313/thinking/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%94%E6%89%80%E6%84%9F/</guid>
      <description>2023年上，看了浪潮之巅。
20世纪不联网信息产业密度不断扩大，新型了各大历史上著名的公司，有的至今还在，有的早已灭亡。科学技术的不断发展，有的公司靠自己影响力，有的公司靠自己的垄断，有的公司在技术上的发展却无法商业变现。历史上著名的太阳公司，雅虎公司。好的公司里面必要有优秀的人才。
每一个叫的名字的公司，之前都经历过一段痛苦时间，每一个站在行业顶端的互联网公司，都占据着市场上诸多的利润。不要看到大公司的今天，回头看看，他们的一路。任何事情也都是如此。
下面的记录的一些定律：未来的一天这些定律也可能不复存在
计算机行业的发展规律 摩尔定律 每18个月，计算机等IT产品的性能翻一番；或者是说相同性能的计算机等IT产品，每18个月价钱会降一半。【小范围适用于你买电子产品】
安迪-比尔定律 安迪：英特尔公司传奇CEO
比尔: 微软公司创始人比尔盖茨
软件压榨着硬件的性能
以微软为首的软件开发公司吃掉硬件提升带来的全部好处，迫使用户更新机器，让硬件厂商受益。硬件厂商继而研发，根据摩尔定律，提升硬件性能，为微软下一步更新软件做准备，形成完整生态链。
反摩尔定律 一个IT公司如果今天和18个月前卖掉同样多的、同样的产品，它的营业额就会降一半。
反摩尔定律逼着所有硬件公司都必须追赶上摩尔定律规定的更新速度。
信息产业的规律性 70-20-10 行业老大吃掉市场的70%，老二吃掉20%，剩下的瓜分10%
诺威格定律 一家公司的市场占有率超过50%，就无法在翻一番了。公司进行“横向扩展” 、业务转型
基因决定定律 一家公司的基因决定了这家公司的发展
黑格尔的一句话: 凡是现实的都是合理的，凡是合理的都是现实的。All that is real is rational; and all that is rational is real
意思是说: 现实存在的现象，当初产生它的时候必然有它产生的原因和理由。如果这个理由将来不存在了，终究有一天它也会消亡。
巴菲特：成功的关键不在于做对了多少件事，而在于少犯多少错误
工业革命与颠覆式创新 蒸汽机 电 信息革命-计算机 人工智能 技术革命的共性 时间间隔大约70-90年 拥有核心技术 带来新的财富剧增 信息和能量的造就
对服务的需求 对高端人才的需求 对品质的需求 对新事物的需求 工业革命的范式 现有产业 + 蒸汽机 = 新的产业 现有产业 + 电 = 新的产业 现有产业 + 摩尔定律 = 新的产业 第四次工业革命 - 智能革命， 上世纪70年代就提出来数据驱动的方法 现有产业 + 智能技术 = 新的产业 工业革命的核心资源：</description>
    </item>
    
    
    
  </channel>
</rss>
