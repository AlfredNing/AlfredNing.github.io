[{"content":"","permalink":"http://localhost:1313/note/program/java/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","summary":"","title":"排序之归并排序"},{"content":"原理介绍 ","permalink":"http://localhost:1313/note/program/java/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","summary":"原理介绍 ","title":"排序之冒泡排序"},{"content":" springCloud和springboot版本之间的对应关系：https://spring.io/projects/spring-cloud springboot和kafka的版本对应关系：https://spring.io/projects/spring-kafka\nSpringBoot全局异常处理 package com.example.demo01.infra.advice; import jakarta.servlet.http.HttpServletResponse; import lombok.extern.slf4j.Slf4j; import org.springframework.http.HttpStatus; import org.springframework.validation.BindingResult; import org.springframework.validation.FieldError; import org.springframework.validation.ObjectError; import org.springframework.web.bind.MethodArgumentNotValidException; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.bind.annotation.RestControllerAdvice; /** * 全局异常处理器 * * @author Alfred.Ning * @since 2024年08月15日 21:17:00 */ @RestControllerAdvice @ResponseBody @Slf4j public class GlobalExceptionHandler { @ExceptionHandler(value = {MethodArgumentNotValidException.class}) public ResponseResult\u0026lt;String\u0026gt; handleValidException(MethodArgumentNotValidException ex, HttpServletResponse httpServletResponse) { log.error(\u0026#34;[GlobalExceptionHandler][handleValidException] 参数校验exception\u0026#34;, ex); return wrapperBindingResult(ex.getBindingResult(), httpServletResponse); } private ResponseResult\u0026lt;String\u0026gt; wrapperBindingResult(BindingResult bindingResult, HttpServletResponse httpServletResponse) { StringBuilder errorMsg = new StringBuilder(); for (ObjectError error : bindingResult.getAllErrors()) { if (error instanceof FieldError) { errorMsg.append(((FieldError) error).getField()).append(\u0026#34;: \u0026#34;); } errorMsg.append(error.getDefaultMessage() == null ? \u0026#34;\u0026#34; : error.getDefaultMessage()); } httpServletResponse.setStatus(HttpStatus.BAD_REQUEST.value()); return ResponseResult.failed(ResultCode.FAILED.getCode(),null); } } 请求日志记录 package com.example.demo01.infra.advice; import jakarta.servlet.http.HttpServletRequest; import jakarta.servlet.http.HttpServletResponse; import java.util.ArrayList; import java.util.List; import lombok.extern.slf4j.Slf4j; import org.apache.tomcat.util.buf.StringUtils; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.annotation.AfterReturning; import org.aspectj.lang.annotation.Before; import org.aspectj.lang.annotation.Pointcut; import org.springframework.context.annotation.Configuration; import org.springframework.validation.BindingResult; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes; import org.springframework.web.multipart.MultipartFile; /** * @author Alfred.Ning * @since 2024年08月15日 21:24:00 */ @Configuration @Slf4j public class WebLogAspect { @Pointcut(\u0026#34;@within(org.springframework.stereotype.Controller) || @within(org.springframework.web.bind.annotation.RestController)\u0026#34;) public void cutController() { } @Before(\u0026#34;cutController()\u0026#34;) public void doBefore(JoinPoint point) { //获取拦截方法的参数 HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest(); String url = request.getRequestURL().toString(); List\u0026lt;Object\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (Object object : point.getArgs()) { if (object instanceof MultipartFile || object instanceof HttpServletRequest || object instanceof HttpServletResponse || object instanceof BindingResult) { continue; } list.add(object); } log.info(\u0026#34;请求 uri:[{}],params:[{}]\u0026#34;, url, list); } /** * 返回通知： 1. 在目标方法正常结束之后执行 1. 在返回通知中补充请求日志信息，如返回时间，方法耗时，返回值，并且保存日志信息 * * @param response * @throws Throwable */ @AfterReturning(returning = \u0026#34;response\u0026#34;, pointcut = \u0026#34;cutController()\u0026#34;) public void doAfterReturning(Object response) { if (response != null) { log.info(\u0026#34;请求返回result:[{}]\u0026#34;, response); } } } 通过Filter接口也可以实现\n","permalink":"http://localhost:1313/note/program/spring/spring%E5%B7%A5%E5%85%B7-%E6%97%A5%E5%BF%97%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","summary":"springCloud和springboot版本之间的对应关系：https://spring.io/projects/spring-cloud springboot和kafka的版本对应关系：https://spring.io/projects/spring-kafka\nSpringBoot全局异常处理 package com.example.demo01.infra.advice; import jakarta.servlet.http.HttpServletResponse; import lombok.extern.slf4j.Slf4j; import org.springframework.http.HttpStatus; import org.springframework.validation.BindingResult; import org.springframework.validation.FieldError; import org.springframework.validation.ObjectError; import org.springframework.web.bind.MethodArgumentNotValidException; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.bind.annotation.RestControllerAdvice; /** * 全局异常处理器 * * @author Alfred.Ning * @since 2024年08月15日 21:17:00 */ @RestControllerAdvice @ResponseBody @Slf4j public class GlobalExceptionHandler { @ExceptionHandler(value = {MethodArgumentNotValidException.class}) public ResponseResult\u0026lt;String\u0026gt; handleValidException(MethodArgumentNotValidException ex, HttpServletResponse httpServletResponse) { log.error(\u0026#34;[GlobalExceptionHandler][handleValidException] 参数校验exception\u0026#34;, ex); return wrapperBindingResult(ex.getBindingResult(), httpServletResponse); } private ResponseResult\u0026lt;String\u0026gt; wrapperBindingResult(BindingResult bindingResult, HttpServletResponse httpServletResponse) { StringBuilder errorMsg = new StringBuilder(); for (ObjectError error : bindingResult.","title":"SpringBoot工具"},{"content":"背景 今天打扫了房间，清理掉了很多没有用的东西，最根本性发现几个问题。\n很多东西，都是不需要的 今天扔了好多东西，有的东西甚至都还是全新的，有的甚至当初留下来，想的是以后能用到。可往往占据了地方，结果到最后还是扔掉了。\n仔细想想，其实人生并不是需要那么多额外的东西\n反而拥有那么多的东西，会让人变得迷茫，也会使自己的空间变得暗小。 对于之后的借鉴意义，想买一个东西，想流下一个东西，需要用长期的眼光来审视它，假如之后都不会在用到它，那就不假思索的将他挥之而去。\n功能归类，才是最好的选择 之前每次打扫房间，都会有一个疑问。为什么我上次刚打扫的房间，收拾的干干净净，这次就有变的很乱了呢。回过头来，自己想想，因为从上次之后，回家就不会把同一个东西放到它以前的位置上，而只是顺手放的。 像这种情况，最好的解法，放东西的时候，想好它最应该摆放在哪里。每次拿完重新饭的时候，不要懒惰，放到时候自己想想，它和之前放的是不是同一个位置。最忌讳的就是，回来之后放纵自己，随手丢。\n警惕奶头乐 这个时代最想毒品的就是手机了。想我一样，好不容易有个周末，结果刷了剧，特别的那种短视频，就很容易让人上瘾，长期以往，包括的自己的神经和生活都会受到影响。\n奶头乐这类东西，现在有，将来也有。未有能做到，当触及到奶头乐边缘的时候里面停止，进行心里批判。\n拥有一个好的习惯 上面说了那么多，如果落到具体实践中来，就是一定需要养成一个良好的生活习惯。开始去做很难，就容易被其他事物分心，长期就会变成间歇性的努力。而这种现状就是在去执行好的习惯时候，被奶头乐占据了上方。\n好的习惯，是习惯成自然。不随其他情况发生变化。也不是因为今天很累，忘记了诸如此类的而去打破养成习惯。 当习惯一旦养成，万物皆不可摧毁。\n成长就是不断地对抗天性\n人生最值钱的是自己的时间，在你走后，你也许给这个世界留下不了什么。但你一定要证明自己曾来过这个世界。 长远的审视自己，时间很快。 保持专注，保证警醒\n","permalink":"http://localhost:1313/thinking/%E8%AE%B020240714/","summary":"背景 今天打扫了房间，清理掉了很多没有用的东西，最根本性发现几个问题。\n很多东西，都是不需要的 今天扔了好多东西，有的东西甚至都还是全新的，有的甚至当初留下来，想的是以后能用到。可往往占据了地方，结果到最后还是扔掉了。\n仔细想想，其实人生并不是需要那么多额外的东西\n反而拥有那么多的东西，会让人变得迷茫，也会使自己的空间变得暗小。 对于之后的借鉴意义，想买一个东西，想流下一个东西，需要用长期的眼光来审视它，假如之后都不会在用到它，那就不假思索的将他挥之而去。\n功能归类，才是最好的选择 之前每次打扫房间，都会有一个疑问。为什么我上次刚打扫的房间，收拾的干干净净，这次就有变的很乱了呢。回过头来，自己想想，因为从上次之后，回家就不会把同一个东西放到它以前的位置上，而只是顺手放的。 像这种情况，最好的解法，放东西的时候，想好它最应该摆放在哪里。每次拿完重新饭的时候，不要懒惰，放到时候自己想想，它和之前放的是不是同一个位置。最忌讳的就是，回来之后放纵自己，随手丢。\n警惕奶头乐 这个时代最想毒品的就是手机了。想我一样，好不容易有个周末，结果刷了剧，特别的那种短视频，就很容易让人上瘾，长期以往，包括的自己的神经和生活都会受到影响。\n奶头乐这类东西，现在有，将来也有。未有能做到，当触及到奶头乐边缘的时候里面停止，进行心里批判。\n拥有一个好的习惯 上面说了那么多，如果落到具体实践中来，就是一定需要养成一个良好的生活习惯。开始去做很难，就容易被其他事物分心，长期就会变成间歇性的努力。而这种现状就是在去执行好的习惯时候，被奶头乐占据了上方。\n好的习惯，是习惯成自然。不随其他情况发生变化。也不是因为今天很累，忘记了诸如此类的而去打破养成习惯。 当习惯一旦养成，万物皆不可摧毁。\n成长就是不断地对抗天性\n人生最值钱的是自己的时间，在你走后，你也许给这个世界留下不了什么。但你一定要证明自己曾来过这个世界。 长远的审视自己，时间很快。 保持专注，保证警醒","title":"记20240714"},{"content":"","permalink":"http://localhost:1313/test02/","summary":"","title":"Test02"},{"content":"2023年上，看了浪潮之巅。\n20世纪不联网信息产业密度不断扩大，新型了各大历史上著名的公司，有的至今还在，有的早已灭亡。科学技术的不断发展，有的公司靠自己影响力，有的公司靠自己的垄断，有的公司在技术上的发展却无法商业变现。历史上著名的太阳公司，雅虎公司。好的公司里面必要有优秀的人才。\n每一个叫的名字的公司，之前都经历过一段痛苦时间，每一个站在行业顶端的互联网公司，都占据着市场上诸多的利润。不要看到大公司的今天，回头看看，他们的一路。任何事情也都是如此。\n下面的记录的一些定律：未来的一天这些定律也可能不复存在\n计算机行业的发展规律 摩尔定律 每18个月，计算机等IT产品的性能翻一番；或者是说相同性能的计算机等IT产品，每18个月价钱会降一半。【小范围适用于你买电子产品】\n安迪-比尔定律 安迪：英特尔公司传奇CEO\n比尔: 微软公司创始人比尔盖茨\n软件压榨着硬件的性能\n以微软为首的软件开发公司吃掉硬件提升带来的全部好处，迫使用户更新机器，让硬件厂商受益。硬件厂商继而研发，根据摩尔定律，提升硬件性能，为微软下一步更新软件做准备，形成完整生态链。\n反摩尔定律 一个IT公司如果今天和18个月前卖掉同样多的、同样的产品，它的营业额就会降一半。\n反摩尔定律逼着所有硬件公司都必须追赶上摩尔定律规定的更新速度。\n信息产业的规律性 70-20-10 行业老大吃掉市场的70%，老二吃掉20%，剩下的瓜分10%\n诺威格定律 一家公司的市场占有率超过50%，就无法在翻一番了。公司进行“横向扩展” 、业务转型\n基因决定定律 一家公司的基因决定了这家公司的发展\n黑格尔的一句话: 凡是现实的都是合理的，凡是合理的都是现实的。All that is real is rational; and all that is rational is real\n意思是说: 现实存在的现象，当初产生它的时候必然有它产生的原因和理由。如果这个理由将来不存在了，终究有一天它也会消亡。\n巴菲特：成功的关键不在于做对了多少件事，而在于少犯多少错误\n工业革命与颠覆式创新 蒸汽机 电 信息革命-计算机 人工智能 技术革命的共性 时间间隔大约70-90年 拥有核心技术 带来新的财富剧增 信息和能量的造就\n对服务的需求 对高端人才的需求 对品质的需求 对新事物的需求 工业革命的范式 现有产业 + 蒸汽机 = 新的产业 现有产业 + 电 = 新的产业 现有产业 + 摩尔定律 = 新的产业 第四次工业革命 - 智能革命， 上世纪70年代就提出来数据驱动的方法 现有产业 + 智能技术 = 新的产业 工业革命的核心资源：\n第一次是煤和铁\n第二次是石油\n第三次是资本\n第四次是数据\n范式：现有产业 + 新技术 = 新的产业\n与其担忧明天，不如顺应历史的潮流，积极思考，在未来自己能发挥出多大的价值。\n回顾过去，是为了展望未来。过去如此，未来也是如此。\n为了适应新时代的变化，我们需要摒弃过去那种依赖规则和普适的规律，强调因果关系的机械做事方式，变成利用信息解决不确定性的问题。\n追求卓越，拒绝贫庸，不被淘汰\n伟大公司的特质 世界因之而不同。对全世界而不仅仅是一个国家、一个地区产生巨大的正面影响。 能挣钱 每一次经济危机之后，一些旧的行业会失去很多工作，而这些工作永远回不来了。\n中国目前IT领域的最大问题有两个。第一，几乎找不到有一万小时工作经验的工程师，因为一个年轻人毕业五六年后就开始从事管理工作，以至于一线研发的工程师永远是欠缺经验的。所以中国的产品和服务总是给人“便宜但低质”的印象，很难占领产业链的上游。第二，由于中国经济增长很快，市场很大，IT公司不需要把产品和服务做得很精，就能获得市场并快速增长，很多成功靠的是运气而非实力和水平。这些公司的领导人，在公司收入从一个亿增长到100亿时，能力显然没有增加一百倍，但是“谱”却随着收入的增加而增加。一旦到海外和跨国公司竞争，就时常碰壁了。真正成功的跨国公司在人员构成上，尤其是高层人士的构成上都是国际化的，多元文化的撞击不仅能创造出伟大的产品，而且会成为全球竞争力的保障。相比美国的大公司，中国优秀的公司在人员构成上还过于单一，要想彻底做到多元化，还有较长的路要走。\n中国的现实问题是，人们似乎不需要靠科技的进步和实业就可以取得财富。看看中国富豪榜的构成，有几个是贝尔、福特这样的发明家，又有几个是洛克菲勒和卡内基这样的实业家。几乎所有富豪的财富，或者来自于股市，或者来自于房市。当人们不再把房市、股市作为最快的挣钱手段时，不再玩一轮轮融资吹泡泡的游戏时，就是中国可以诞生下一个Google的时候了。\n科技的发展不是均匀的，而是以浪潮的形式出现。对个人来讲，看清楚浪潮，赶上浪潮，便不枉此生。\n","permalink":"http://localhost:1313/thinking/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%94%E6%89%80%E6%84%9F/","summary":"2023年上，看了浪潮之巅。\n20世纪不联网信息产业密度不断扩大，新型了各大历史上著名的公司，有的至今还在，有的早已灭亡。科学技术的不断发展，有的公司靠自己影响力，有的公司靠自己的垄断，有的公司在技术上的发展却无法商业变现。历史上著名的太阳公司，雅虎公司。好的公司里面必要有优秀的人才。\n每一个叫的名字的公司，之前都经历过一段痛苦时间，每一个站在行业顶端的互联网公司，都占据着市场上诸多的利润。不要看到大公司的今天，回头看看，他们的一路。任何事情也都是如此。\n下面的记录的一些定律：未来的一天这些定律也可能不复存在\n计算机行业的发展规律 摩尔定律 每18个月，计算机等IT产品的性能翻一番；或者是说相同性能的计算机等IT产品，每18个月价钱会降一半。【小范围适用于你买电子产品】\n安迪-比尔定律 安迪：英特尔公司传奇CEO\n比尔: 微软公司创始人比尔盖茨\n软件压榨着硬件的性能\n以微软为首的软件开发公司吃掉硬件提升带来的全部好处，迫使用户更新机器，让硬件厂商受益。硬件厂商继而研发，根据摩尔定律，提升硬件性能，为微软下一步更新软件做准备，形成完整生态链。\n反摩尔定律 一个IT公司如果今天和18个月前卖掉同样多的、同样的产品，它的营业额就会降一半。\n反摩尔定律逼着所有硬件公司都必须追赶上摩尔定律规定的更新速度。\n信息产业的规律性 70-20-10 行业老大吃掉市场的70%，老二吃掉20%，剩下的瓜分10%\n诺威格定律 一家公司的市场占有率超过50%，就无法在翻一番了。公司进行“横向扩展” 、业务转型\n基因决定定律 一家公司的基因决定了这家公司的发展\n黑格尔的一句话: 凡是现实的都是合理的，凡是合理的都是现实的。All that is real is rational; and all that is rational is real\n意思是说: 现实存在的现象，当初产生它的时候必然有它产生的原因和理由。如果这个理由将来不存在了，终究有一天它也会消亡。\n巴菲特：成功的关键不在于做对了多少件事，而在于少犯多少错误\n工业革命与颠覆式创新 蒸汽机 电 信息革命-计算机 人工智能 技术革命的共性 时间间隔大约70-90年 拥有核心技术 带来新的财富剧增 信息和能量的造就\n对服务的需求 对高端人才的需求 对品质的需求 对新事物的需求 工业革命的范式 现有产业 + 蒸汽机 = 新的产业 现有产业 + 电 = 新的产业 现有产业 + 摩尔定律 = 新的产业 第四次工业革命 - 智能革命， 上世纪70年代就提出来数据驱动的方法 现有产业 + 智能技术 = 新的产业 工业革命的核心资源：","title":"浪潮之巔所感"}]