<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>C&#43;&#43;基础4 | AlfredNing</title>
<meta name="keywords" content="">
<meta name="description" content="数据封装 面向对象编程中把数据和操作数据的函数绑定在一起的一个概念。同等概念既数据隐藏
默认情况下，在类中定义的所有项目都是私有的。
把一个类定义为另一个类的友元类，会暴露实现细节，从而降低了封装性。理想的做法是尽可能地对外隐藏每个类的实现细节
设计策略 通常情况下，我们都会设置类成员状态为私有（private），除非我们真的需要将其暴露，这样才能保证良好的封装性。
这通常应用于数据成员，但它同样适用于所有成员，包括虚函数
接口（抽象类） 接口描述类的行为和功能，而不需要完成特定类的实现。
c&#43;&#43;中的接口是用抽象类来实现，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与数据分离开的概念
抽象类: 类中至少有一个函数被声明为纯虚函数，纯虚函数是通过在声明中使用 &ldquo;= 0&rdquo; 来指定的
设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。
因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C&#43;&#43; 支持使用 ABC 声明接口。如果没有在派生类中重载纯虚函数，就尝试实例化该类的对象，会导致编译错误。
可用于实例化对象的类被称为具体类。
#include &lt;iostream&gt; using namespace std; // 基类 class Shape {public: // 提供接口框架的纯虚函数 virtual int getArea() = 0; void setWidth(int w) { width = w; } void setHeight(int h) { height = h; }protected: int width; int height;}; // 派生类 class Rectangle: public Shape{public: int getArea() { return (width * height); }}; class Triangle : public Shape { public: int getArea() { return (width * height) / 2; } }; int main(void) { Rectangle Rect; Triangle Tri; Rect.">
<meta name="author" content="AlfredNing">
<link rel="canonical" href="https://github.com/AlfredNing/note/program/game/c&#43;&#43;/c&#43;&#43;%E5%9F%BA%E7%A1%804/">
<meta name="google-site-verification" content="XYZabc">
<meta name="yandex-verification" content="XYZabc">
<meta name="msvalidate.01" content="XYZabc">
<link crossorigin="anonymous" href="/AlfredNing/assets/css/stylesheet.04a2bdb2f4eabd29dd97f76a3c76512da23fc76565cdcbfcfb0efd278404737a.css" integrity="sha256-BKK9svTqvSndl/dqPHZRLaI/x2Vlzcv8&#43;w79J4QEc3o=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/AlfredNing/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://github.com/AlfredNing/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="https://github.com/AlfredNing/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="https://github.com/AlfredNing/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="https://github.com/AlfredNing/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="https://github.com/AlfredNing/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-123-45', 'auto');
	
	ga('send', 'pageview');
}
</script><meta property="og:title" content="C&#43;&#43;基础4" />
<meta property="og:description" content="数据封装 面向对象编程中把数据和操作数据的函数绑定在一起的一个概念。同等概念既数据隐藏
默认情况下，在类中定义的所有项目都是私有的。
把一个类定义为另一个类的友元类，会暴露实现细节，从而降低了封装性。理想的做法是尽可能地对外隐藏每个类的实现细节
设计策略 通常情况下，我们都会设置类成员状态为私有（private），除非我们真的需要将其暴露，这样才能保证良好的封装性。
这通常应用于数据成员，但它同样适用于所有成员，包括虚函数
接口（抽象类） 接口描述类的行为和功能，而不需要完成特定类的实现。
c&#43;&#43;中的接口是用抽象类来实现，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与数据分离开的概念
抽象类: 类中至少有一个函数被声明为纯虚函数，纯虚函数是通过在声明中使用 &ldquo;= 0&rdquo; 来指定的
设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。
因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C&#43;&#43; 支持使用 ABC 声明接口。如果没有在派生类中重载纯虚函数，就尝试实例化该类的对象，会导致编译错误。
可用于实例化对象的类被称为具体类。
#include &lt;iostream&gt; using namespace std; // 基类 class Shape {public: // 提供接口框架的纯虚函数 virtual int getArea() = 0; void setWidth(int w) { width = w; } void setHeight(int h) { height = h; }protected: int width; int height;}; // 派生类 class Rectangle: public Shape{public: int getArea() { return (width * height); }}; class Triangle : public Shape { public: int getArea() { return (width * height) / 2; } }; int main(void) { Rectangle Rect; Triangle Tri; Rect." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://github.com/AlfredNing/note/program/game/c&#43;&#43;/c&#43;&#43;%E5%9F%BA%E7%A1%804/" /><meta property="article:section" content="note" />
<meta property="article:published_time" content="2023-03-27T20:10:47+08:00" />
<meta property="article:modified_time" content="2023-03-27T20:10:47+08:00" /><meta property="og:site_name" content="Alfred.Ning" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C&#43;&#43;基础4"/>
<meta name="twitter:description" content="数据封装 面向对象编程中把数据和操作数据的函数绑定在一起的一个概念。同等概念既数据隐藏
默认情况下，在类中定义的所有项目都是私有的。
把一个类定义为另一个类的友元类，会暴露实现细节，从而降低了封装性。理想的做法是尽可能地对外隐藏每个类的实现细节
设计策略 通常情况下，我们都会设置类成员状态为私有（private），除非我们真的需要将其暴露，这样才能保证良好的封装性。
这通常应用于数据成员，但它同样适用于所有成员，包括虚函数
接口（抽象类） 接口描述类的行为和功能，而不需要完成特定类的实现。
c&#43;&#43;中的接口是用抽象类来实现，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与数据分离开的概念
抽象类: 类中至少有一个函数被声明为纯虚函数，纯虚函数是通过在声明中使用 &ldquo;= 0&rdquo; 来指定的
设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。
因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C&#43;&#43; 支持使用 ABC 声明接口。如果没有在派生类中重载纯虚函数，就尝试实例化该类的对象，会导致编译错误。
可用于实例化对象的类被称为具体类。
#include &lt;iostream&gt; using namespace std; // 基类 class Shape {public: // 提供接口框架的纯虚函数 virtual int getArea() = 0; void setWidth(int w) { width = w; } void setHeight(int h) { height = h; }protected: int width; int height;}; // 派生类 class Rectangle: public Shape{public: int getArea() { return (width * height); }}; class Triangle : public Shape { public: int getArea() { return (width * height) / 2; } }; int main(void) { Rectangle Rect; Triangle Tri; Rect."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "笔记",
      "item": "https://github.com/AlfredNing/note/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "编程",
      "item": "https://github.com/AlfredNing/note/program/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "C++基础4",
      "item": "https://github.com/AlfredNing/note/program/game/c++/c++%E5%9F%BA%E7%A1%804/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C++基础4",
  "name": "C\u002b\u002b基础4",
  "description": "数据封装 面向对象编程中把数据和操作数据的函数绑定在一起的一个概念。同等概念既数据隐藏\n默认情况下，在类中定义的所有项目都是私有的。\n把一个类定义为另一个类的友元类，会暴露实现细节，从而降低了封装性。理想的做法是尽可能地对外隐藏每个类的实现细节\n设计策略 通常情况下，我们都会设置类成员状态为私有（private），除非我们真的需要将其暴露，这样才能保证良好的封装性。\n这通常应用于数据成员，但它同样适用于所有成员，包括虚函数\n接口（抽象类） 接口描述类的行为和功能，而不需要完成特定类的实现。\nc++中的接口是用抽象类来实现，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与数据分离开的概念\n抽象类: 类中至少有一个函数被声明为纯虚函数，纯虚函数是通过在声明中使用 \u0026ldquo;= 0\u0026rdquo; 来指定的\n设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。\n因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重载纯虚函数，就尝试实例化该类的对象，会导致编译错误。\n可用于实例化对象的类被称为具体类。\n#include \u0026lt;iostream\u0026gt; using namespace std; // 基类 class Shape {public: // 提供接口框架的纯虚函数 virtual int getArea() = 0; void setWidth(int w) { width = w; } void setHeight(int h) { height = h; }protected: int width; int height;}; // 派生类 class Rectangle: public Shape{public: int getArea() { return (width * height); }}; class Triangle : public Shape { public: int getArea() { return (width * height) / 2; } }; int main(void) { Rectangle Rect; Triangle Tri; Rect.",
  "keywords": [
    ""
  ],
  "articleBody": "数据封装 面向对象编程中把数据和操作数据的函数绑定在一起的一个概念。同等概念既数据隐藏\n默认情况下，在类中定义的所有项目都是私有的。\n把一个类定义为另一个类的友元类，会暴露实现细节，从而降低了封装性。理想的做法是尽可能地对外隐藏每个类的实现细节\n设计策略 通常情况下，我们都会设置类成员状态为私有（private），除非我们真的需要将其暴露，这样才能保证良好的封装性。\n这通常应用于数据成员，但它同样适用于所有成员，包括虚函数\n接口（抽象类） 接口描述类的行为和功能，而不需要完成特定类的实现。\nc++中的接口是用抽象类来实现，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与数据分离开的概念\n抽象类: 类中至少有一个函数被声明为纯虚函数，纯虚函数是通过在声明中使用 “= 0” 来指定的\n设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。\n因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重载纯虚函数，就尝试实例化该类的对象，会导致编译错误。\n可用于实例化对象的类被称为具体类。\n#include using namespace std; // 基类 class Shape {public: // 提供接口框架的纯虚函数 virtual int getArea() = 0; void setWidth(int w) { width = w; } void setHeight(int h) { height = h; }protected: int width; int height;}; // 派生类 class Rectangle: public Shape{public: int getArea() { return (width * height); }}; class Triangle : public Shape { public: int getArea() { return (width * height) / 2; } }; int main(void) { Rectangle Rect; Triangle Tri; Rect.setWidth(5); Rect.setHeight(7); // 输出对象的面积 cout \u003c\u003c \"Total Rectangle area: \" \u003c\u003c Rect.getArea() \u003c\u003c endl; Tri.setWidth(5); Tri.setHeight(7); // 输出对象的面积 cout \u003c\u003c \"Total Triangle area: \" \u003c\u003c Tri.getArea() \u003c\u003c endl; return 0; } 设计策略 面向对象的系统可能会使用一个抽象基类为所有的外部应用程序提供一个适当的、通用的、标准化的接口。然后，派生类通过继承抽象基类，就把所有类似的操作都继承下来。\n外部应用程序提供的功能（即公有函数）在抽象基类中是以纯虚函数的形式存在的。这些纯虚函数在相应的派生类中被实现。\n这个架构也使得新的应用程序可以很容易地被添加到系统中，即使是在系统被定义之后依然可以如此\n文件和流 标准库 fstream：从文件读取流和向文件写入流\n据类型 描述 ofstream 该数据类型表示输出文件流，用于创建文件并向文件写入信息。 ifstream 该数据类型表示输入文件流，用于从文件读取信息。 fstream 该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。 打开文件 在从文件读取信息或者向文件写入信息之前，必须先打开文件。ofstream 和 fstream 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 ifstream 对象\nvoid open(const char *filename, ios::openmode mode); ofstream outfile; // 写入文件模式 截断文件 outfile.open(\"file.dat\", ios::out | ios::trunc ); // 打开文件，读写 fstream afile; afile.open(\"file.dat\", ios::out | ios::in ); 模式标志 描述 ios::app 追加模式。所有写入都追加到文件末尾。 ios::ate 文件打开后定位到文件末尾。 ios::in 打开文件用于读取。 ios::out 打开文件用于写入。 ios::trunc 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。 关闭文件 在 C++ 编程中，使用流插入运算符（ « ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里使用的是 ofstream 或 fstream 对象，而不是 cout 对象\n读取文件 使用流提取运算符（ » ）从文件读取信息，对象是ofstream或fstream\n#include #include using namespace std; int main() { char data[100]; // 写模式打开文件 ofstream outfile; outfile.open(\"afile.dat\"); cout \u003c\u003c \"Write to the file \" \u003c\u003c endl; cout \u003c\u003c \"Enter your name \" \u003c\u003c endl; cin.getline(data, 100); // 写文件写入 outfile \u003c\u003c data \u003c\u003c endl; // 读模式打开文件 ifstream infile; infile.open(\"afile.dat\"); cout \u003c\u003c \"Reading from the file \" \u003c\u003c endl; infile \u003e\u003e data; cout \u003c\u003c data \u003c\u003c endl; infile \u003e\u003e data; cout \u003c\u003c data \u003c\u003c endl; infile.close(); return 0; } 文件位置指针\nistream 和 ostream 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 seekg（“seek get”）和关于 ostream 的 seekp（“seek put”）。\nseekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 ios::beg（默认的，从流的开头开始定位），也可以是 ios::cur（从流的当前位置开始定位），也可以是 ios::end（从流的末尾开始定位）。\n文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。\n异常处理 throw： 当问题出现， 程序会抛出一个异常 catch: 捕获异常处理 try: try 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块 可以使用 throw 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。\n#include using namespace std; double division(int a, int b) { if (b == 0) { throw \"Diviision By Zero\"; } return a / b; } int main() { try { double z = division(50, 0); cout \u003c\u003c z \u003c\u003c endl; } catch (const char* msg) { cerr \u003c\u003c msg \u003c\u003c endl; } return 0; } 标准异常 定义新的异常 通过继承和重载 exception 类来定义新的异常\n#include using namespace std; struct MyException : public exception { const char* what() const throw() { return \"C++ exception\"; } }; int main() { try { throw MyException(); } catch (MyException\u0026 e) { cout \u003c\u003c \"e: \" \u003c\u003c e.what() \u003c\u003c endl; } catch (exception\u0026 e) { // 其他错误 } return 0; } 动态内存 栈：在函数内部声明的所有变量都将占用栈内存 堆: 程序未使用的内存，在程序运行时候可用于动态内存分配 new运算符: 给定类型的变量在运行时分配堆内的内存，返回分配的内存地址\n如果不需要动态分配内存，使用delete运算符，删除之前由 new 运算符分配的内存\n包括数组在内的任意内置的数据类型，也可以是包括类或结构在内的用户自定义的任何数据类型。\nmalloc() 函数在 C 语言中就出现了，在 C++ 中仍然存在，但建议尽量不要使用 malloc() 函数。new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象\n#include using namespace std; int main() { double* pvalue = NULL; // 初始化为null的指针 pvalue = new double; // 申请内存 *pvalue = 29494.99; // 在申请的内存存储值 cout \u003c\u003c \"Value of pavlue: \" \u003c\u003c *pvalue \u003c\u003c endl; delete pvalue; // 释放内存 return 0; } 数组的动态内存分配 char* pvalue = NULL; // 初始化为 null 的指针 pvalue = new char[20]; // 为变量请求内存 delete []pvalue; // 删除 pvalue 所指向的数组 // new 多维数组分配内存 int ROW = 2;int COL = 3; double **pvalue = new double* [ROW]; // 为行分配内存 // 为列分配内存 for(int i = 0; i \u003c COL; i++) { pvalue[i] = new double[COL]; } // 释放多维数组内存： for(int i = 0; i \u003c COL; i++) { delete[] pvalue[i]; } delete [] pvalue; 对象的动态内存分配 #include using namespace std; class Box { public: Box() { cout \u003c\u003c \"调用构造函数！\" \u003c\u003c endl; } ~Box() { cout \u003c\u003c \"调用析构函数！\" \u003c\u003c endl; } };int main() { Box* myBoxArray = new Box[4]; delete[] myBoxArray; // Delete array return 0; } 如果要为一个包含四个 Box 对象的数组分配内存，构造函数将被调用 4 次，同样地，当删除这些对象时，析构函数也将被调用相同的次数（4次）。 命名空间 作为附加信息来区分不同库中相同名称的函数、类、变量等，使用了命名空间既定义了上下文。本质上，命名空间定义了一个范围\n定义命名空间 关键字 namespace后跟命名空间的名称\n为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称：name::code; // code 可以是变量或函数\n#include using namespace std; namespace first_space { void func() { cout \u003c\u003c \"Inside first_space \" \u003c\u003c endl; } } namespace second_space { void func() { cout \u003c\u003c \"Inside second_space \" \u003c\u003c endl; } } int main() { first_space::func(); second_space::func(); return 0; } using指令 使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称 using 指令也可以用来指定命名空间中的特定项目\nusing 指令引入的名称遵循正常的范围规则。名称从使用 using 指令开始是可见的，直到该范围结束。此时，在范围以外定义的同名实体是隐藏的。\n#include using namespace std; namespace first_space { void func() { cout \u003c\u003c \"Inside first_space \" \u003c\u003c endl; } } namespace second_space { void func() { cout \u003c\u003c \"Inside second_space \" \u003c\u003c endl; } } using namespace first_space; using std::cout; int main() { func(); second_space::func(); return 0; } 不连续的命名空间 命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。一个命名空间的各个组成部分可以分散在多个文件中\n所以，如果命名空间中的某个组成部分需要请求定义在另一个文件中的名称，则仍然需要声明该名称。下面的命名空间定义可以是定义一个新的命名空间，也可以是为已有的命名空间增加新的元素\n嵌套的命名空间 namespace namespace_name1 { // 代码声明 namespace namespace_name2 { // 代码声明 } } // 通过使用 :: 运算符来访问嵌套的命名空间中的成员 // 访问 namespace_name2 中的成员 using namespace namespace_name1::namespace_name2; // 访问 namespace:name1 中的成员 using namespace namespace_name1; 模板 模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。\n模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念\n可以使用模板来定义函数和类\n函数模板 #include using namespace std; template \u003ctypename T\u003e inline T const\u0026 Max(T const\u0026 a, T const\u0026 b) { return a \u003c b ? b : a; } int main() { int i = 39; int j = 20; cout \u003c\u003c \"Max(i,j): \" \u003c\u003c Max(i, j) \u003c\u003c endl; cout \u003c\u003c \"Max(i, j): \" \u003c\u003c Max(i, j) \u003c\u003c endl; double f1 = 13.5; double f2 = 20.7; cout \u003c\u003c \"Max(f1, f2): \" \u003c\u003c Max(f1, f2) \u003c\u003c endl; string s1 = \"Hello\"; string s2 = \"World\"; cout \u003c\u003c \"Max(s1, s2): \" \u003c\u003c Max(s1, s2) \u003c\u003c endl; return 0; } 类模板 #include #include #include #include #include using namespace std; template \u003cclass T\u003e class Stack { private: vector\u003cT\u003e elems; public: void push(T const\u0026); void pop(); T top() const; bool empty() const { return elems.empty(); } }; template \u003cclass T\u003e void Stack\u003cT\u003e::push(T const\u0026 elem) { elems.push_back(elem); } template \u003cclass T\u003e void Stack\u003cT\u003e::pop() { if (elems.empty()) { throw out_of_range(\"Stack\u003c\u003e::pop(): empty stack\"); } elems.pop_back(); } template \u003cclass T\u003e T Stack\u003cT\u003e::top() const { if (elems.empty()) { throw out_of_range(\"Stack\u003c\u003e::pop(): empty stack\"); } return elems.back(); } int main() { try { Stack\u003cint\u003e intStack; Stack\u003cstring\u003e strStack; intStack.push(8); cout \u003c\u003c intStack.top() \u003c\u003c endl; strStack.push(\"hello\"); cout \u003c\u003c strStack.top() \u003c\u003c endl; strStack.pop(); strStack.pop(); } catch (exception const\u0026 ex) { cerr \u003c\u003c \"Exception: \" \u003c\u003c ex.what() \u003c\u003c endl; return -1; } return 0; } 预处理器 指令用在指示编译器在实际编译器之前完成所需完成的预处理\n所有的预处理器以#开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾 #include #define、#if、#else、#line 等 #define 预处理 #define 预处理指令用于创建符号常量。该符号常量通常称为宏\n函数宏 #define 来定义一个带有参数的宏\n#include using namespace std; #define MIN(a,b) (a",
  "wordCount" : "1235",
  "inLanguage": "zh",
  "datePublished": "2023-03-27T20:10:47+08:00",
  "dateModified": "2023-03-27T20:10:47+08:00",
  "author":[{
    "@type": "Person",
    "name": "AlfredNing"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://github.com/AlfredNing/note/program/game/c++/c++%E5%9F%BA%E7%A1%804/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "AlfredNing",
    "logo": {
      "@type": "ImageObject",
      "url": "https://github.com/AlfredNing/%3Clink%20/%20abs%20url%3E"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://github.com/AlfredNing" accesskey="h" title="AlfredNing (Alt + H)">AlfredNing</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://github.com/AlfredNing/note/" title="📓笔记">
                    <span>📓笔记</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/AlfredNing/thinking/" title="🤔想法">
                    <span>🤔想法</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/AlfredNing/search/" title="🔎搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔎搜索</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/AlfredNing/tags/" title="🏷️标签">
                    <span>🏷️标签</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/AlfredNing/archives" title="🗄️归档">
                    <span>🗄️归档</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/AlfredNing/about" title="🤙关于">
                    <span>🤙关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://github.com/AlfredNing">主页</a>&nbsp;»&nbsp;<a href="https://github.com/AlfredNing/note/">笔记</a>&nbsp;»&nbsp;<a href="https://github.com/AlfredNing/note/program/">编程</a></div>
    <h1 class="post-title">
      C&#43;&#43;基础4
    </h1>
    <div class="post-meta">创建:&nbsp;<span title='2023-03-27 20:10:47 +0800 CST'>2023年-03月-27日</span>&nbsp;|&nbsp;更新:&nbsp;2023年-03月-27日&nbsp;|&nbsp;字数:&nbsp;1235字&nbsp;|&nbsp;时长:&nbsp;6分钟&nbsp;|&nbsp;AlfredNing




</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e6%95%b0%e6%8d%ae%e5%b0%81%e8%a3%85" aria-label="数据封装">数据封装</a><ul>
                        
                <li>
                    <a href="#%e8%ae%be%e8%ae%a1%e7%ad%96%e7%95%a5" aria-label="设计策略">设计策略</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%8e%a5%e5%8f%a3%e6%8a%bd%e8%b1%a1%e7%b1%bb" aria-label="接口（抽象类）">接口（抽象类）</a><ul>
                        
                <li>
                    <a href="#%e8%ae%be%e8%ae%a1%e7%ad%96%e7%95%a5-1" aria-label="设计策略">设计策略</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%96%87%e4%bb%b6%e5%92%8c%e6%b5%81" aria-label="文件和流">文件和流</a><ul>
                        <ul>
                        
                <li>
                    <a href="#%e6%89%93%e5%bc%80%e6%96%87%e4%bb%b6" aria-label="打开文件">打开文件</a></li>
                <li>
                    <a href="#%e5%85%b3%e9%97%ad%e6%96%87%e4%bb%b6" aria-label="关闭文件">关闭文件</a></li>
                <li>
                    <a href="#%e8%af%bb%e5%8f%96%e6%96%87%e4%bb%b6" aria-label="读取文件">读取文件</a></li></ul>
                    </ul>
                </li>
                <li>
                    <a href="#%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86" aria-label="异常处理">异常处理</a><ul>
                        
                <li>
                    <a href="#%e6%a0%87%e5%87%86%e5%bc%82%e5%b8%b8" aria-label="标准异常">标准异常</a></li>
                <li>
                    <a href="#%e5%ae%9a%e4%b9%89%e6%96%b0%e7%9a%84%e5%bc%82%e5%b8%b8" aria-label="定义新的异常">定义新的异常</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%8a%a8%e6%80%81%e5%86%85%e5%ad%98" aria-label="动态内存">动态内存</a><ul>
                        
                <li>
                    <a href="#%e6%95%b0%e7%bb%84%e7%9a%84%e5%8a%a8%e6%80%81%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d" aria-label="数组的动态内存分配">数组的动态内存分配</a><ul>
                        
                <li>
                    <a href="#%e5%af%b9%e8%b1%a1%e7%9a%84%e5%8a%a8%e6%80%81%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d" aria-label="对象的动态内存分配">对象的动态内存分配</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4" aria-label="命名空间">命名空间</a><ul>
                        
                <li>
                    <a href="#%e5%ae%9a%e4%b9%89%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4" aria-label="定义命名空间">定义命名空间</a></li>
                <li>
                    <a href="#using%e6%8c%87%e4%bb%a4" aria-label="using指令">using指令</a></li>
                <li>
                    <a href="#%e4%b8%8d%e8%bf%9e%e7%bb%ad%e7%9a%84%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4" aria-label="不连续的命名空间">不连续的命名空间</a></li>
                <li>
                    <a href="#%e5%b5%8c%e5%a5%97%e7%9a%84%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4" aria-label="嵌套的命名空间">嵌套的命名空间</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%a8%a1%e6%9d%bf" aria-label="模板">模板</a><ul>
                        
                <li>
                    <a href="#%e5%87%bd%e6%95%b0%e6%a8%a1%e6%9d%bf" aria-label="函数模板">函数模板</a></li>
                <li>
                    <a href="#%e7%b1%bb%e6%a8%a1%e6%9d%bf" aria-label="类模板">类模板</a></li></ul>
                </li>
                <li>
                    <a href="#%e9%a2%84%e5%a4%84%e7%90%86%e5%99%a8" aria-label="预处理器">预处理器</a><ul>
                        
                <li>
                    <a href="#define-%e9%a2%84%e5%a4%84%e7%90%86" aria-label="#define 预处理">#define 预处理</a><ul>
                        
                <li>
                    <a href="#%e5%87%bd%e6%95%b0%e5%ae%8f" aria-label="函数宏">函数宏</a></li>
                <li>
                    <a href="#%e6%9d%a1%e4%bb%b6%e7%bc%96%e8%af%91" aria-label="条件编译">条件编译</a></li>
                <li>
                    <a href="#-%e5%92%8c--%e8%bf%90%e7%ae%97%e7%ac%a6" aria-label="# 和 ## 运算符"># 和 ## 运算符</a></li></ul>
                </li>
                <li>
                    <a href="#%e9%a2%84%e5%ae%9a%e4%b9%89%e5%ae%8f" aria-label="预定义宏">预定义宏</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        
        activeElement = elements[0];
        const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
        document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
    }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
            const id = encodeURI(element.getAttribute('id')).toLowerCase();
            if (element === activeElement){
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
            } else {
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
            }
        })
    }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>
  <div class="post-content"><h1 id="数据封装">数据封装<a hidden class="anchor" aria-hidden="true" href="#数据封装">#</a></h1>
<p>面向对象编程中把数据和操作数据的函数绑定在一起的一个概念。同等概念既数据隐藏</p>
<p>默认情况下，在类中定义的所有项目都是私有的。</p>
<p>把一个类定义为另一个类的友元类，会暴露实现细节，从而降低了封装性。理想的做法是尽可能地对外隐藏每个类的实现细节</p>
<h2 id="设计策略">设计策略<a hidden class="anchor" aria-hidden="true" href="#设计策略">#</a></h2>
<p>通常情况下，我们都会设置类成员状态为私有（private），除非我们真的需要将其暴露，这样才能保证良好的<strong>封装性</strong>。</p>
<p>这通常应用于数据成员，但它同样适用于所有成员，包括虚函数</p>
<h1 id="接口抽象类">接口（抽象类）<a hidden class="anchor" aria-hidden="true" href="#接口抽象类">#</a></h1>
<p>接口描述类的行为和功能，而不需要完成特定类的实现。</p>
<p>c++中的接口是用抽象类来实现，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与数据分离开的概念</p>
<p><strong>抽象类: 类中至少有一个函数被声明为纯虚函数</strong>，纯虚函数是通过在声明中使用 &ldquo;= 0&rdquo; 来指定的</p>
<p>设计<strong>抽象类</strong>（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为<strong>接口</strong>使用。如果试图实例化一个抽象类的对象，会导致编译错误。</p>
<p>因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重载纯虚函数，就尝试实例化该类的对象，会导致编译错误。</p>
<p>可用于实例化对象的类被称为<strong>具体类</strong>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 基类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Shape</span> <span class="p">{</span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 提供接口框架的纯虚函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">virtual</span> <span class="kt">int</span> <span class="n">getArea</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">setWidth</span><span class="p">(</span><span class="kt">int</span> <span class="n">w</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">width</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">setHeight</span><span class="p">(</span><span class="kt">int</span> <span class="n">h</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">height</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">height</span><span class="p">;};</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 派生类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Rectangle</span><span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span><span class="p">{</span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">getArea</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">(</span><span class="n">width</span> <span class="o">*</span> <span class="n">height</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Triangle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">getArea</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="p">(</span><span class="n">width</span> <span class="o">*</span> <span class="n">height</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Rectangle</span> <span class="n">Rect</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Triangle</span>  <span class="n">Tri</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Rect</span><span class="p">.</span><span class="n">setWidth</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Rect</span><span class="p">.</span><span class="n">setHeight</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 输出对象的面积
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Total Rectangle area: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">Rect</span><span class="p">.</span><span class="n">getArea</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Tri</span><span class="p">.</span><span class="n">setWidth</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Tri</span><span class="p">.</span><span class="n">setHeight</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 输出对象的面积
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Total Triangle area: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">Tri</span><span class="p">.</span><span class="n">getArea</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="设计策略-1">设计策略<a hidden class="anchor" aria-hidden="true" href="#设计策略-1">#</a></h2>
<p>面向对象的系统可能会使用一个抽象基类为所有的外部应用程序提供一个适当的、通用的、标准化的接口。然后，派生类通过继承抽象基类，就把所有类似的操作都继承下来。</p>
<p>外部应用程序提供的功能（即公有函数）在抽象基类中是以纯虚函数的形式存在的。这些纯虚函数在相应的派生类中被实现。</p>
<p>这个架构也使得新的应用程序可以很容易地被添加到系统中，即使是在系统被定义之后依然可以如此</p>
<h1 id="文件和流">文件和流<a hidden class="anchor" aria-hidden="true" href="#文件和流">#</a></h1>
<p>标准库 <strong>fstream</strong>：从文件读取流和向文件写入流</p>
<table>
<thead>
<tr>
<th>据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ofstream</td>
<td>该数据类型表示输出文件流，用于创建文件并向文件写入信息。</td>
</tr>
<tr>
<td>ifstream</td>
<td>该数据类型表示输入文件流，用于从文件读取信息。</td>
</tr>
<tr>
<td>fstream</td>
<td>该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。</td>
</tr>
</tbody>
</table>
<h3 id="打开文件">打开文件<a hidden class="anchor" aria-hidden="true" href="#打开文件">#</a></h3>
<p>在从文件读取信息或者向文件写入信息之前，必须先打开文件。<strong>ofstream</strong> 和 <strong>fstream</strong> 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 <strong>ifstream</strong> 对象</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="n">ios</span><span class="o">::</span><span class="n">openmode</span> <span class="n">mode</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ofstream</span> <span class="n">outfile</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 写入文件模式 截断文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">outfile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">&#34;file.dat&#34;</span><span class="p">,</span> <span class="n">ios</span><span class="o">::</span><span class="n">out</span> <span class="o">|</span> <span class="n">ios</span><span class="o">::</span><span class="n">trunc</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 打开文件，读写
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">fstream</span>  <span class="n">afile</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">afile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">&#34;file.dat&#34;</span><span class="p">,</span> <span class="n">ios</span><span class="o">::</span><span class="n">out</span> <span class="o">|</span> <span class="n">ios</span><span class="o">::</span><span class="n">in</span> <span class="p">);</span>
</span></span></code></pre></div><table>
<thead>
<tr>
<th>模式标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ios::app</td>
<td>追加模式。所有写入都追加到文件末尾。</td>
</tr>
<tr>
<td>ios::ate</td>
<td>文件打开后定位到文件末尾。</td>
</tr>
<tr>
<td>ios::in</td>
<td>打开文件用于读取。</td>
</tr>
<tr>
<td>ios::out</td>
<td>打开文件用于写入。</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。</td>
</tr>
</tbody>
</table>
<h3 id="关闭文件">关闭文件<a hidden class="anchor" aria-hidden="true" href="#关闭文件">#</a></h3>
<p>在 C++ 编程中，使用流插入运算符（ &laquo; ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里使用的是 <strong>ofstream</strong> 或 <strong>fstream</strong> 对象，而不是 <strong>cout</strong> 对象</p>
<h3 id="读取文件">读取文件<a hidden class="anchor" aria-hidden="true" href="#读取文件">#</a></h3>
<p>使用流提取运算符（ &raquo; ）从文件读取信息，对象是ofstream或fstream</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 写模式打开文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">ofstream</span> <span class="n">outfile</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">outfile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">&#34;afile.dat&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Write to the file &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Enter your name &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">cin</span><span class="p">.</span><span class="n">getline</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 写文件写入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 读模式打开文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">ifstream</span> <span class="n">infile</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">infile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">&#34;afile.dat&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Reading from the file &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">infile</span> <span class="o">&gt;&gt;</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">infile</span> <span class="o">&gt;&gt;</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">infile</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>文件位置指针</p>
<p><strong>istream</strong> 和 <strong>ostream</strong> 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 <strong>seekg</strong>（&ldquo;seek get&rdquo;）和关于 ostream 的 <strong>seekp</strong>（&ldquo;seek put&rdquo;）。</p>
<p>seekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 <strong>ios::beg</strong>（默认的，从流的开头开始定位），也可以是 <strong>ios::cur</strong>（从流的当前位置开始定位），也可以是 <strong>ios::end</strong>（从流的末尾开始定位）。</p>
<p>文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。</p>
<h1 id="异常处理">异常处理<a hidden class="anchor" aria-hidden="true" href="#异常处理">#</a></h1>
<ul>
<li>throw： 当问题出现， 程序会抛出一个异常</li>
<li>catch:  捕获异常处理</li>
<li>try:  <strong>try</strong> 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块</li>
</ul>
<p>可以使用 <strong>throw</strong> 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">double</span> <span class="nf">division</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">throw</span> <span class="s">&#34;Diviision By Zero&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">double</span> <span class="n">z</span> <span class="o">=</span> <span class="n">division</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">z</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">msg</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="标准异常">标准异常<a hidden class="anchor" aria-hidden="true" href="#标准异常">#</a></h2>
<p><img loading="lazy" src="https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20230327203905933.png" alt="image-20230327203905933"  />
</p>
<h2 id="定义新的异常">定义新的异常<a hidden class="anchor" aria-hidden="true" href="#定义新的异常">#</a></h2>
<p>通过继承和重载 <strong>exception</strong> 类来定义新的异常</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">MyException</span> <span class="o">:</span> <span class="k">public</span> <span class="n">exception</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">what</span><span class="p">()</span> <span class="k">const</span> <span class="k">throw</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="s">&#34;C++ exception&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">throw</span> <span class="n">MyException</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">catch</span> <span class="p">(</span><span class="n">MyException</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;e: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">catch</span> <span class="p">(</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 其他错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h1 id="动态内存">动态内存<a hidden class="anchor" aria-hidden="true" href="#动态内存">#</a></h1>
<ul>
<li>栈：在函数内部声明的所有变量都将占用栈内存</li>
<li>堆: 程序未使用的内存，在程序运行时候可用于动态内存分配</li>
</ul>
<p>new运算符: 给定类型的变量在运行时分配堆内的内存，返回分配的内存地址</p>
<p>如果不需要动态分配内存，使用delete运算符，删除之前由 new 运算符分配的内存</p>
<p>包括数组在内的任意内置的数据类型，也可以是包括类或结构在内的用户自定义的任何数据类型。</p>
<p><strong>malloc() 函数在 C 语言中就出现了，在 C++ 中仍然存在，但建议尽量不要使用 malloc() 函数。new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">double</span><span class="o">*</span> <span class="n">pvalue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// 初始化为null的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">pvalue</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">;</span> <span class="c1">// 申请内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="o">*</span><span class="n">pvalue</span> <span class="o">=</span> <span class="mf">29494.99</span><span class="p">;</span> <span class="c1">// 在申请的内存存储值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Value of pavlue: &#34;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">pvalue</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">delete</span> <span class="n">pvalue</span><span class="p">;</span> <span class="c1">// 释放内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="数组的动态内存分配">数组的动态内存分配<a hidden class="anchor" aria-hidden="true" href="#数组的动态内存分配">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">char</span><span class="o">*</span> <span class="n">pvalue</span>  <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>   <span class="c1">// 初始化为 null 的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">pvalue</span>  <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span> <span class="c1">// 为变量请求内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">delete</span> <span class="p">[]</span><span class="n">pvalue</span><span class="p">;</span>        <span class="c1">// 删除 pvalue 所指向的数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// new  多维数组分配内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">ROW</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="kt">int</span> <span class="n">COL</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">double</span> <span class="o">**</span><span class="n">pvalue</span>  <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">*</span> <span class="p">[</span><span class="n">ROW</span><span class="p">];</span> <span class="c1">// 为行分配内存
</span></span></span><span class="line"><span class="cl"><span class="c1">// 为列分配内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">COL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">pvalue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">COL</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 释放多维数组内存：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">COL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">delete</span><span class="p">[]</span> <span class="n">pvalue</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">delete</span> <span class="p">[]</span> <span class="n">pvalue</span><span class="p">;</span>
</span></span></code></pre></div><h3 id="对象的动态内存分配">对象的动态内存分配<a hidden class="anchor" aria-hidden="true" href="#对象的动态内存分配">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Box</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">Box</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;调用构造函数！&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="o">~</span><span class="n">Box</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;调用析构函数！&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">Box</span><span class="o">*</span> <span class="n">myBoxArray</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Box</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">delete</span><span class="p">[]</span> <span class="n">myBoxArray</span><span class="p">;</span> <span class="c1">// Delete array
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="err">如果要为一个包含四个</span> <span class="n">Box</span> <span class="err">对象的数组分配内存，构造函数将被调用</span> <span class="mi">4</span> <span class="err">次，同样地，当删除这些对象时，析构函数也将被调用相同的次数（</span><span class="mi">4</span><span class="err">次）。</span>
</span></span></code></pre></div><h1 id="命名空间">命名空间<a hidden class="anchor" aria-hidden="true" href="#命名空间">#</a></h1>
<p>作为附加信息来区分不同库中相同名称的函数、类、变量等，使用了命名空间既定义了上下文。<strong>本质上，命名空间定义了一个范围</strong></p>
<h2 id="定义命名空间">定义命名空间<a hidden class="anchor" aria-hidden="true" href="#定义命名空间">#</a></h2>
<p>关键字 <strong>namespace</strong>后跟命名空间的名称</p>
<p>为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称：<strong>name::code;  // code 可以是变量或函数</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">first_space</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Inside first_space &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">second_space</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Inside second_space &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">first_space</span><span class="o">::</span><span class="n">func</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">second_space</span><span class="o">::</span><span class="n">func</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="using指令">using指令<a hidden class="anchor" aria-hidden="true" href="#using指令">#</a></h2>
<p>使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称
using 指令也可以用来指定命名空间中的特定项目</p>
<p><strong>using</strong> 指令引入的名称遵循正常的范围规则。名称从使用 <strong>using</strong> 指令开始是可见的，直到该范围结束。此时，在范围以外定义的同名实体是隐藏的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">first_space</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Inside first_space &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">second_space</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Inside second_space &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">first_space</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">func</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">second_space</span><span class="o">::</span><span class="n">func</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="不连续的命名空间">不连续的命名空间<a hidden class="anchor" aria-hidden="true" href="#不连续的命名空间">#</a></h2>
<p>命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。一个命名空间的各个组成部分可以分散在多个文件中</p>
<p>所以，如果命名空间中的某个组成部分需要请求定义在另一个文件中的名称，则仍然需要声明该名称。下面的命名空间定义可以是定义一个新的命名空间，也可以是为已有的命名空间增加新的元素</p>
<h2 id="嵌套的命名空间">嵌套的命名空间<a hidden class="anchor" aria-hidden="true" href="#嵌套的命名空间">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">namespace_name1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// 代码声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">namespace</span> <span class="n">namespace_name2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 代码声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 通过使用 :: 运算符来访问嵌套的命名空间中的成员
</span></span></span><span class="line"><span class="cl"><span class="c1">// 访问 namespace_name2 中的成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">namespace_name1</span><span class="o">::</span><span class="n">namespace_name2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 访问 namespace:name1 中的成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">namespace_name1</span><span class="p">;</span>
</span></span></code></pre></div><h1 id="模板">模板<a hidden class="anchor" aria-hidden="true" href="#模板">#</a></h1>
<p>模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。</p>
<p>模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念</p>
<p>可以使用模板来定义函数和类</p>
<h2 id="函数模板">函数模板<a hidden class="anchor" aria-hidden="true" href="#函数模板">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kr">inline</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">Max</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="o">?</span> <span class="nl">b</span> <span class="p">:</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">39</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Max(i,j): &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">Max</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Max(i, j): &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">Max</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">double</span> <span class="n">f1</span> <span class="o">=</span> <span class="mf">13.5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">double</span> <span class="n">f2</span> <span class="o">=</span> <span class="mf">20.7</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Max(f1, f2): &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">Max</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">string</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">&#34;Hello&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">string</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">&#34;World&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Max(s1, s2): &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">Max</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="类模板">类模板<a hidden class="anchor" aria-hidden="true" href="#类模板">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdexcept&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Stack</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">elems</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="nf">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">T</span> <span class="nf">top</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">elems</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">push</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">elems</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">elem</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">pop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">elems</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">throw</span> <span class="nf">out_of_range</span><span class="p">(</span><span class="s">&#34;Stack&lt;&gt;::pop()</span><span class="o">:</span> <span class="n">empty</span> <span class="n">stack</span><span class="s">&#34;)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">elems</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">top</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">elems</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">throw</span> <span class="nf">out_of_range</span><span class="p">(</span><span class="s">&#34;Stack&lt;&gt;::pop()</span><span class="o">:</span> <span class="n">empty</span> <span class="n">stack</span><span class="s">&#34;)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">elems</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">try</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">Stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">intStack</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">Stack</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">strStack</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">intStack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">intStack</span><span class="p">.</span><span class="n">top</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">strStack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">strStack</span><span class="p">.</span><span class="n">top</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">strStack</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">		<span class="n">strStack</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">catch</span> <span class="p">(</span><span class="n">exception</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Exception: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h1 id="预处理器">预处理器<a hidden class="anchor" aria-hidden="true" href="#预处理器">#</a></h1>
<p>指令用在指示编译器在实际编译器之前完成所需完成的预处理</p>
<ul>
<li>所有的预处理器以#开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾</li>
<li>#include #define、#if、#else、#line 等</li>
</ul>
<h2 id="define-预处理">#define 预处理<a hidden class="anchor" aria-hidden="true" href="#define-预处理">#</a></h2>
<p>#define 预处理指令用于创建符号常量。该符号常量通常称为<strong>宏</strong></p>
<h3 id="函数宏">函数宏<a hidden class="anchor" aria-hidden="true" href="#函数宏">#</a></h3>
<p>#define 来定义一个带有参数的宏</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define MIN(a,b) (a&lt;b ? a : b)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span> <span class="p">(){</span>
</span></span><span class="line"><span class="cl">   <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">i</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">j</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">&#34;较小的值为：&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">MIN</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="条件编译">条件编译<a hidden class="anchor" aria-hidden="true" href="#条件编译">#</a></h3>
<p>有几个指令可以用来有选择地对部分程序源代码进行编译。这个过程被称为条件编译。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#ifndef NULL   
</span></span></span><span class="line"><span class="cl"><span class="cp">#define NULL 0
</span></span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 调试
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#ifdef DEBUG   
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">cerr</span> <span class="o">&lt;&lt;</span><span class="s">&#34;Variable x = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#if 0</span><span class="c">   不进行编译的代码#endif
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define DEBUG 
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MIN(a, b)( (b &lt; a) ? b : a)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">i</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">j</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef  DEBUG
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>	<span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Trace: Inside main function&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif </span><span class="c1">//  DEBUG
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#if 0</span><span class="c">
</span></span></span><span class="line"><span class="cl"><span class="c">	/*注释部分*/
</span></span></span><span class="line"><span class="cl"><span class="c">	cout &lt;&lt; MKSTR(hello c++) &lt;&lt; endl;
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;The minimum is &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">MIN</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef DEBUG
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>	<span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Trace: Coming out of main function&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif </span><span class="c1">// DEBUG
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="-和--运算符"># 和 ## 运算符<a hidden class="anchor" aria-hidden="true" href="#-和--运算符">#</a></h3>
<p># 和 ## 预处理运算符在 C++ 和 ANSI/ISO C 中都是可用的。# 运算符会把 replacement-text 令牌转换为用引号引起来的字符串</p>
<p>## 运算符用于连接两个令牌</p>
<h2 id="预定义宏">预定义宏<a hidden class="anchor" aria-hidden="true" href="#预定义宏">#</a></h2>
<table>
<thead>
<tr>
<th>宏</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>LINE</strong></td>
<td>这会在程序编译时包含当前行号。</td>
</tr>
<tr>
<td><strong>FILE</strong></td>
<td>这会在程序编译时包含当前文件名。</td>
</tr>
<tr>
<td><strong>DATE</strong></td>
<td>这会包含一个形式为 month/day/year 的字符串，它表示把源文件转换为目标代码的日期。</td>
</tr>
<tr>
<td><strong>TIME</strong></td>
<td>这会包含一个形式为 hour:minute:second 的字符串，它表示程序被编译的时间。</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Value of __LINE__ : &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">__LINE__</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Value of __FILE__ : &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">__FILE__</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Value of __DATE__ : &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">__DATE__</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Value of __TIME__ : &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">__TIME__</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://github.com/AlfredNing/tags/c&#43;&#43;/">c&#43;&#43;</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://github.com/AlfredNing/note/program/game/c&#43;&#43;/c&#43;&#43;%E5%9F%BA%E7%A1%805/">
    <span class="title">« 上一页</span>
    <br>
    <span>C&#43;&#43;基础5</span>
  </a>
  <a class="next" href="https://github.com/AlfredNing/note/program/game/c&#43;&#43;/c&#43;&#43;%E5%9F%BA%E7%A1%803/">
    <span class="title">下一页 »</span>
    <br>
    <span>C&#43;&#43;基础3</span>
  </a>
</nav>

  </footer><div>
    <div class="pagination__title">
        <span class="pagination__title-h" style="font-size: 20px;">💬评论</span>
        <hr />
    </div>

    <div id="tcomment">
    </div>
    <script src="https://utteranc.es/client.js"
        repo="AlfredNing/AlfredNing.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
</div>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://github.com/AlfredNing">AlfredNing</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script></body>

</html>
